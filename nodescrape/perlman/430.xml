<?xml version="1.0" encoding="windows-1252"?>
<node id="430" title="perlman:perltoc4" created="1999-08-25 03:45:59" updated="2005-06-13 11:45:36">
<type id="116">
perlman</type>
<author id="114">
gods</author>
<data>
<field name="doctext">
&lt;HR&gt;
&lt;H1&gt;&lt;A NAME="New_Diagnostics"&gt;New Diagnostics&lt;/A&gt;&lt;/H1&gt;
&lt;P&gt;
Several new conditions will trigger warnings that were silent before. Some
only affect certain platforms. The following new warnings and errors
outline these. These messages are classified as follows (listed in
increasing order of desperation):

&lt;P&gt;
&lt;PRE&gt;   (W) A warning (optional).
   (D) A deprecation (optional).
   (S) A severe warning (mandatory).
   (F) A fatal error (trappable).
   (P) An internal error you should never see (trappable).
   (X) A very fatal error (nontrappable).
   (A) An alien error message (not generated by Perl).
&lt;/PRE&gt;
&lt;DL&gt;
&lt;DT&gt;&lt;STRONG&gt;&lt;A NAME="item__my_"&gt;&amp;quot;my&amp;quot; variable %s masks earlier declaration in same scope&lt;/A&gt;&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(W)&lt;/FONT&gt; 
&lt;FONT SIZE=-1&gt;A&lt;/FONT&gt; lexical variable has been redeclared in the same scope, effectively eliminating all access to the previous instance. This is almost always a typographical error. Note that the earlier variable will still exist until the end of the scope or until all closure referents to it are destroyed.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;&lt;A NAME="item__s"&gt;%s argument is not a HASH element or slice&lt;/A&gt;&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(F)&lt;/FONT&gt; The argument to 
&lt;CODE&gt;delete()&lt;/CODE&gt; must be either a hash element, such as

&lt;P&gt;
&lt;PRE&gt;    $foo{$bar}
    $ref-&amp;gt;&amp;#091;12&amp;#093;-&amp;gt;{&amp;quot;susie&amp;quot;}
&lt;/PRE&gt;
&lt;P&gt;
or a hash slice, such as

&lt;P&gt;
&lt;PRE&gt;    @foo{$bar, $baz, $xyzzy}
    @{$ref-&amp;gt;&amp;#091;12&amp;#093;}{&amp;quot;susie&amp;quot;, &amp;quot;queue&amp;quot;}
&lt;/PRE&gt;
&lt;DT&gt;&lt;STRONG&gt;&lt;A NAME="item_Allocation"&gt;Allocation too large: %lx&lt;/A&gt;&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(X)&lt;/FONT&gt; You can't allocate more than 
&lt;FONT SIZE=-1&gt;64K&lt;/FONT&gt; on an 
&lt;FONT SIZE=-1&gt;MS-DOS&lt;/FONT&gt; machine.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;Allocation too large&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(F)&lt;/FONT&gt; You can't allocate more than 2^31+``small amount''
bytes.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;&lt;A NAME="item_Applying"&gt;Applying %s to %s will act on scalar(%s)&lt;/A&gt;&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(W)&lt;/FONT&gt; The pattern match (//), substitution (s///), and
transliteration (tr///) operators work on scalar values. If you apply one
of them to an array or a hash, it will convert the array or hash to a
scalar value -- the length of an array, or the population info of a hash --
and then work on that scalar value. This is probably not what you meant to
do. See
[perlfunc:grep|grep] and [perlfunc:map|map] for alternatives.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;&lt;A NAME="item_Attempt"&gt;Attempt to free nonexistent shared string&lt;/A&gt;&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(P)&lt;/FONT&gt; Perl maintains a reference counted internal table
of strings to optimize the storage and access of hash keys and other
strings. This indicates someone tried to decrement the reference count of a
string that can no longer be found in the table.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;Attempt to use reference as lvalue in substr&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(W)&lt;/FONT&gt; You supplied a reference as the first argument to 
&lt;CODE&gt;substr()&lt;/CODE&gt; used as an lvalue, which is pretty strange. Perhaps you forgot to dereference it first. See
 [perlfunc:substr|substr].

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;&lt;A NAME="item_Bareword"&gt;Bareword &amp;quot;%s&amp;quot; refers to nonexistent package&lt;/A&gt;&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(W)&lt;/FONT&gt; You used a qualified bareword of the form &lt;CODE&gt;Foo::&lt;/CODE&gt;, but the compiler saw no other uses of that namespace before that point.
Perhaps you need to predeclare a package?

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;&lt;A NAME="item_Can"&gt;Can't redefine active sort subroutine %s&lt;/A&gt;&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(F)&lt;/FONT&gt; Perl optimizes the internal handling of sort
subroutines and keeps pointers into them. You tried to redefine one such
sort subroutine when it was currently active, which is not allowed. If you
really want to do this, you should write &lt;CODE&gt;sort { &amp;amp;func } @x&lt;/CODE&gt; instead of &lt;CODE&gt;sort func @x&lt;/CODE&gt;.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;Can't use bareword (&amp;quot;%s&amp;quot;) as %s ref while &amp;quot;strict refs&amp;quot; in use&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(F)&lt;/FONT&gt; Only hard references are allowed by ``strict
refs''. Symbolic references are disallowed. See [perlman:perlref|the perlref manpage].

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;&lt;A NAME="item_Cannot"&gt;Cannot resolve method `%s' overloading `%s' in package `%s'&lt;/A&gt;&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(P)&lt;/FONT&gt; Internal error trying to resolve overloading
specified by a method name (as opposed to a subroutine reference).

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;&lt;A NAME="item_Constant"&gt;Constant subroutine %s redefined&lt;/A&gt;&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(S)&lt;/FONT&gt; You redefined a subroutine which had previously
been eligible for inlining. See [perlman:perlsub] for commentary and workarounds.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;Constant subroutine %s undefined&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(S)&lt;/FONT&gt; You undefined a subroutine which had previously
been eligible for inlining. See [perlman:perlsub] for commentary and workarounds.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;&lt;A NAME="item_Copy"&gt;Copy method did not return a reference&lt;/A&gt;&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(F)&lt;/FONT&gt; The method which overloads ``='' is buggy. See &lt;U&gt;Copy Constructor&lt;/U&gt;.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;&lt;A NAME="item_Died"&gt;Died&lt;/A&gt;&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(F)&lt;/FONT&gt; You passed 
&lt;CODE&gt;die()&lt;/CODE&gt; an empty string (the equivalent of
 [perlfunc:die]) or you called it with no args and both &lt;CODE&gt;$@&lt;/CODE&gt; and &lt;CODE&gt;$_&lt;/CODE&gt; were empty.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;&lt;A NAME="item_Exiting"&gt;Exiting pseudo-block via %s&lt;/A&gt;&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(W)&lt;/FONT&gt; You are exiting a rather special block construct
(like a sort block or subroutine) by unconventional means, such as a goto,
or a loop control statement. See [perlfunc:sort|sort].

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;&lt;A NAME="item_Identifier"&gt;Identifier too long&lt;/A&gt;&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(F)&lt;/FONT&gt; Perl limits identifiers (names for variables,
functions, etc.) to 252 characters for simple names, somewhat more for
compound names (like
&lt;CODE&gt;$A::B&lt;/CODE&gt;). You've exceeded Perl's limits. Future versions of Perl are likely to
eliminate these arbitrary limitations.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;&lt;A NAME="item_Illegal"&gt;Illegal character %s (carriage return)&lt;/A&gt;&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(F)&lt;/FONT&gt; 
&lt;FONT SIZE=-1&gt;A&lt;/FONT&gt; carriage return character was found in the input. This is an error, and not a warning, because carriage return characters can break multi-line strings, including here documents (e.g.,
 &lt;CODE&gt;print &amp;lt;&amp;lt;EOF;&lt;/CODE&gt;).

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;Illegal switch in PERL5OPT: %s&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(X)&lt;/FONT&gt; The 
&lt;FONT SIZE=-1&gt;PERL5OPT&lt;/FONT&gt; environment variable may only be used to set the following switches:
 &lt;STRONG&gt;-&amp;#091;DIMUdmw&amp;#093;&lt;/STRONG&gt;.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;&lt;A NAME="item_Integer"&gt;Integer overflow in hex number&lt;/A&gt;&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(S)&lt;/FONT&gt; The literal hex number you have specified is too
big for your architecture. On a 32-bit architecture the largest hex literal
is 0xFFFFFFFF.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;Integer overflow in octal number&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(S)&lt;/FONT&gt; The literal octal number you have specified is too
big for your architecture. On a 32-bit architecture the largest octal
literal is 037777777777.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;&lt;A NAME="item_internal"&gt;internal error: glob failed&lt;/A&gt;&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(P)&lt;/FONT&gt; Something went wrong with the external 
&lt;CODE&gt;program(s)&lt;/CODE&gt; used for
 [perlfunc:glob|glob]
and &lt;CODE&gt;&amp;lt;*.c&amp;gt;&lt;/CODE&gt;. This may mean that your csh 
&lt;FONT SIZE=-1&gt;(C&lt;/FONT&gt; shell) is broken. If so, you should change all of
the csh-related variables in config.sh: If you have tcsh, make the
variables refer to it as if it were csh (e.g. &lt;CODE&gt;full_csh='/usr/bin/tcsh'&lt;/CODE&gt;); otherwise, make them all empty (except that &lt;CODE&gt;d_csh&lt;/CODE&gt; should be [perlfunc:undef]) so that Perl will think csh is missing. In either case, after editing
config.sh, run
&lt;CODE&gt;./Configure -S&lt;/CODE&gt; and rebuild Perl.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;&lt;A NAME="item_Invalid"&gt;Invalid conversion in %s: &amp;quot;%s&amp;quot;&lt;/A&gt;&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(W)&lt;/FONT&gt; Perl does not understand the given format
conversion. See [perlfunc:sprintf|sprintf].

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;Invalid type in pack: '%s'&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(F)&lt;/FONT&gt; The given character is not a valid pack type. See [perlfunc:pack|pack].

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;Invalid type in unpack: '%s'&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(F)&lt;/FONT&gt; The given character is not a valid unpack type.
See [perlfunc:unpack|unpack].

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;&lt;A NAME="item_Name"&gt;Name &amp;quot;%s::%s&amp;quot; used only once: possible typo&lt;/A&gt;&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(W)&lt;/FONT&gt; Typographical errors often show up as unique
variable names. If you had a good reason for having a unique name, then
just mention it again somehow to suppress the message (the &lt;CODE&gt;use vars&lt;/CODE&gt; pragma is provided for just this purpose).

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;&lt;A NAME="item_Null"&gt;Null picture in formline&lt;/A&gt;&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(F)&lt;/FONT&gt; The first argument to formline must be a valid
format picture specification. It was found to be empty, which probably
means you supplied it an uninitialized value. See [perlman:perlform|the perlform manpage].

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;&lt;A NAME="item_Offset"&gt;Offset outside string&lt;/A&gt;&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(F)&lt;/FONT&gt; You tried to do a read/write/send/recv operation
with an offset pointing outside the buffer. This is difficult to imagine.
The sole exception to this is that [perlfunc:sysread|sysread()]ing past the buffer will extend the buffer and zero pad the new area.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;&lt;A NAME="item_Out"&gt;Out of memory!&lt;/A&gt;&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(X|F)&lt;/FONT&gt; The 
&lt;CODE&gt;malloc()&lt;/CODE&gt; function returned 0, indicating there was insufficient remaining memory (or virtual memory) to satisfy the request.

&lt;P&gt;
The request was judged to be small, so the possibility to trap it depends
on the way Perl was compiled. By default it is not trappable. However, if
compiled for this, Perl may use the contents of &lt;CODE&gt;$^M&lt;/CODE&gt; as an emergency pool after 
&lt;CODE&gt;die()ing&lt;/CODE&gt; with this message.
In this case the error is trappable &lt;EM&gt;once&lt;/EM&gt;.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;Out of memory during request for %s&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(F)&lt;/FONT&gt; The 
&lt;CODE&gt;malloc()&lt;/CODE&gt; function returned 0, indicating there was insufficient remaining memory (or virtual memory) to satisfy the request. However, the request was judged large enough (compile-time default is 
&lt;FONT SIZE=-1&gt;64K),&lt;/FONT&gt; so a possibility to shut down by trapping this error is granted.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;&lt;A NAME="item_panic"&gt;panic: frexp&lt;/A&gt;&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(P)&lt;/FONT&gt; The library function 
&lt;CODE&gt;frexp()&lt;/CODE&gt; failed, making 
&lt;CODE&gt;printf(``%f'')&lt;/CODE&gt; impossible.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;&lt;A NAME="item_Possible"&gt;Possible attempt to put comments in qw() list&lt;/A&gt;&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(W)&lt;/FONT&gt; 
&lt;CODE&gt;qw()&lt;/CODE&gt; lists contain items separated by whitespace; as with literal strings, comment characters are not ignored, but are instead treated as literal data. (You may have used different delimiters than the parentheses shown here; braces are also frequently used.)

&lt;P&gt;
You probably wrote something like this:

&lt;P&gt;
&lt;PRE&gt;    @list = qw(
        a # a comment
        b # another comment
    );
&lt;/PRE&gt;
&lt;P&gt;
when you should have written this:

&lt;P&gt;
&lt;PRE&gt;    @list = qw(
        a
        b
    );
&lt;/PRE&gt;
&lt;P&gt;
If you really want comments, build your list the old-fashioned way, with
quotes and commas:

&lt;P&gt;
&lt;PRE&gt;    @list = (
        'a',    # a comment
        'b',    # another comment
    );
&lt;/PRE&gt;
&lt;DT&gt;&lt;STRONG&gt;Possible attempt to separate words with commas&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(W)&lt;/FONT&gt; 
&lt;CODE&gt;qw()&lt;/CODE&gt; lists contain items separated by whitespace; therefore commas aren't needed to separate the items. (You may have used different delimiters than the parentheses shown here; braces are also frequently used.)

&lt;P&gt;
You probably wrote something like this:

&lt;P&gt;
&lt;PRE&gt;    qw! a, b, c !;
&lt;/PRE&gt;
&lt;P&gt;
which puts literal commas into some of the list items. Write it without
commas if you don't want them to appear in your data:

&lt;P&gt;
&lt;PRE&gt;    qw! a b c !;
&lt;/PRE&gt;
&lt;DT&gt;&lt;STRONG&gt;&lt;A NAME="item_Scalar"&gt;Scalar value @%s{%s} better written as $%s{%s}&lt;/A&gt;&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(W)&lt;/FONT&gt; You've used a hash slice (indicated by @) to
select a single element of a hash. Generally it's better to ask for a
scalar value (indicated by $). The difference is that &lt;CODE&gt;$foo{&amp;amp;bar}&lt;/CODE&gt; always behaves like a scalar, both when assigning to it and when evaluating
its argument, while &lt;CODE&gt;@foo{&amp;amp;bar}&lt;/CODE&gt; behaves like a list when you assign to it, and provides a list context to
its subscript, which can do weird things if you're expecting only one
subscript.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;&lt;A NAME="item_Stub"&gt;Stub found while resolving method `%s' overloading `%s' in package `%s'&lt;/A&gt;&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(P)&lt;/FONT&gt; Overloading resolution over &lt;CODE&gt;@ISA&lt;/CODE&gt; tree
may be broken by importing stubs. Stubs should never be implicitely
created, but explicit calls to &lt;CODE&gt;can&lt;/CODE&gt;
may break this.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;&lt;A NAME="item_Too"&gt;Too late for &amp;quot;-T&amp;quot; option&lt;/A&gt;&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(X)&lt;/FONT&gt; The #! line (or local equivalent) in a Perl script
contains the
&lt;STRONG&gt;-T&lt;/STRONG&gt; option, but Perl was not invoked with &lt;STRONG&gt;-T&lt;/STRONG&gt; in its argument list. This is an error because, by the time Perl discovers
a &lt;STRONG&gt;-T&lt;/STRONG&gt; in a script, it's too late to properly taint everything from the
environment. So Perl gives up.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;&lt;A NAME="item_untie"&gt;untie attempted while %d inner references still exist&lt;/A&gt;&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(W)&lt;/FONT&gt; 
&lt;FONT SIZE=-1&gt;A&lt;/FONT&gt; copy of the object returned from
 [perlfunc:tie|tie] (or &lt;CODE&gt;tied&lt;/CODE&gt;) was still valid when [perlfunc:untie|untie] was called.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;&lt;A NAME="item_Unrecognized"&gt;Unrecognized character %s&lt;/A&gt;&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(F)&lt;/FONT&gt; The Perl parser has no idea what to do with the
specified character in your Perl script (or eval). Perhaps you tried to run
a compressed script, a binary program, or a directory as a Perl program.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;&lt;A NAME="item_Unsupported"&gt;Unsupported function fork&lt;/A&gt;&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(F)&lt;/FONT&gt; Your version of executable does not support
forking.

&lt;P&gt;
Note that under some systems, like 
&lt;FONT SIZE=-1&gt;OS/2,&lt;/FONT&gt; there may be different flavors of Perl
executables, some of which may support fork, some not. Try changing the
name you call Perl by to &lt;CODE&gt;perl_&lt;/CODE&gt;, &lt;CODE&gt;perl__&lt;/CODE&gt;, and so on.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;&lt;A NAME="item_Use"&gt;Use of &amp;quot;$$&amp;lt;digit&amp;gt;&amp;quot; to mean &amp;quot;${$}&amp;lt;digit&amp;gt;&amp;quot; is deprecated&lt;/A&gt;&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(D)&lt;/FONT&gt; Perl versions before 5.004 misinterpreted any type
marker followed by ``$'' and a digit. For example, ``$$0'' was incorrectly
taken to mean ``${$}0'' instead of ``${$0}''. This bug is (mostly) fixed in
Perl 5.004.

&lt;P&gt;
However, the developers of Perl 5.004 could not fix this bug completely,
because at least two widely-used modules depend on the old meaning of
``$$0'' in a string. So Perl 5.004 still interprets ``$$&amp;lt;digit&amp;gt;'' in
the old (broken) way inside strings; but it generates this message as a
warning. And in Perl 5.005, this special treatment will cease.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;&lt;A NAME="item_Value"&gt;Value of %s can be &amp;quot;0&amp;quot;; test with defined()&lt;/A&gt;&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(W)&lt;/FONT&gt; In a conditional expression, you used &amp;lt;
&lt;FONT SIZE=-1&gt;HANDLE&amp;gt;,&lt;/FONT&gt; &amp;lt;*&amp;gt; (glob), [perlfunc:each|each()], or [perlfunc:readdir|readdir()] as a boolean value. Each of these constructs can return a value of ``0'';
that would make the conditional expression false, which is probably not
what you intended. When using these constructs in conditional expressions,
test their values with the [perlfunc:defined|defined] operator.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;&lt;A NAME="item_Variable"&gt;Variable &amp;quot;%s&amp;quot; may be unavailable&lt;/A&gt;&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(W)&lt;/FONT&gt; An inner (nested) &lt;EM&gt;anonymous&lt;/EM&gt; subroutine is inside a &lt;EM&gt;named&lt;/EM&gt;
subroutine, and outside that is another subroutine; and the anonymous
(innermost) subroutine is referencing a lexical variable defined in the
outermost subroutine. For example:

&lt;P&gt;
&lt;PRE&gt;   sub outermost { my $a; sub middle { sub { $a } } }
&lt;/PRE&gt;
&lt;P&gt;
If the anonymous subroutine is called or referenced (directly or
indirectly) from the outermost subroutine, it will share the variable as
you would expect. But if the anonymous subroutine is called or referenced
when the outermost subroutine is not active, it will see the value of the
shared variable as it was before and during the *first* call to the
outermost subroutine, which is probably not what you want.

&lt;P&gt;
In these circumstances, it is usually best to make the middle subroutine
anonymous, using the [perlfunc:sub] syntax. Perl has specific support for shared variables in nested anonymous
subroutines; a named subroutine in between interferes with this feature.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;Variable &amp;quot;%s&amp;quot; will not stay shared&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(W)&lt;/FONT&gt; An inner (nested) &lt;EM&gt;named&lt;/EM&gt; subroutine is referencing a lexical variable defined in an outer
subroutine.

&lt;P&gt;
When the inner subroutine is called, it will probably see the value of the
outer subroutine's variable as it was before and during the *first* call to
the outer subroutine; in this case, after the first call to the outer
subroutine is complete, the inner and outer subroutines will no longer
share a common value for the variable. In other words, the variable will no
longer be shared.

&lt;P&gt;
Furthermore, if the outer subroutine is anonymous and references a lexical
variable outside itself, then the outer and inner subroutines will &lt;EM&gt;never&lt;/EM&gt; share the given variable.

&lt;P&gt;
This problem can usually be solved by making the inner subroutine
anonymous, using the [perlfunc:sub] syntax. When inner anonymous subs that reference variables in outer
subroutines are called or referenced, they are automatically rebound to the
current values of such variables.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;&lt;A NAME="item_Warning"&gt;Warning: something's wrong&lt;/A&gt;&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(W)&lt;/FONT&gt; You passed 
&lt;CODE&gt;warn()&lt;/CODE&gt; an empty string (the equivalent of
 [perlman:perlguts]) or you called it with no args and &lt;CODE&gt;$_&lt;/CODE&gt; was empty.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;&lt;A NAME="item_Ill"&gt;Ill-formed logical name |%s| in prime_env_iter&lt;/A&gt;&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(W)&lt;/FONT&gt; 
&lt;FONT SIZE=-1&gt;A&lt;/FONT&gt; warning peculiar to 
&lt;FONT SIZE=-1&gt;VMS.&lt;/FONT&gt; 
&lt;FONT SIZE=-1&gt;A&lt;/FONT&gt; logical name was encountered when preparing to iterate over &lt;CODE&gt;%ENV&lt;/CODE&gt; which violates the syntactic rules governing logical names. Since it cannot be translated normally, it is skipped, and will not appear in 
&lt;FONT SIZE=-1&gt;%ENV.&lt;/FONT&gt; This may be a benign occurrence, as some software packages might directly modify logical name tables and introduce nonstandard names, or it may indicate that a logical name table has been corrupted.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;&lt;A NAME="item_Got"&gt;Got an error from DosAllocMem&lt;/A&gt;&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(P)&lt;/FONT&gt; An error peculiar to 
&lt;FONT SIZE=-1&gt;OS/2.&lt;/FONT&gt; Most probably you're using an obsolete version of Perl, and this should not happen anyway.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;&lt;A NAME="item_Malformed"&gt;Malformed PERLLIB_PREFIX&lt;/A&gt;&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(F)&lt;/FONT&gt; An error peculiar to 
&lt;FONT SIZE=-1&gt;OS/2.&lt;/FONT&gt; 
&lt;FONT SIZE=-1&gt;PERLLIB_PREFIX&lt;/FONT&gt; should be of the form

&lt;P&gt;
&lt;PRE&gt;    prefix1;prefix2
&lt;/PRE&gt;
&lt;P&gt;
or

&lt;P&gt;
&lt;PRE&gt;    prefix1 prefix2
&lt;/PRE&gt;
&lt;P&gt;
with nonempty prefix1 and prefix2. If &lt;CODE&gt;prefix1&lt;/CODE&gt; is indeed a prefix of a builtin library search path, prefix2 is substituted. The error may appear if components are not found, or are too long. See 
&lt;FONT SIZE=-1&gt;``PERLLIB_PREFIX''&lt;/FONT&gt; in
 &lt;EM&gt;README.os2&lt;/EM&gt;.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;&lt;A NAME="item_PERL_SH_DIR"&gt;PERL_SH_DIR too long&lt;/A&gt;&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(F)&lt;/FONT&gt; An error peculiar to 
&lt;FONT SIZE=-1&gt;OS/2.&lt;/FONT&gt; 
&lt;FONT SIZE=-1&gt;PERL_SH_DIR&lt;/FONT&gt; is the directory to find the

&lt;CODE&gt;sh&lt;/CODE&gt;-shell in. See 
&lt;FONT SIZE=-1&gt;``PERL_SH_DIR''&lt;/FONT&gt; in &lt;EM&gt;README.os2&lt;/EM&gt;.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;&lt;A NAME="item_Process"&gt;Process terminated by SIG%s&lt;/A&gt;&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(W)&lt;/FONT&gt; This is a standard message issued by 
&lt;FONT SIZE=-1&gt;OS/2&lt;/FONT&gt; applications, while &lt;CODE&gt;*nix&lt;/CODE&gt; applications die in silence. It is considered a feature of the 
&lt;FONT SIZE=-1&gt;OS/2&lt;/FONT&gt; port. One can easily disable this by appropriate sighandlers, see

[perlman:perlipc]. See also ``Process terminated by 
&lt;FONT SIZE=-1&gt;SIGTERM/SIGINT''&lt;/FONT&gt; in &lt;EM&gt;README.os2&lt;/EM&gt;.

&lt;/DL&gt;
&lt;P&gt;
&lt;HR&gt;
&lt;H1&gt;&lt;A NAME="BUGS"&gt;BUGS&lt;/A&gt;&lt;/H1&gt;
&lt;P&gt;
If you find what you think is a bug, you might check the headers of
recently posted articles in the comp.lang.perl.misc newsgroup. There may
also be information at &lt;A
HREF="http://www.perl.com/perl/,"&gt;http://www.perl.com/perl/,&lt;/A&gt; the Perl
Home Page.

&lt;P&gt;
If you believe you have an unreported bug, please run the &lt;STRONG&gt;perlbug&lt;/STRONG&gt;
program included with your release. Make sure you trim your bug down to a
tiny but sufficient test case. Your bug report, along with the output of &lt;CODE&gt;perl -V&lt;/CODE&gt;, will be sent off to &amp;lt;&lt;EM&gt;perlbug@perl.com&lt;/EM&gt;&amp;gt; to be analysed by the Perl porting team.

&lt;P&gt;
&lt;HR&gt;
&lt;H1&gt;&lt;A NAME="SEE_ALSO"&gt;SEE ALSO&lt;/A&gt;&lt;/H1&gt;
&lt;P&gt;
The &lt;EM&gt;Changes&lt;/EM&gt; file for exhaustive details on what changed.

&lt;P&gt;
The &lt;EM&gt;INSTALL&lt;/EM&gt; file for how to build Perl. This file has been significantly updated for
5.004, so even veteran users should look through it.

&lt;P&gt;
The &lt;EM&gt;README&lt;/EM&gt; file for general stuff.

&lt;P&gt;
The &lt;EM&gt;Copying&lt;/EM&gt; file for copyright information.

&lt;P&gt;
&lt;HR&gt;
&lt;H1&gt;&lt;A NAME="HISTORY"&gt;HISTORY&lt;/A&gt;&lt;/H1&gt;
&lt;P&gt;
Constructed by Tom Christiansen, grabbing material with permission from
innumerable contributors, with kibitzing by more than a few Perl porters.

&lt;P&gt;
Last update: Wed May 14 11:14:09 
&lt;FONT SIZE=-1&gt;EDT&lt;/FONT&gt; 1997
&lt;HR&gt;
&lt;BR&gt;Return to the [Library]&lt;BR&gt;</field>
</data>
</node>
