<?xml version="1.0" encoding="windows-1252"?>
<node id="419" title="perlman:perltoot" created="1999-08-25 03:11:10" updated="2005-08-15 08:11:25">
<type id="116">
perlman</type>
<author id="114">
gods</author>
<data>
<field name="doctext">
&lt;HR&gt;
&lt;P&gt;
&lt;H1&gt;&lt;A NAME="NAME"&gt;NAME&lt;/A&gt;&lt;/H1&gt;
&lt;P&gt;
perltoot - Tom's object-oriented tutorial for perl

&lt;P&gt;
&lt;HR&gt;
&lt;H1&gt;&lt;A NAME="DESCRIPTION"&gt;DESCRIPTION&lt;/A&gt;&lt;/H1&gt;
&lt;P&gt;
Object-oriented programming is a big seller these days. Some managers would
rather have objects than sliced bread. Why is that? What's so special about
an object? Just what &lt;EM&gt;is&lt;/EM&gt; an object anyway?

&lt;P&gt;
An object is nothing but a way of tucking away complex behaviours into a
neat little easy-to-use bundle. (This is what professors call abstraction.)
Smart people who have nothing to do but sit around for weeks on end
figuring out really hard problems make these nifty objects that even
regular people can use. (This is what professors call software reuse.)
Users (well, programmers) can play with this little bundle all they want,
but they aren't to open it up and mess with the insides. Just like an
expensive piece of hardware, the contract says that you void the warranty
if you muck with the cover. So don't do that.

&lt;P&gt;
The heart of objects is the class, a protected little private namespace full of data and functions. 
&lt;FONT SIZE=-1&gt;A&lt;/FONT&gt; class is a set of related routines that addresses some problem area. You can think of it as a user-defined type. The Perl package mechanism, also used for more traditional modules, is used for class modules as well. Objects ``live'' in a class, meaning that they belong to some package.

&lt;P&gt;
More often than not, the class provides the user with little bundles. These
bundles are objects. They know whose class they belong to, and how to
behave. Users ask the class to do something, like ``give me an object.'' Or
they can ask one of these objects to do something. Asking a class to do
something for you is calling a &lt;EM&gt;class method&lt;/EM&gt;. Asking an object to do something for you is calling an &lt;EM&gt;object method&lt;/EM&gt;. Asking either a class (usually) or an object (sometimes) to give you back
an object is calling a &lt;EM&gt;constructor&lt;/EM&gt;, which is just a kind of method.

&lt;P&gt;
That's all well and good, but how is an object different from any other
Perl data type? Just what is an object &lt;EM&gt;really&lt;/EM&gt;; that is, what's its fundamental type? The answer to the first question is
easy. An object is different from any other data type in Perl in one and
only one way: you may dereference it using not merely string or numeric
subscripts as with simple arrays and hashes, but with named subroutine
calls. In a word, with &lt;EM&gt;methods&lt;/EM&gt;.

&lt;P&gt;
The answer to the second question is that it's a reference, and not just
any reference, mind you, but one whose referent has been &lt;EM&gt;bless&lt;/EM&gt;()ed into a particular class (read: package). What kind of reference? Well,
the answer to that one is a bit less concrete. That's because in Perl the
designer of the class can employ any sort of reference they'd like as the
underlying intrinsic data type. It could be a scalar, an array, or a hash
reference. It could even be a code reference. But because of its inherent
flexibility, an object is usually a hash reference.

&lt;P&gt;
&lt;HR&gt;
&lt;H1&gt;&lt;A NAME="Creating_a_Class"&gt;Creating a Class&lt;/A&gt;&lt;/H1&gt;
&lt;P&gt;
Before you create a class, you need to decide what to name it. That's
because the class (package) name governs the name of the file used to house
it, just as with regular modules. Then, that class (package) should provide
one or more ways to generate objects. Finally, it should provide mechanisms
to allow users of its objects to indirectly manipulate these objects from a
distance.

&lt;P&gt;
For example, let's make a simple Person class module. It gets stored in the file Person.pm. If it were called a Happy::Person class, it would be stored in the file Happy/Person.pm, and its package would become Happy::Person instead of just Person. (On a personal computer not running Unix or Plan 9, but something like MacOS or 
&lt;FONT SIZE=-1&gt;VMS,&lt;/FONT&gt; the directory separator may be different, but the principle is the same.) Do not assume any formal relationship between modules based on their directory names. This is merely a grouping convenience, and has no effect on inheritance, variable accessibility, or anything else.

&lt;P&gt;
For this module we aren't going to use Exporter, because we're a
well-behaved class module that doesn't export anything at all. In order to
manufacture objects, a class needs to have a &lt;EM&gt;constructor
method&lt;/EM&gt;. 
&lt;FONT SIZE=-1&gt;A&lt;/FONT&gt; constructor gives you back not just a regular data type, but a brand-new object in that class. This magic is taken care of by the 
&lt;CODE&gt;bless()&lt;/CODE&gt; function, whose sole purpose is to enable its referent to be used as an object. Remember: being an object really means nothing more than that methods may now be called against it.

&lt;P&gt;
While a constructor may be named anything you'd like, most Perl programmers seem to like to call theirs 
&lt;CODE&gt;new().&lt;/CODE&gt; However, 
&lt;CODE&gt;new()&lt;/CODE&gt; is not a reserved word, and a class is under no obligation to supply such. Some programmers have also been known to use a function with the same name as the class as the constructor.

&lt;P&gt;
&lt;HR&gt;
&lt;H2&gt;&lt;A NAME="Object_Representation"&gt;Object Representation&lt;/A&gt;&lt;/H2&gt;
&lt;P&gt;
By far the most common mechanism used in Perl to represent a Pascal record, a 
&lt;FONT SIZE=-1&gt;C&lt;/FONT&gt; struct, or a 
&lt;FONT SIZE=-1&gt;C++&lt;/FONT&gt; class is an anonymous hash. That's because a hash has an arbitrary number of data fields, each conveniently accessed by an arbitrary name of your own devising.

&lt;P&gt;
If you were just doing a simple struct-like emulation, you would likely go
about it something like this:

&lt;P&gt;
&lt;PRE&gt;    $rec = {
        name  =&amp;gt; &amp;quot;Jason&amp;quot;,
        age   =&amp;gt; 23,
        peers =&amp;gt; &amp;#091; &amp;quot;Norbert&amp;quot;, &amp;quot;Rhys&amp;quot;, &amp;quot;Phineas&amp;quot;&amp;#093;,
    };
&lt;/PRE&gt;
&lt;P&gt;
If you felt like it, you could add a bit of visual distinction by up-casing
the hash keys:

&lt;P&gt;
&lt;PRE&gt;    $rec = {
        NAME  =&amp;gt; &amp;quot;Jason&amp;quot;,
        AGE   =&amp;gt; 23,
        PEERS =&amp;gt; &amp;#091; &amp;quot;Norbert&amp;quot;, &amp;quot;Rhys&amp;quot;, &amp;quot;Phineas&amp;quot;&amp;#093;,
    };
&lt;/PRE&gt;
&lt;P&gt;
And so you could get at &lt;CODE&gt;$rec-&amp;gt;{NAME}&lt;/CODE&gt; to find ``Jason'', or
&lt;CODE&gt;@{ $rec-&amp;gt;{PEERS} }&lt;/CODE&gt; to get at ``Norbert'', ``Rhys'', and ``Phineas''. (Have you ever noticed
how many 23-year-old programmers seem to be named ``Jason'' these days? :-)

&lt;P&gt;
This same model is often used for classes, although it is not considered
the pinnacle of programming propriety for folks from outside the class to
come waltzing into an object, brazenly accessing its data members directly.
Generally speaking, an object should be considered an opaque cookie that
you use &lt;EM&gt;object methods&lt;/EM&gt; to access. Visually, methods look like you're dereffing a reference using a
function name instead of brackets or braces.

&lt;P&gt;
&lt;HR&gt;
&lt;H2&gt;&lt;A NAME="Class_Interface"&gt;Class Interface&lt;/A&gt;&lt;/H2&gt;
&lt;P&gt;
Some languages provide a formal syntactic interface to a class's methods,
but Perl does not. It relies on you to read the documentation of each
class. If you try to call an undefined method on an object, Perl won't
complain, but the program will trigger an exception while it's running.
Likewise, if you call a method expecting a prime number as its argument
with a non-prime one instead, you can't expect the compiler to catch this.
(Well, you can expect it all you like, but it's not going to happen.)

&lt;P&gt;
Let's suppose you have a well-educated user of your Person class, someone
who has read the docs that explain the prescribed interface. Here's how
they might use the Person class:

&lt;P&gt;
&lt;PRE&gt;    use Person;
&lt;/PRE&gt;
&lt;P&gt;
&lt;PRE&gt;    $him = Person-&amp;gt;new();
    $him-&amp;gt;name(&amp;quot;Jason&amp;quot;);
    $him-&amp;gt;age(23);
    $him-&amp;gt;peers( &amp;quot;Norbert&amp;quot;, &amp;quot;Rhys&amp;quot;, &amp;quot;Phineas&amp;quot; );
&lt;/PRE&gt;
&lt;P&gt;
&lt;PRE&gt;    push @All_Recs, $him;  # save object in array for later
&lt;/PRE&gt;
&lt;P&gt;
&lt;PRE&gt;    printf &amp;quot;%s is %d years old.\n&amp;quot;, $him-&amp;gt;name, $him-&amp;gt;age;
    print &amp;quot;His peers are: &amp;quot;, join(&amp;quot;, &amp;quot;, $him-&amp;gt;peers), &amp;quot;\n&amp;quot;;
&lt;/PRE&gt;
&lt;P&gt;
&lt;PRE&gt;    printf &amp;quot;Last rec's name is %s\n&amp;quot;, $All_Recs&amp;#091;-1&amp;#093;-&amp;gt;name;
&lt;/PRE&gt;
&lt;P&gt;
As you can see, the user of the class doesn't know (or at least, has no
business paying attention to the fact) that the object has one particular
implementation or another. The interface to the class and its objects is
exclusively via methods, and that's all the user of the class should ever
play with.

&lt;P&gt;
&lt;HR&gt;
&lt;H2&gt;&lt;A NAME="Constructors_and_Instance_Method"&gt;Constructors and Instance Methods&lt;/A&gt;&lt;/H2&gt;
&lt;P&gt;
Still, &lt;EM&gt;someone&lt;/EM&gt; has to know what's in the object. And that someone is the class. It implements methods that the programmer uses to access the object. Here's how to implement the Person class using the standard hash-ref-as-an-object idiom. We'll make a class method called 
&lt;CODE&gt;new()&lt;/CODE&gt; to act as the constructor, and three object methods called 
&lt;CODE&gt;name(),&lt;/CODE&gt; 
&lt;CODE&gt;age(),&lt;/CODE&gt; and 
&lt;CODE&gt;peers()&lt;/CODE&gt; to get at per-object data hidden away in our anonymous hash.

&lt;P&gt;
&lt;PRE&gt;    package Person;
    use strict;
&lt;/PRE&gt;
&lt;P&gt;
&lt;PRE&gt;    ##################################################
    ## the object constructor (simplistic version)  ##
    ##################################################
    sub new {
        my $self  = {};
        $self-&amp;gt;{NAME}   = undef;
        $self-&amp;gt;{AGE}    = undef;
        $self-&amp;gt;{PEERS}  = &amp;#091;&amp;#093;;
        bless($self);           # but see below
        return $self;
    }
&lt;/PRE&gt;
&lt;P&gt;
&lt;PRE&gt;    ##############################################
    ## methods to access per-object data        ##
    ##                                          ##
    ## With args, they set the value.  Without  ##
    ## any, they only retrieve it/them.         ##
    ##############################################
&lt;/PRE&gt;
&lt;P&gt;
&lt;PRE&gt;    sub name {
        my $self = shift;
        if (@_) { $self-&amp;gt;{NAME} = shift }
        return $self-&amp;gt;{NAME};
    }
&lt;/PRE&gt;
&lt;P&gt;
&lt;PRE&gt;    sub age {
        my $self = shift;
        if (@_) { $self-&amp;gt;{AGE} = shift }
        return $self-&amp;gt;{AGE};
    }
&lt;/PRE&gt;
&lt;P&gt;
&lt;PRE&gt;    sub peers {
        my $self = shift;
        if (@_) { @{ $self-&amp;gt;{PEERS} } = @_ }
        return @{ $self-&amp;gt;{PEERS} };
    }
&lt;/PRE&gt;
&lt;P&gt;
&lt;PRE&gt;    1;  # so the require or use succeeds
&lt;/PRE&gt;
&lt;P&gt;
We've created three methods to access an object's data, 
&lt;CODE&gt;name(),&lt;/CODE&gt; 
&lt;CODE&gt;age(),&lt;/CODE&gt; and 
&lt;CODE&gt;peers().&lt;/CODE&gt; These are all substantially similar. If called with an argument, they set the appropriate field; otherwise they return the value held by that field, meaning the value of that hash key.

&lt;P&gt;
&lt;HR&gt;
&lt;H2&gt;&lt;A NAME="Planning_for_the_Future_Better_"&gt;Planning for the Future: Better Constructors&lt;/A&gt;&lt;/H2&gt;
&lt;P&gt;
Even though at this point you may not even know what it means, someday you're going to worry about inheritance. (You can safely ignore this for now and worry about it later if you'd like.) To ensure that this all works out smoothly, you must use the double-argument form of 
&lt;CODE&gt;bless().&lt;/CODE&gt; The second argument is the class into which the referent will be blessed. By not assuming our own class as the default second argument and instead using the class passed into us, we make our constructor inheritable.

&lt;P&gt;
While we're at it, let's make our constructor a bit more flexible. Rather
than being uniquely a class method, we'll set it up so that it can be
called as either a class method &lt;EM&gt;or&lt;/EM&gt; an object method. That way you can say:

&lt;P&gt;
&lt;PRE&gt;    $me  = Person-&amp;gt;new();
    $him = $me-&amp;gt;new();
&lt;/PRE&gt;
&lt;P&gt;
To do this, all we have to do is check whether what was passed in was a reference or not. If so, we were invoked as an object method, and we need to extract the package (class) using the 
&lt;CODE&gt;ref()&lt;/CODE&gt; function. If not, we just use the string passed in as the package name for blessing our referent.

&lt;P&gt;
&lt;PRE&gt;    sub new {
        my $proto = shift;
        my $class = ref($proto) || $proto;
        my $self  = {};
        $self-&amp;gt;{NAME}   = undef;
        $self-&amp;gt;{AGE}    = undef;
        $self-&amp;gt;{PEERS}  = &amp;#091;&amp;#093;;
        bless ($self, $class);
        return $self;
    }
&lt;/PRE&gt;
&lt;P&gt;
That's about all there is for constructors. These methods bring objects to
life, returning neat little opaque bundles to the user to be used in
subsequent method calls.

&lt;P&gt;
&lt;HR&gt;
&lt;H2&gt;&lt;A NAME="Destructors"&gt;Destructors&lt;/A&gt;&lt;/H2&gt;
&lt;P&gt;
Every story has a beginning and an end. The beginning of the object's story
is its constructor, explicitly called when the object comes into existence.
But the ending of its story is the &lt;EM&gt;destructor&lt;/EM&gt;, a method implicitly called when an object leaves this life. Any per-object clean-up code is placed in the destructor, which must (in Perl) be called 
&lt;FONT SIZE=-1&gt;DESTROY.&lt;/FONT&gt;

&lt;P&gt;
If constructors can have arbitrary names, then why not destructors? Because while a constructor is explicitly called, a destructor is not. Destruction happens automatically via Perl's garbage collection 
&lt;FONT SIZE=-1&gt;(GC)&lt;/FONT&gt; system, which is a quick but somewhat lazy reference-based 
&lt;FONT SIZE=-1&gt;GC&lt;/FONT&gt; system. To know what to call, Perl insists that the destructor be named 
&lt;FONT SIZE=-1&gt;DESTROY.&lt;/FONT&gt; Perl's notion of the right time to call a destructor is not well-defined currently, which is why your destructors should not rely on when they are called.

&lt;P&gt;
Why is 
&lt;FONT SIZE=-1&gt;DESTROY&lt;/FONT&gt; in all caps? Perl on occasion uses purely uppercase function names as a convention to indicate that the function will be automatically called by Perl in some way. Others that are called implicitly include 
&lt;FONT SIZE=-1&gt;BEGIN,&lt;/FONT&gt; 
&lt;FONT SIZE=-1&gt;END,&lt;/FONT&gt; 
&lt;FONT SIZE=-1&gt;AUTOLOAD,&lt;/FONT&gt; plus all methods used by tied objects, described in
 [perlman:perltie|the perltie manpage].

&lt;P&gt;
In really good object-oriented programming languages, the user doesn't care when the destructor is called. It just happens when it's supposed to. In low-level languages without any 
&lt;FONT SIZE=-1&gt;GC&lt;/FONT&gt; at all, there's no way to depend on this happening at the right time, so the programmer must explicitly call the destructor to clean up memory and state, crossing their fingers that it's the right time to do so. Unlike 
&lt;FONT SIZE=-1&gt;C++,&lt;/FONT&gt; an object destructor is nearly never needed in Perl, and even when it is, explicit invocation is uncalled for. In the case of our Person class, we don't need a destructor because Perl takes care of simple matters like memory deallocation.

&lt;P&gt;
The only situation where Perl's reference-based 
&lt;FONT SIZE=-1&gt;GC&lt;/FONT&gt; won't work is when there's a circularity in the
data structure, such as:

&lt;P&gt;
&lt;PRE&gt;    $this-&amp;gt;{WHATEVER} = $this;
&lt;/PRE&gt;
&lt;P&gt;
In that case, you must delete the self-reference manually if you expect
your program not to leak memory. While admittedly error-prone, this is the
best we can do right now. Nonetheless, rest assured that when your program
is finished, its objects' destructors are all duly called. So you are
guaranteed that an object &lt;EM&gt;eventually&lt;/EM&gt; gets properly destroyed, except in the unique case of a program that never exits. (If you're running Perl embedded in another application, this full 
&lt;FONT SIZE=-1&gt;GC&lt;/FONT&gt; pass happens a bit more frequently--whenever a thread shuts down.)

&lt;P&gt;
&lt;HR&gt;
&lt;H2&gt;&lt;A NAME="Other_Object_Methods"&gt;Other Object Methods&lt;/A&gt;&lt;/H2&gt;
&lt;P&gt;
The methods we've talked about so far have either been constructors or else simple ``data methods'', interfaces to data stored in the object. These are a bit like an object's data members in the 
&lt;FONT SIZE=-1&gt;C++&lt;/FONT&gt; world, except that strangers don't access them as data. Instead, they should only access the object's data indirectly via its methods. This is an important rule: in Perl, access to an object's data should
 &lt;EM&gt;only&lt;/EM&gt;
be made through methods.

&lt;P&gt;
Perl doesn't impose restrictions on who gets to use which methods. The
public-versus-private distinction is by convention, not syntax. (Well,
unless you use the Alias module described below in
&lt;A HREF="#Data_Members_as_Variables"&gt;Data Members as Variables&lt;/A&gt;.) Occasionally you'll see method names beginning or ending with an
underscore or two. This marking is a convention indicating that the methods
are private to that class alone and sometimes to its closest acquaintances,
its immediate subclasses. But this distinction is not enforced by Perl
itself. It's up to the programmer to behave.

&lt;P&gt;
There's no reason to limit methods to those that simply access data.
Methods can do anything at all. The key point is that they're invoked
against an object or a class. Let's say we'd like object methods that do
more than fetch or set one particular field.

&lt;P&gt;
&lt;PRE&gt;    sub exclaim {
        my $self = shift;
        return sprintf &amp;quot;Hi, I'm %s, age %d, working with %s&amp;quot;,
            $self-&amp;gt;{NAME}, $self-&amp;gt;{AGE}, join(&amp;quot;, &amp;quot;, $self-&amp;gt;{PEERS});
    }
&lt;/PRE&gt;
&lt;P&gt;
Or maybe even one like this:

&lt;P&gt;
&lt;PRE&gt;    sub happy_birthday {
        my $self = shift;
        return ++$self-&amp;gt;{AGE};
    }
&lt;/PRE&gt;
&lt;P&gt;
Some might argue that one should go at these this way:

&lt;P&gt;
&lt;PRE&gt;    sub exclaim {
        my $self = shift;
        return sprintf &amp;quot;Hi, I'm %s, age %d, working with %s&amp;quot;,
            $self-&amp;gt;name, $self-&amp;gt;age, join(&amp;quot;, &amp;quot;, $self-&amp;gt;peers);
    }
&lt;/PRE&gt;
&lt;P&gt;
&lt;PRE&gt;    sub happy_birthday {
        my $self = shift;
        return $self-&amp;gt;age( $self-&amp;gt;age() + 1 );
    }
&lt;/PRE&gt;
&lt;P&gt;
But since these methods are all executing in the class itself, this may not
be critical. There are tradeoffs to be made. Using direct hash access is
faster (about an order of magnitude faster, in fact), and it's more
convenient when you want to interpolate in strings. But using methods (the
external interface) internally shields not just the users of your class but
even you yourself from changes in your data representation.

&lt;P&gt;
&lt;HR&gt;
&lt;H1&gt;&lt;A NAME="Class_Data"&gt;Class Data&lt;/A&gt;&lt;/H1&gt;
&lt;P&gt;
What about ``class data'', data items common to each object in a class?
What would you want that for? Well, in your Person class, you might like to
keep track of the total people alive. How do you implement that?

&lt;P&gt;
You &lt;EM&gt;could&lt;/EM&gt; make it a global variable called $Person::Census. But about only reason
you'd do that would be if you &lt;EM&gt;wanted&lt;/EM&gt; people to be able to get at your class data directly. They could just say
$Person::Census and play around with it. Maybe this is ok in your design
scheme. You might even conceivably want to make it an exported variable. To
be exportable, a variable must be a (package) global. If this were a
traditional module rather than an object-oriented one, you might do that.

&lt;P&gt;
While this approach is expected in most traditional modules, it's generally
considered rather poor form in most object modules. In an object module,
you should set up a protective veil to separate interface from
implementation. So provide a class method to access class data just as you
provide object methods to access object data.

&lt;P&gt;
So, you &lt;EM&gt;could&lt;/EM&gt; still keep &lt;CODE&gt;$Census&lt;/CODE&gt; as a package global and rely upon others to
honor the contract of the module and therefore not play around with its
implementation. You could even be supertricky and make &lt;CODE&gt;$Census&lt;/CODE&gt;
a tied object as described in [perlman:perltie|the perltie manpage], thereby intercepting all accesses.

&lt;P&gt;
But more often than not, you just want to make your class data a
file-scoped lexical. To do so, simply put this at the top of the file:

&lt;P&gt;
&lt;PRE&gt;    my $Census = 0;
&lt;/PRE&gt;
&lt;P&gt;
Even though the scope of a 
&lt;CODE&gt;my()&lt;/CODE&gt; normally expires when the block in which it was declared is done (in this case the whole file being required or used), Perl's deep binding of lexical variables guarantees that the variable will not be deallocated, remaining accessible to functions declared within that scope. This doesn't work with global variables given temporary values via 
&lt;CODE&gt;local(),&lt;/CODE&gt; though.

&lt;P&gt;
Irrespective of whether you leave &lt;CODE&gt;$Census&lt;/CODE&gt; a package global or
make it instead a file-scoped lexical, you should make these changes to
your Person::new() constructor:

&lt;P&gt;
&lt;PRE&gt;    sub new {
        my $proto = shift;
        my $class = ref($proto) || $proto;
        my $self  = {};
        $Census++;
        $self-&amp;gt;{NAME}   = undef;
        $self-&amp;gt;{AGE}    = undef;
        $self-&amp;gt;{PEERS}  = &amp;#091;&amp;#093;;
        bless ($self, $class);
        return $self;
    }
&lt;/PRE&gt;
&lt;P&gt;
&lt;PRE&gt;    sub population {
        return $Census;
    }
&lt;/PRE&gt;
&lt;P&gt;
Now that we've done this, we certainly do need a destructor so that when
Person is destroyed, the &lt;CODE&gt;$Census&lt;/CODE&gt; goes down. Here's how this
could be done:

&lt;P&gt;
&lt;PRE&gt;    sub DESTROY { --$Census }
&lt;/PRE&gt;
&lt;P&gt;
Notice how there's no memory to deallocate in the destructor? That's
something that Perl takes care of for you all by itself.

&lt;P&gt;
&lt;HR&gt;
&lt;H2&gt;&lt;A NAME="Accessing_Class_Data"&gt;Accessing Class Data&lt;/A&gt;&lt;/H2&gt;
&lt;P&gt;
It turns out that this is not really a good way to go about handling class data. 
&lt;FONT SIZE=-1&gt;A&lt;/FONT&gt; good scalable rule is that
 &lt;EM&gt;you must never reference class
data directly from an object method&lt;/EM&gt;. Otherwise you aren't building a scalable, inheritable class. The object
must be the rendezvous point for all operations, especially from an object
method. The globals (class data) would in some sense be in the ``wrong''
package in your derived classes. In Perl, methods execute in the context of
the class they were defined in, &lt;EM&gt;not&lt;/EM&gt; that of the object that triggered them. Therefore, namespace visibility of
package globals in methods is unrelated to inheritance.

&lt;P&gt;
Got that? Maybe not. Ok, let's say that some other class ``borrowed'' (well, inherited) the 
&lt;FONT SIZE=-1&gt;DESTROY&lt;/FONT&gt; method as it was defined above. When those objects are destroyed, the original &lt;CODE&gt;$Census&lt;/CODE&gt; variable will be altered, not the one in the new class's package namespace. Perhaps this is what you want, but probably it isn't.

&lt;P&gt;
Here's how to fix this. We'll store a reference to the data in the value accessed by the hash key 
&lt;FONT SIZE=-1&gt;``_CENSUS''.&lt;/FONT&gt; Why the underscore? Well, mostly because an initial underscore already conveys strong feelings of magicalness to a 
&lt;FONT SIZE=-1&gt;C&lt;/FONT&gt; programmer. It's really just a mnemonic device to remind ourselves that this field is special and not to be used as a public data member in the same way that 
&lt;FONT SIZE=-1&gt;NAME,&lt;/FONT&gt; 
&lt;FONT SIZE=-1&gt;AGE,&lt;/FONT&gt; and 
&lt;FONT SIZE=-1&gt;PEERS&lt;/FONT&gt; are. (Because we've been developing this code under the strict pragma, prior to perl version 5.004 we'll have to quote the field name.)

&lt;P&gt;
&lt;PRE&gt;    sub new {
        my $proto = shift;
        my $class = ref($proto) || $proto;
        my $self  = {};
        $self-&amp;gt;{NAME}     = undef;
        $self-&amp;gt;{AGE}      = undef;
        $self-&amp;gt;{PEERS}    = &amp;#091;&amp;#093;;
        # &amp;quot;private&amp;quot; data
        $self-&amp;gt;{&amp;quot;_CENSUS&amp;quot;} = \$Census;
        bless ($self, $class);
        ++ ${ $self-&amp;gt;{&amp;quot;_CENSUS&amp;quot;} };
        return $self;
    }
&lt;/PRE&gt;
&lt;P&gt;
&lt;PRE&gt;    sub population {
        my $self = shift;
        if (ref $self) {
            return ${ $self-&amp;gt;{&amp;quot;_CENSUS&amp;quot;} };
        } else {
            return $Census;
        }
    }
&lt;/PRE&gt;
&lt;P&gt;
&lt;PRE&gt;    sub DESTROY {
        my $self = shift;
        -- ${ $self-&amp;gt;{&amp;quot;_CENSUS&amp;quot;} };
    }
&lt;/PRE&gt;
&lt;P&gt;
&lt;HR&gt;
&lt;H2&gt;&lt;A NAME="Debugging_Methods"&gt;Debugging Methods&lt;/A&gt;&lt;/H2&gt;
&lt;P&gt;
It's common for a class to have a debugging mechanism. For example, you might want to see when objects are created or destroyed. To do that, add a debugging variable as a file-scoped lexical. For this, we'll pull in the standard Carp module to emit our warnings and fatal messages. That way messages will come out with the caller's filename and line number instead of our own; if we wanted them to be from our own perspective, we'd just use 
&lt;CODE&gt;die()&lt;/CODE&gt; and 
&lt;CODE&gt;warn()&lt;/CODE&gt; directly instead of 
&lt;CODE&gt;croak()&lt;/CODE&gt; and 
&lt;CODE&gt;carp()&lt;/CODE&gt; respectively.

&lt;P&gt;
&lt;PRE&gt;    use Carp;
    my $Debugging = 0;
&lt;/PRE&gt;
&lt;P&gt;
Now add a new class method to access the variable.

&lt;P&gt;
&lt;PRE&gt;    sub debug {
        my $class = shift;
        if (ref $class)  { confess &amp;quot;Class method called as object method&amp;quot; }
        unless (@_ == 1) { confess &amp;quot;usage: CLASSNAME-&amp;gt;debug(level)&amp;quot; }
        $Debugging = shift;
    }
&lt;/PRE&gt;
&lt;P&gt;
Now fix up 
&lt;FONT SIZE=-1&gt;DESTROY&lt;/FONT&gt; to murmur a bit as the moribund object
expires:

&lt;P&gt;
&lt;PRE&gt;    sub DESTROY {
        my $self = shift;
        if ($Debugging) { carp &amp;quot;Destroying $self &amp;quot; . $self-&amp;gt;name }
        -- ${ $self-&amp;gt;{&amp;quot;_CENSUS&amp;quot;} };
    }
&lt;/PRE&gt;
&lt;P&gt;
One could conceivably make a per-object debug state. That way you could
call both of these:

&lt;P&gt;
&lt;PRE&gt;    Person-&amp;gt;debug(1);   # entire class
    $him-&amp;gt;debug(1);     # just this object
&lt;/PRE&gt;
&lt;P&gt;
To do so, we need our debugging method to be a ``bimodal'' one, one that
works on both classes &lt;EM&gt;and&lt;/EM&gt; objects. Therefore, adjust the 
&lt;CODE&gt;debug()&lt;/CODE&gt; and 
&lt;FONT SIZE=-1&gt;DESTROY&lt;/FONT&gt; methods as follows:

&lt;P&gt;
&lt;PRE&gt;    sub debug {
        my $self = shift;
        confess &amp;quot;usage: thing-&amp;gt;debug(level)&amp;quot;    unless @_ == 1;
        my $level = shift;
        if (ref($self))  {
            $self-&amp;gt;{&amp;quot;_DEBUG&amp;quot;} = $level;         # just myself
        } else {
            $Debugging        = $level;         # whole class
        }
    }
&lt;/PRE&gt;
&lt;P&gt;
&lt;PRE&gt;    sub DESTROY {
        my $self = shift;
        if ($Debugging || $self-&amp;gt;{&amp;quot;_DEBUG&amp;quot;}) {
            carp &amp;quot;Destroying $self &amp;quot; . $self-&amp;gt;name;
        }
        -- ${ $self-&amp;gt;{&amp;quot;_CENSUS&amp;quot;} };
    }
&lt;/PRE&gt;
&lt;P&gt;
What happens if a derived class (which we'll call Employee) inherits
methods from this Person base class? Then &lt;CODE&gt;Employee-&amp;gt;debug()&lt;/CODE&gt;, when called as a class method, manipulates $Person::Debugging not
$Employee::Debugging.

&lt;P&gt;
&lt;HR&gt;
&lt;H2&gt;&lt;A NAME="Class_Destructors"&gt;Class Destructors&lt;/A&gt;&lt;/H2&gt;
&lt;P&gt;
The object destructor handles the death of each distinct object. But
sometimes you want a bit of cleanup when the entire class is shut down,
which currently only happens when the program exits. To make such a
&lt;EM&gt;class destructor&lt;/EM&gt;, create a function in that class's package named 
&lt;FONT SIZE=-1&gt;END.&lt;/FONT&gt; This works just like the 
&lt;FONT SIZE=-1&gt;END&lt;/FONT&gt; function in traditional modules, meaning that it gets called whenever your program exits unless it execs or dies of an uncaught signal. For example,

&lt;P&gt;
&lt;PRE&gt;    sub END {
        if ($Debugging) {
            print &amp;quot;All persons are going away now.\n&amp;quot;;
        }
    }
&lt;/PRE&gt;
&lt;P&gt;
When the program exits, all the class destructors 
&lt;FONT SIZE=-1&gt;(END&lt;/FONT&gt; functions) are be called in the opposite order that they were loaded in 
&lt;FONT SIZE=-1&gt;(LIFO&lt;/FONT&gt; order).

&lt;P&gt;
&lt;HR&gt;
&lt;H2&gt;&lt;A NAME="Documenting_the_Interface"&gt;Documenting the Interface&lt;/A&gt;&lt;/H2&gt;
&lt;P&gt;
And there you have it: we've just shown you the &lt;EM&gt;implementation&lt;/EM&gt; of this Person class. Its &lt;EM&gt;interface&lt;/EM&gt; would be its documentation. Usually this means putting it in pod (``plain
old documentation'') format right there in the same file. In our Person
example, we would place the following docs anywhere in the Person.pm file.
Even though it looks mostly like code, it's not. It's embedded
documentation such as would be used by the pod2man, pod2html, or pod2text
programs. The Perl compiler ignores pods entirely, just as the translators
ignore code. Here's an example of some pods describing the informal
interface:

&lt;P&gt;
&lt;PRE&gt;    =head1 NAME
&lt;/PRE&gt;
&lt;P&gt;
&lt;PRE&gt;    Person - class to implement people
&lt;/PRE&gt;
&lt;P&gt;
&lt;PRE&gt;    =head1 SYNOPSIS
&lt;/PRE&gt;
&lt;P&gt;
&lt;PRE&gt;     use Person;
&lt;/PRE&gt;
&lt;P&gt;
&lt;PRE&gt;     #################
     # class methods #
     #################
     $ob    = Person-&amp;gt;new;
     $count = Person-&amp;gt;population;
&lt;/PRE&gt;
&lt;P&gt;
&lt;PRE&gt;     #######################
     # object data methods #
     #######################
&lt;/PRE&gt;
&lt;P&gt;
&lt;PRE&gt;     ### get versions ###
         $who   = $ob-&amp;gt;name;
         $years = $ob-&amp;gt;age;
         @pals  = $ob-&amp;gt;peers;
&lt;/PRE&gt;
&lt;P&gt;
&lt;PRE&gt;     ### set versions ###
         $ob-&amp;gt;name(&amp;quot;Jason&amp;quot;);
         $ob-&amp;gt;age(23);
         $ob-&amp;gt;peers( &amp;quot;Norbert&amp;quot;, &amp;quot;Rhys&amp;quot;, &amp;quot;Phineas&amp;quot; );
&lt;/PRE&gt;
&lt;P&gt;
&lt;PRE&gt;     ########################
     # other object methods #
     ########################
&lt;/PRE&gt;
&lt;P&gt;
&lt;PRE&gt;     $phrase = $ob-&amp;gt;exclaim;
     $ob-&amp;gt;happy_birthday;
&lt;/PRE&gt;
&lt;P&gt;
&lt;PRE&gt;    =head1 DESCRIPTION
&lt;/PRE&gt;
&lt;P&gt;
&lt;PRE&gt;    The Person class implements dah dee dah dee dah....
&lt;/PRE&gt;
&lt;P&gt;
That's all there is to the matter of interface versus implementation. 
&lt;FONT SIZE=-1&gt;A&lt;/FONT&gt; programmer who opens up the module and plays around
with all the private little shiny bits that were safely locked up behind
the interface contract has voided the warranty, and you shouldn't worry
about their fate.

&lt;P&gt;
&lt;HR&gt;
&lt;H1&gt;&lt;A NAME="Aggregation"&gt;Aggregation&lt;/A&gt;&lt;/H1&gt;
&lt;P&gt;
Suppose you later want to change the class to implement better names.
Perhaps you'd like to support both given names (called Christian names,
irrespective of one's religion) and family names (called surnames), plus
nicknames and titles. If users of your Person class have been properly
accessing it through its documented interface, then you can easily change
the underlying implementation. If they haven't, then they lose and it's
their fault for breaking the contract and voiding their warranty.

&lt;P&gt;
To do this, we'll make another class, this one called Fullname. What's the
Fullname class look like? To answer that question, you have to first figure
out how you want to use it. How about we use it this way:

&lt;P&gt;
&lt;PRE&gt;    $him = Person-&amp;gt;new();
    $him-&amp;gt;fullname-&amp;gt;title(&amp;quot;St&amp;quot;);
    $him-&amp;gt;fullname-&amp;gt;christian(&amp;quot;Thomas&amp;quot;);
    $him-&amp;gt;fullname-&amp;gt;surname(&amp;quot;Aquinas&amp;quot;);
    $him-&amp;gt;fullname-&amp;gt;nickname(&amp;quot;Tommy&amp;quot;);
    printf &amp;quot;His normal name is %s\n&amp;quot;, $him-&amp;gt;name;
    printf &amp;quot;But his real name is %s\n&amp;quot;, $him-&amp;gt;fullname-&amp;gt;as_string;
&lt;/PRE&gt;
&lt;P&gt;
Ok. To do this, we'll change Person::new() so that it supports a full name
field this way:

&lt;P&gt;
&lt;PRE&gt;    sub new {
        my $proto = shift;
        my $class = ref($proto) || $proto;
        my $self  = {};
        $self-&amp;gt;{FULLNAME} = Fullname-&amp;gt;new();
        $self-&amp;gt;{AGE}      = undef;
        $self-&amp;gt;{PEERS}    = &amp;#091;&amp;#093;;
        $self-&amp;gt;{&amp;quot;_CENSUS&amp;quot;} = \$Census;
        bless ($self, $class);
        ++ ${ $self-&amp;gt;{&amp;quot;_CENSUS&amp;quot;} };
        return $self;
    }
&lt;/PRE&gt;
&lt;P&gt;
&lt;PRE&gt;    sub fullname {
        my $self = shift;
        return $self-&amp;gt;{FULLNAME};
    }
&lt;/PRE&gt;
&lt;P&gt;
Then to support old code, define Person::name() this way:

&lt;P&gt;
&lt;PRE&gt;    sub name {
        my $self = shift;
        return $self-&amp;gt;{FULLNAME}-&amp;gt;nickname(@_)
          ||   $self-&amp;gt;{FULLNAME}-&amp;gt;christian(@_);
    }
&lt;/PRE&gt;
&lt;P&gt;
Here's the Fullname class. We'll use the same technique of using a hash
reference to hold data fields, and methods by the appropriate name to
access them:

&lt;P&gt;
&lt;PRE&gt;    package Fullname;
    use strict;
&lt;/PRE&gt;
&lt;P&gt;
&lt;PRE&gt;    sub new {
        my $proto = shift;
        my $class = ref($proto) || $proto;
        my $self  = {
            TITLE       =&amp;gt; undef,
            CHRISTIAN   =&amp;gt; undef,
            SURNAME     =&amp;gt; undef,
            NICK        =&amp;gt; undef,
        };
        bless ($self, $class);
        return $self;
    }
&lt;/PRE&gt;
&lt;P&gt;
&lt;PRE&gt;    sub christian {
        my $self = shift;
        if (@_) { $self-&amp;gt;{CHRISTIAN} = shift }
        return $self-&amp;gt;{CHRISTIAN};
    }
&lt;/PRE&gt;
&lt;P&gt;
&lt;PRE&gt;    sub surname {
        my $self = shift;
        if (@_) { $self-&amp;gt;{SURNAME} = shift }
        return $self-&amp;gt;{SURNAME};
    }
&lt;/PRE&gt;
&lt;P&gt;
&lt;PRE&gt;    sub nickname {
        my $self = shift;
        if (@_) { $self-&amp;gt;{NICK} = shift }
        return $self-&amp;gt;{NICK};
    }
&lt;/PRE&gt;
&lt;P&gt;
&lt;PRE&gt;    sub title {
        my $self = shift;
        if (@_) { $self-&amp;gt;{TITLE} = shift }
        return $self-&amp;gt;{TITLE};
    }
&lt;/PRE&gt;
&lt;P&gt;
&lt;PRE&gt;    sub as_string {
        my $self = shift;
        my $name = join(&amp;quot; &amp;quot;, @$self{'CHRISTIAN', 'SURNAME'});
        if ($self-&amp;gt;{TITLE}) {
            $name = $self-&amp;gt;{TITLE} . &amp;quot; &amp;quot; . $name;
        }
        return $name;
    }
&lt;/PRE&gt;
&lt;P&gt;
&lt;PRE&gt;    1;
&lt;/PRE&gt;
&lt;P&gt;
Finally, here's the test program:

&lt;P&gt;
&lt;PRE&gt;    #!/usr/bin/perl -w
    use strict;
    use Person;
    sub END { show_census() }
&lt;/PRE&gt;
&lt;P&gt;
&lt;PRE&gt;    sub show_census ()  {
        printf &amp;quot;Current population: %d\n&amp;quot;, Person-&amp;gt;population;
    }
&lt;/PRE&gt;
&lt;P&gt;
&lt;PRE&gt;    Person-&amp;gt;debug(1);
&lt;/PRE&gt;
&lt;P&gt;
&lt;PRE&gt;    show_census();
&lt;/PRE&gt;
&lt;P&gt;
&lt;PRE&gt;    my $him = Person-&amp;gt;new();
&lt;/PRE&gt;
&lt;P&gt;
&lt;PRE&gt;    $him-&amp;gt;fullname-&amp;gt;christian(&amp;quot;Thomas&amp;quot;);
    $him-&amp;gt;fullname-&amp;gt;surname(&amp;quot;Aquinas&amp;quot;);
    $him-&amp;gt;fullname-&amp;gt;nickname(&amp;quot;Tommy&amp;quot;);
    $him-&amp;gt;fullname-&amp;gt;title(&amp;quot;St&amp;quot;);
    $him-&amp;gt;age(1);
&lt;/PRE&gt;
&lt;P&gt;
&lt;PRE&gt;    printf &amp;quot;%s is really %s.\n&amp;quot;, $him-&amp;gt;name, $him-&amp;gt;fullname;
    printf &amp;quot;%s's age: %d.\n&amp;quot;, $him-&amp;gt;name, $him-&amp;gt;age;
    $him-&amp;gt;happy_birthday;
    printf &amp;quot;%s's age: %d.\n&amp;quot;, $him-&amp;gt;name, $him-&amp;gt;age;
&lt;/PRE&gt;
&lt;P&gt;
&lt;PRE&gt;    show_census();
&lt;/PRE&gt;
&lt;P&gt;
&lt;HR&gt;
&lt;H1&gt;&lt;A NAME="Inheritance"&gt;Inheritance&lt;/A&gt;&lt;/H1&gt;
&lt;P&gt;
Object-oriented programming systems all support some notion of inheritance.
Inheritance means allowing one class to piggy-back on top of another one so
you don't have to write the same code again and again. It's about software
reuse, and therefore related to Laziness, the principal virtue of a
programmer. (The import/export mechanisms in traditional modules are also a
form of code reuse, but a simpler one than the true inheritance that you
find in object modules.)

&lt;P&gt;
Sometimes the syntax of inheritance is built into the core of the language, and sometimes it's not. Perl has no special syntax for specifying the class (or classes) to inherit from. Instead, it's all strictly in the semantics. Each package can have a variable called 
&lt;FONT SIZE=-1&gt;@ISA,&lt;/FONT&gt; which governs (method) inheritance. If you try to call a method on an object or class, and that method is not found in that object's package, Perl then looks to &lt;CODE&gt;@ISA&lt;/CODE&gt; for other packages to go looking through in search of the missing method.

&lt;P&gt;
Like the special per-package variables recognized by Exporter (such as 
&lt;FONT SIZE=-1&gt;@EXPORT,&lt;/FONT&gt; 
&lt;FONT SIZE=-1&gt;@EXPORT_OK,&lt;/FONT&gt; 
&lt;FONT SIZE=-1&gt;@EXPORT_FAIL,&lt;/FONT&gt; 
&lt;FONT SIZE=-1&gt;%EXPORT_TAGS,&lt;/FONT&gt; and 
&lt;FONT SIZE=-1&gt;$VERSION),&lt;/FONT&gt; the &lt;CODE&gt;@ISA&lt;/CODE&gt; array
 &lt;EM&gt;must&lt;/EM&gt; be a package-scoped global and not a file-scoped lexical created via 
&lt;CODE&gt;my().&lt;/CODE&gt; Most classes have just one item in their &lt;CODE&gt;@ISA&lt;/CODE&gt; array. In this case, we have what's called ``single inheritance'', or 
&lt;FONT SIZE=-1&gt;SI&lt;/FONT&gt; for short.

&lt;P&gt;
Consider this class:

&lt;P&gt;
&lt;PRE&gt;    package Employee;
    use Person;
    @ISA = (&amp;quot;Person&amp;quot;);
    1;
&lt;/PRE&gt;
&lt;P&gt;
Not a lot to it, eh? All it's doing so far is loading in another class and
stating that this one will inherit methods from that other class if need
be. We have given it none of its own methods. We rely upon an Employee to
behave just like a Person.

&lt;P&gt;
Setting up an empty class like this is called the ``empty subclass test'';
that is, making a derived class that does nothing but inherit from a base
class. If the original base class has been designed properly, then the new
derived class can be used as a drop-in replacement for the old one. This
means you should be able to write a program like this:

&lt;P&gt;
&lt;PRE&gt;    use Employee;
    my $empl = Employee-&amp;gt;new();
    $empl-&amp;gt;name(&amp;quot;Jason&amp;quot;);
    $empl-&amp;gt;age(23);
    printf &amp;quot;%s is age %d.\n&amp;quot;, $empl-&amp;gt;name, $empl-&amp;gt;age;
&lt;/PRE&gt;
&lt;P&gt;
By proper design, we mean always using the two-argument form of 
&lt;CODE&gt;bless(),&lt;/CODE&gt; avoiding direct
access of global data, and not exporting anything. If you look back at the
Person::new() function we defined above, we were careful to do that.
There's a bit of package data used in the constructor, but the reference to
this is stored on the object itself and all other methods access package
data via that reference, so we should be ok.

&lt;P&gt;
What do we mean by the Person::new() function -- isn't that actually a method? Well, in principle, yes. 
&lt;FONT SIZE=-1&gt;A&lt;/FONT&gt; method is just a function that expects as its first argument a class name (package) or object (blessed reference). Person::new() is the function that both the

&lt;CODE&gt;Person-&amp;gt;new()&lt;/CODE&gt; method and the &lt;CODE&gt;Employee-&amp;gt;new()&lt;/CODE&gt; method end up calling. Understand that while a method call looks a lot like
a function call, they aren't really quite the same, and if you treat them
as the same, you'll very soon be left with nothing but broken programs.
First, the actual underlying calling conventions are different: method
calls get an extra argument. Second, function calls don't do inheritance,
but methods do.

&lt;P&gt;
&lt;PRE&gt;        Method Call             Resulting Function Call
        -----------             ------------------------
        Person-&amp;gt;new()           Person::new(&amp;quot;Person&amp;quot;)
        Employee-&amp;gt;new()         Person::new(&amp;quot;Employee&amp;quot;)
&lt;/PRE&gt;
&lt;P&gt;
So don't use function calls when you mean to call a method.

&lt;P&gt;
If an employee is just a Person, that's not all too very interesting. So let's add some other methods. We'll give our employee data fields to access their salary, their employee 
&lt;FONT SIZE=-1&gt;ID,&lt;/FONT&gt; and their start date.

&lt;P&gt;
If you're getting a little tired of creating all these nearly identical
methods just to get at the object's data, do not despair. Later, we'll
describe several different convenience mechanisms for shortening this up.
Meanwhile, here's the straight-forward way:

&lt;P&gt;
&lt;PRE&gt;    sub salary {
        my $self = shift;
        if (@_) { $self-&amp;gt;{SALARY} = shift }
        return $self-&amp;gt;{SALARY};
    }
&lt;/PRE&gt;
&lt;P&gt;
&lt;PRE&gt;    sub id_number {
        my $self = shift;
        if (@_) { $self-&amp;gt;{ID} = shift }
        return $self-&amp;gt;{ID};
    }
&lt;/PRE&gt;
&lt;P&gt;
&lt;PRE&gt;    sub start_date {
        my $self = shift;
        if (@_) { $self-&amp;gt;{START_DATE} = shift }
        return $self-&amp;gt;{START_DATE};
    }
&lt;/PRE&gt;
&lt;P&gt;
&lt;HR&gt;
&lt;H2&gt;&lt;A NAME="Overridden_Methods"&gt;Overridden Methods&lt;/A&gt;&lt;/H2&gt;
&lt;P&gt;
What happens when both a derived class and its base class have the same method defined? Well, then you get the derived class's version of that method. For example, let's say that we want the 
&lt;CODE&gt;peers()&lt;/CODE&gt; method called on an employee to act a bit differently. Instead of just returning the list of peer names, let's return slightly different strings. So doing this:

&lt;P&gt;
&lt;PRE&gt;    $empl-&amp;gt;peers(&amp;quot;Peter&amp;quot;, &amp;quot;Paul&amp;quot;, &amp;quot;Mary&amp;quot;);
    printf &amp;quot;His peers are: %s\n&amp;quot;, join(&amp;quot;, &amp;quot;, $empl-&amp;gt;peers);
&lt;/PRE&gt;
&lt;P&gt;
will produce:

&lt;P&gt;
&lt;PRE&gt;    His peers are: PEON=PETER, PEON=PAUL, PEON=MARY
&lt;/PRE&gt;
&lt;P&gt;
To do this, merely add this definition into the Employee.pm file:

&lt;P&gt;
&lt;PRE&gt;    sub peers {
        my $self = shift;
        if (@_) { @{ $self-&amp;gt;{PEERS} } = @_ }
        return map { &amp;quot;PEON=\U$_&amp;quot; } @{ $self-&amp;gt;{PEERS} };
    }
&lt;/PRE&gt;
&lt;P&gt;
There, we've just demonstrated the high-falutin' concept known in certain
circles as &lt;EM&gt;polymorphism&lt;/EM&gt;. We've taken on the form and behaviour of an existing object, and then
we've altered it to suit our own purposes. This is a form of Laziness.
(Getting polymorphed is also what happens when the wizard decides you'd
look better as a frog.)

&lt;P&gt;
Every now and then you'll want to have a method call trigger both its derived class (also known as ``subclass'') version as well as its base class (also known as ``superclass'') version. In practice, constructors and destructors are likely to want to do this, and it probably also makes sense in the 
&lt;CODE&gt;debug()&lt;/CODE&gt; method we showed previously.

&lt;P&gt;
To do this, add this to Employee.pm:

&lt;P&gt;
&lt;PRE&gt;    use Carp;
    my $Debugging = 0;
&lt;/PRE&gt;
&lt;P&gt;
&lt;PRE&gt;    sub debug {
        my $self = shift;
        confess &amp;quot;usage: thing-&amp;gt;debug(level)&amp;quot;    unless @_ == 1;
        my $level = shift;
        if (ref($self))  {
            $self-&amp;gt;{&amp;quot;_DEBUG&amp;quot;} = $level;
        } else {
            $Debugging = $level;            # whole class
        }
        Person::debug($self, $Debugging);   # don't really do this
    }
&lt;/PRE&gt;
&lt;P&gt;
As you see, we turn around and call the Person package's 
&lt;CODE&gt;debug()&lt;/CODE&gt; function. But this is far too fragile for good design. What if Person doesn't have a 
&lt;CODE&gt;debug()&lt;/CODE&gt; function, but is inheriting
 &lt;EM&gt;its&lt;/EM&gt; 
&lt;CODE&gt;debug()&lt;/CODE&gt; method from elsewhere?
It would have been slightly better to say

&lt;P&gt;
&lt;PRE&gt;    Person-&amp;gt;debug($Debugging);
&lt;/PRE&gt;
&lt;P&gt;
But even that's got too much hard-coded. It's somewhat better to say

&lt;P&gt;
&lt;PRE&gt;    $self-&amp;gt;Person::debug($Debugging);
&lt;/PRE&gt;
&lt;P&gt;
Which is a funny way to say to start looking for a 
&lt;CODE&gt;debug()&lt;/CODE&gt; method up in Person.
This strategy is more often seen on overridden object methods than on
overridden class methods.

&lt;P&gt;
There is still something a bit off here. We've hard-coded our superclass's name. This in particular is bad if you change which classes you inherit from, or add others. Fortunately, the pseudoclass 
&lt;FONT SIZE=-1&gt;SUPER&lt;/FONT&gt; comes to the rescue here.

&lt;P&gt;
&lt;PRE&gt;    $self-&amp;gt;SUPER::debug($Debugging);
&lt;/PRE&gt;
&lt;P&gt;
This way it starts looking in my class's 
&lt;FONT SIZE=-1&gt;@ISA.&lt;/FONT&gt; This only makes sense from &lt;EM&gt;within&lt;/EM&gt; a method call, though. Don't try to access anything in 
&lt;FONT SIZE=-1&gt;SUPER::&lt;/FONT&gt; from anywhere else, because it doesn't exist
outside an overridden method call.

&lt;P&gt;
Things are getting a bit complicated here. Have we done anything we
shouldn't? As before, one way to test whether we're designing a decent
class is via the empty subclass test. Since we already have an Employee
class that we're trying to check, we'd better get a new empty subclass that
can derive from Employee. Here's one:

&lt;P&gt;
&lt;PRE&gt;    package Boss;
    use Employee;        # :-)
    @ISA = qw(Employee);
&lt;/PRE&gt;
&lt;P&gt;
And here's the test program:

&lt;P&gt;
&lt;PRE&gt;    #!/usr/bin/perl -w
    use strict;
    use Boss;
    Boss-&amp;gt;debug(1);
&lt;/PRE&gt;
&lt;P&gt;
&lt;PRE&gt;    my $boss = Boss-&amp;gt;new();
&lt;/PRE&gt;
&lt;P&gt;
&lt;PRE&gt;    $boss-&amp;gt;fullname-&amp;gt;title(&amp;quot;Don&amp;quot;);
    $boss-&amp;gt;fullname-&amp;gt;surname(&amp;quot;Pichon Alvarez&amp;quot;);
    $boss-&amp;gt;fullname-&amp;gt;christian(&amp;quot;Federico Jesus&amp;quot;);
    $boss-&amp;gt;fullname-&amp;gt;nickname(&amp;quot;Fred&amp;quot;);
&lt;/PRE&gt;
&lt;P&gt;
&lt;PRE&gt;    $boss-&amp;gt;age(47);
    $boss-&amp;gt;peers(&amp;quot;Frank&amp;quot;, &amp;quot;Felipe&amp;quot;, &amp;quot;Faust&amp;quot;);
&lt;/PRE&gt;
&lt;P&gt;
&lt;PRE&gt;    printf &amp;quot;%s is age %d.\n&amp;quot;, $boss-&amp;gt;fullname, $boss-&amp;gt;age;
    printf &amp;quot;His peers are: %s\n&amp;quot;, join(&amp;quot;, &amp;quot;, $boss-&amp;gt;peers);
&lt;/PRE&gt;
&lt;P&gt;
Running it, we see that we're still ok. If you'd like to dump out your object in a nice format, somewhat like the way the 'x' command works in the debugger, you could use the Data::Dumper module from 
&lt;FONT SIZE=-1&gt;CPAN&lt;/FONT&gt; this way:

&lt;P&gt;
&lt;PRE&gt;    use Data::Dumper;
    print &amp;quot;Here's the boss:\n&amp;quot;;
    print Dumper($boss);
&lt;/PRE&gt;
&lt;P&gt;
Which shows us something like this:

&lt;P&gt;
&lt;PRE&gt;    Here's the boss:
    $VAR1 = bless( {
         _CENSUS =&amp;gt; \1,
         FULLNAME =&amp;gt; bless( {
                              TITLE =&amp;gt; 'Don',
                              SURNAME =&amp;gt; 'Pichon Alvarez',
                              NICK =&amp;gt; 'Fred',
                              CHRISTIAN =&amp;gt; 'Federico Jesus'
                            }, 'Fullname' ),
         AGE =&amp;gt; 47,
         PEERS =&amp;gt; &amp;#091;
                    'Frank',
                    'Felipe',
                    'Faust'
                  &amp;#093;
       }, 'Boss' );
&lt;/PRE&gt;
&lt;P&gt;
Hm.... something's missing there. What about the salary, start date, and 
&lt;FONT SIZE=-1&gt;ID&lt;/FONT&gt; fields? Well, we never set them to anything, even undef, so they don't show up in the hash's keys. The Employee class has no 
&lt;CODE&gt;new()&lt;/CODE&gt; method of its own, and the 
&lt;CODE&gt;new()&lt;/CODE&gt; method in Person doesn't know about Employees. (Nor should it: proper 
&lt;FONT SIZE=-1&gt;OO&lt;/FONT&gt; design dictates that a subclass be allowed to know about its immediate superclass, but never vice-versa.) So let's fix up Employee::new() this way:

&lt;P&gt;
&lt;PRE&gt;    sub new {
        my $proto = shift;
        my $class = ref($proto) || $proto;
        my $self  = $class-&amp;gt;SUPER::new();
        $self-&amp;gt;{SALARY}        = undef;
        $self-&amp;gt;{ID}            = undef;
        $self-&amp;gt;{START_DATE}    = undef;
        bless ($self, $class);          # reconsecrate
        return $self;
    }
&lt;/PRE&gt;
&lt;P&gt;
Now if you dump out an Employee or Boss object, you'll find that new fields
show up there now.

&lt;P&gt;
&lt;HR&gt;
&lt;H2&gt;&lt;A NAME="Multiple_Inheritance"&gt;Multiple Inheritance&lt;/A&gt;&lt;/H2&gt;
&lt;P&gt;
Ok, at the risk of confusing beginners and annoying 
&lt;FONT SIZE=-1&gt;OO&lt;/FONT&gt; gurus, it's time to confess that Perl's object system includes that controversial notion known as multiple inheritance, or 
&lt;FONT SIZE=-1&gt;MI&lt;/FONT&gt; for short. All this means is that rather than having just one parent class who in turn might itself have a parent class, etc., that you can directly inherit from two or more parents. It's true that some uses of 
&lt;FONT SIZE=-1&gt;MI&lt;/FONT&gt; can get you into trouble, although hopefully not quite so much trouble with Perl as with dubiously-OO languages like 
&lt;FONT SIZE=-1&gt;C++.&lt;/FONT&gt;

&lt;P&gt;
The way it works is actually pretty simple: just put more than one package
name in your &lt;CODE&gt;@ISA&lt;/CODE&gt; array. When it comes time for Perl to go
finding methods for your object, it looks at each of these packages in
order. Well, kinda. It's actually a fully recursive, depth-first order.
Consider a bunch of &lt;CODE&gt;@ISA&lt;/CODE&gt; arrays like this:

&lt;P&gt;
&lt;PRE&gt;    @First::ISA    = qw( Alpha );
    @Second::ISA   = qw( Beta );
    @Third::ISA    = qw( First Second );
&lt;/PRE&gt;
&lt;P&gt;
If you have an object of class Third:

&lt;P&gt;
&lt;PRE&gt;    my $ob = Third-&amp;gt;new();
    $ob-&amp;gt;spin();
&lt;/PRE&gt;
&lt;P&gt;
How do we find a 
&lt;CODE&gt;spin()&lt;/CODE&gt; method (or a 
&lt;CODE&gt;new()&lt;/CODE&gt; method for that matter)? Because the search is depth-first, classes will be looked up in the following order: Third, First, Alpha, Second, and Beta.

&lt;P&gt;
In practice, few class modules have been seen that actually make use of 
&lt;FONT SIZE=-1&gt;MI.&lt;/FONT&gt; One nearly always chooses simple containership of one class within another over 
&lt;FONT SIZE=-1&gt;MI.&lt;/FONT&gt; That's why our Person object
 &lt;EM&gt;contained&lt;/EM&gt; a Fullname object. That doesn't mean it &lt;EM&gt;was&lt;/EM&gt; one.

&lt;P&gt;
However, there is one particular area where 
&lt;FONT SIZE=-1&gt;MI&lt;/FONT&gt; in Perl is rampant: borrowing another class's class
methods. This is rather common, especially with some bundled ``objectless''
classes, like Exporter, DynaLoader, AutoLoader, and SelfLoader. These
classes do not provide constructors; they exist only so you may inherit
their class methods. (It's not entirely clear why inheritance was done here
rather than traditional module importation.)

&lt;P&gt;
For example, here is the 
&lt;FONT SIZE=-1&gt;POSIX&lt;/FONT&gt; module's 
&lt;FONT SIZE=-1&gt;@ISA:&lt;/FONT&gt;

&lt;P&gt;
&lt;PRE&gt;    package POSIX;
    @ISA = qw(Exporter DynaLoader);
&lt;/PRE&gt;
&lt;P&gt;
The 
&lt;FONT SIZE=-1&gt;POSIX&lt;/FONT&gt; module isn't really an object module, but then, neither are Exporter or DynaLoader. They're just lending their classes' behaviours to 
&lt;FONT SIZE=-1&gt;POSIX.&lt;/FONT&gt;

&lt;P&gt;
Why don't people use 
&lt;FONT SIZE=-1&gt;MI&lt;/FONT&gt; for object methods much? One reason is that it can have complicated side-effects. For one thing, your inheritance graph (no longer a tree) might converge back to the same base class. Although Perl guards against recursive inheritance, merely having parents who are related to each other via a common ancestor, incestuous though it sounds, is not forbidden. What if in our Third class shown above we wanted its 
&lt;CODE&gt;new()&lt;/CODE&gt; method to also call both overridden constructors in its two parent classes? The 
&lt;FONT SIZE=-1&gt;SUPER&lt;/FONT&gt; notation would only find the first one. Also, what about if the Alpha and Beta classes both had a common ancestor, like Nought? If you kept climbing up the inheritance tree calling overridden methods, you'd end up calling Nought::new() twice, which might well be a bad idea.

&lt;P&gt;
&lt;HR&gt;
&lt;H2&gt;&lt;A NAME="UNIVERSAL_The_Root_of_All_Objec"&gt;UNIVERSAL: The Root of All Objects&lt;/A&gt;&lt;/H2&gt;
&lt;P&gt;
Wouldn't it be convenient if all objects were rooted at some ultimate base class? That way you could give every object common methods without having to go and add it to each and every 
&lt;FONT SIZE=-1&gt;@ISA.&lt;/FONT&gt; Well, it turns out that you can. You don't see it, but Perl tacitly and irrevocably assumes that there's an extra element at the end of 
&lt;FONT SIZE=-1&gt;@ISA:&lt;/FONT&gt; the class 
&lt;FONT SIZE=-1&gt;UNIVERSAL.&lt;/FONT&gt; In version 5.003, there were no predefined methods there, but you could put whatever you felt like into it.

&lt;P&gt;
However, as of version 5.004 (or some subversive releases, like 5.003_08), 
&lt;FONT SIZE=-1&gt;UNIVERSAL&lt;/FONT&gt; has some methods in it already. These are builtin to your Perl binary, so they don't take any extra time to load. Predefined methods include 
&lt;CODE&gt;isa(),&lt;/CODE&gt; 
&lt;CODE&gt;can(),&lt;/CODE&gt; and 
&lt;CODE&gt;VERSION().&lt;/CODE&gt; 
&lt;CODE&gt;isa()&lt;/CODE&gt; tells you whether an object or class ``is'' another one without having to traverse the hierarchy yourself:

&lt;P&gt;
&lt;PRE&gt;   $has_io = $fd-&amp;gt;isa(&amp;quot;IO::Handle&amp;quot;);
   $itza_handle = IO::Socket-&amp;gt;isa(&amp;quot;IO::Handle&amp;quot;);
&lt;/PRE&gt;
&lt;P&gt;
The 
&lt;CODE&gt;can()&lt;/CODE&gt; method, called against
that object or class, reports back whether its string argument is a
callable method name in that class. In fact, it gives you back a function
reference to that method:

&lt;P&gt;
&lt;PRE&gt;   $his_print_method = $obj-&amp;gt;can('as_string');
&lt;/PRE&gt;
&lt;P&gt;
Finally, the 
&lt;FONT SIZE=-1&gt;VERSION&lt;/FONT&gt; method checks whether the class (or the
object's class) has a package global called &lt;CODE&gt;$VERSION&lt;/CODE&gt; that's
high enough, as in:

&lt;P&gt;
&lt;PRE&gt;    Some_Module-&amp;gt;VERSION(3.0);
    $his_vers = $ob-&amp;gt;VERSION();
&lt;/PRE&gt;
&lt;P&gt;
However, we don't usually call 
&lt;FONT SIZE=-1&gt;VERSION&lt;/FONT&gt; ourselves. (Remember that an all uppercase
function name is a Perl convention that indicates that the function will be
automatically used by Perl in some way.) In this case, it happens when you
say

&lt;P&gt;
&lt;PRE&gt;    use Some_Module 3.0;
&lt;/PRE&gt;
&lt;P&gt;
If you wanted to add version checking to your Person class explained above,
just add this to Person.pm:

&lt;P&gt;
&lt;PRE&gt;    use vars qw($VERSION);
    $VERSION = '1.1';
&lt;/PRE&gt;
&lt;P&gt;
and then in Employee.pm could you can say

&lt;P&gt;
&lt;PRE&gt;    use Employee 1.1;
&lt;/PRE&gt;
&lt;P&gt;
And it would make sure that you have at least that version number or higher
available. This is not the same as loading in that exact version number. No
mechanism currently exists for concurrent installation of multiple versions
of a module. Lamentably.

&lt;P&gt;
&lt;HR&gt;
&lt;H1&gt;&lt;A NAME="Alternate_Object_Representations"&gt;Alternate Object Representations&lt;/A&gt;&lt;/H1&gt;
&lt;P&gt;
Nothing requires objects to be implemented as hash references. An object
can be any sort of reference so long as its referent has been suitably
blessed. That means scalar, array, and code references are also fair game.

&lt;P&gt;

&lt;FONT SIZE=-1&gt;A&lt;/FONT&gt; scalar would work if the object has only one datum
to hold. An array would work for most cases, but makes inheritance a bit
dodgy because you have to invent new indices for the derived classes.

&lt;P&gt;
&lt;HR&gt;
&lt;H2&gt;&lt;A NAME="Arrays_as_Objects"&gt;Arrays as Objects&lt;/A&gt;&lt;/H2&gt;
&lt;P&gt;
If the user of your class honors the contract and sticks to the advertised
interface, then you can change its underlying interface if you feel like
it. Here's another implementation that conforms to the same interface
specification. This time we'll use an array reference instead of a hash
reference to represent the object.

&lt;P&gt;
&lt;PRE&gt;    package Person;
    use strict;
&lt;/PRE&gt;
&lt;P&gt;
&lt;PRE&gt;    my($NAME, $AGE, $PEERS) = ( 0 .. 2 );
&lt;/PRE&gt;
&lt;P&gt;
&lt;PRE&gt;    ############################################
    ## the object constructor (array version) ##
    ############################################
    sub new {
        my $self = &amp;#091;&amp;#093;;
        $self-&amp;gt;&amp;#091;$NAME&amp;#093;   = undef;  # this is unnecessary
        $self-&amp;gt;&amp;#091;$AGE&amp;#093;    = undef;  # as is this
        $self-&amp;gt;&amp;#091;$PEERS&amp;#093;  = &amp;#091;&amp;#093;;     # but this isn't, really
        bless($self);
        return $self;
    }
&lt;/PRE&gt;
&lt;P&gt;
&lt;PRE&gt;    sub name {
        my $self = shift;
        if (@_) { $self-&amp;gt;&amp;#091;$NAME&amp;#093; = shift }
        return $self-&amp;gt;&amp;#091;$NAME&amp;#093;;
    }
&lt;/PRE&gt;
&lt;P&gt;
&lt;PRE&gt;    sub age {
        my $self = shift;
        if (@_) { $self-&amp;gt;&amp;#091;$AGE&amp;#093; = shift }
        return $self-&amp;gt;&amp;#091;$AGE&amp;#093;;
    }
&lt;/PRE&gt;
&lt;P&gt;
&lt;PRE&gt;    sub peers {
        my $self = shift;
        if (@_) { @{ $self-&amp;gt;&amp;#091;$PEERS&amp;#093; } = @_ }
        return @{ $self-&amp;gt;&amp;#091;$PEERS&amp;#093; };
    }
&lt;/PRE&gt;
&lt;P&gt;
&lt;PRE&gt;    1;  # so the require or use succeeds
&lt;/PRE&gt;
&lt;P&gt;
You might guess that the array access would be a lot faster than the hash
access, but they're actually comparable. The array is a &lt;EM&gt;little&lt;/EM&gt;
bit faster, but not more than ten or fifteen percent, even when you replace the variables above like &lt;CODE&gt;$AGE&lt;/CODE&gt; with literal numbers, like 1. 
&lt;FONT SIZE=-1&gt;A&lt;/FONT&gt; bigger difference between the two approaches can be found in memory use. 
&lt;FONT SIZE=-1&gt;A&lt;/FONT&gt; hash representation takes up more memory than an array representation because you have to allocate memory for the keys as well as for the values. However, it really isn't that bad, especially since as of version 5.004, memory is only allocated once for a given hash key, no matter how many hashes have that key. It's expected that sometime in the future, even these differences will fade into obscurity as more efficient underlying representations are devised.

&lt;P&gt;
Still, the tiny edge in speed (and somewhat larger one in memory) is enough
to make some programmers choose an array representation for simple classes.
There's still a little problem with scalability, though, because later in
life when you feel like creating subclasses, you'll find that hashes just
work out better.

&lt;P&gt;
&lt;HR&gt;
&lt;H2&gt;&lt;A NAME="Closures_as_Objects"&gt;Closures as Objects&lt;/A&gt;&lt;/H2&gt;
&lt;P&gt;
Using a code reference to represent an object offers some fascinating
possibilities. We can create a new anonymous function (closure) who alone
in all the world can see the object's data. This is because we put the data
into an anonymous hash that's lexically visible only to the closure we
create, bless, and return as the object. This object's methods turn around
and call the closure as a regular subroutine call, passing it the field we
want to affect. (Yes, the double-function call is slow, but if you wanted
fast, you wouldn't be using objects at all, eh? :-)

&lt;P&gt;
Use would be similar to before:

&lt;P&gt;
&lt;PRE&gt;    use Person;
    $him = Person-&amp;gt;new();
    $him-&amp;gt;name(&amp;quot;Jason&amp;quot;);
    $him-&amp;gt;age(23);
    $him-&amp;gt;peers( &amp;#091; &amp;quot;Norbert&amp;quot;, &amp;quot;Rhys&amp;quot;, &amp;quot;Phineas&amp;quot; &amp;#093; );
    printf &amp;quot;%s is %d years old.\n&amp;quot;, $him-&amp;gt;name, $him-&amp;gt;age;
    print &amp;quot;His peers are: &amp;quot;, join(&amp;quot;, &amp;quot;, @{$him-&amp;gt;peers}), &amp;quot;\n&amp;quot;;
&lt;/PRE&gt;
&lt;P&gt;
but the implementation would be radically, perhaps even sublimely
different:

&lt;P&gt;
&lt;PRE&gt;    package Person;
&lt;/PRE&gt;
&lt;P&gt;
&lt;PRE&gt;    sub new {
         my $that  = shift;
         my $class = ref($that) || $that;
         my $self = {
            NAME  =&amp;gt; undef,
            AGE   =&amp;gt; undef,
            PEERS =&amp;gt; &amp;#091;&amp;#093;,
         };
         my $closure = sub {
            my $field = shift;
            if (@_) { $self-&amp;gt;{$field} = shift }
            return    $self-&amp;gt;{$field};
        };
        bless($closure, $class);
        return $closure;
    }
&lt;/PRE&gt;
&lt;P&gt;
&lt;PRE&gt;    sub name   { &amp;amp;{ $_&amp;#091;0&amp;#093; }(&amp;quot;NAME&amp;quot;,  @_&amp;#091; 1 .. $#_ &amp;#093; ) }
    sub age    { &amp;amp;{ $_&amp;#091;0&amp;#093; }(&amp;quot;AGE&amp;quot;,   @_&amp;#091; 1 .. $#_ &amp;#093; ) }
    sub peers  { &amp;amp;{ $_&amp;#091;0&amp;#093; }(&amp;quot;PEERS&amp;quot;, @_&amp;#091; 1 .. $#_ &amp;#093; ) }
&lt;/PRE&gt;
&lt;P&gt;
&lt;PRE&gt;    1;
&lt;/PRE&gt;
&lt;P&gt;
Because this object is hidden behind a code reference, it's probably a bit mysterious to those whose background is more firmly rooted in standard procedural or object-based programming languages than in functional programming languages whence closures derive. The object created and returned by the 
&lt;CODE&gt;new()&lt;/CODE&gt; method is itself not a data reference as we've seen before. It's an anonymous code reference that has within it access to a specific version (lexical binding and instantiation) of the object's data, which are stored in the private variable $self. Although this is the same function each time, it contains a different version of $self.

&lt;P&gt;
When a method like &lt;CODE&gt;$him-&amp;gt;name(&amp;quot;Jason&amp;quot;)&lt;/CODE&gt; is called, its implicit zeroth argument is the invoking object--just as it is with all method calls. But in this case, it's our code reference (something like a function pointer in 
&lt;FONT SIZE=-1&gt;C++,&lt;/FONT&gt; but with deep binding of lexical variables). There's not a lot to be done with a code reference beyond calling it, so that's just what we do when we say
 &lt;CODE&gt;&amp;amp;{$_&amp;#091;0&amp;#093;}&lt;/CODE&gt;. This is just a regular function call, not a method call. The initial argument is the string 
&lt;FONT SIZE=-1&gt;``NAME'',&lt;/FONT&gt; and any remaining arguments are whatever had been passed to the method itself.

&lt;P&gt;
Once we're executing inside the closure that had been created in 
&lt;CODE&gt;new(),&lt;/CODE&gt; the &lt;CODE&gt;$self&lt;/CODE&gt; hash reference suddenly becomes visible. The closure grabs its first argument 
&lt;FONT SIZE=-1&gt;(``NAME''&lt;/FONT&gt; in this case because that's what the 
&lt;CODE&gt;name()&lt;/CODE&gt; method passed it), and uses that string to subscript into the private hash hidden in its unique version of $self.

&lt;P&gt;
Nothing under the sun will allow anyone outside the executing method to be
able to get at this hidden data. Well, nearly nothing. You &lt;EM&gt;could&lt;/EM&gt;
single step through the program using the debugger and find out the pieces
while you're in the method, but everyone else is out of luck.

&lt;P&gt;
There, if that doesn't excite the Scheme folks, then 
&lt;FONT SIZE=-1&gt;I&lt;/FONT&gt; just don't know what will. Translation of this technique into 
&lt;FONT SIZE=-1&gt;C++,&lt;/FONT&gt; Java, or any other braindead-static language is left as a futile exercise for aficionados of those camps.

&lt;P&gt;
You could even add a bit of nosiness via the 
&lt;CODE&gt;caller()&lt;/CODE&gt; function and make
the closure refuse to operate unless called via its own package. This would
no doubt satisfy certain fastidious concerns of programming police and
related puritans.

&lt;P&gt;
If you were wondering when Hubris, the third principle virtue of a
programmer, would come into play, here you have it. (More seriously, Hubris
is just the pride in craftsmanship that comes from having written a sound
bit of well-designed code.)

&lt;P&gt;
&lt;HR&gt;
&lt;H1&gt;&lt;A NAME="AUTOLOAD_Proxy_Methods"&gt;AUTOLOAD: Proxy Methods&lt;/A&gt;&lt;/H1&gt;
&lt;P&gt;
Autoloading is a way to intercept calls to undefined methods. An autoload routine may choose to create a new function on the fly, either loaded from disk or perhaps just 
&lt;CODE&gt;eval()ed&lt;/CODE&gt; right there. This define-on-the-fly strategy is why it's called autoloading.

&lt;P&gt;
But that's only one possible approach. Another one is to just have the
autoloaded method itself directly provide the requested service. When used
in this way, you may think of autoloaded methods as ``proxy'' methods.

&lt;P&gt;
When Perl tries to call an undefined function in a particular package and that function is not defined, it looks for a function in that same package called 
&lt;FONT SIZE=-1&gt;AUTOLOAD.&lt;/FONT&gt; If one exists, it's called with the same arguments as the original function would have had. The fully-qualified name of the function is stored in that package's global variable 
&lt;FONT SIZE=-1&gt;$AUTOLOAD.&lt;/FONT&gt; Once called, the function can do anything it would like, including defining a new function by the right name, and then doing a really fancy kind of
 [perlfunc:goto|goto] right to it, erasing itself from the call stack.

&lt;P&gt;
What does this have to do with objects? After all, we keep talking about functions, not methods. Well, since a method is just a function with an extra argument and some fancier semantics about where it's found, we can use autoloading for methods, too. Perl doesn't start looking for an 
&lt;FONT SIZE=-1&gt;AUTOLOAD&lt;/FONT&gt; method until it has exhausted the recursive hunt up through 
&lt;FONT SIZE=-1&gt;@ISA,&lt;/FONT&gt; though. Some programmers have even been known to define a 
&lt;FONT SIZE=-1&gt;UNIVERSAL::AUTOLOAD&lt;/FONT&gt; method to trap unresolved method calls to any kind of object.

&lt;P&gt;
&lt;HR&gt;
&lt;H2&gt;&lt;A NAME="Autoloaded_Data_Methods"&gt;Autoloaded Data Methods&lt;/A&gt;&lt;/H2&gt;
&lt;P&gt;
You probably began to get a little suspicious about the duplicated code way
back earlier when we first showed you the Person class, and then later the
Employee class. Each method used to access the hash fields looked virtually
identical. This should have tickled that great programming virtue,
Impatience, but for the time, we let Laziness win out, and so did nothing.
Proxy methods can cure this.

&lt;P&gt;
Instead of writing a new function every time we want a new data field,
we'll use the autoload mechanism to generate (actually, mimic) methods on
the fly. To verify that we're accessing a valid member, we will check
against an &lt;CODE&gt;_permitted&lt;/CODE&gt; (pronounced ``under-permitted'') field, which is a reference to a file-scoped lexical (like a 
&lt;FONT SIZE=-1&gt;C&lt;/FONT&gt; file static) hash of permitted fields in this record called %fields. Why the underscore? For the same reason as the 
&lt;FONT SIZE=-1&gt;_CENSUS&lt;/FONT&gt; field we once used: as a marker that means ``for internal use only''.

&lt;P&gt;
Here's what the module initialization code and class constructor will look
like when taking this approach:

&lt;P&gt;
&lt;PRE&gt;    package Person;
    use Carp;
    use vars qw($AUTOLOAD);  # it's a package global
&lt;/PRE&gt;
&lt;P&gt;
&lt;PRE&gt;    my %fields = (
        name        =&amp;gt; undef,
        age         =&amp;gt; undef,
        peers       =&amp;gt; undef,
    );
&lt;/PRE&gt;
&lt;P&gt;
&lt;PRE&gt;    sub new {
        my $that  = shift;
        my $class = ref($that) || $that;
        my $self  = {
            _permitted =&amp;gt; \%fields,
            %fields,
        };
        bless $self, $class;
        return $self;
    }
&lt;/PRE&gt;
&lt;P&gt;
If we wanted our record to have default values, we could fill those in
where current we have [perlfunc:undef|undef] in the &lt;CODE&gt;%fields&lt;/CODE&gt; hash.

&lt;P&gt;
Notice how we saved a reference to our class data on the object itself?
Remember that it's important to access class data through the object itself
instead of having any method reference &lt;CODE&gt;%fields&lt;/CODE&gt; directly, or
else you won't have a decent inheritance.

&lt;P&gt;
The real magic, though, is going to reside in our proxy method, which will handle all calls to undefined methods for objects of class Person (or subclasses of Person). It has to be called 
&lt;FONT SIZE=-1&gt;AUTOLOAD.&lt;/FONT&gt; Again, it's all caps because it's called for us implicitly by Perl itself, not by a user directly.

&lt;P&gt;
&lt;PRE&gt;    sub AUTOLOAD {
        my $self = shift;
        my $type = ref($self)
                    or croak &amp;quot;$self is not an object&amp;quot;;
&lt;/PRE&gt;
&lt;P&gt;
&lt;PRE&gt;        my $name = $AUTOLOAD;
        $name =~ s/.*://;   # strip fully-qualified portion
&lt;/PRE&gt;
&lt;P&gt;
&lt;PRE&gt;        unless (exists $self-&amp;gt;{_permitted}-&amp;gt;{$name} ) {
            croak &amp;quot;Can't access `$name' field in class $type&amp;quot;;
        }
&lt;/PRE&gt;
&lt;P&gt;
&lt;PRE&gt;        if (@_) {
            return $self-&amp;gt;{$name} = shift;
        } else {
            return $self-&amp;gt;{$name};
        }
    }
&lt;/PRE&gt;
&lt;P&gt;
Pretty nifty, eh? All we have to do to add new data fields is modify
%fields. No new functions need be written.

&lt;P&gt;
&lt;BR&gt;[perlman:perltoot2|More...]&lt;BR&gt;
&lt;BR&gt;Return to the [Library]&lt;BR</field>
</data>
</node>
