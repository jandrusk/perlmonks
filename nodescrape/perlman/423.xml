<?xml version="1.0" encoding="windows-1252"?>
<node id="423" title="perlman:perldiag3" created="1999-08-25 03:24:53" updated="2005-06-13 11:45:04">
<type id="116">
perlman</type>
<author id="114">
gods</author>
<data>
<field name="doctext">
&lt;DL&gt;
&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;&lt;A NAME="item_Type"&gt;Type of arg %d to %s must be %s (not %s)&lt;/A&gt;&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(F)&lt;/FONT&gt; This function requires the argument in that
position to be of a certain type. Arrays must be &lt;CODE&gt;@NAME&lt;/CODE&gt; or &lt;CODE&gt;@{EXPR}&lt;/CODE&gt;. Hashes must be &lt;CODE&gt;%NAME&lt;/CODE&gt; or &lt;CODE&gt;%{EXPR}&lt;/CODE&gt;. No implicit dereferencing is allowed--use the 
&lt;FONT SIZE=-1&gt;{EXPR}&lt;/FONT&gt; forms as an explicit dereference. See [perlman:perlref|the perlref manpage].

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;&lt;A NAME="item_umask"&gt;umask: argument is missing initial 0&lt;/A&gt;&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(W)&lt;/FONT&gt; 
&lt;FONT SIZE=-1&gt;A&lt;/FONT&gt; umask of 222 is incorrect. It should be 0222, because octal literals always start with 0 in Perl, as in 
&lt;FONT SIZE=-1&gt;C.&lt;/FONT&gt;

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;&lt;A NAME="item_umask"&gt;umask not implemented&lt;/A&gt;&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(F)&lt;/FONT&gt; Your machine doesn't implement the umask function and you tried to use it to restrict permissions for yourself 
&lt;FONT SIZE=-1&gt;(EXPR&lt;/FONT&gt; &amp;amp; 0700).

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;&lt;A NAME="item_Unable"&gt;Unable to create sub named &amp;quot;%s&amp;quot;&lt;/A&gt;&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(F)&lt;/FONT&gt; You attempted to create or access a subroutine
with an illegal name.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;&lt;A NAME="item_Unbalanced"&gt;Unbalanced context: %d more PUSHes than POPs&lt;/A&gt;&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(W)&lt;/FONT&gt; The exit code detected an internal inconsistency
in how many execution contexts were entered and left.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;Unbalanced saves: %d more saves than restores&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(W)&lt;/FONT&gt; The exit code detected an internal inconsistency
in how many values were temporarily localized.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;Unbalanced scopes: %d more ENTERs than LEAVEs&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(W)&lt;/FONT&gt; The exit code detected an internal inconsistency
in how many blocks were entered and left.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;Unbalanced tmps: %d more allocs than frees&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(W)&lt;/FONT&gt; The exit code detected an internal inconsistency
in how many mortal scalars were allocated and freed.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;&lt;A NAME="item_Undefined"&gt;Undefined format &amp;quot;%s&amp;quot; called&lt;/A&gt;&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(F)&lt;/FONT&gt; The format indicated doesn't seem to exist.
Perhaps it's really in another package? See [perlman:perlform|the perlform manpage].

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;Undefined sort subroutine &amp;quot;%s&amp;quot; called&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(F)&lt;/FONT&gt; The sort comparison routine specified doesn't seem
to exist. Perhaps it's in a different package? See [perlfunc:sort|sort].

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;Undefined subroutine &amp;amp;%s called&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(F)&lt;/FONT&gt; The subroutine indicated hasn't been defined, or
if it was, it has since been undefined.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;Undefined subroutine called&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(F)&lt;/FONT&gt; The anonymous subroutine you're trying to call
hasn't been defined, or if it was, it has since been undefined.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;Undefined subroutine in sort&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(F)&lt;/FONT&gt; The sort comparison routine specified is declared
but doesn't seem to have been defined yet. See [perlfunc:sort|sort].

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;Undefined top format &amp;quot;%s&amp;quot; called&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(F)&lt;/FONT&gt; The format indicated doesn't seem to exist.
Perhaps it's really in another package? See [perlman:perlform|the perlform manpage].

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;Undefined value assigned to typeglob&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(W)&lt;/FONT&gt; An undefined value was assigned to a typeglob, a
la &lt;CODE&gt;*foo = undef&lt;/CODE&gt;. This does nothing. It's possible that you really mean &lt;CODE&gt;undef *foo&lt;/CODE&gt;.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;&lt;A NAME="item_unexec"&gt;unexec of %s into %s failed!&lt;/A&gt;&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(F)&lt;/FONT&gt; The 
&lt;CODE&gt;unexec()&lt;/CODE&gt; routine failed for some reason. See your local 
&lt;FONT SIZE=-1&gt;FSF&lt;/FONT&gt; representative, who probably put it there in the first place.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;&lt;A NAME="item_Unknown"&gt;Unknown BYTEORDER&lt;/A&gt;&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(F)&lt;/FONT&gt; There are no byte-swapping functions for a machine
with this byte order.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;&lt;A NAME="item_unmatched"&gt;unmatched () in regexp&lt;/A&gt;&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(F)&lt;/FONT&gt; Unbackslashed parentheses must always be balanced
in regular expressions. If you're a vi user, the % key is valuable for
finding the matching parenthesis. See [perlman:perlre|the perlre manpage].

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;&lt;A NAME="item_Unmatched"&gt;Unmatched right bracket&lt;/A&gt;&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(F)&lt;/FONT&gt; The lexer counted more closing curly brackets
(braces) than opening ones, so you're probably missing an opening bracket.
As a general rule, you'll find the missing one (so to speak) near the place
you were last editing.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;unmatched &amp;#091;&amp;#093; in regexp&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(F)&lt;/FONT&gt; The brackets around a character class must match.
If you wish to include a closing bracket in a character class, backslash it
or put it first. See [perlman:perlre|the perlre manpage].

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;&lt;A NAME="item_Unquoted"&gt;Unquoted string &amp;quot;%s&amp;quot; may clash with future reserved word&lt;/A&gt;&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(W)&lt;/FONT&gt; You used a bareword that might someday be claimed
as a reserved word. It's best to put such a word in quotes, or capitalize
it somehow, or insert an underbar into it. You might also declare it as a
subroutine.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;&lt;A NAME="item_Unrecognized"&gt;Unrecognized character %s&lt;/A&gt;&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(F)&lt;/FONT&gt; The Perl parser has no idea what to do with the
specified character in your Perl script (or eval). Perhaps you tried to run
a compressed script, a binary program, or a directory as a Perl program.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;Unrecognized signal name &amp;quot;%s&amp;quot;&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(F)&lt;/FONT&gt; You specified a signal name to the 
&lt;CODE&gt;kill()&lt;/CODE&gt; function that was not recognized. Say
 &lt;CODE&gt;kill -l&lt;/CODE&gt; in your shell to see the valid signal names on your system.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;Unrecognized switch: -%s  (-h will show valid options)&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(F)&lt;/FONT&gt; You specified an illegal option to Perl. Don't do
that. (If you think you didn't do that, check the #! line to see if it's
supplying the bad switch on your behalf.)

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;&lt;A NAME="item_Unsuccessful"&gt;Unsuccessful %s on filename containing newline&lt;/A&gt;&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(W)&lt;/FONT&gt; 
&lt;FONT SIZE=-1&gt;A&lt;/FONT&gt; file operation was attempted on a filename, and that operation failed, 
&lt;FONT SIZE=-1&gt;PROBABLY&lt;/FONT&gt; because the filename contained a newline, 
&lt;FONT SIZE=-1&gt;PROBABLY&lt;/FONT&gt; because you forgot to 
&lt;CODE&gt;chop()&lt;/CODE&gt; or 
&lt;CODE&gt;chomp()&lt;/CODE&gt; it off. See
 [perlfunc:chomp|chomp].

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;&lt;A NAME="item_Unsupported"&gt;Unsupported directory function &amp;quot;%s&amp;quot; called&lt;/A&gt;&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(F)&lt;/FONT&gt; Your machine doesn't support 
&lt;CODE&gt;opendir()&lt;/CODE&gt; and 
&lt;CODE&gt;readdir().&lt;/CODE&gt;

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;Unsupported function fork&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(F)&lt;/FONT&gt; Your version of executable does not support
forking.

&lt;P&gt;
Note that under some systems, like 
&lt;FONT SIZE=-1&gt;OS/2,&lt;/FONT&gt; there may be different flavors of Perl
executables, some of which may support fork, some not. Try changing the
name you call Perl by to &lt;CODE&gt;perl_&lt;/CODE&gt;, &lt;CODE&gt;perl__&lt;/CODE&gt;, and so on.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;Unsupported function %s&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(F)&lt;/FONT&gt; This machine doesn't implement the indicated
function, apparently. At least, Configure doesn't think so.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;Unsupported socket function &amp;quot;%s&amp;quot; called&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(F)&lt;/FONT&gt; Your machine doesn't support the Berkeley socket
mechanism, or at least that's what Configure thought.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;&lt;A NAME="item_Unterminated"&gt;Unterminated ltgt operator&lt;/A&gt;&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(F)&lt;/FONT&gt; The lexer saw a left angle bracket in a place
where it was expecting a term, so it's looking for the corresponding right
angle bracket, and not finding it. Chances are you left some needed
parentheses out earlier in the line, and you really meant a ``less than''.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;&lt;A NAME="item_Use"&gt;Use of &amp;quot;$$&amp;lt;digit&amp;gt;&amp;quot; to mean &amp;quot;${$}&amp;lt;digit&amp;gt;&amp;quot; is deprecated&lt;/A&gt;&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(D)&lt;/FONT&gt; Perl versions before 5.004 misinterpreted any type
marker followed by ``$'' and a digit. For example, ``$$0'' was incorrectly
taken to mean ``${$}0'' instead of ``${$0}''. This bug is (mostly) fixed in
Perl 5.004.

&lt;P&gt;
However, the developers of Perl 5.004 could not fix this bug completely,
because at least two widely-used modules depend on the old meaning of
``$$0'' in a string. So Perl 5.004 still interprets ``$$&amp;lt;digit&amp;gt;'' in
the old (broken) way inside strings; but it generates this message as a
warning. And in Perl 5.005, this special treatment will cease.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;Use of $# is deprecated&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(D)&lt;/FONT&gt; This was an ill-advised attempt to emulate a
poorly defined &lt;STRONG&gt;awk&lt;/STRONG&gt; feature. Use an explicit 
&lt;CODE&gt;printf()&lt;/CODE&gt; or 
&lt;CODE&gt;sprintf()&lt;/CODE&gt; instead.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;Use of $* is deprecated&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(D)&lt;/FONT&gt; This variable magically turned on multi-line
pattern matching, both for you and for any luckless subroutine that you
happen to call. You should use the new [perlman:perlop] and [perlman:perlop] modifiers now to do that without the dangerous action-at-a-distance effects
of &lt;CODE&gt;$*&lt;/CODE&gt;.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;Use of %s in printf format not supported&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(F)&lt;/FONT&gt; You attempted to use a feature of printf that is accessible from only 
&lt;FONT SIZE=-1&gt;C.&lt;/FONT&gt; This usually means there's a better way to do it in Perl.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;Use of bare ltlt to mean ltlt&amp;quot;&amp;quot; is deprecated&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(D)&lt;/FONT&gt; You are now encouraged to use the explicitly
quoted form if you wish to use an empty line as the terminator of the
here-document.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;Use of implicit split to @_ is deprecated&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(D)&lt;/FONT&gt; It makes a lot of work for the compiler when you clobber a subroutine's argument list, so it's better if you assign the results of a 
&lt;CODE&gt;split()&lt;/CODE&gt; explicitly to an array (or list).

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;Use of inherited AUTOLOAD for non-method %s() is deprecated&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(D)&lt;/FONT&gt; As an (ahem) accidental feature, &lt;CODE&gt;AUTOLOAD&lt;/CODE&gt; subroutines are looked up as methods (using the &lt;CODE&gt;@ISA&lt;/CODE&gt; hierarchy) even when the subroutines to be autoloaded were called as plain
functions (e.g. &lt;CODE&gt;Foo::bar()&lt;/CODE&gt;), not as methods (e.g. &lt;CODE&gt;Foo-&amp;gt;bar()&lt;/CODE&gt; or &lt;CODE&gt;$obj-&amp;gt;bar()&lt;/CODE&gt;).

&lt;P&gt;
This bug will be rectified in Perl 5.005, which will use method lookup only
for methods' &lt;CODE&gt;AUTOLOAD&lt;/CODE&gt;s. However, there is a significant base of existing code that may be using
the old behavior. So, as an interim step, Perl 5.004 issues an optional
warning when non-methods use inherited &lt;CODE&gt;AUTOLOAD&lt;/CODE&gt;s.

&lt;P&gt;
The simple rule is: Inheritance will not work when autoloading non-methods.
The simple fix for old code is: In any module that used to depend on
inheriting &lt;CODE&gt;AUTOLOAD&lt;/CODE&gt; for non-methods from a base class named
&lt;CODE&gt;BaseClass&lt;/CODE&gt;, execute &lt;CODE&gt;*AUTOLOAD = \&amp;amp;BaseClass::AUTOLOAD&lt;/CODE&gt; during startup.

&lt;P&gt;
In code that currently says &lt;CODE&gt;use AutoLoader; @ISA = qw(AutoLoader);&lt;/CODE&gt; you should remove AutoLoader from &lt;CODE&gt;@ISA&lt;/CODE&gt; and change &lt;CODE&gt;use AutoLoader;&lt;/CODE&gt; to
&lt;CODE&gt;use AutoLoader 'AUTOLOAD';&lt;/CODE&gt;.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;Use of reserved word &amp;quot;%s&amp;quot; is deprecated&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(D)&lt;/FONT&gt; The indicated bareword is a reserved word. Future
versions of perl may use it as a keyword, so you're better off either
explicitly quoting the word in a manner appropriate for its context of use,
or using a different name altogether. The warning can be suppressed for
subroutine names by either adding a &lt;CODE&gt;&amp;amp;&lt;/CODE&gt; prefix, or using a package qualifier, e.g. &lt;CODE&gt;&amp;amp;our()&lt;/CODE&gt;, or &lt;CODE&gt;Foo::our()&lt;/CODE&gt;.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;Use of %s is deprecated&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(D)&lt;/FONT&gt; The construct indicated is no longer recommended
for use, generally because there's a better way to do it, and also because
the old way has bad side effects.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;Use of uninitialized value&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(W)&lt;/FONT&gt; An undefined value was used as if it were already
defined. It was interpreted as a ``'' or a 0, but maybe it was a mistake.
To suppress this warning assign an initial value to your variables.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;&lt;A NAME="item_Useless"&gt;Useless use of &amp;quot;re&amp;quot; pragma&lt;/A&gt;&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(W)&lt;/FONT&gt; You did &lt;CODE&gt;use re;&lt;/CODE&gt; without any arguments. That isn't very useful.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;Useless use of %s in void context&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(W)&lt;/FONT&gt; You did something without a side effect in a context that does nothing with the return value, such as a statement that doesn't return a value from a block, or the left side of a scalar comma operator. Very often this points not to stupidity on your part, but a failure of Perl to parse your program the way you thought it would. For example, you'd get this if you mixed up your 
&lt;FONT SIZE=-1&gt;C&lt;/FONT&gt; precedence with Python precedence and said

&lt;P&gt;
&lt;PRE&gt;    $one, $two = 1, 2;
&lt;/PRE&gt;
&lt;P&gt;
when you meant to say

&lt;P&gt;
&lt;PRE&gt;    ($one, $two) = (1, 2);
&lt;/PRE&gt;
&lt;P&gt;
Another common error is to use ordinary parentheses to construct a list
reference when you should be using square or curly brackets, for example,
if you say

&lt;P&gt;
&lt;PRE&gt;    $array = (1,2);
&lt;/PRE&gt;
&lt;P&gt;
when you should have said

&lt;P&gt;
&lt;PRE&gt;    $array = &amp;#091;1,2&amp;#093;;
&lt;/PRE&gt;
&lt;P&gt;
The square brackets explicitly turn a list value into a scalar value, while
parentheses do not. So when a parenthesized list is evaluated in a scalar
context, the comma is treated like C's comma operator, which throws away
the left argument, which is not what you want. See
[perlman:perlref|the perlref manpage] for more on this.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;&lt;A NAME="item_untie"&gt;untie attempted while %d inner references still exist&lt;/A&gt;&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(W)&lt;/FONT&gt; 
&lt;FONT SIZE=-1&gt;A&lt;/FONT&gt; copy of the object returned from
 [perlfunc:tie|tie] (or &lt;CODE&gt;tied&lt;/CODE&gt;) was still valid when [perlfunc:untie|untie] was called.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;&lt;A NAME="item_Value"&gt;Value of %s can be &amp;quot;0&amp;quot;; test with defined()&lt;/A&gt;&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(W)&lt;/FONT&gt; In a conditional expression, you used &amp;lt;
&lt;FONT SIZE=-1&gt;HANDLE&amp;gt;,&lt;/FONT&gt; &amp;lt;*&amp;gt; (glob), [perlfunc:each|each()], or [perlfunc:readdir|readdir()] as a boolean value. Each of these constructs can return a value of ``0'';
that would make the conditional expression false, which is probably not
what you intended. When using these constructs in conditional expressions,
test their values with the [perlfunc:defined|defined] operator.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;&lt;A NAME="item_Variable"&gt;Variable &amp;quot;%s&amp;quot; is not imported%s&lt;/A&gt;&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(F)&lt;/FONT&gt; While ``use strict'' in effect, you referred to a
global variable that you apparently thought was imported from another
module, because something else of the same name (usually a subroutine) is
exported by that module. It usually means you put the wrong funny character
on the front of your variable.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;Variable &amp;quot;%s&amp;quot; may be unavailable&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(W)&lt;/FONT&gt; An inner (nested) &lt;EM&gt;anonymous&lt;/EM&gt; subroutine is inside a &lt;EM&gt;named&lt;/EM&gt;
subroutine, and outside that is another subroutine; and the anonymous
(innermost) subroutine is referencing a lexical variable defined in the
outermost subroutine. For example:

&lt;P&gt;
&lt;PRE&gt;   sub outermost { my $a; sub middle { sub { $a } } }
&lt;/PRE&gt;
&lt;P&gt;
If the anonymous subroutine is called or referenced (directly or
indirectly) from the outermost subroutine, it will share the variable as
you would expect. But if the anonymous subroutine is called or referenced
when the outermost subroutine is not active, it will see the value of the
shared variable as it was before and during the *first* call to the
outermost subroutine, which is probably not what you want.

&lt;P&gt;
In these circumstances, it is usually best to make the middle subroutine
anonymous, using the [perlfunc:sub] syntax. Perl has specific support for shared variables in nested anonymous
subroutines; a named subroutine in between interferes with this feature.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;Variable &amp;quot;%s&amp;quot; will not stay shared&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(W)&lt;/FONT&gt; An inner (nested) &lt;EM&gt;named&lt;/EM&gt; subroutine is referencing a lexical variable defined in an outer
subroutine.

&lt;P&gt;
When the inner subroutine is called, it will probably see the value of the
outer subroutine's variable as it was before and during the *first* call to
the outer subroutine; in this case, after the first call to the outer
subroutine is complete, the inner and outer subroutines will no longer
share a common value for the variable. In other words, the variable will no
longer be shared.

&lt;P&gt;
Furthermore, if the outer subroutine is anonymous and references a lexical
variable outside itself, then the outer and inner subroutines will &lt;EM&gt;never&lt;/EM&gt; share the given variable.

&lt;P&gt;
This problem can usually be solved by making the inner subroutine
anonymous, using the [perlfunc:sub] syntax. When inner anonymous subs that reference variables in outer
subroutines are called or referenced, they are automatically rebound to the
current values of such variables.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;Variable syntax&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(A)&lt;/FONT&gt; You've accidentally run your script through &lt;STRONG&gt;csh&lt;/STRONG&gt; instead of Perl. Check the #! line, or manually feed your script into Perl
yourself.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;&lt;A NAME="item_perl"&gt;perl: warning: Setting locale failed.&lt;/A&gt;&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(S)&lt;/FONT&gt; The whole warning message will look something
like:

&lt;P&gt;
&lt;PRE&gt;        perl: warning: Setting locale failed.
        perl: warning: Please check that your locale settings:
                LC_ALL = &amp;quot;En_US&amp;quot;,
                LANG = (unset)
            are supported and installed on your system.
        perl: warning: Falling back to the standard locale (&amp;quot;C&amp;quot;).
&lt;/PRE&gt;
&lt;P&gt;
Exactly what were the failed locale settings varies. In the above the settings were that the 
&lt;FONT SIZE=-1&gt;LC_ALL&lt;/FONT&gt; was ``En_US'' and the 
&lt;FONT SIZE=-1&gt;LANG&lt;/FONT&gt; had no value. This error means that Perl detected that you and/or your system administrator have set up the so-called variable system but Perl could not use those settings. This was not dead serious, fortunately: there is a ``default locale'' called 
&lt;FONT SIZE=-1&gt;``C''&lt;/FONT&gt; that Perl can and will use, the script will be run. Before you really fix the problem, however, you will get the same error message each time you run Perl. How to really fix the problem can be found in
 [perlman:perllocale|the perllocale manpage] section &lt;STRONG&gt;LOCALE PROBLEMS&lt;/STRONG&gt;.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;&lt;A NAME="item_Warning"&gt;Warning: something's wrong&lt;/A&gt;&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(W)&lt;/FONT&gt; You passed 
&lt;CODE&gt;warn()&lt;/CODE&gt; an empty string (the equivalent of
 [perlman:perlguts]) or you called it with no args and &lt;CODE&gt;$_&lt;/CODE&gt; was empty.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;Warning: unable to close filehandle %s properly&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(S)&lt;/FONT&gt; The implicit 
&lt;CODE&gt;close()&lt;/CODE&gt; done by an 
&lt;CODE&gt;open()&lt;/CODE&gt; got an error indication on the 
&lt;CODE&gt;close().&lt;/CODE&gt; This usually indicates your file system ran out of disk space.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;Warning: Use of &amp;quot;%s&amp;quot; without parentheses is ambiguous&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(S)&lt;/FONT&gt; You wrote a unary operator followed by something
that looks like a binary operator that could also have been interpreted as
a term or unary operator. For instance, if you know that the rand function
has a default argument of 1.0, and you write

&lt;P&gt;
&lt;PRE&gt;    rand + 5;
&lt;/PRE&gt;
&lt;P&gt;
you may 
&lt;FONT SIZE=-1&gt;THINK&lt;/FONT&gt; you wrote the same thing as

&lt;P&gt;
&lt;PRE&gt;    rand() + 5;
&lt;/PRE&gt;
&lt;P&gt;
but in actual fact, you got

&lt;P&gt;
&lt;PRE&gt;    rand(+5);
&lt;/PRE&gt;
&lt;P&gt;
So put in parentheses to say what you really mean.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;&lt;A NAME="item_Write"&gt;Write on closed filehandle&lt;/A&gt;&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(W)&lt;/FONT&gt; The filehandle you're writing to got itself closed
sometime before now. Check your logic flow.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;&lt;A NAME="item_X"&gt;X outside of string&lt;/A&gt;&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(F)&lt;/FONT&gt; You had a pack template that specified a relative
position before the beginning of the string being unpacked. See [perlfunc:pack|pack].

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;&lt;A NAME="item_x"&gt;x outside of string&lt;/A&gt;&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(F)&lt;/FONT&gt; You had a pack template that specified a relative
position after the end of the string being unpacked. See [perlfunc:pack|pack].

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;&lt;A NAME="item_Xsub"&gt;Xsub &amp;quot;%s&amp;quot; called in sort&lt;/A&gt;&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(F)&lt;/FONT&gt; The use of an external subroutine as a sort
comparison is not yet supported.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;Xsub called in sort&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(F)&lt;/FONT&gt; The use of an external subroutine as a sort
comparison is not yet supported.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;&lt;A NAME="item_You"&gt;You can't use -l on a filehandle&lt;/A&gt;&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(F)&lt;/FONT&gt; 
&lt;FONT SIZE=-1&gt;A&lt;/FONT&gt; filehandle represents an opened file, and when you opened the file it already went past any symlink you are presumably trying to look for. Use a filename instead.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;&lt;A NAME="item_YOU"&gt;YOU HAVEN'T DISABLED SET-ID SCRIPTS IN THE KERNEL YET!&lt;/A&gt;&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(F)&lt;/FONT&gt; And you probably never will, because you probably don't have the sources to your kernel, and your vendor probably doesn't give a rip about what you want. Your best bet is to use the wrapsuid script in the eg directory to put a setuid 
&lt;FONT SIZE=-1&gt;C&lt;/FONT&gt; wrapper around your script.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;You need to quote &amp;quot;%s&amp;quot;&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(W)&lt;/FONT&gt; You assigned a bareword as a signal handler name. Unfortunately, you already have a subroutine of that name declared, which means that Perl 5 will try to call the subroutine when the assignment is executed, which is probably not what you want. (If it 
&lt;FONT SIZE=-1&gt;IS&lt;/FONT&gt; what you want, put an &amp;amp; in front.)

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;&lt;A NAME="item__gs_etsockopt_"&gt;&amp;#091;gs&amp;#093;etsockopt() on closed fd&lt;/A&gt;&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(W)&lt;/FONT&gt; You tried to get or set a socket option on a closed socket. Did you forget to check the return value of your 
&lt;CODE&gt;socket()&lt;/CODE&gt; call? See
 [perlfunc:getsockopt|getsockopt].

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;&lt;A NAME="item__1"&gt;\1 better written as $1&lt;/A&gt;&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(W)&lt;/FONT&gt; Outside of patterns, backreferences live on as
variables. The use of backslashes is grandfathered on the right-hand side
of a substitution, but stylistically it's better to use the variable form
because other Perl programmers will expect it, and it works better if there
are more than 9 backreferences.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;&lt;A NAME="item__"&gt;'|' and 'lt' may not both be specified on command line&lt;/A&gt;&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(F)&lt;/FONT&gt; An error peculiar to 
&lt;FONT SIZE=-1&gt;VMS.&lt;/FONT&gt; Perl does its own command line redirection, and found that 
&lt;FONT SIZE=-1&gt;STDIN&lt;/FONT&gt; was a pipe, and that you also tried to redirect 
&lt;FONT SIZE=-1&gt;STDIN&lt;/FONT&gt; using '&amp;lt;'. Only one 
&lt;FONT SIZE=-1&gt;STDIN&lt;/FONT&gt; stream to a customer, please.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;'|' and 'gt' may not both be specified on command line&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(F)&lt;/FONT&gt; An error peculiar to 
&lt;FONT SIZE=-1&gt;VMS.&lt;/FONT&gt; Perl does its own command line redirection, and thinks you tried to redirect stdout both to a file and into a pipe to another command. You need to choose one or the other, though nothing's stopping you from piping into a program or Perl script which 'splits' output into two streams, such as

&lt;P&gt;
&lt;PRE&gt;    open(OUT,&amp;quot;&amp;gt;$ARGV&amp;#091;0&amp;#093;&amp;quot;) or die &amp;quot;Can't write to $ARGV&amp;#091;0&amp;#093;: $!&amp;quot;;
    while (&amp;lt;STDIN&amp;gt;) {
        print;
        print OUT;
    }
    close OUT;
&lt;/PRE&gt;
&lt;DT&gt;&lt;STRONG&gt;&lt;A NAME="item_Got"&gt;Got an error from DosAllocMem&lt;/A&gt;&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(P)&lt;/FONT&gt; An error peculiar to 
&lt;FONT SIZE=-1&gt;OS/2.&lt;/FONT&gt; Most probably you're using an obsolete version of Perl, and this should not happen anyway.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;&lt;A NAME="item_Malformed"&gt;Malformed PERLLIB_PREFIX&lt;/A&gt;&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(F)&lt;/FONT&gt; An error peculiar to 
&lt;FONT SIZE=-1&gt;OS/2.&lt;/FONT&gt; 
&lt;FONT SIZE=-1&gt;PERLLIB_PREFIX&lt;/FONT&gt; should be of the form

&lt;P&gt;
&lt;PRE&gt;    prefix1;prefix2
&lt;/PRE&gt;
&lt;P&gt;
or

&lt;P&gt;
&lt;PRE&gt;    prefix1 prefix2
&lt;/PRE&gt;
&lt;P&gt;
with nonempty prefix1 and prefix2. If &lt;CODE&gt;prefix1&lt;/CODE&gt; is indeed a prefix of a builtin library search path, prefix2 is substituted. The error may appear if components are not found, or are too long. See 
&lt;FONT SIZE=-1&gt;``PERLLIB_PREFIX''&lt;/FONT&gt; in
 &lt;EM&gt;README.os2&lt;/EM&gt;.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;&lt;A NAME="item_PERL_SH_DIR"&gt;PERL_SH_DIR too long&lt;/A&gt;&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(F)&lt;/FONT&gt; An error peculiar to 
&lt;FONT SIZE=-1&gt;OS/2.&lt;/FONT&gt; 
&lt;FONT SIZE=-1&gt;PERL_SH_DIR&lt;/FONT&gt; is the directory to find the

&lt;CODE&gt;sh&lt;/CODE&gt;-shell in. See 
&lt;FONT SIZE=-1&gt;``PERL_SH_DIR''&lt;/FONT&gt; in &lt;EM&gt;README.os2&lt;/EM&gt;.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;&lt;A NAME="item_Process"&gt;Process terminated by SIG%s&lt;/A&gt;&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(W)&lt;/FONT&gt; This is a standard message issued by 
&lt;FONT SIZE=-1&gt;OS/2&lt;/FONT&gt; applications, while &lt;CODE&gt;*nix&lt;/CODE&gt; applications die in silence. It is considered a feature of the 
&lt;FONT SIZE=-1&gt;OS/2&lt;/FONT&gt; port. One can easily disable this by appropriate sighandlers, see

[perlman:perlipc]. See also ``Process terminated by 
&lt;FONT SIZE=-1&gt;SIGTERM/SIGINT''&lt;/FONT&gt; in &lt;EM&gt;README.os2&lt;/EM&gt;.

&lt;/DL&gt;
&lt;HR&gt;
&lt;BR&gt;Return to the [Library]&lt;BR&gt;</field>
</data>
</node>
