<?xml version="1.0" encoding="windows-1252"?>
<node id="421" title="perlman:perldiag" created="1999-08-25 03:15:37" updated="2005-08-15 10:43:33">
<type id="116">
perlman</type>
<author id="114">
gods</author>
<data>
<field name="doctext">
&lt;HR&gt;
&lt;P&gt;
&lt;H1&gt;&lt;A NAME="NAME"&gt;NAME&lt;/A&gt;&lt;/H1&gt;
&lt;P&gt;
perldiag - various Perl diagnostics

&lt;P&gt;
&lt;HR&gt;
&lt;H1&gt;&lt;A NAME="DESCRIPTION"&gt;DESCRIPTION&lt;/A&gt;&lt;/H1&gt;
&lt;P&gt;
These messages are classified as follows (listed in increasing order of
desperation):

&lt;P&gt;
&lt;PRE&gt;    (W) A warning (optional).
    (D) A deprecation (optional).
    (S) A severe warning (mandatory).
    (F) A fatal error (trappable).
    (P) An internal error you should never see (trappable).
    (X) A very fatal error (nontrappable).
    (A) An alien error message (not generated by Perl).
&lt;/PRE&gt;
&lt;P&gt;
Optional warnings are enabled by using the &lt;STRONG&gt;-w&lt;/STRONG&gt; switch. Warnings may be captured by setting &lt;CODE&gt;$SIG{__WARN__}&lt;/CODE&gt; to a reference to a routine that will be called on each warning instead of
printing it. See [perlman:perlvar|the perlvar manpage]. Trappable errors may be trapped using the eval operator. See
[perlfunc:eval|eval].

&lt;P&gt;
Some of these messages are generic. Spots that vary are denoted with a %s,
just as in a printf format. Note that some messages start with a %s! The
symbols &lt;CODE&gt;&amp;quot;%(-?@&lt;/CODE&gt; sort before the letters, while &lt;CODE&gt;&amp;#091;&lt;/CODE&gt; and &lt;CODE&gt;\&lt;/CODE&gt; sort after.

&lt;DL&gt;
&lt;DT&gt;&lt;STRONG&gt;&lt;A NAME="item__my_"&gt;&amp;quot;my&amp;quot; variable %s can't be in a package&lt;/A&gt;&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(F)&lt;/FONT&gt; Lexically scoped variables aren't in a package, so it doesn't make sense to try to declare one with a package qualifier on the front. Use 
&lt;CODE&gt;local()&lt;/CODE&gt; if you want to localize a package variable.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;&amp;quot;my&amp;quot; variable %s masks earlier declaration in same scope&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(W)&lt;/FONT&gt; 
&lt;FONT SIZE=-1&gt;A&lt;/FONT&gt; lexical variable has been redeclared in the same scope, effectively eliminating all access to the previous instance. This is almost always a typographical error. Note that the earlier variable will still exist until the end of the scope or until all closure referents to it are destroyed.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;&lt;A NAME="item__no_"&gt;&amp;quot;no&amp;quot; not allowed in expression&lt;/A&gt;&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(F)&lt;/FONT&gt; The ``no'' keyword is recognized and executed at
compile time, and returns no useful value. See [perlman:perlmod|the perlmod manpage].

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;&lt;A NAME="item__use_"&gt;&amp;quot;use&amp;quot; not allowed in expression&lt;/A&gt;&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(F)&lt;/FONT&gt; The ``use'' keyword is recognized and executed at
compile time, and returns no useful value. See [perlman:perlmod|the perlmod manpage].

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;&lt;A NAME="item__"&gt;% may only be used in unpack&lt;/A&gt;&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(F)&lt;/FONT&gt; You can't pack a string by supplying a checksum,
because the checksumming process loses information, and you can't go the
other way. See [perlfunc:unpack|unpack].

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;&lt;A NAME="item__s"&gt;%s (...) interpreted as function&lt;/A&gt;&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(W)&lt;/FONT&gt; You've run afoul of the rule that says that any
list operator followed by parentheses turns into a function, with all the
list operators arguments found inside the parentheses. See [perlman:perlop].

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;%s argument is not a HASH element&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(F)&lt;/FONT&gt; The argument to 
&lt;CODE&gt;exists()&lt;/CODE&gt; must be a hash element, such as

&lt;P&gt;
&lt;PRE&gt;    $foo{$bar}
    $ref-&amp;gt;&amp;#091;12&amp;#093;-&amp;gt;{&amp;quot;susie&amp;quot;}
&lt;/PRE&gt;
&lt;DT&gt;&lt;STRONG&gt;%s argument is not a HASH element or slice&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(F)&lt;/FONT&gt; The argument to 
&lt;CODE&gt;delete()&lt;/CODE&gt; must be either a hash element, such as

&lt;P&gt;
&lt;PRE&gt;    $foo{$bar}
    $ref-&amp;gt;&amp;#091;12&amp;#093;-&amp;gt;{&amp;quot;susie&amp;quot;}
&lt;/PRE&gt;
&lt;P&gt;
or a hash slice, such as

&lt;P&gt;
&lt;PRE&gt;    @foo{$bar, $baz, $xyzzy}
    @{$ref-&amp;gt;&amp;#091;12&amp;#093;}{&amp;quot;susie&amp;quot;, &amp;quot;queue&amp;quot;}
&lt;/PRE&gt;
&lt;DT&gt;&lt;STRONG&gt;%s did not return a true value&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(F)&lt;/FONT&gt; 
&lt;FONT SIZE=-1&gt;A&lt;/FONT&gt; required (or used) file must return a true value to indicate that it compiled correctly and ran its initialization code correctly. It's traditional to end such a file with a ``1;'', though any true value would do. See
 [perlfunc:require|require].

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;%s found where operator expected&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(S)&lt;/FONT&gt; The Perl lexer knows whether to expect a term or
an operator. If it sees what it knows to be a term when it was expecting to
see an operator, it gives you this warning. Usually it indicates that an
operator or delimiter was omitted, such as a semicolon.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;%s had compilation errors&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(F)&lt;/FONT&gt; The final summary message when a &lt;CODE&gt;perl -c&lt;/CODE&gt; fails.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;%s has too many errors&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(F)&lt;/FONT&gt; The parser has given up trying to parse the
program after 10 errors. Further error messages would likely be
uninformative.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;%s matches null string many times&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(W)&lt;/FONT&gt; The pattern you've specified would be an infinite
loop if the regular expression engine didn't specifically check for that.
See [perlman:perlre|the perlre manpage].

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;%s never introduced&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(S)&lt;/FONT&gt; The symbol in question was declared but somehow
went out of scope before it could possibly have been used.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;%s syntax OK&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(F)&lt;/FONT&gt; The final summary message when a &lt;CODE&gt;perl -c&lt;/CODE&gt; succeeds.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;&lt;A NAME="item__s_"&gt;%s: Command not found&lt;/A&gt;&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(A)&lt;/FONT&gt; You've accidentally run your script through &lt;STRONG&gt;csh&lt;/STRONG&gt; instead of Perl. Check the #! line, or manually feed your script into Perl
yourself.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;%s: Expression syntax&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(A)&lt;/FONT&gt; You've accidentally run your script through &lt;STRONG&gt;csh&lt;/STRONG&gt; instead of Perl. Check the #! line, or manually feed your script into Perl
yourself.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;%s: Undefined variable&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(A)&lt;/FONT&gt; You've accidentally run your script through &lt;STRONG&gt;csh&lt;/STRONG&gt; instead of Perl. Check the #! line, or manually feed your script into Perl
yourself.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;%s: not found&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(A)&lt;/FONT&gt; You've accidentally run your script through the
Bourne shell instead of Perl. Check the #! line, or manually feed your
script into Perl yourself.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;&lt;A NAME="item__Missing"&gt;(Missing semicolon on previous line?)&lt;/A&gt;&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(S)&lt;/FONT&gt; This is an educated guess made in conjunction with
the message ``%s found where operator expected''. Don't automatically put a
semicolon on the previous line just because you saw this message.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;&lt;A NAME="item__P"&gt;-P not allowed for setuid/setgid script&lt;/A&gt;&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(F)&lt;/FONT&gt; The script would have to be opened by the 
&lt;FONT SIZE=-1&gt;C&lt;/FONT&gt; preprocessor by name, which provides a race condition that breaks security.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;&lt;A NAME="item__T"&gt;-T and -B not implemented on filehandles&lt;/A&gt;&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(F)&lt;/FONT&gt; Perl can't peek at the stdio buffer of filehandles
when it doesn't know about your kind of stdio. You'll have to use a
filename instead.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;&lt;A NAME="item__p"&gt;-p destination: %s&lt;/A&gt;&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(F)&lt;/FONT&gt; An error occurred during the implicit output
invoked by the &lt;CODE&gt;-p&lt;/CODE&gt;
command-line switch. (This output goes to 
&lt;FONT SIZE=-1&gt;STDOUT&lt;/FONT&gt; unless you've redirected it with 
&lt;CODE&gt;select().)&lt;/CODE&gt;

&lt;P&gt;&lt;LI&gt;&lt;STRONG&gt;&lt;A NAME="item_Server_error"&gt;Server error&lt;/A&gt;&lt;/STRONG&gt;

See Server error.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;&lt;A NAME="item__"&gt;?+* follows nothing in regexp&lt;/A&gt;&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(F)&lt;/FONT&gt; You started a regular expression with a
quantifier. Backslash it if you meant it literally. See [perlman:perlre|the perlre manpage].

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;&lt;A NAME="item__"&gt;@ outside of string&lt;/A&gt;&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(F)&lt;/FONT&gt; You had a pack template that specified an absolute
position outside the string being unpacked. See [perlfunc:pack|pack].

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;&lt;A NAME="item_accept"&gt;accept() on closed fd&lt;/A&gt;&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(W)&lt;/FONT&gt; You tried to do an accept on a closed socket. Did you forget to check the return value of your 
&lt;CODE&gt;socket()&lt;/CODE&gt; call? See
 [perlfunc:accept|accept].

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;&lt;A NAME="item_Allocation"&gt;Allocation too large: %lx&lt;/A&gt;&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(X)&lt;/FONT&gt; You can't allocate more than 
&lt;FONT SIZE=-1&gt;64K&lt;/FONT&gt; on an 
&lt;FONT SIZE=-1&gt;MS-DOS&lt;/FONT&gt; machine.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;&lt;A NAME="item_Applying"&gt;Applying %s to %s will act on scalar(%s)&lt;/A&gt;&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(W)&lt;/FONT&gt; The pattern match (//), substitution (s///), and
transliteration (tr///) operators work on scalar values. If you apply one
of them to an array or a hash, it will convert the array or hash to a
scalar value -- the length of an array, or the population info of a hash --
and then work on that scalar value. This is probably not what you meant to
do. See
[perlfunc:grep|grep] and [perlfunc:map|map] for alternatives.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;&lt;A NAME="item_Arg"&gt;Arg too short for msgsnd&lt;/A&gt;&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(F)&lt;/FONT&gt; 
&lt;CODE&gt;msgsnd()&lt;/CODE&gt; requires a string at least as long as 
&lt;CODE&gt;sizeof(long).&lt;/CODE&gt;

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;&lt;A NAME="item_Ambiguous"&gt;Ambiguous use of %s resolved as %s&lt;/A&gt;&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(W)(S)&lt;/FONT&gt; You said something that may not be interpreted
the way you thought. Normally it's pretty easy to disambiguate it by
supplying a missing quote, operator, parenthesis pair or declaration.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;Ambiguous call resolved as CORE::%s(), qualify as such or use &amp;amp;&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(W)&lt;/FONT&gt; 
&lt;FONT SIZE=-1&gt;A&lt;/FONT&gt; subroutine you have declared has the same name as a Perl keyword, and you have used the name without qualification for calling one or the other. Perl decided to call the builtin because the subroutine is not imported.

&lt;P&gt;
To force interpretation as a subroutine call, either put an ampersand
before the subroutine name, or qualify the name with its package.
Alternatively, you can import the subroutine (or pretend that it's imported
with the &lt;CODE&gt;use subs&lt;/CODE&gt; pragma).

&lt;P&gt;
To silently interpret it as the Perl operator, use the &lt;CODE&gt;CORE::&lt;/CODE&gt; prefix on the operator (e.g. &lt;CODE&gt;CORE::log($x)&lt;/CODE&gt;) or by declaring the subroutine to be an object method (see &lt;U&gt;the attrs manpage&lt;/U&gt;&lt;!--../lib/attrs.html--&gt;).

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;&lt;A NAME="item_Args"&gt;Args must match #! line&lt;/A&gt;&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(F)&lt;/FONT&gt; The setuid emulator requires that the arguments
Perl was invoked with match the arguments specified on the #! line. Since
some systems impose a one-argument limit on the #! line, try combining
switches; for example, turn &lt;CODE&gt;-w -U&lt;/CODE&gt; into &lt;CODE&gt;-wU&lt;/CODE&gt;.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;&lt;A NAME="item_Argument"&gt;Argument &amp;quot;%s&amp;quot; isn't numeric%s&lt;/A&gt;&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(W)&lt;/FONT&gt; The indicated string was fed as an argument to an
operator that expected a numeric value instead. If you're fortunate the
message will identify which operator was so unfortunate.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;&lt;A NAME="item_Array"&gt;Array @%s missing the @ in argument %d of %s()&lt;/A&gt;&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(D)&lt;/FONT&gt; Really old Perl let you omit the @ on array names
in some spots. This is now heavily deprecated.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;&lt;A NAME="item_assertion"&gt;assertion botched: %s&lt;/A&gt;&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(P)&lt;/FONT&gt; The malloc package that comes with Perl had an
internal failure.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;&lt;A NAME="item_Assertion"&gt;Assertion failed: file &amp;quot;%s&amp;quot;&lt;/A&gt;&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(P)&lt;/FONT&gt; 
&lt;FONT SIZE=-1&gt;A&lt;/FONT&gt; general assertion failed. The file in question must be examined.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;&lt;A NAME="item_Assignment"&gt;Assignment to both a list and a scalar&lt;/A&gt;&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(F)&lt;/FONT&gt; If you assign to a conditional operator, the 2nd
and 3rd arguments must either both be scalars or both be lists. Otherwise
Perl won't know which context to supply to the right side.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;&lt;A NAME="item_Attempt"&gt;Attempt to free non-arena SV: 0x%lx&lt;/A&gt;&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(P)&lt;/FONT&gt; All 
&lt;FONT SIZE=-1&gt;SV&lt;/FONT&gt; objects are supposed to be allocated from arenas that will be garbage collected on exit. An 
&lt;FONT SIZE=-1&gt;SV&lt;/FONT&gt; was discovered to be outside any of those arenas.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;Attempt to free nonexistent shared string&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(P)&lt;/FONT&gt; Perl maintains a reference counted internal table
of strings to optimize the storage and access of hash keys and other
strings. This indicates someone tried to decrement the reference count of a
string that can no longer be found in the table.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;Attempt to free temp prematurely&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(W)&lt;/FONT&gt; Mortalized values are supposed to be freed by the 
&lt;CODE&gt;free_tmps()&lt;/CODE&gt; routine. This indicates that something else is freeing the 
&lt;FONT SIZE=-1&gt;SV&lt;/FONT&gt; before the 
&lt;CODE&gt;free_tmps()&lt;/CODE&gt; routine gets a chance, which means that the 
&lt;CODE&gt;free_tmps()&lt;/CODE&gt; routine will be freeing an unreferenced scalar when it does try to free it.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;Attempt to free unreferenced glob pointers&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(P)&lt;/FONT&gt; The reference counts got screwed up on symbol
aliases.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;Attempt to free unreferenced scalar&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(W)&lt;/FONT&gt; Perl went to decrement the reference count of a scalar to see if it would go to 0, and discovered that it had already gone to 0 earlier, and should have been freed, and in fact, probably was freed. This could indicate that 
&lt;CODE&gt;SvREFCNT_dec()&lt;/CODE&gt; was called too many times, or that 
&lt;CODE&gt;SvREFCNT_inc()&lt;/CODE&gt; was called too few times, or that the 
&lt;FONT SIZE=-1&gt;SV&lt;/FONT&gt; was mortalized when it shouldn't have been, or that memory has been corrupted.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;Attempt to pack pointer to temporary value&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(W)&lt;/FONT&gt; You tried to pass a temporary value (like the result of a function, or a computed expression) to the ``p'' 
&lt;CODE&gt;pack()&lt;/CODE&gt; template. This means the result contains a pointer to a location that could become invalid anytime, even before the end of the current statement. Use literals or global values as arguments to the ``p'' 
&lt;CODE&gt;pack()&lt;/CODE&gt; template to avoid this warning.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;Attempt to use reference as lvalue in substr&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(W)&lt;/FONT&gt; You supplied a reference as the first argument to 
&lt;CODE&gt;substr()&lt;/CODE&gt; used as an lvalue, which is pretty strange. Perhaps you forgot to dereference it first. See
 [perlfunc:substr|substr].

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;&lt;A NAME="item_Bad"&gt;Bad arg length for %s, is %d, should be %d&lt;/A&gt;&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(F)&lt;/FONT&gt; You passed a buffer of the wrong size to one of 
&lt;CODE&gt;msgctl(),&lt;/CODE&gt; 
&lt;CODE&gt;semctl()&lt;/CODE&gt; or 
&lt;CODE&gt;shmctl().&lt;/CODE&gt; In 
&lt;FONT SIZE=-1&gt;C&lt;/FONT&gt; parlance, the correct sizes are, respectively,

sizeof(struct&amp;nbsp;msqid_ds&amp;nbsp;*), sizeof(struct&amp;nbsp;semid_ds&amp;nbsp;*), and
sizeof(struct&amp;nbsp;shmid_ds&amp;nbsp;*).

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;Bad filehandle: %s&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(F)&lt;/FONT&gt; 
&lt;FONT SIZE=-1&gt;A&lt;/FONT&gt; symbol was passed to something wanting a filehandle, but the symbol has no filehandle associated with it. Perhaps you didn't do an 
&lt;CODE&gt;open(),&lt;/CODE&gt; or did it in another package.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;Bad free() ignored&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(S)&lt;/FONT&gt; An internal routine called 
&lt;CODE&gt;free()&lt;/CODE&gt; on something that had never been 
&lt;CODE&gt;malloc()ed&lt;/CODE&gt; in the first place. Mandatory, but can be disabled by setting environment variable
 &lt;CODE&gt;PERL_BADFREE&lt;/CODE&gt; to 1.

&lt;P&gt;
This message can be quite often seen with DB_File on systems with ``hard''
dynamic linking, like &lt;CODE&gt;AIX&lt;/CODE&gt; and &lt;CODE&gt;OS/2&lt;/CODE&gt;. It is a bug of
&lt;CODE&gt;Berkeley DB&lt;/CODE&gt; which is left unnoticed if &lt;CODE&gt;DB&lt;/CODE&gt; uses &lt;EM&gt;forgiving&lt;/EM&gt;
system 
&lt;CODE&gt;malloc().&lt;/CODE&gt;

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;Bad hash&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(P)&lt;/FONT&gt; One of the internal hash routines was passed a null 
&lt;FONT SIZE=-1&gt;HV&lt;/FONT&gt; pointer.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;Bad index while coercing array into hash&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(F)&lt;/FONT&gt; The index looked up in the hash found as the 0'th
element of a pseudo-hash is not legal. Index values must be at 1 or
greater. See [perlman:perlref|the perlref manpage].

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;Bad name after %s::&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(F)&lt;/FONT&gt; You started to name a symbol by using a package
prefix, and then didn't finish the symbol. In particular, you can't
interpolate outside of quotes, so

&lt;P&gt;
&lt;PRE&gt;    $var = 'myvar';
    $sym = mypack::$var;
&lt;/PRE&gt;
&lt;P&gt;
is not the same as

&lt;P&gt;
&lt;PRE&gt;    $var = 'myvar';
    $sym = &amp;quot;mypack::$var&amp;quot;;
&lt;/PRE&gt;
&lt;DT&gt;&lt;STRONG&gt;Bad symbol for array&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(P)&lt;/FONT&gt; An internal request asked to add an array entry to
something that wasn't a symbol table entry.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;Bad symbol for filehandle&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(P)&lt;/FONT&gt; An internal request asked to add a filehandle
entry to something that wasn't a symbol table entry.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;Bad symbol for hash&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(P)&lt;/FONT&gt; An internal request asked to add a hash entry to
something that wasn't a symbol table entry.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;&lt;A NAME="item_Badly"&gt;Badly placed ()'s&lt;/A&gt;&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(A)&lt;/FONT&gt; You've accidentally run your script through &lt;STRONG&gt;csh&lt;/STRONG&gt; instead of Perl. Check the #! line, or manually feed your script into Perl
yourself.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;&lt;A NAME="item_Bareword"&gt;Bareword &amp;quot;%s&amp;quot; not allowed while &amp;quot;strict subs&amp;quot; in use&lt;/A&gt;&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(F)&lt;/FONT&gt; With ``strict subs'' in use, a bareword is only
allowed as a subroutine identifier, in curly braces or to the left of the
``=&amp;gt;'' symbol. Perhaps you need to predeclare a subroutine?

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;Bareword &amp;quot;%s&amp;quot; refers to nonexistent package&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(W)&lt;/FONT&gt; You used a qualified bareword of the form &lt;CODE&gt;Foo::&lt;/CODE&gt;, but the compiler saw no other uses of that namespace before that point.
Perhaps you need to predeclare a package?

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;&lt;A NAME="item_BEGIN"&gt;BEGIN failed--compilation aborted&lt;/A&gt;&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(F)&lt;/FONT&gt; An untrapped exception was raised while executing a 
&lt;FONT SIZE=-1&gt;BEGIN&lt;/FONT&gt; subroutine. Compilation stops immediately and the interpreter is exited.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;BEGIN not safe after errors--compilation aborted&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(F)&lt;/FONT&gt; Perl found a &lt;CODE&gt;BEGIN {}&lt;/CODE&gt; subroutine (or a [perlfunc:use|use] directive, which implies a &lt;CODE&gt;BEGIN {}&lt;/CODE&gt;) after one or more compilation errors had already occurred. Since the
intended environment for the &lt;CODE&gt;BEGIN {}&lt;/CODE&gt;
could not be guaranteed (due to the errors), and since subsequent code
likely depends on its correct operation, Perl just gave up.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;&lt;A NAME="item_bind"&gt;bind() on closed fd&lt;/A&gt;&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(W)&lt;/FONT&gt; You tried to do a bind on a closed socket. Did you forget to check the return value of your 
&lt;CODE&gt;socket()&lt;/CODE&gt; call? See
 [perlfunc:bind|bind].

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;&lt;A NAME="item_Bizarre"&gt;Bizarre copy of %s in %s&lt;/A&gt;&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(P)&lt;/FONT&gt; Perl detected an attempt to copy an internal value
that is not copiable.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;&lt;A NAME="item_Callback"&gt;Callback called exit&lt;/A&gt;&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(F)&lt;/FONT&gt; 
&lt;FONT SIZE=-1&gt;A&lt;/FONT&gt; subroutine invoked from an external package via 
&lt;CODE&gt;perl_call_sv()&lt;/CODE&gt; exited by calling exit.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;&lt;A NAME="item_Can"&gt;Can't &amp;quot;goto&amp;quot; outside a block&lt;/A&gt;&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(F)&lt;/FONT&gt; 
&lt;FONT SIZE=-1&gt;A&lt;/FONT&gt; ``goto'' statement was executed to jump out of what might look like a block, except that it isn't a proper block. This usually occurs if you tried to jump out of a 
&lt;CODE&gt;sort()&lt;/CODE&gt; block or subroutine, which is a no-no. See
 [perlfunc:goto|goto].

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;Can't &amp;quot;goto&amp;quot; into the middle of a foreach loop&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(F)&lt;/FONT&gt; 
&lt;FONT SIZE=-1&gt;A&lt;/FONT&gt; ``goto'' statement was executed to jump into the middle of a foreach loop. You can't get there from here. See
 [perlfunc:goto|goto].

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;Can't &amp;quot;last&amp;quot; outside a block&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(F)&lt;/FONT&gt; 
&lt;FONT SIZE=-1&gt;A&lt;/FONT&gt; ``last'' statement was executed to break out of the current block, except that there's this itty bitty problem called there isn't a current block. Note that an ``if'' or ``else'' block doesn't count as a ``loopish'' block, as doesn't a block given to 
&lt;CODE&gt;sort().&lt;/CODE&gt; You can usually double the curlies to get the same effect though, because the inner curlies will be considered a block that loops once. See
 [perlfunc:last|last].

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;Can't &amp;quot;next&amp;quot; outside a block&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(F)&lt;/FONT&gt; 
&lt;FONT SIZE=-1&gt;A&lt;/FONT&gt; ``next'' statement was executed to reiterate the current block, but there isn't a current block. Note that an ``if'' or ``else'' block doesn't count as a ``loopish'' block, as doesn't a block given to 
&lt;CODE&gt;sort().&lt;/CODE&gt; You can usually double the curlies to get the same effect though, because the inner curlies will be considered a block that loops once. See
 [perlfunc:next|next].

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;Can't &amp;quot;redo&amp;quot; outside a block&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(F)&lt;/FONT&gt; 
&lt;FONT SIZE=-1&gt;A&lt;/FONT&gt; ``redo'' statement was executed to restart the current block, but there isn't a current block. Note that an ``if'' or ``else'' block doesn't count as a ``loopish'' block, as doesn't a block given to 
&lt;CODE&gt;sort().&lt;/CODE&gt; You can usually double the curlies to get the same effect though, because the inner curlies will be considered a block that loops once. See
 [perlfunc:redo|redo].

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;Can't bless non-reference value&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(F)&lt;/FONT&gt; Only hard references may be blessed. This is how
Perl ``enforces'' encapsulation of objects. See [perlman:perlobj|the perlobj manpage].

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;Can't break at that line&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(S)&lt;/FONT&gt; 
&lt;FONT SIZE=-1&gt;A&lt;/FONT&gt; warning intended to only be printed while running within the debugger, indicating the line number specified wasn't the location of a statement that could be stopped at.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;Can't call method &amp;quot;%s&amp;quot; in empty package &amp;quot;%s&amp;quot;&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(F)&lt;/FONT&gt; You called a method correctly, and it correctly indicated a package functioning as a class, but that package doesn't have 
&lt;FONT SIZE=-1&gt;ANYTHING&lt;/FONT&gt; defined in it, let alone methods. See
 [perlman:perlobj|the perlobj manpage].

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;Can't call method &amp;quot;%s&amp;quot; on unblessed reference&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(F)&lt;/FONT&gt; 
&lt;FONT SIZE=-1&gt;A&lt;/FONT&gt; method call must know in what package it's supposed to run. It ordinarily finds this out from the object reference you supply, but you didn't supply an object reference in this case. 
&lt;FONT SIZE=-1&gt;A&lt;/FONT&gt; reference isn't an object reference until it has been blessed. See
 [perlman:perlobj|the perlobj manpage].

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;Can't call method &amp;quot;%s&amp;quot; without a package or object reference&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(F)&lt;/FONT&gt; You used the syntax of a method call, but the slot
filled by the object reference or package name contains an expression that
returns a defined value which is neither an object reference nor a package
name. Something like this will reproduce the error:

&lt;P&gt;
&lt;PRE&gt;    $BADREF = 42;
    process $BADREF 1,2,3;
    $BADREF-&amp;gt;process(1,2,3);
&lt;/PRE&gt;
&lt;DT&gt;&lt;STRONG&gt;Can't call method &amp;quot;%s&amp;quot; on an undefined value&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(F)&lt;/FONT&gt; You used the syntax of a method call, but the slot
filled by the object reference or package name contains an undefined value.
Something like this will reproduce the error:

&lt;P&gt;
&lt;PRE&gt;    $BADREF = undef;
    process $BADREF 1,2,3;
    $BADREF-&amp;gt;process(1,2,3);
&lt;/PRE&gt;
&lt;DT&gt;&lt;STRONG&gt;Can't chdir to %s&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(F)&lt;/FONT&gt; You called &lt;CODE&gt;perl -x/foo/bar&lt;/CODE&gt;, but &lt;CODE&gt;/foo/bar&lt;/CODE&gt; is not a directory that you can chdir to, possibly because it doesn't
exist.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;Can't coerce %s to integer in %s&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(F)&lt;/FONT&gt; Certain types of SVs, in particular real symbol
table entries (typeglobs), can't be forced to stop being what they are. So
you can't say things like:

&lt;P&gt;
&lt;PRE&gt;    *foo += 1;
&lt;/PRE&gt;
&lt;P&gt;
You 
&lt;FONT SIZE=-1&gt;CAN&lt;/FONT&gt; say

&lt;P&gt;
&lt;PRE&gt;    $foo = *foo;
    $foo += 1;
&lt;/PRE&gt;
&lt;P&gt;
but then &lt;CODE&gt;$foo&lt;/CODE&gt; no longer contains a glob.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;Can't coerce %s to number in %s&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(F)&lt;/FONT&gt; Certain types of SVs, in particular real symbol
table entries (typeglobs), can't be forced to stop being what they are.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;Can't coerce %s to string in %s&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(F)&lt;/FONT&gt; Certain types of SVs, in particular real symbol
table entries (typeglobs), can't be forced to stop being what they are.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;Can't coerce array into hash&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(F)&lt;/FONT&gt; You used an array where a hash was expected, but
the array has no information on how to map from keys to array indices. You
can do that only with arrays that have a hash reference at index 0.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;Can't create pipe mailbox&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(P)&lt;/FONT&gt; An error peculiar to 
&lt;FONT SIZE=-1&gt;VMS.&lt;/FONT&gt; The process is suffering from exhausted quotas or other plumbing problems.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;Can't declare %s in my&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(F)&lt;/FONT&gt; Only scalar, array, and hash variables may be
declared as lexical variables. They must have ordinary identifiers as
names.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;Can't do inplace edit on %s: %s&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(S)&lt;/FONT&gt; The creation of the new file failed for the
indicated reason.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;Can't do inplace edit without backup&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(F)&lt;/FONT&gt; You're on a system such as 
&lt;FONT SIZE=-1&gt;MS-DOS&lt;/FONT&gt; that gets confused if you try reading from a deleted (but still opened) file. You have to say
 &lt;CODE&gt;-i.bak&lt;/CODE&gt;, or some such.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;Can't do inplace edit: %s gt 14 characters&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(S)&lt;/FONT&gt; There isn't enough room in the filename to make a
backup name for the file.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;Can't do inplace edit: %s is not a regular file&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(S)&lt;/FONT&gt; You tried to use the &lt;STRONG&gt;-i&lt;/STRONG&gt; switch on a special file, such as a file in /dev, or a 
&lt;FONT SIZE=-1&gt;FIFO.&lt;/FONT&gt; The file was ignored.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;Can't do setegid!&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(P)&lt;/FONT&gt; The 
&lt;CODE&gt;setegid()&lt;/CODE&gt; call failed for some reason in the setuid emulator of suidperl.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;Can't do seteuid!&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(P)&lt;/FONT&gt; The setuid emulator of suidperl failed for some
reason.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;Can't do setuid&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(F)&lt;/FONT&gt; This typically means that ordinary perl tried to
exec suidperl to do setuid emulation, but couldn't exec it. It looks for a
name of the form sperl5.000 in the same directory that the perl executable
resides under the name perl5.000, typically /usr/local/bin on Unix
machines. If the file is there, check the execute permissions. If it isn't,
ask your sysadmin why he and/or she removed it.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;Can't do waitpid with flags&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(F)&lt;/FONT&gt; This machine doesn't have either 
&lt;CODE&gt;waitpid()&lt;/CODE&gt; or 
&lt;CODE&gt;wait4(),&lt;/CODE&gt; so only 
&lt;CODE&gt;waitpid()&lt;/CODE&gt; without flags is emulated.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;Can't do {n,m} with n gt m&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(F)&lt;/FONT&gt; Minima must be less than or equal to maxima. If
you really want your regexp to match something 0 times, just put {0}. See [perlman:perlre|the perlre manpage].

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;Can't emulate -%s on #! line&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(F)&lt;/FONT&gt; The #! line specifies a switch that doesn't make
sense at this point. For example, it'd be kind of silly to put a &lt;STRONG&gt;-x&lt;/STRONG&gt; on the #! line.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;Can't exec &amp;quot;%s&amp;quot;: %s&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(W)&lt;/FONT&gt; An 
&lt;CODE&gt;system(),&lt;/CODE&gt; 
&lt;CODE&gt;exec(),&lt;/CODE&gt; or piped open call could not execute the named program for the indicated reason. Typical reasons include: the permissions were wrong on the file, the file wasn't found in
 &lt;CODE&gt;$ENV{PATH}&lt;/CODE&gt;, the executable in question was compiled for another architecture, or the
#! line in a script points to an interpreter that can't be run for similar
reasons. (Or maybe your system doesn't support #! at all.)

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;Can't exec %s&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(F)&lt;/FONT&gt; Perl was trying to execute the indicated program
for you because that's what the #! line said. If that's not what you
wanted, you may need to mention ``perl'' on the #! line somewhere.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;Can't execute %s&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(F)&lt;/FONT&gt; You used the &lt;STRONG&gt;-S&lt;/STRONG&gt; switch, but the copies of the script to execute found in the 
&lt;FONT SIZE=-1&gt;PATH&lt;/FONT&gt; did not have correct permissions.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;Can't find %s on PATH, '.' not in PATH&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(F)&lt;/FONT&gt; You used the &lt;STRONG&gt;-S&lt;/STRONG&gt; switch, but the script to execute could not be found in the 
&lt;FONT SIZE=-1&gt;PATH,&lt;/FONT&gt; or at least not with the correct permissions. The script exists in the current directory, but 
&lt;FONT SIZE=-1&gt;PATH&lt;/FONT&gt; prohibits running it.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;Can't find %s on PATH&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(F)&lt;/FONT&gt; You used the &lt;STRONG&gt;-S&lt;/STRONG&gt; switch, but the script to execute could not be found in the 
&lt;FONT SIZE=-1&gt;PATH.&lt;/FONT&gt;

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;Can't find label %s&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(F)&lt;/FONT&gt; You said to goto a label that isn't mentioned
anywhere that it's possible for us to go to. See [perlfunc:goto|goto].

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;Can't find string terminator %s anywhere before EOF&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(F)&lt;/FONT&gt; Perl strings can stretch over multiple lines. This
message means that the closing delimiter was omitted. Because bracketed
quotes count nesting levels, the following is missing its final
parenthesis:

&lt;P&gt;
&lt;PRE&gt;    print q(The character '(' starts a side comment.);
&lt;/PRE&gt;
&lt;P&gt;
If you're getting this error from a here-document, you may have included unseen whitespace before or after your closing tag. 
&lt;FONT SIZE=-1&gt;A&lt;/FONT&gt; good programmer's editor will have a way to help you find these characters.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;Can't fork&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(F)&lt;/FONT&gt; 
&lt;FONT SIZE=-1&gt;A&lt;/FONT&gt; fatal error occurred while trying to fork while opening a pipeline.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;Can't get filespec - stale stat buffer?&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(S)&lt;/FONT&gt; 
&lt;FONT SIZE=-1&gt;A&lt;/FONT&gt; warning peculiar to 
&lt;FONT SIZE=-1&gt;VMS.&lt;/FONT&gt; This arises because of the difference between access checks under 
&lt;FONT SIZE=-1&gt;VMS&lt;/FONT&gt; and under the Unix model Perl assumes. Under 
&lt;FONT SIZE=-1&gt;VMS,&lt;/FONT&gt; access checks are done by filename, rather than by bits in the stat buffer, so that ACLs and other protections can be taken into account. Unfortunately, Perl assumes that the stat buffer contains all the necessary information, and passes it, instead of the filespec, to the access checking routine. It will try to retrieve the filespec using the device name and 
&lt;FONT SIZE=-1&gt;FID&lt;/FONT&gt; present in the stat buffer, but this works only if you haven't made a subsequent call to the 
&lt;FONT SIZE=-1&gt;CRTL&lt;/FONT&gt; 
&lt;CODE&gt;stat()&lt;/CODE&gt; routine, because the device name is overwritten with each call. If this warning appears, the name lookup failed, and the access checking routine gave up and returned 
&lt;FONT SIZE=-1&gt;FALSE,&lt;/FONT&gt; just to be conservative. (Note: The access checking routine knows about the Perl
 [perlfunc:stat|stat] operator and file tests, so you shouldn't ever see this warning in response
to a Perl command; it arises only if some internal code takes stat buffers
lightly.)

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;Can't get pipe mailbox device name&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(P)&lt;/FONT&gt; An error peculiar to 
&lt;FONT SIZE=-1&gt;VMS.&lt;/FONT&gt; After creating a mailbox to act as a pipe, Perl can't retrieve its name for later use.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;Can't get SYSGEN parameter value for MAXBUF&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(P)&lt;/FONT&gt; An error peculiar to 
&lt;FONT SIZE=-1&gt;VMS.&lt;/FONT&gt; Perl asked &lt;CODE&gt;$GETSYI&lt;/CODE&gt; how big you want your mailbox buffers to be, and didn't get an answer.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;Can't goto subroutine outside a subroutine&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(F)&lt;/FONT&gt; The deeply magical ``goto subroutine'' call can only replace one subroutine call for another. It can't manufacture one out of whole cloth. In general you should be calling it out of only an 
&lt;FONT SIZE=-1&gt;AUTOLOAD&lt;/FONT&gt; routine anyway. See

[perlfunc:goto|goto].

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;Can't goto subroutine from an eval-string&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(F)&lt;/FONT&gt; The ``goto subroutine'' call can't be used to jump out of an eval ``string''. (You can use it to jump out of an eval 
&lt;FONT SIZE=-1&gt;{BLOCK},&lt;/FONT&gt; but you probably don't want to.)

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;Can't localize through a reference&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(F)&lt;/FONT&gt; You said something like &lt;CODE&gt;local $$ref&lt;/CODE&gt;, which Perl can't currently handle, because when it goes to restore the old value of whatever [perlfunc:ref] pointed to after the scope of the 
&lt;CODE&gt;local()&lt;/CODE&gt; is finished, it can't be sure that [perlfunc:ref] will still be a reference.
  

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;Can't localize lexical variable %s&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(F)&lt;/FONT&gt; You used local on a variable name that was
previously declared as a lexical variable using ``my''. This is not
allowed. If you want to localize a package variable of the same name,
qualify it with the package name.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;Can't localize pseudo-hash element&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(F)&lt;/FONT&gt; You said something like &lt;CODE&gt;local $ar-&amp;gt;{'key'}&lt;/CODE&gt;, where &lt;CODE&gt;$ar&lt;/CODE&gt; is a reference to a pseudo-hash. That hasn't been
implemented yet, but you can get a similar effect by localizing the
corresponding array element directly -- &lt;CODE&gt;local $ar-&amp;gt;&amp;#091;$ar-&amp;gt;&amp;#091;0&amp;#093;{'key'}&amp;#093;&lt;/CODE&gt;.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;Can't locate auto/%s.al in @INC&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(F)&lt;/FONT&gt; 
&lt;FONT SIZE=-1&gt;A&lt;/FONT&gt; function (or method) was called in a package which allows autoload, but there is no function to autoload. Most probable causes are a misprint in a function/method name or a failure to
 &lt;CODE&gt;AutoSplit&lt;/CODE&gt; the file, say, by doing &lt;CODE&gt;make install&lt;/CODE&gt;.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;Can't locate %s in @INC&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(F)&lt;/FONT&gt; You said to do (or require, or use) a file that couldn't be found in any of the libraries mentioned in 
&lt;FONT SIZE=-1&gt;@INC.&lt;/FONT&gt; Perhaps you need to set the 
&lt;FONT SIZE=-1&gt;PERL5LIB&lt;/FONT&gt; or 
&lt;FONT SIZE=-1&gt;PERL5OPT&lt;/FONT&gt; environment variable to say where the extra library is, or maybe the script needs to add the library name to 
&lt;FONT SIZE=-1&gt;@INC.&lt;/FONT&gt; Or maybe you just misspelled the name of the file. See
 [perlfunc:require|require].

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;Can't locate object method &amp;quot;%s&amp;quot; via package &amp;quot;%s&amp;quot;&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(F)&lt;/FONT&gt; You called a method correctly, and it correctly
indicated a package functioning as a class, but that package doesn't define
that particular method, nor does any of its base classes. See [perlman:perlobj|the perlobj manpage].

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;Can't locate package %s for @%s::ISA&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(W)&lt;/FONT&gt; The &lt;CODE&gt;@ISA&lt;/CODE&gt; array contained the name of
another package that doesn't seem to exist.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;Can't make list assignment to \%ENV on this system&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(F)&lt;/FONT&gt; List assignment to &lt;CODE&gt;%ENV&lt;/CODE&gt; is not supported on some systems, notably 
&lt;FONT SIZE=-1&gt;VMS.&lt;/FONT&gt;

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;Can't modify %s in %s&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(F)&lt;/FONT&gt; You aren't allowed to assign to the item
indicated, or otherwise try to change it, such as with an auto-increment.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;Can't modify nonexistent substring&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(P)&lt;/FONT&gt; The internal routine that does assignment to a 
&lt;CODE&gt;substr()&lt;/CODE&gt; was handed a 
&lt;FONT SIZE=-1&gt;NULL.&lt;/FONT&gt;

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;Can't msgrcv to read-only var&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(F)&lt;/FONT&gt; The target of a msgrcv must be modifiable to be
used as a receive buffer.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;Can't open %s: %s&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(S)&lt;/FONT&gt; The implicit opening of a file through use of the &lt;CODE&gt;&amp;lt;&amp;gt;&lt;/CODE&gt;
filehandle, either implicitly under the &lt;CODE&gt;-n&lt;/CODE&gt; or &lt;CODE&gt;-p&lt;/CODE&gt; command-line switches, or explicitly, failed for the indicated reason.
Usually this is because you don't have read permission for a file which you
named on the command line.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;Can't open bidirectional pipe&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(W)&lt;/FONT&gt; You tried to say [perlfunc:open|open(CMD, &amp;quot;|cmd|&amp;quot;)], which is not supported. You can try any of several modules in the Perl
library to do this, such as IPC::Open2. Alternately, direct the pipe's
output to a file using ``&amp;gt;'', and then read it in under a different
file handle.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;Can't open error file %s as stderr&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(F)&lt;/FONT&gt; An error peculiar to 
&lt;FONT SIZE=-1&gt;VMS.&lt;/FONT&gt; Perl does its own command line redirection, and couldn't open the file specified after '2&amp;gt;' or '2&amp;gt;&amp;gt;' on the command line for writing.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;Can't open input file %s as stdin&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(F)&lt;/FONT&gt; An error peculiar to 
&lt;FONT SIZE=-1&gt;VMS.&lt;/FONT&gt; Perl does its own command line redirection, and couldn't open the file specified after '&amp;lt;' on the command line for reading.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;Can't open output file %s as stdout&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(F)&lt;/FONT&gt; An error peculiar to 
&lt;FONT SIZE=-1&gt;VMS.&lt;/FONT&gt; Perl does its own command line redirection, and couldn't open the file specified after '&amp;gt;' or '&amp;gt;&amp;gt;' on the command line for writing.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;Can't open output pipe (name: %s)&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(P)&lt;/FONT&gt; An error peculiar to 
&lt;FONT SIZE=-1&gt;VMS.&lt;/FONT&gt; Perl does its own command line redirection, and couldn't open the pipe into which to send data destined for stdout.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;Can't open perl script &amp;quot;%s&amp;quot;: %s&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(F)&lt;/FONT&gt; The script you specified can't be opened for the
indicated reason.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;Can't redefine active sort subroutine %s&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(F)&lt;/FONT&gt; Perl optimizes the internal handling of sort
subroutines and keeps pointers into them. You tried to redefine one such
sort subroutine when it was currently active, which is not allowed. If you
really want to do this, you should write &lt;CODE&gt;sort { &amp;amp;func } @x&lt;/CODE&gt; instead of &lt;CODE&gt;sort func @x&lt;/CODE&gt;.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;Can't rename %s to %s: %s, skipping file&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(S)&lt;/FONT&gt; The rename done by the &lt;STRONG&gt;-i&lt;/STRONG&gt; switch failed for some reason, probably because you don't have write
permission to the directory.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;Can't reopen input pipe (name: %s) in binary mode&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(P)&lt;/FONT&gt; An error peculiar to 
&lt;FONT SIZE=-1&gt;VMS.&lt;/FONT&gt; Perl thought stdin was a pipe, and tried to reopen it to accept binary data. Alas, it failed.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;Can't reswap uid and euid&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(P)&lt;/FONT&gt; The 
&lt;CODE&gt;setreuid()&lt;/CODE&gt; call failed for some reason in the setuid emulator of suidperl.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;Can't return outside a subroutine&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(F)&lt;/FONT&gt; The return statement was executed in mainline
code, that is, where there was no subroutine call to return out of. See [perlman:perlsub|the perlsub manpage].

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;Can't stat script &amp;quot;%s&amp;quot;&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(P)&lt;/FONT&gt; For some reason you can't 
&lt;CODE&gt;fstat()&lt;/CODE&gt; the script even though you have it open already. Bizarre.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;Can't swap uid and euid&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(P)&lt;/FONT&gt; The 
&lt;CODE&gt;setreuid()&lt;/CODE&gt; call failed for some reason in the setuid emulator of suidperl.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;Can't take log of %g&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(F)&lt;/FONT&gt; For ordinary real numbers, you can't take the
logarithm of a negative number or zero. There's a Math::Complex package
that comes standard with Perl, though, if you really want to do that for
the negative numbers.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;Can't take sqrt of %g&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(F)&lt;/FONT&gt; For ordinary real numbers, you can't take the
square root of a negative number. There's a Math::Complex package that
comes standard with Perl, though, if you really want to do that.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;Can't undef active subroutine&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(F)&lt;/FONT&gt; You can't undefine a routine that's currently
running. You can, however, redefine it while it's running, and you can even
undef the redefined subroutine while the old routine is running. Go figure.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;Can't unshift&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(F)&lt;/FONT&gt; You tried to unshift an ``unreal'' array that
can't be unshifted, such as the main Perl stack.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;Can't upgrade that kind of scalar&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(P)&lt;/FONT&gt; The internal sv_upgrade routine adds ``members'' to an 
&lt;FONT SIZE=-1&gt;SV,&lt;/FONT&gt; making it into a more specialized kind of 
&lt;FONT SIZE=-1&gt;SV.&lt;/FONT&gt; The top several 
&lt;FONT SIZE=-1&gt;SV&lt;/FONT&gt; types are so specialized, however, that they cannot be interconverted. This message indicates that such a conversion was attempted.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;Can't upgrade to undef&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(P)&lt;/FONT&gt; The undefined 
&lt;FONT SIZE=-1&gt;SV&lt;/FONT&gt; is the bottom of the totem pole, in the scheme of upgradability. Upgrading to undef indicates an error in the code calling sv_upgrade.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;Can't use %%! because Errno.pm is not available&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(F)&lt;/FONT&gt; The first time the %! hash is used, perl
automatically loads the Errno.pm module. The Errno module is expected to
tie the %! hash to provide symbolic names for &lt;CODE&gt;$!&lt;/CODE&gt; errno values.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;Can't use &amp;quot;my %s&amp;quot; in sort comparison&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(F)&lt;/FONT&gt; The global variables &lt;CODE&gt;$a&lt;/CODE&gt; and
&lt;CODE&gt;$b&lt;/CODE&gt; are reserved for sort comparisons. You mentioned
&lt;CODE&gt;$a&lt;/CODE&gt; or &lt;CODE&gt;$b&lt;/CODE&gt; in the same line as the &amp;lt;=&amp;gt; or
cmp operator, and the variable had earlier been declared as a lexical
variable. Either qualify the sort variable with the package name, or rename
the lexical variable.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;Can't use %s for loop variable&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(F)&lt;/FONT&gt; Only a simple scalar variable may be used as a
loop variable on a foreach.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;Can't use %s ref as %s ref&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(F)&lt;/FONT&gt; You've mixed up your reference types. You have to dereference a reference of the type needed. You can use the 
&lt;CODE&gt;ref()&lt;/CODE&gt; function to test the type of the reference, if need be.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;Can't use \1 to mean $1 in expression&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(W)&lt;/FONT&gt; In an ordinary expression, backslash is a unary operator that creates a reference to its argument. The use of backslash to indicate a backreference to a matched substring is valid only as part of a regular expression pattern. Trying to do this in ordinary Perl code produces a value that prints out looking like 
&lt;CODE&gt;SCALAR(0xdecaf).&lt;/CODE&gt; Use the &lt;CODE&gt;$1&lt;/CODE&gt; form instead.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;Can't use bareword (&amp;quot;%s&amp;quot;) as %s ref while \&amp;quot;strict refs\&amp;quot; in use&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(F)&lt;/FONT&gt; Only hard references are allowed by ``strict
refs''. Symbolic references are disallowed. See [perlman:perlref|the perlref manpage].

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;Can't use string (&amp;quot;%s&amp;quot;) as %s ref while &amp;quot;strict refs&amp;quot; in use&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(F)&lt;/FONT&gt; Only hard references are allowed by ``strict
refs''. Symbolic references are disallowed. See [perlman:perlref|the perlref manpage].

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;Can't use an undefined value as %s reference&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(F)&lt;/FONT&gt; 
&lt;FONT SIZE=-1&gt;A&lt;/FONT&gt; value used as either a hard reference or a symbolic reference must be a defined value. This helps to delurk some insidious errors.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;Can't use global %s in &amp;quot;my&amp;quot;&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(F)&lt;/FONT&gt; You tried to declare a magical variable as a
lexical variable. This is not allowed, because the magic can be tied to
only one location (namely the global variable) and it would be incredibly
confusing to have variables in your program that looked like magical
variables but weren't.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;Can't use subscript on %s&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(F)&lt;/FONT&gt; The compiler tried to interpret a bracketed
expression as a subscript. But to the left of the brackets was an
expression that didn't look like an array reference, or anything else
subscriptable.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;Can't x= to read-only value&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(F)&lt;/FONT&gt; You tried to repeat a constant value (often the
undefined value) with an assignment operator, which implies modifying the
value itself. Perhaps you need to copy the value to a temporary, and repeat
that.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;&lt;A NAME="item_Cannot"&gt;Cannot find an opnumber for &amp;quot;%s&amp;quot;&lt;/A&gt;&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(F)&lt;/FONT&gt; 
&lt;FONT SIZE=-1&gt;A&lt;/FONT&gt; string of a form &lt;CODE&gt;CORE::word&lt;/CODE&gt; was given to 
&lt;CODE&gt;prototype(),&lt;/CODE&gt; but there is
no builtin with the name &lt;CODE&gt;word&lt;/CODE&gt;.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;Cannot resolve method `%s' overloading `%s' in package `%s'&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(F|P)&lt;/FONT&gt; Error resolving overloading specified by a
method name (as opposed to a subroutine reference): no such method callable
via the package. If method name is &lt;CODE&gt;???&lt;/CODE&gt;, this is an internal error.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;&lt;A NAME="item_Character"&gt;Character class syntax &amp;#091;. .&amp;#093; is reserved for future extensions&lt;/A&gt;&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(W)&lt;/FONT&gt; Within regular expression character classes (&amp;#091;&amp;#093;)
the syntax beginning with ``&amp;#091;.'' and ending with ``.&amp;#093;'' is reserved for
future extensions. If you need to represent those character sequences
inside a regular expression character class, just quote the square brackets
with the backslash: ``\&amp;#091;.'' and ``.\&amp;#093;''.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;Character class syntax &amp;#091;: :&amp;#093; is reserved for future extensions&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(W)&lt;/FONT&gt; Within regular expression character classes (&amp;#091;&amp;#093;)
the syntax beginning with ``&amp;#091;:'' and ending with ``:&amp;#093;'' is reserved for
future extensions. If you need to represent those character sequences
inside a regular expression character class, just quote the square brackets
with the backslash: ``\&amp;#091;:'' and ``:\&amp;#093;''.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;Character class syntax &amp;#091;= =&amp;#093; is reserved for future extensions&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(W)&lt;/FONT&gt; Within regular expression character classes (&amp;#091;&amp;#093;)
the syntax beginning with ``&amp;#091;='' and ending with ``=&amp;#093;'' is reserved for
future extensions. If you need to represent those character sequences
inside a regular expression character class, just quote the square brackets
with the backslash: ``\&amp;#091;='' and ``=\&amp;#093;''.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;&lt;A NAME="item_chmod"&gt;chmod: mode argument is missing initial 0&lt;/A&gt;&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(W)&lt;/FONT&gt; 
&lt;FONT SIZE=-1&gt;A&lt;/FONT&gt; novice will sometimes say

&lt;P&gt;
&lt;PRE&gt;    chmod 777, $filename
&lt;/PRE&gt;
&lt;P&gt;
not realizing that 777 will be interpreted as a decimal number, equivalent to 01411. Octal constants are introduced with a leading 0 in Perl, as in 
&lt;FONT SIZE=-1&gt;C.&lt;/FONT&gt;

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;&lt;A NAME="item_Close"&gt;Close on unopened file lt%sgt&lt;/A&gt;&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(W)&lt;/FONT&gt; You tried to close a filehandle that was never
opened.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;&lt;A NAME="item_Compilation"&gt;Compilation failed in require&lt;/A&gt;&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(F)&lt;/FONT&gt; Perl could not compile a file specified in a [perlfunc:require|require] statement. Perl uses this generic message when none of the errors that it
encountered were severe enough to halt compilation immediately.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;&lt;A NAME="item_Complex"&gt;Complex regular subexpression recursion limit (%d) exceeded&lt;/A&gt;&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(W)&lt;/FONT&gt; The regular expression engine uses recursion in
complex situations where back-tracking is required. Recursion depth is
limited to 32766, or perhaps less in architectures where the stack cannot
grow arbitrarily. (``Simple'' and ``medium'' situations are handled without
recursion and are not subject to a limit.) Try shortening the string under
examination; looping in Perl code (e.g. with &lt;CODE&gt;while&lt;/CODE&gt;) rather than in the regular expression engine; or rewriting the regular
expression so that it is simpler or backtracks less. (See [perlman:perlbook|the perlbook manpage]
for information on &lt;EM&gt;Mastering Regular Expressions&lt;/EM&gt;.)

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;&lt;A NAME="item_connect"&gt;connect() on closed fd&lt;/A&gt;&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(W)&lt;/FONT&gt; You tried to do a connect on a closed socket. Did you forget to check the return value of your 
&lt;CODE&gt;socket()&lt;/CODE&gt; call? See
 [perlfunc:connect|connect].

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;&lt;A NAME="item_Constant"&gt;Constant subroutine %s redefined&lt;/A&gt;&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(S)&lt;/FONT&gt; You redefined a subroutine which had previously
been eligible for inlining. See [perlman:perlsub] for commentary and workarounds.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;Constant subroutine %s undefined&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(S)&lt;/FONT&gt; You undefined a subroutine which had previously
been eligible for inlining. See [perlman:perlsub] for commentary and workarounds.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;&lt;A NAME="item_Copy"&gt;Copy method did not return a reference&lt;/A&gt;&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(F)&lt;/FONT&gt; The method which overloads ``='' is buggy. See &lt;U&gt;Copy Constructor&lt;/U&gt;.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;&lt;A NAME="item_Corrupt"&gt;Corrupt malloc ptr 0x%lx at 0x%lx&lt;/A&gt;&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(P)&lt;/FONT&gt; The malloc package that comes with Perl had an
internal failure.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;&lt;A NAME="item_corrupted"&gt;corrupted regexp pointers&lt;/A&gt;&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(P)&lt;/FONT&gt; The regular expression engine got confused by what
the regular expression compiler gave it.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;corrupted regexp program&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(P)&lt;/FONT&gt; The regular expression engine got passed a regexp
program without a valid magic number.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;&lt;A NAME="item_Deep"&gt;Deep recursion on subroutine &amp;quot;%s&amp;quot;&lt;/A&gt;&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(W)&lt;/FONT&gt; This subroutine has called itself (directly or
indirectly) 100 times more than it has returned. This probably indicates an
infinite recursion, unless you're writing strange benchmark programs, in
which case it indicates something else.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;&lt;A NAME="item_Delimiter"&gt;Delimiter for here document is too long&lt;/A&gt;&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(F)&lt;/FONT&gt; In a here document construct like &lt;CODE&gt;&amp;lt;&amp;lt;FOO&lt;/CODE&gt;, the label
&lt;CODE&gt;FOO&lt;/CODE&gt; is too long for Perl to handle. You have to be seriously twisted to write
code that triggers this error.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;&lt;A NAME="item_Did"&gt;Did you mean &amp;amp;%s instead?&lt;/A&gt;&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(W)&lt;/FONT&gt; You probably referred to an imported subroutine
&lt;CODE&gt;&amp;amp;FOO&lt;/CODE&gt; as &lt;CODE&gt;$FOO&lt;/CODE&gt; or some such.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;Did you mean $ or @ instead of %?&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(W)&lt;/FONT&gt; You probably said %hash{$key} when you meant
$hash{$key} or @hash{@keys}. On the other hand, maybe you just meant
&lt;CODE&gt;%hash&lt;/CODE&gt; and got carried away.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;&lt;A NAME="item_Died"&gt;Died&lt;/A&gt;&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(F)&lt;/FONT&gt; You passed 
&lt;CODE&gt;die()&lt;/CODE&gt; an empty string (the equivalent of
 [perlfunc:die]) or you called it with no args and both &lt;CODE&gt;$@&lt;/CODE&gt; and &lt;CODE&gt;$_&lt;/CODE&gt; were empty.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;&lt;A NAME="item_Do"&gt;Do you need to predeclare %s?&lt;/A&gt;&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(S)&lt;/FONT&gt; This is an educated guess made in conjunction with the message ``%s found where operator expected''. It often means a subroutine or module name is being referenced that hasn't been declared yet. This may be because of ordering problems in your file, or because of a missing ``sub'', ``package'', ``require'', or ``use'' statement. If you're referencing something that isn't defined yet, you don't actually have to define the subroutine or package before the current location. You can use an empty ``sub foo;'' or ``package 
&lt;FONT SIZE=-1&gt;FOO;''&lt;/FONT&gt; to enter a ``forward'' declaration.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;&lt;A NAME="item_Don"&gt;Don't know how to handle magic of type '%s'&lt;/A&gt;&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(P)&lt;/FONT&gt; The internal handling of magical variables has
been cursed.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;&lt;A NAME="item_do_study"&gt;do_study: out of memory&lt;/A&gt;&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(P)&lt;/FONT&gt; This should have been caught by 
&lt;CODE&gt;safemalloc()&lt;/CODE&gt; instead.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;&lt;A NAME="item_Duplicate"&gt;Duplicate free() ignored&lt;/A&gt;&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(S)&lt;/FONT&gt; An internal routine called 
&lt;CODE&gt;free()&lt;/CODE&gt; on something that had already been freed.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;&lt;A NAME="item_elseif"&gt;elseif should be elsif&lt;/A&gt;&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(S)&lt;/FONT&gt; There is no keyword ``elseif'' in Perl because
Larry thinks it's ugly. Your code will be interpreted as an attempt to call
a method named ``elseif'' for the class returned by the following block.
This is unlikely to be what you want.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;&lt;A NAME="item_END"&gt;END failed--cleanup aborted&lt;/A&gt;&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(F)&lt;/FONT&gt; An untrapped exception was raised while executing an 
&lt;FONT SIZE=-1&gt;END&lt;/FONT&gt; subroutine. The interpreter is immediately exited.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;&lt;A NAME="item_Error"&gt;Error converting file specification %s&lt;/A&gt;&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(F)&lt;/FONT&gt; An error peculiar to 
&lt;FONT SIZE=-1&gt;VMS.&lt;/FONT&gt; Because Perl may have to deal with file specifications in either 
&lt;FONT SIZE=-1&gt;VMS&lt;/FONT&gt; or Unix syntax, it converts them to a single form when it must operate on them directly. Either you've passed an invalid file specification to Perl, or you've found a case the conversion routines don't handle. Drat.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;%s: Eval-group in insecure regular expression&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(F)&lt;/FONT&gt; Perl detected tainted data when trying to compile
a regular expression that contains the &lt;CODE&gt;(?{ ... })&lt;/CODE&gt; zero-width assertion, which is unsafe. See [perlman:perlre], and [perlman:perlsec|the perlsec manpage].

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;%s: Eval-group not allowed, use re 'eval'&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(F)&lt;/FONT&gt; 
&lt;FONT SIZE=-1&gt;A&lt;/FONT&gt; regular expression contained the
 &lt;CODE&gt;(?{ ... })&lt;/CODE&gt; zero-width assertion, but that construct is only allowed when the &lt;CODE&gt;use re 'eval'&lt;/CODE&gt; pragma is in effect. See [perlman:perlre].

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;%s: Eval-group not allowed at run time&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(F)&lt;/FONT&gt; Perl tried to compile a regular expression
containing the &lt;CODE&gt;(?{ ... })&lt;/CODE&gt;
zero-width assertion at run time, as it would when the pattern contains interpolated values. Since that is a security risk, it is not allowed. If you insist, you may still do this by explicitly building the pattern from an interpolated string at run time and using that in an 
&lt;CODE&gt;eval().&lt;/CODE&gt; See
 [perlman:perlre].

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;&lt;A NAME="item_Excessively"&gt;Excessively long &amp;lt;&amp;gt; operator&lt;/A&gt;&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(F)&lt;/FONT&gt; The contents of a &amp;lt;&amp;gt; operator may not exceed the maximum size of a Perl identifier. If you're just trying to glob a long list of filenames, try using the 
&lt;CODE&gt;glob()&lt;/CODE&gt; operator, or put the filenames into a variable and glob that.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;&lt;A NAME="item_Execution"&gt;Execution of %s aborted due to compilation errors&lt;/A&gt;&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(F)&lt;/FONT&gt; The final summary message when a Perl compilation
fails.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;&lt;A NAME="item_Exiting"&gt;Exiting eval via %s&lt;/A&gt;&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(W)&lt;/FONT&gt; You are exiting an eval by unconventional means,
such as a goto, or a loop control statement.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;Exiting pseudo-block via %s&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(W)&lt;/FONT&gt; You are exiting a rather special block construct
(like a sort block or subroutine) by unconventional means, such as a goto,
or a loop control statement. See [perlfunc:sort|sort].

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;Exiting subroutine via %s&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(W)&lt;/FONT&gt; You are exiting a subroutine by unconventional
means, such as a goto, or a loop control statement.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;Exiting substitution via %s&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(W)&lt;/FONT&gt; You are exiting a substitution by unconventional
means, such as a return, a goto, or a loop control statement.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;&lt;A NAME="item_Explicit"&gt;Explicit blessing to '' (assuming package main)&lt;/A&gt;&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(W)&lt;/FONT&gt; You are blessing a reference to a zero length string. This has the effect of blessing the reference into the package main. This is usually not what you want. Consider providing a default target package, e.g. 
&lt;CODE&gt;bless($ref,&lt;/CODE&gt; &lt;CODE&gt;$p&lt;/CODE&gt; or 'MyPackage');

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;&lt;A NAME="item_Fatal"&gt;Fatal VMS error at %s, line %d&lt;/A&gt;&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(P)&lt;/FONT&gt; An error peculiar to 
&lt;FONT SIZE=-1&gt;VMS.&lt;/FONT&gt; Something untoward happened in a 
&lt;FONT SIZE=-1&gt;VMS&lt;/FONT&gt; system service or 
&lt;FONT SIZE=-1&gt;RTL&lt;/FONT&gt; routine; Perl's exit status should provide more details. The filename in ``at %s'' and the line number in ``line %d'' tell you which section of the Perl source code is distressed.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;&lt;A NAME="item_fcntl"&gt;fcntl is not implemented&lt;/A&gt;&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(F)&lt;/FONT&gt; Your machine apparently doesn't implement 
&lt;CODE&gt;fcntl().&lt;/CODE&gt; What is this, a 
&lt;FONT SIZE=-1&gt;PDP-11&lt;/FONT&gt; or something?

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;&lt;A NAME="item_Filehandle"&gt;Filehandle %s never opened&lt;/A&gt;&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(W)&lt;/FONT&gt; An 
&lt;FONT SIZE=-1&gt;I/O&lt;/FONT&gt; operation was attempted on a filehandle that was never initialized. You need to do an 
&lt;CODE&gt;open()&lt;/CODE&gt; or a 
&lt;CODE&gt;socket()&lt;/CODE&gt; call, or call a constructor from the FileHandle package.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;Filehandle %s opened for only input&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(W)&lt;/FONT&gt; You tried to write on a read-only filehandle. If
you intended it to be a read-write filehandle, you needed to open it with
``+&amp;lt;'' or ``+&amp;gt;'' or ``+&amp;gt;&amp;gt;'' instead of with ``&amp;lt;'' or
nothing. If you intended only to write the file, use ``&amp;gt;'' or
``&amp;gt;&amp;gt;''. See
[perlfunc:open|open].

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;Filehandle opened for only input&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(W)&lt;/FONT&gt; You tried to write on a read-only filehandle. If
you intended it to be a read-write filehandle, you needed to open it with
``+&amp;lt;'' or ``+&amp;gt;'' or ``+&amp;gt;&amp;gt;'' instead of with ``&amp;lt;'' or
nothing. If you intended only to write the file, use ``&amp;gt;'' or
``&amp;gt;&amp;gt;''. See
[perlfunc:open|open].

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;&lt;A NAME="item_Final"&gt;Final $ should be \$ or $name&lt;/A&gt;&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(F)&lt;/FONT&gt; You must now decide whether the final $ in a
string was meant to be a literal dollar sign, or was meant to introduce a
variable name that happens to be missing. So you have to put either the
backslash or the name.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;Final @ should be \@ or @name&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(F)&lt;/FONT&gt; You must now decide whether the final @ in a
string was meant to be a literal ``at'' sign, or was meant to introduce a
variable name that happens to be missing. So you have to put either the
backslash or the name.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;&lt;A NAME="item_Format"&gt;Format %s redefined&lt;/A&gt;&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(W)&lt;/FONT&gt; You redefined a format. To suppress this warning,
say

&lt;P&gt;
&lt;PRE&gt;    {
        local $^W = 0;
        eval &amp;quot;format NAME =...&amp;quot;;
    }
&lt;/PRE&gt;
&lt;DT&gt;&lt;STRONG&gt;Format not terminated&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(F)&lt;/FONT&gt; 
&lt;FONT SIZE=-1&gt;A&lt;/FONT&gt; format must be terminated by a line with a solitary dot. Perl got to the end of your file without finding such a line.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;&lt;A NAME="item_Found"&gt;Found = in conditional, should be ==&lt;/A&gt;&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(W)&lt;/FONT&gt; You said

&lt;P&gt;
&lt;PRE&gt;    if ($foo = 123)
&lt;/PRE&gt;
&lt;P&gt;
when you meant

&lt;P&gt;
&lt;PRE&gt;    if ($foo == 123)
&lt;/PRE&gt;
&lt;P&gt;
(or something like that).

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;&lt;A NAME="item_gdbm"&gt;gdbm store returned %d, errno %d, key &amp;quot;%s&amp;quot;&lt;/A&gt;&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(S)&lt;/FONT&gt; 
&lt;FONT SIZE=-1&gt;A&lt;/FONT&gt; warning from the GDBM_File extension that a store failed.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;&lt;A NAME="item_gethostent"&gt;gethostent not implemented&lt;/A&gt;&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(F)&lt;/FONT&gt; Your 
&lt;FONT SIZE=-1&gt;C&lt;/FONT&gt; library apparently doesn't implement 
&lt;CODE&gt;gethostent(),&lt;/CODE&gt; probably because if it did, it'd feel morally obligated to return every hostname on the Internet.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;&lt;A NAME="item_get"&gt;get{sock,peer}name() on closed fd&lt;/A&gt;&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(W)&lt;/FONT&gt; You tried to get a socket or peer socket name on a closed socket. Did you forget to check the return value of your 
&lt;CODE&gt;socket()&lt;/CODE&gt; call?

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;&lt;A NAME="item_getpwnam"&gt;getpwnam returned invalid UIC %#o for user &amp;quot;%s&amp;quot;&lt;/A&gt;&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(S)&lt;/FONT&gt; 
&lt;FONT SIZE=-1&gt;A&lt;/FONT&gt; warning peculiar to 
&lt;FONT SIZE=-1&gt;VMS.&lt;/FONT&gt; The call to
 &lt;CODE&gt;sys$getuai&lt;/CODE&gt; underlying the
[perlfunc:getpwnam|getpwnam] operator returned an invalid 
&lt;FONT SIZE=-1&gt;UIC.&lt;/FONT&gt;

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;&lt;A NAME="item_Glob"&gt;Glob not terminated&lt;/A&gt;&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(F)&lt;/FONT&gt; The lexer saw a left angle bracket in a place
where it was expecting a term, so it's looking for the corresponding right
angle bracket, and not finding it. Chances are you left some needed
parentheses out earlier in the line, and you really meant a ``less than''.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;&lt;A NAME="item_Global"&gt;Global symbol &amp;quot;%s&amp;quot; requires explicit package name&lt;/A&gt;&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(F)&lt;/FONT&gt; You've said ``use strict vars'', which indicates
that all variables must either be lexically scoped (using ``my''), or
explicitly qualified to say which package the global variable is in (using
``::'').

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;&lt;A NAME="item_goto"&gt;goto must have label&lt;/A&gt;&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(F)&lt;/FONT&gt; Unlike with ``next'' or ``last'', you're not
allowed to goto an unspecified destination. See [perlfunc:goto|goto].

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;&lt;A NAME="item_Had"&gt;Had to create %s unexpectedly&lt;/A&gt;&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(S)&lt;/FONT&gt; 
&lt;FONT SIZE=-1&gt;A&lt;/FONT&gt; routine asked for a symbol from a symbol table that ought to have existed already, but for some reason it didn't, and had to be created on an emergency basis to prevent a core dump.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;&lt;A NAME="item_Hash"&gt;Hash %%s missing the % in argument %d of %s()&lt;/A&gt;&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(D)&lt;/FONT&gt; Really old Perl let you omit the % on hash names
in some spots. This is now heavily deprecated.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;&lt;A NAME="item_Identifier"&gt;Identifier too long&lt;/A&gt;&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(F)&lt;/FONT&gt; Perl limits identifiers (names for variables,
functions, etc.) to about 250 characters for simple names, and somewhat
more for compound names (like &lt;CODE&gt;$A::B&lt;/CODE&gt;). You've exceeded Perl's limits. Future versions of Perl are likely to
eliminate these arbitrary limitations.
&lt;DD&gt;
&lt;/DL&gt;
&lt;BR&gt;
[perlman:perldiag2|More...]&lt;BR&gt;
&lt;BR&gt;Return to the [Library]&lt;BR&gt;</field>
</data>
</node>
