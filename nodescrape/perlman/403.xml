<?xml version="1.0" encoding="windows-1252"?>
<node id="403" title="perlman:perlvar" created="1999-08-25 02:43:38" updated="2005-08-15 12:30:21">
<type id="116">
perlman</type>
<author id="114">
gods</author>
<data>
<field name="doctext">


&lt;HR&gt;
&lt;P&gt;
&lt;H1&gt;&lt;A NAME="NAME"&gt;NAME&lt;/A&gt;&lt;/H1&gt;
&lt;P&gt;
perlvar - Perl predefined variables

&lt;P&gt;
&lt;HR&gt;
&lt;H1&gt;&lt;A NAME="DESCRIPTION"&gt;DESCRIPTION&lt;/A&gt;&lt;/H1&gt;
&lt;P&gt;
&lt;HR&gt;
&lt;H2&gt;&lt;A NAME="Predefined_Names"&gt;Predefined Names&lt;/A&gt;&lt;/H2&gt;
&lt;P&gt;
The following names have special meaning to Perl. Most punctuation names
have reasonable mnemonics, or analogues in one of the shells. Nevertheless,
if you wish to use long variable names, you just need to say

&lt;P&gt;
&lt;PRE&gt;    use English;
&lt;/PRE&gt;
&lt;P&gt;
at the top of your program. This will alias all the short names to the long
names in the current package. Some even have medium names, generally
borrowed from &lt;STRONG&gt;awk&lt;/STRONG&gt;.

&lt;P&gt;
To go a step further, those variables that depend on the currently selected filehandle may instead (and preferably) be set by calling an object method on the FileHandle object. (Summary lines below for this contain the word 
&lt;FONT SIZE=-1&gt;HANDLE.)&lt;/FONT&gt; First you must say

&lt;P&gt;
&lt;PRE&gt;    use FileHandle;
&lt;/PRE&gt;
&lt;P&gt;
after which you may use either

&lt;P&gt;
&lt;PRE&gt;    method HANDLE EXPR
&lt;/PRE&gt;
&lt;P&gt;
or more safely,

&lt;P&gt;
&lt;PRE&gt;    HANDLE-&amp;gt;method(EXPR)
&lt;/PRE&gt;
&lt;P&gt;
Each of the methods returns the old value of the FileHandle attribute. The methods each take an optional 
&lt;FONT SIZE=-1&gt;EXPR,&lt;/FONT&gt; which if supplied specifies the new value for the FileHandle attribute in question. If not supplied, most of the methods do nothing to the current value, except for 
&lt;CODE&gt;autoflush(),&lt;/CODE&gt; which will assume a 1 for you, just to be different.

&lt;P&gt;

&lt;FONT SIZE=-1&gt;A&lt;/FONT&gt; few of these variables are considered ``read-only''.
This means that if you try to assign to this variable, either directly or
indirectly through a reference, you'll raise a run-time exception.

&lt;P&gt;
The following list is ordered by scalar variables first, then the arrays, then the hashes (except 
&lt;FONT SIZE=-1&gt;$^M&lt;/FONT&gt; was added in the wrong place). This is somewhat obscured by the fact that &lt;CODE&gt;%ENV&lt;/CODE&gt; and &lt;CODE&gt;%SIG&lt;/CODE&gt; are listed as $ENV{expr} and $SIG{expr}.

&lt;DL&gt;
&lt;DT&gt;&lt;STRONG&gt;&lt;A NAME="item__ARG"&gt;$ARG&lt;/A&gt;&lt;/STRONG&gt;&lt;DD&gt;
&lt;DT&gt;&lt;STRONG&gt;&lt;A NAME="item__"&gt;$_&lt;/A&gt;&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;
The default input and pattern-searching space. The following pairs are
equivalent:

&lt;P&gt;
&lt;PRE&gt;    while (&amp;lt;&amp;gt;) {...}    # equivalent in only while!
    while (defined($_ = &amp;lt;&amp;gt;)) {...}
&lt;/PRE&gt;
&lt;P&gt;
&lt;PRE&gt;    /^Subject:/
    $_ =~ /^Subject:/
&lt;/PRE&gt;
&lt;P&gt;
&lt;PRE&gt;    tr/a-z/A-Z/
    $_ =~ tr/a-z/A-Z/
&lt;/PRE&gt;
&lt;P&gt;
&lt;PRE&gt;    chop
    chop($_)
&lt;/PRE&gt;
&lt;P&gt;
Here are the places where Perl will assume &lt;CODE&gt;$_&lt;/CODE&gt; even if you
don't use it:

&lt;UL&gt;
&lt;LI&gt;
&lt;P&gt;
Various unary functions, including functions like 
&lt;CODE&gt;ord()&lt;/CODE&gt; and 
&lt;CODE&gt;int(),&lt;/CODE&gt; as well as the all file tests (
&lt;CODE&gt;-f&lt;/CODE&gt;, &lt;CODE&gt;-d&lt;/CODE&gt;) except for &lt;CODE&gt;-t&lt;/CODE&gt;, which defaults to 
&lt;FONT SIZE=-1&gt;STDIN.&lt;/FONT&gt;

&lt;P&gt;&lt;LI&gt;

Various list functions like 
&lt;CODE&gt;print()&lt;/CODE&gt; and 
&lt;CODE&gt;unlink().&lt;/CODE&gt;

&lt;P&gt;&lt;LI&gt;

The pattern matching operations [perlman:perlop], [perlman:perlop], and [perlman:perlop] when used without an &lt;CODE&gt;=~&lt;/CODE&gt; operator.

&lt;P&gt;&lt;LI&gt;

The default iterator variable in a &lt;CODE&gt;foreach&lt;/CODE&gt; loop if no other variable is supplied.

&lt;P&gt;&lt;LI&gt;

The implicit iterator variable in the 
&lt;CODE&gt;grep()&lt;/CODE&gt; and 
&lt;CODE&gt;map()&lt;/CODE&gt; functions.

&lt;P&gt;&lt;LI&gt;

The default place to put an input record when a &lt;CODE&gt;&amp;lt;FH&amp;gt;&lt;/CODE&gt;
operation's result is tested by itself as the sole criterion of a &lt;CODE&gt;while&lt;/CODE&gt;
test. Note that outside of a &lt;CODE&gt;while&lt;/CODE&gt; test, this will not happen.

&lt;/UL&gt;
&lt;P&gt;
(Mnemonic: underline is understood in certain operations.)

&lt;/DL&gt;
&lt;DL&gt;
&lt;DT&gt;&lt;STRONG&gt;&lt;A NAME="item__ltdigitsgt"&gt;$ltdigitsgt&lt;/A&gt;&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;
Contains the subpattern from the corresponding set of parentheses in the
last pattern matched, not counting patterns matched in nested blocks that
have been exited already. (Mnemonic: like \digits.) These variables are all
read-only.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;&lt;A NAME="item__MATCH"&gt;$MATCH&lt;/A&gt;&lt;/STRONG&gt;&lt;DD&gt;
&lt;DT&gt;&lt;STRONG&gt;&lt;A NAME="item__amp_"&gt;$&amp;amp;&lt;/A&gt;&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;
The string matched by the last successful pattern match (not counting any matches hidden within a 
&lt;FONT SIZE=-1&gt;BLOCK&lt;/FONT&gt; or 
&lt;CODE&gt;eval()&lt;/CODE&gt; enclosed by the current 
&lt;FONT SIZE=-1&gt;BLOCK).&lt;/FONT&gt; (Mnemonic: like &amp;amp; in some editors.) This variable is read-only.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;&lt;A NAME="item__PREMATCH"&gt;$PREMATCH&lt;/A&gt;&lt;/STRONG&gt;&lt;DD&gt;
&lt;DT&gt;&lt;STRONG&gt;&lt;A NAME="item__"&gt;$`&lt;/A&gt;&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;
The string preceding whatever was matched by the last successful pattern match (not counting any matches hidden within a 
&lt;FONT SIZE=-1&gt;BLOCK&lt;/FONT&gt; or eval enclosed by the current 
&lt;FONT SIZE=-1&gt;BLOCK).&lt;/FONT&gt; (Mnemonic:
 &lt;CODE&gt;`&lt;/CODE&gt; often precedes a quoted string.) This variable is read-only.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;&lt;A NAME="item__POSTMATCH"&gt;$POSTMATCH&lt;/A&gt;&lt;/STRONG&gt;&lt;DD&gt;
&lt;DT&gt;&lt;STRONG&gt;&lt;A NAME="item__"&gt;$'&lt;/A&gt;&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;
The string following whatever was matched by the last successful pattern match (not counting any matches hidden within a 
&lt;FONT SIZE=-1&gt;BLOCK&lt;/FONT&gt; or 
&lt;CODE&gt;eval()&lt;/CODE&gt; enclosed by the current 
&lt;FONT SIZE=-1&gt;BLOCK).&lt;/FONT&gt; (Mnemonic:
 &lt;CODE&gt;'&lt;/CODE&gt; often follows a quoted string.) Example:

&lt;P&gt;
&lt;PRE&gt;    $_ = 'abcdefghi';
    /def/;
    print &amp;quot;$`:$&amp;amp;:$'\n&amp;quot;;         # prints abc:def:ghi
&lt;/PRE&gt;
&lt;P&gt;
This variable is read-only.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;&lt;A NAME="item__LAST_PAREN_MATCH"&gt;$LAST_PAREN_MATCH&lt;/A&gt;&lt;/STRONG&gt;&lt;DD&gt;
&lt;DT&gt;&lt;STRONG&gt;&lt;A NAME="item__"&gt;$+&lt;/A&gt;&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;
The last bracket matched by the last search pattern. This is useful if you
don't know which of a set of alternative patterns matched. For example:

&lt;P&gt;
&lt;PRE&gt;    /Version: (.*)|Revision: (.*)/ &amp;amp;&amp;amp; ($rev = $+);
&lt;/PRE&gt;
&lt;P&gt;
(Mnemonic: be positive and forward looking.) This variable is read-only.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;&lt;A NAME="item__MULTILINE_MATCHING"&gt;$MULTILINE_MATCHING&lt;/A&gt;&lt;/STRONG&gt;&lt;DD&gt;
&lt;DT&gt;&lt;STRONG&gt;&lt;A NAME="item__"&gt;$*&lt;/A&gt;&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;
Set to 1 to do multi-line matching within a string, 0 to tell Perl that it
can assume that strings contain a single line, for the purpose of
optimizing pattern matches. Pattern matches on strings containing multiple
newlines can produce confusing results when ``&lt;CODE&gt;$*&lt;/CODE&gt;'' is 0. Default is 0. (Mnemonic: * matches multiple things.) Note that
this variable influences the interpretation of only ``&lt;CODE&gt;^&lt;/CODE&gt;'' and ``&lt;CODE&gt;$&lt;/CODE&gt;''. 
&lt;FONT SIZE=-1&gt;A&lt;/FONT&gt; literal newline can be searched for even when &lt;CODE&gt;$* == 0&lt;/CODE&gt;.

&lt;P&gt;
Use of ``&lt;CODE&gt;$*&lt;/CODE&gt;'' is deprecated in modern Perls, supplanted by the [perlman:perlop] and [perlman:perlop] modifiers on pattern matching.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;&lt;A NAME="item_input_line_number"&gt;input_line_number HANDLE EXPR&lt;/A&gt;&lt;/STRONG&gt;&lt;DD&gt;
&lt;DT&gt;&lt;STRONG&gt;&lt;A NAME="item__INPUT_LINE_NUMBER"&gt;$INPUT_LINE_NUMBER&lt;/A&gt;&lt;/STRONG&gt;&lt;DD&gt;
&lt;DT&gt;&lt;STRONG&gt;&lt;A NAME="item__NR"&gt;$NR&lt;/A&gt;&lt;/STRONG&gt;&lt;DD&gt;
&lt;DT&gt;&lt;STRONG&gt;&lt;A NAME="item__"&gt;$.&lt;/A&gt;&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;
The current input line number for the last file handle from which you read
(or performed a [perlfunc:seek|seek] or [perlfunc:tell|tell] on). An explicit close on a filehandle resets the line number. Because ``&lt;CODE&gt;&amp;lt;&amp;gt;&lt;/CODE&gt;'' never does an explicit close, line numbers increase across 
&lt;FONT SIZE=-1&gt;ARGV&lt;/FONT&gt; files (but see examples under 
&lt;CODE&gt;eof()).&lt;/CODE&gt; Localizing
 &lt;CODE&gt;$.&lt;/CODE&gt; has the effect of also localizing Perl's notion of ``the last read
filehandle''. (Mnemonic: many programs use ``.'' to mean the current line
number.)

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;&lt;A NAME="item_input_record_separator"&gt;input_record_separator HANDLE EXPR&lt;/A&gt;&lt;/STRONG&gt;&lt;DD&gt;
&lt;DT&gt;&lt;STRONG&gt;&lt;A NAME="item__INPUT_RECORD_SEPARATOR"&gt;$INPUT_RECORD_SEPARATOR&lt;/A&gt;&lt;/STRONG&gt;&lt;DD&gt;
&lt;DT&gt;&lt;STRONG&gt;&lt;A NAME="item__RS"&gt;$RS&lt;/A&gt;&lt;/STRONG&gt;&lt;DD&gt;
&lt;DT&gt;&lt;STRONG&gt;&lt;A NAME="item__"&gt;$/&lt;/A&gt;&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;
The input record separator, newline by default. Works like &lt;STRONG&gt;awk&lt;/STRONG&gt;'s 
&lt;FONT SIZE=-1&gt;RS&lt;/FONT&gt; variable, including treating empty lines as
delimiters if set to the null string. (Note: An empty line cannot contain
any spaces or tabs.) You may set it to a multi-character string to match a
multi-character delimiter, or to [perlfunc:undef|undef] to read to end of file. Note that setting it to &lt;CODE&gt;&amp;quot;\n\n&amp;quot;&lt;/CODE&gt; means something slightly different than setting it to
&lt;CODE&gt;&amp;quot;&amp;quot;&lt;/CODE&gt;, if the file contains consecutive empty lines. Setting it to
&lt;CODE&gt;&amp;quot;&amp;quot;&lt;/CODE&gt; will treat two or more consecutive empty lines as a single empty line.
Setting it to &lt;CODE&gt;&amp;quot;\n\n&amp;quot;&lt;/CODE&gt; will blindly assume that the next input character belongs to the next
paragraph, even if it's a newline. (Mnemonic: / is used to delimit line
boundaries when quoting poetry.)

&lt;P&gt;
&lt;PRE&gt;    undef $/;
    $_ = &amp;lt;FH&amp;gt;;          # whole file now here
    s/\n&amp;#091; \t&amp;#093;+/ /g;
&lt;/PRE&gt;
&lt;P&gt;
Remember: the value of $/ is a string, not a regexp. 
&lt;FONT SIZE=-1&gt;AWK&lt;/FONT&gt; has to be better for something :-)

&lt;P&gt;
Setting $/ to a reference to an integer, scalar containing an integer, or
scalar that's convertable to an integer will attempt to read records
instead of lines, with the maximum record size being the referenced
integer. So this:

&lt;P&gt;
&lt;PRE&gt;    $/ = \32768; # or \&amp;quot;32768&amp;quot;, or \$var_containing_32768
    open(FILE, $myfile);
    $_ = &amp;lt;FILE&amp;gt;;
&lt;/PRE&gt;
&lt;P&gt;
will read a record of no more than 32768 bytes from 
&lt;FONT SIZE=-1&gt;FILE.&lt;/FONT&gt; If you're not reading from a record-oriented file (or your 
&lt;FONT SIZE=-1&gt;OS&lt;/FONT&gt; doesn't have record-oriented files), then you'll likely get a full chunk of data with every read. If a record is larger than the record size you've set, you'll get the record back in pieces.

&lt;P&gt;
On 
&lt;FONT SIZE=-1&gt;VMS,&lt;/FONT&gt; record reads are done with the equivalent of [perlfunc:sysread|sysread], so it's best not to mix record and non-record reads on the same file. (This is likely not a problem, as any file you'd want to read in record mode is proably usable in line mode) Non-VMS systems perform normal 
&lt;FONT SIZE=-1&gt;I/O,&lt;/FONT&gt; so it's safe to mix record and non-record reads of a file.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;&lt;A NAME="item_autoflush"&gt;autoflush HANDLE EXPR&lt;/A&gt;&lt;/STRONG&gt;&lt;DD&gt;
&lt;DT&gt;&lt;STRONG&gt;&lt;A NAME="item__OUTPUT_AUTOFLUSH"&gt;$OUTPUT_AUTOFLUSH&lt;/A&gt;&lt;/STRONG&gt;&lt;DD&gt;
&lt;DT&gt;&lt;STRONG&gt;&lt;A NAME="item__"&gt;$|&lt;/A&gt;&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;
If set to nonzero, forces a flush right away and after every write or print
on the currently selected output channel. Default is 0 (regardless of
whether the channel is actually buffered by the system or not; &lt;CODE&gt;$|&lt;/CODE&gt; tells you only whether you've asked Perl explicitly to flush after each write). Note that 
&lt;FONT SIZE=-1&gt;STDOUT&lt;/FONT&gt; will typically be line buffered if output is to the terminal and block buffered otherwise. Setting this variable is useful primarily when you are outputting to a pipe, such as when you are running a Perl script under rsh and want to see the output as it's happening. This has no effect on input buffering. (Mnemonic: when you want your pipes to be piping hot.)

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;&lt;A NAME="item_output_field_separator"&gt;output_field_separator HANDLE EXPR&lt;/A&gt;&lt;/STRONG&gt;&lt;DD&gt;
&lt;DT&gt;&lt;STRONG&gt;&lt;A NAME="item__OUTPUT_FIELD_SEPARATOR"&gt;$OUTPUT_FIELD_SEPARATOR&lt;/A&gt;&lt;/STRONG&gt;&lt;DD&gt;
&lt;DT&gt;&lt;STRONG&gt;&lt;A NAME="item__OFS"&gt;$OFS&lt;/A&gt;&lt;/STRONG&gt;&lt;DD&gt;
&lt;DT&gt;&lt;STRONG&gt;&lt;A NAME="item__"&gt;$,&lt;/A&gt;&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;
The output field separator for the print operator. Ordinarily the print
operator simply prints out the comma-separated fields you specify. To get
behavior more like &lt;STRONG&gt;awk&lt;/STRONG&gt;, set this variable as you would set &lt;STRONG&gt;awk&lt;/STRONG&gt;'s 
&lt;FONT SIZE=-1&gt;OFS&lt;/FONT&gt; variable to specify what is printed between
fields. (Mnemonic: what is printed when there is a , in your print
statement.)

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;&lt;A NAME="item_output_record_separator"&gt;output_record_separator HANDLE EXPR&lt;/A&gt;&lt;/STRONG&gt;&lt;DD&gt;
&lt;DT&gt;&lt;STRONG&gt;&lt;A NAME="item__OUTPUT_RECORD_SEPARATOR"&gt;$OUTPUT_RECORD_SEPARATOR&lt;/A&gt;&lt;/STRONG&gt;&lt;DD&gt;
&lt;DT&gt;&lt;STRONG&gt;&lt;A NAME="item__ORS"&gt;$ORS&lt;/A&gt;&lt;/STRONG&gt;&lt;DD&gt;
&lt;DT&gt;&lt;STRONG&gt;&lt;A NAME="item__"&gt;$\&lt;/A&gt;&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;
The output record separator for the print operator. Ordinarily the print
operator simply prints out the comma-separated fields you specify, with no
trailing newline or record separator assumed. To get behavior more like &lt;STRONG&gt;awk&lt;/STRONG&gt;, set this variable as you would set &lt;STRONG&gt;awk&lt;/STRONG&gt;'s 
&lt;FONT SIZE=-1&gt;ORS&lt;/FONT&gt; variable to specify what is printed at the end of
the print. (Mnemonic: you set ``&lt;CODE&gt;$\&lt;/CODE&gt;'' instead of adding \n at the end of the print. Also, it's just like &lt;CODE&gt;$/&lt;/CODE&gt;, but it's what you get ``back'' from Perl.)

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;&lt;A NAME="item__LIST_SEPARATOR"&gt;$LIST_SEPARATOR&lt;/A&gt;&lt;/STRONG&gt;&lt;DD&gt;
&lt;DT&gt;&lt;STRONG&gt;&lt;A NAME="item__"&gt;$&amp;quot;&lt;/A&gt;&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;
This is like ``&lt;CODE&gt;$,&lt;/CODE&gt;'' except that it applies to array values interpolated into a double-quoted string (or similar interpreted string). Default is a space. (Mnemonic: obvious, 
&lt;FONT SIZE=-1&gt;I&lt;/FONT&gt; think.)

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;&lt;A NAME="item__SUBSCRIPT_SEPARATOR"&gt;$SUBSCRIPT_SEPARATOR&lt;/A&gt;&lt;/STRONG&gt;&lt;DD&gt;
&lt;DT&gt;&lt;STRONG&gt;&lt;A NAME="item__SUBSEP"&gt;$SUBSEP&lt;/A&gt;&lt;/STRONG&gt;&lt;DD&gt;
&lt;DT&gt;&lt;STRONG&gt;&lt;A NAME="item__"&gt;$;&lt;/A&gt;&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;
The subscript separator for multidimensional array emulation. If you refer
to a hash element as

&lt;P&gt;
&lt;PRE&gt;    $foo{$a,$b,$c}
&lt;/PRE&gt;
&lt;P&gt;
it really means

&lt;P&gt;
&lt;PRE&gt;    $foo{join($;, $a, $b, $c)}
&lt;/PRE&gt;
&lt;P&gt;
But don't put

&lt;P&gt;
&lt;PRE&gt;    @foo{$a,$b,$c}      # a slice--note the @
&lt;/PRE&gt;
&lt;P&gt;
which means

&lt;P&gt;
&lt;PRE&gt;    ($foo{$a},$foo{$b},$foo{$c})
&lt;/PRE&gt;
&lt;P&gt;
Default is ``\034'', the same as 
&lt;FONT SIZE=-1&gt;SUBSEP&lt;/FONT&gt; in &lt;STRONG&gt;awk&lt;/STRONG&gt;. Note that if your keys contain binary data there might not be any safe
value for ``&lt;CODE&gt;$;&lt;/CODE&gt;''. (Mnemonic: comma (the syntactic subscript separator) is a semi-semicolon. Yeah, 
&lt;FONT SIZE=-1&gt;I&lt;/FONT&gt; know, it's pretty lame, but ``
&lt;CODE&gt;$,&lt;/CODE&gt;'' is already taken for something more important.)

&lt;P&gt;
Consider using ``real'' multidimensional arrays.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;&lt;A NAME="item__OFMT"&gt;$OFMT&lt;/A&gt;&lt;/STRONG&gt;&lt;DD&gt;
&lt;DT&gt;&lt;STRONG&gt;&lt;A NAME="item__"&gt;$#&lt;/A&gt;&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;
The output format for printed numbers. This variable is a half-hearted
attempt to emulate &lt;STRONG&gt;awk&lt;/STRONG&gt;'s 
&lt;FONT SIZE=-1&gt;OFMT&lt;/FONT&gt; variable. There are times, however, when &lt;STRONG&gt;awk&lt;/STRONG&gt; and Perl have differing notions of what is in fact numeric. The initial
value is %.&lt;EM&gt;n&lt;/EM&gt;g, where &lt;EM&gt;n&lt;/EM&gt; is the value of the macro 
&lt;FONT SIZE=-1&gt;DBL_DIG&lt;/FONT&gt; from your system's &lt;EM&gt;float.h&lt;/EM&gt;. This is different from
&lt;STRONG&gt;awk&lt;/STRONG&gt;'s default 
&lt;FONT SIZE=-1&gt;OFMT&lt;/FONT&gt; setting of %.6g, so you need to set ``&lt;CODE&gt;$#&lt;/CODE&gt;'' explicitly to get &lt;STRONG&gt;awk&lt;/STRONG&gt;'s value. (Mnemonic: # is the number sign.)

&lt;P&gt;
Use of ``&lt;CODE&gt;$#&lt;/CODE&gt;'' is deprecated.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;&lt;A NAME="item_format_page_number"&gt;format_page_number HANDLE EXPR&lt;/A&gt;&lt;/STRONG&gt;&lt;DD&gt;
&lt;DT&gt;&lt;STRONG&gt;&lt;A NAME="item__FORMAT_PAGE_NUMBER"&gt;$FORMAT_PAGE_NUMBER&lt;/A&gt;&lt;/STRONG&gt;&lt;DD&gt;
&lt;DT&gt;&lt;STRONG&gt;&lt;A NAME="item__"&gt;$%&lt;/A&gt;&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;
The current page number of the currently selected output channel.
(Mnemonic: % is page number in &lt;STRONG&gt;nroff&lt;/STRONG&gt;.)

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;&lt;A NAME="item_format_lines_per_page"&gt;format_lines_per_page HANDLE EXPR&lt;/A&gt;&lt;/STRONG&gt;&lt;DD&gt;
&lt;DT&gt;&lt;STRONG&gt;&lt;A NAME="item__FORMAT_LINES_PER_PAGE"&gt;$FORMAT_LINES_PER_PAGE&lt;/A&gt;&lt;/STRONG&gt;&lt;DD&gt;
&lt;DT&gt;&lt;STRONG&gt;&lt;A NAME="item__"&gt;$=&lt;/A&gt;&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;
The current page length (printable lines) of the currently selected output
channel. Default is 60. (Mnemonic: = has horizontal lines.)

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;&lt;A NAME="item_format_lines_left"&gt;format_lines_left HANDLE EXPR&lt;/A&gt;&lt;/STRONG&gt;&lt;DD&gt;
&lt;DT&gt;&lt;STRONG&gt;&lt;A NAME="item__FORMAT_LINES_LEFT"&gt;$FORMAT_LINES_LEFT&lt;/A&gt;&lt;/STRONG&gt;&lt;DD&gt;
&lt;DT&gt;&lt;STRONG&gt;&lt;A NAME="item__"&gt;$-&lt;/A&gt;&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;
The number of lines left on the page of the currently selected output
channel. (Mnemonic: lines_on_page - lines_printed.)

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;&lt;A NAME="item_format_name"&gt;format_name HANDLE EXPR&lt;/A&gt;&lt;/STRONG&gt;&lt;DD&gt;
&lt;DT&gt;&lt;STRONG&gt;&lt;A NAME="item__FORMAT_NAME"&gt;$FORMAT_NAME&lt;/A&gt;&lt;/STRONG&gt;&lt;DD&gt;
&lt;DT&gt;&lt;STRONG&gt;&lt;A NAME="item__"&gt;$~&lt;/A&gt;&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;
The name of the current report format for the currently selected output
channel. Default is name of the filehandle. (Mnemonic: brother to ``&lt;CODE&gt;$^&lt;/CODE&gt;''.)

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;&lt;A NAME="item_format_top_name"&gt;format_top_name HANDLE EXPR&lt;/A&gt;&lt;/STRONG&gt;&lt;DD&gt;
&lt;DT&gt;&lt;STRONG&gt;&lt;A NAME="item__FORMAT_TOP_NAME"&gt;$FORMAT_TOP_NAME&lt;/A&gt;&lt;/STRONG&gt;&lt;DD&gt;
&lt;DT&gt;&lt;STRONG&gt;&lt;A NAME="item__"&gt;$^&lt;/A&gt;&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;
The name of the current top-of-page format for the currently selected output channel. Default is name of the filehandle with 
&lt;FONT SIZE=-1&gt;_TOP&lt;/FONT&gt; appended. (Mnemonic: points to top of page.)

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;&lt;A NAME="item_format_line_break_characters"&gt;format_line_break_characters HANDLE EXPR&lt;/A&gt;&lt;/STRONG&gt;&lt;DD&gt;
&lt;DT&gt;&lt;STRONG&gt;&lt;A NAME="item__FORMAT_LINE_BREAK_CHARACTERS"&gt;$FORMAT_LINE_BREAK_CHARACTERS&lt;/A&gt;&lt;/STRONG&gt;&lt;DD&gt;
&lt;DT&gt;&lt;STRONG&gt;&lt;A NAME="item__"&gt;$:&lt;/A&gt;&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;
The current set of characters after which a string may be broken to fill
continuation fields (starting with ^) in a format. Default is
"&amp;nbsp;\n-", to break on whitespace or hyphens. (Mnemonic: a ``colon'' in poetry is a
part of a line.)

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;&lt;A NAME="item_format_formfeed"&gt;format_formfeed HANDLE EXPR&lt;/A&gt;&lt;/STRONG&gt;&lt;DD&gt;
&lt;DT&gt;&lt;STRONG&gt;&lt;A NAME="item__FORMAT_FORMFEED"&gt;$FORMAT_FORMFEED&lt;/A&gt;&lt;/STRONG&gt;&lt;DD&gt;
&lt;DT&gt;&lt;STRONG&gt;&lt;A NAME="item__L"&gt;$^L&lt;/A&gt;&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;
What formats output to perform a form feed. Default is \f.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;&lt;A NAME="item__ACCUMULATOR"&gt;$ACCUMULATOR&lt;/A&gt;&lt;/STRONG&gt;&lt;DD&gt;
&lt;DT&gt;&lt;STRONG&gt;&lt;A NAME="item__A"&gt;$^A&lt;/A&gt;&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;
The current value of the 
&lt;CODE&gt;write()&lt;/CODE&gt; accumulator for 
&lt;CODE&gt;format()&lt;/CODE&gt; lines. 
&lt;FONT SIZE=-1&gt;A&lt;/FONT&gt; format contains 
&lt;CODE&gt;formline()&lt;/CODE&gt; commands that put their result into
 &lt;CODE&gt;$^A&lt;/CODE&gt;. After calling its format, 
&lt;CODE&gt;write()&lt;/CODE&gt; prints out the
contents of &lt;CODE&gt;$^A&lt;/CODE&gt; and empties. So you never actually see the contents of &lt;CODE&gt;$^A&lt;/CODE&gt; unless you call 
&lt;CODE&gt;formline()&lt;/CODE&gt; yourself and
then look at it. See [perlman:perlform|the perlform manpage] and
[perlfunc:formline|formline()].

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;&lt;A NAME="item__CHILD_ERROR"&gt;$CHILD_ERROR&lt;/A&gt;&lt;/STRONG&gt;&lt;DD&gt;
&lt;DT&gt;&lt;STRONG&gt;&lt;A NAME="item__"&gt;$?&lt;/A&gt;&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;
The status returned by the last pipe close, backtick (&lt;CODE&gt;``&lt;/CODE&gt;) command, or 
&lt;CODE&gt;system()&lt;/CODE&gt; operator. Note that this is the status word returned by the 
&lt;CODE&gt;wait()&lt;/CODE&gt; system call (or else is made up to look like it). Thus, the exit value of the subprocess is actually (
&lt;CODE&gt;$? &amp;gt;&amp;gt; 8&lt;/CODE&gt;), and &lt;CODE&gt;$? &amp;amp; 127&lt;/CODE&gt;
gives which signal, if any, the process died from, and &lt;CODE&gt;$? &amp;amp; 128&lt;/CODE&gt; reports whether there was a core dump. (Mnemonic: similar to &lt;STRONG&gt;sh&lt;/STRONG&gt; and &lt;STRONG&gt;ksh&lt;/STRONG&gt;.)

&lt;P&gt;
Additionally, if the &lt;CODE&gt;h_errno&lt;/CODE&gt; variable is supported in 
&lt;FONT SIZE=-1&gt;C,&lt;/FONT&gt; its value is returned via $? if any of the &lt;CODE&gt;gethost*()&lt;/CODE&gt; functions fail.

&lt;P&gt;
Note that if you have installed a signal handler for &lt;CODE&gt;SIGCHLD&lt;/CODE&gt;, the value of &lt;CODE&gt;$?&lt;/CODE&gt; will usually be wrong outside that handler.

&lt;P&gt;
Inside an &lt;CODE&gt;END&lt;/CODE&gt; subroutine &lt;CODE&gt;$?&lt;/CODE&gt; contains the value that is going to be given to [perlfunc:exit|exit()]. You can modify &lt;CODE&gt;$?&lt;/CODE&gt; in an &lt;CODE&gt;END&lt;/CODE&gt; subroutine to change the exit status of the script.

&lt;P&gt;
Under 
&lt;FONT SIZE=-1&gt;VMS,&lt;/FONT&gt; the pragma &lt;CODE&gt;use vmsish 'status'&lt;/CODE&gt; makes &lt;CODE&gt;$?&lt;/CODE&gt; reflect the actual 
&lt;FONT SIZE=-1&gt;VMS&lt;/FONT&gt; exit status, instead of the default emulation of 
&lt;FONT SIZE=-1&gt;POSIX&lt;/FONT&gt; status.

&lt;P&gt;
Also see &lt;A HREF="#Error_Indicators"&gt;Error Indicators&lt;/A&gt;.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;&lt;A NAME="item__OS_ERROR"&gt;$OS_ERROR&lt;/A&gt;&lt;/STRONG&gt;&lt;DD&gt;
&lt;DT&gt;&lt;STRONG&gt;&lt;A NAME="item__ERRNO"&gt;$ERRNO&lt;/A&gt;&lt;/STRONG&gt;&lt;DD&gt;
&lt;DT&gt;&lt;STRONG&gt;&lt;A NAME="item__"&gt;$!&lt;/A&gt;&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;
If used in a numeric context, yields the current value of errno, with all
the usual caveats. (This means that you shouldn't depend on the value of &lt;CODE&gt;$!&lt;/CODE&gt; to be anything in particular unless you've gotten a specific error return
indicating a system error.) If used in a string context, yields the
corresponding system error string. You can assign to &lt;CODE&gt;$!&lt;/CODE&gt; to set &lt;EM&gt;errno&lt;/EM&gt; if, for instance, you want &lt;CODE&gt;&amp;quot;$!&amp;quot;&lt;/CODE&gt; to return the string for error &lt;EM&gt;n&lt;/EM&gt;, or you want to set the exit value for the 
&lt;CODE&gt;die()&lt;/CODE&gt; operator. (Mnemonic: What
just went bang?)

&lt;P&gt;
Also see &lt;A HREF="#Error_Indicators"&gt;Error Indicators&lt;/A&gt;.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;&lt;A NAME="item__EXTENDED_OS_ERROR"&gt;$EXTENDED_OS_ERROR&lt;/A&gt;&lt;/STRONG&gt;&lt;DD&gt;
&lt;DT&gt;&lt;STRONG&gt;&lt;A NAME="item__E"&gt;$^E&lt;/A&gt;&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;
Error information specific to the current operating system. At the moment,
this differs from &lt;CODE&gt;$!&lt;/CODE&gt; under only 
&lt;FONT SIZE=-1&gt;VMS,&lt;/FONT&gt; 
&lt;FONT SIZE=-1&gt;OS/2,&lt;/FONT&gt; and Win32 (and for MacPerl). On all other platforms,
 &lt;CODE&gt;$^E&lt;/CODE&gt; is always just the same as &lt;CODE&gt;$!&lt;/CODE&gt;.

&lt;P&gt;
Under 
&lt;FONT SIZE=-1&gt;VMS,&lt;/FONT&gt; &lt;CODE&gt;$^E&lt;/CODE&gt; provides the 
&lt;FONT SIZE=-1&gt;VMS&lt;/FONT&gt; status value from the last system error. This is
more specific information about the last system error than that provided by &lt;CODE&gt;$!&lt;/CODE&gt;. This is particularly important when &lt;CODE&gt;$!&lt;/CODE&gt; is set to &lt;STRONG&gt;EVMSERR&lt;/STRONG&gt;.

&lt;P&gt;
Under 
&lt;FONT SIZE=-1&gt;OS/2,&lt;/FONT&gt; &lt;CODE&gt;$^E&lt;/CODE&gt; is set to the error code of the last call to 
&lt;FONT SIZE=-1&gt;OS/2&lt;/FONT&gt; 
&lt;FONT SIZE=-1&gt;API&lt;/FONT&gt; either via 
&lt;FONT SIZE=-1&gt;CRT,&lt;/FONT&gt; or directly from perl.

&lt;P&gt;
Under Win32, &lt;CODE&gt;$^E&lt;/CODE&gt; always returns the last error information reported by the Win32 call &lt;CODE&gt;GetLastError()&lt;/CODE&gt; which describes the last error from within the Win32 
&lt;FONT SIZE=-1&gt;API.&lt;/FONT&gt; Most Win32-specific code will report errors via &lt;CODE&gt;$^E&lt;/CODE&gt;. 
&lt;FONT SIZE=-1&gt;ANSI&lt;/FONT&gt; 
&lt;FONT SIZE=-1&gt;C&lt;/FONT&gt; and UNIX-like calls set
 &lt;CODE&gt;errno&lt;/CODE&gt; and so most portable Perl code will report errors via &lt;CODE&gt;$!&lt;/CODE&gt;. 

&lt;P&gt;
Caveats mentioned in the description of &lt;CODE&gt;$!&lt;/CODE&gt; generally apply to
&lt;CODE&gt;$^E&lt;/CODE&gt;, also. (Mnemonic: Extra error explanation.)

&lt;P&gt;
Also see &lt;A HREF="#Error_Indicators"&gt;Error Indicators&lt;/A&gt;.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;&lt;A NAME="item__EVAL_ERROR"&gt;$EVAL_ERROR&lt;/A&gt;&lt;/STRONG&gt;&lt;DD&gt;
&lt;DT&gt;&lt;STRONG&gt;&lt;A NAME="item__"&gt;$@&lt;/A&gt;&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;
The Perl syntax error message from the last 
&lt;CODE&gt;eval()&lt;/CODE&gt; command. If null, the last 
&lt;CODE&gt;eval()&lt;/CODE&gt; parsed and executed correctly (although the operations you invoked may have failed in the normal fashion). (Mnemonic: Where was the syntax error ``at''?)

&lt;P&gt;
Note that warning messages are not collected in this variable. You can,
however, set up a routine to process warnings by setting &lt;CODE&gt;$SIG{__WARN__}&lt;/CODE&gt;
as described below.

&lt;P&gt;
Also see &lt;A HREF="#Error_Indicators"&gt;Error Indicators&lt;/A&gt;.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;&lt;A NAME="item__PROCESS_ID"&gt;$PROCESS_ID&lt;/A&gt;&lt;/STRONG&gt;&lt;DD&gt;
&lt;DT&gt;&lt;STRONG&gt;&lt;A NAME="item__PID"&gt;$PID&lt;/A&gt;&lt;/STRONG&gt;&lt;DD&gt;
&lt;DT&gt;&lt;STRONG&gt;&lt;A NAME="item__"&gt;$$&lt;/A&gt;&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;
The process number of the Perl running this script. (Mnemonic: same as
shells.)

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;&lt;A NAME="item__REAL_USER_ID"&gt;$REAL_USER_ID&lt;/A&gt;&lt;/STRONG&gt;&lt;DD&gt;
&lt;DT&gt;&lt;STRONG&gt;&lt;A NAME="item__UID"&gt;$UID&lt;/A&gt;&lt;/STRONG&gt;&lt;DD&gt;
&lt;DT&gt;&lt;STRONG&gt;&lt;A NAME="item__"&gt;$&amp;lt;&lt;/A&gt;&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;
The real uid of this process. (Mnemonic: it's the uid you came &lt;EM&gt;FROM&lt;/EM&gt;, if you're running setuid.)

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;&lt;A NAME="item__EFFECTIVE_USER_ID"&gt;$EFFECTIVE_USER_ID&lt;/A&gt;&lt;/STRONG&gt;&lt;DD&gt;
&lt;DT&gt;&lt;STRONG&gt;&lt;A NAME="item__EUID"&gt;$EUID&lt;/A&gt;&lt;/STRONG&gt;&lt;DD&gt;
&lt;DT&gt;&lt;STRONG&gt;&lt;A NAME="item__"&gt;$&amp;gt;&lt;/A&gt;&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;
The effective uid of this process. Example:

&lt;P&gt;
&lt;PRE&gt;    $&amp;lt; = $&amp;gt;;            # set real to effective uid
    ($&amp;lt;,$&amp;gt;) = ($&amp;gt;,$&amp;lt;);  # swap real and effective uid
&lt;/PRE&gt;
&lt;P&gt;
(Mnemonic: it's the uid you went &lt;EM&gt;TO&lt;/EM&gt;, if you're running setuid.) Note: ``&lt;CODE&gt;$&amp;lt;&lt;/CODE&gt;'' and ``&lt;CODE&gt;$&amp;gt;&lt;/CODE&gt;'' can be swapped only on machines supporting 
&lt;CODE&gt;setreuid().&lt;/CODE&gt;

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;&lt;A NAME="item__REAL_GROUP_ID"&gt;$REAL_GROUP_ID&lt;/A&gt;&lt;/STRONG&gt;&lt;DD&gt;
&lt;DT&gt;&lt;STRONG&gt;&lt;A NAME="item__GID"&gt;$GID&lt;/A&gt;&lt;/STRONG&gt;&lt;DD&gt;
&lt;DT&gt;&lt;STRONG&gt;&lt;A NAME="item__"&gt;$(&lt;/A&gt;&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;
The real gid of this process. If you are on a machine that supports membership in multiple groups simultaneously, gives a space separated list of groups you are in. The first number is the one returned by 
&lt;CODE&gt;getgid(),&lt;/CODE&gt; and the subsequent ones by 
&lt;CODE&gt;getgroups(),&lt;/CODE&gt; one of which may be the same as the first number.

&lt;P&gt;
However, a value assigned to ``&lt;CODE&gt;$(&lt;/CODE&gt;'' must be a single number used to set the real gid. So the value given by
``&lt;CODE&gt;$(&lt;/CODE&gt;'' should &lt;EM&gt;not&lt;/EM&gt; be assigned back to ``&lt;CODE&gt;$(&lt;/CODE&gt;'' without being forced numeric, such as by adding zero.

&lt;P&gt;
(Mnemonic: parentheses are used to &lt;EM&gt;GROUP&lt;/EM&gt; things. The real gid is the group you &lt;EM&gt;LEFT&lt;/EM&gt;, if you're running setgid.)

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;&lt;A NAME="item__EFFECTIVE_GROUP_ID"&gt;$EFFECTIVE_GROUP_ID&lt;/A&gt;&lt;/STRONG&gt;&lt;DD&gt;
&lt;DT&gt;&lt;STRONG&gt;&lt;A NAME="item__EGID"&gt;$EGID&lt;/A&gt;&lt;/STRONG&gt;&lt;DD&gt;
&lt;DT&gt;&lt;STRONG&gt;&lt;A NAME="item__"&gt;$)&lt;/A&gt;&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;
The effective gid of this process. If you are on a machine that supports membership in multiple groups simultaneously, gives a space separated list of groups you are in. The first number is the one returned by 
&lt;CODE&gt;getegid(),&lt;/CODE&gt; and the subsequent ones by 
&lt;CODE&gt;getgroups(),&lt;/CODE&gt; one of which may be the same as the first number.

&lt;P&gt;
Similarly, a value assigned to ``&lt;CODE&gt;$)&lt;/CODE&gt;'' must also be a space-separated list of numbers. The first number is used to set the effective gid, and the rest (if any) are passed to 
&lt;CODE&gt;setgroups().&lt;/CODE&gt; To get the effect of an empty list for 
&lt;CODE&gt;setgroups(),&lt;/CODE&gt; just repeat the new effective gid; that is, to force an effective gid of 5 and an effectively empty 
&lt;CODE&gt;setgroups()&lt;/CODE&gt; list, say
 &lt;CODE&gt;&amp;lt;PRE&amp;gt; $) = &amp;amp;quot;5 5&amp;amp;quot; 
&amp;lt;/PRE&amp;gt;
&lt;/CODE&gt;.

&lt;P&gt;
(Mnemonic: parentheses are used to &lt;EM&gt;GROUP&lt;/EM&gt; things. The effective gid is the group that's &lt;EM&gt;RIGHT&lt;/EM&gt; for you, if you're running setgid.)

&lt;P&gt;
Note: ``&lt;CODE&gt;$&amp;lt;&lt;/CODE&gt;'', ``&lt;CODE&gt;$&amp;gt;&lt;/CODE&gt;'', ``&lt;CODE&gt;$(&lt;/CODE&gt;'' and ``&lt;CODE&gt;$)&lt;/CODE&gt;'' can be set only on machines that support the corresponding &lt;EM&gt;set&amp;#091;re&amp;#093;&amp;#091;ug&amp;#093;id()&lt;/EM&gt; routine. ``&lt;CODE&gt;$(&lt;/CODE&gt;'' and ``&lt;CODE&gt;$)&lt;/CODE&gt;'' can be swapped only on machines supporting 
&lt;CODE&gt;setregid().&lt;/CODE&gt;

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;&lt;A NAME="item__PROGRAM_NAME"&gt;$PROGRAM_NAME&lt;/A&gt;&lt;/STRONG&gt;&lt;DD&gt;
&lt;DT&gt;&lt;STRONG&gt;&lt;A NAME="item__0"&gt;$0&lt;/A&gt;&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;
Contains the name of the file containing the Perl script being executed. On
some operating systems assigning to ``&lt;CODE&gt;$0&lt;/CODE&gt;'' modifies the argument area that the 
&lt;CODE&gt;ps(1)&lt;/CODE&gt; program sees. This is
more useful as a way of indicating the current program state than it is for
hiding the program you're running. (Mnemonic: same as &lt;STRONG&gt;sh&lt;/STRONG&gt; and &lt;STRONG&gt;ksh&lt;/STRONG&gt;.)

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;&lt;A NAME="item__"&gt;$&amp;#091;&lt;/A&gt;&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;
The index of the first element in an array, and of the first character in a
substring. Default is 0, but you could set it to 1 to make Perl behave more
like &lt;STRONG&gt;awk&lt;/STRONG&gt; (or Fortran) when subscripting and when evaluating the 
&lt;CODE&gt;index()&lt;/CODE&gt; and 
&lt;CODE&gt;substr()&lt;/CODE&gt; functions. (Mnemonic: &amp;#091; begins subscripts.)

&lt;P&gt;
As of Perl 5, assignment to ``&lt;CODE&gt;$&amp;#091;&lt;/CODE&gt;'' is treated as a compiler directive, and cannot influence the behavior of
any other file. Its use is discouraged.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;&lt;A NAME="item__PERL_VERSION"&gt;$PERL_VERSION&lt;/A&gt;&lt;/STRONG&gt;&lt;DD&gt;
&lt;DT&gt;&lt;STRONG&gt;&lt;A NAME="item__"&gt;$&amp;#093;&lt;/A&gt;&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;
The version + patchlevel / 1000 of the Perl interpreter. This variable can
be used to determine whether the Perl interpreter executing a script is in
the right range of versions. (Mnemonic: Is this version of perl in the
right bracket?) Example:

&lt;P&gt;
&lt;PRE&gt;    warn &amp;quot;No checksumming!\n&amp;quot; if $&amp;#093; &amp;lt; 3.019;
&lt;/PRE&gt;
&lt;P&gt;
See also the documentation of &lt;CODE&gt;use VERSION&lt;/CODE&gt; and &lt;CODE&gt;require VERSION&lt;/CODE&gt;
for a convenient way to fail if the Perl interpreter is too old.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;&lt;A NAME="item__DEBUGGING"&gt;$DEBUGGING&lt;/A&gt;&lt;/STRONG&gt;&lt;DD&gt;
&lt;DT&gt;&lt;STRONG&gt;&lt;A NAME="item__D"&gt;$^D&lt;/A&gt;&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;
The current value of the debugging flags. (Mnemonic: value of &lt;STRONG&gt;-D&lt;/STRONG&gt;
switch.)

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;&lt;A NAME="item__SYSTEM_FD_MAX"&gt;$SYSTEM_FD_MAX&lt;/A&gt;&lt;/STRONG&gt;&lt;DD&gt;
&lt;DT&gt;&lt;STRONG&gt;&lt;A NAME="item__F"&gt;$^F&lt;/A&gt;&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;
The maximum system file descriptor, ordinarily 2. System file descriptors are passed to 
&lt;CODE&gt;exec()ed&lt;/CODE&gt; processes, while higher file descriptors are not. Also, during an 
&lt;CODE&gt;open(),&lt;/CODE&gt; system file descriptors are preserved even if the 
&lt;CODE&gt;open()&lt;/CODE&gt; fails. (Ordinary file descriptors are closed before the 
&lt;CODE&gt;open()&lt;/CODE&gt; is attempted.) Note that the close-on-exec status of a file descriptor will be decided according to the value of

&lt;CODE&gt;$^F&lt;/CODE&gt; at the time of the open, not the time of the exec.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;&lt;A NAME="item__H"&gt;$^H&lt;/A&gt;&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;
The current set of syntax checks enabled by &lt;CODE&gt;use strict&lt;/CODE&gt; and other block scoped compiler hints. See the documentation of &lt;CODE&gt;strict&lt;/CODE&gt; for more details.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;&lt;A NAME="item__INPLACE_EDIT"&gt;$INPLACE_EDIT&lt;/A&gt;&lt;/STRONG&gt;&lt;DD&gt;
&lt;DT&gt;&lt;STRONG&gt;&lt;A NAME="item__I"&gt;$^I&lt;/A&gt;&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;
The current value of the inplace-edit extension. Use [perlfunc:undef|undef] to disable inplace editing. (Mnemonic: value of &lt;STRONG&gt;-i&lt;/STRONG&gt; switch.)

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;&lt;A NAME="item__M"&gt;$^M&lt;/A&gt;&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;
By default, running out of memory it is not trappable. However, if compiled
for this, Perl may use the contents of &lt;CODE&gt;$^M&lt;/CODE&gt; as an emergency pool after 
&lt;CODE&gt;die()ing&lt;/CODE&gt; with this message. Suppose that your Perl were compiled with 
&lt;FONT SIZE=-1&gt;-DPERL_EMERGENCY_SBRK&lt;/FONT&gt; and used Perl's malloc. Then

&lt;P&gt;
&lt;PRE&gt;    $^M = 'a' x (1&amp;lt;&amp;lt;16);
&lt;/PRE&gt;
&lt;P&gt;
would allocate a 
&lt;FONT SIZE=-1&gt;64K&lt;/FONT&gt; buffer for use when in emergency. See the &lt;EM&gt;INSTALL&lt;/EM&gt;
file for information on how to enable this option. As a disincentive to
casual use of this advanced feature, there is no &lt;U&gt;the English manpage&lt;/U&gt;&lt;!--../lib/English.html--&gt; long name for this variable.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;&lt;A NAME="item__OSNAME"&gt;$OSNAME&lt;/A&gt;&lt;/STRONG&gt;&lt;DD&gt;
&lt;DT&gt;&lt;STRONG&gt;&lt;A NAME="item__O"&gt;$^O&lt;/A&gt;&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;
The name of the operating system under which this copy of Perl was built,
as determined during the configuration process. The value is identical to &lt;CODE&gt;$Config{'osname'}&lt;/CODE&gt;.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;&lt;A NAME="item__PERLDB"&gt;$PERLDB&lt;/A&gt;&lt;/STRONG&gt;&lt;DD&gt;
&lt;DT&gt;&lt;STRONG&gt;&lt;A NAME="item__P"&gt;$^P&lt;/A&gt;&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;
The internal variable for debugging support. Different bits mean the
following (subject to change): 

&lt;OL&gt;
&lt;LI&gt;&lt;STRONG&gt;&lt;A NAME="item_x01"&gt;x01&lt;/A&gt;&lt;/STRONG&gt;
&lt;P&gt;
Debug subroutine enter/exit.

&lt;P&gt;&lt;LI&gt;&lt;STRONG&gt;&lt;A NAME="item_x02"&gt;x02&lt;/A&gt;&lt;/STRONG&gt;

Line-by-line debugging.

&lt;P&gt;&lt;LI&gt;&lt;STRONG&gt;&lt;A NAME="item_x04"&gt;x04&lt;/A&gt;&lt;/STRONG&gt;

Switch off optimizations.

&lt;P&gt;&lt;LI&gt;&lt;STRONG&gt;&lt;A NAME="item_x08"&gt;x08&lt;/A&gt;&lt;/STRONG&gt;

Preserve more data for future interactive inspections.

&lt;P&gt;&lt;LI&gt;&lt;STRONG&gt;&lt;A NAME="item_x10"&gt;x10&lt;/A&gt;&lt;/STRONG&gt;

Keep info about source lines on which a subroutine is defined.

&lt;P&gt;&lt;LI&gt;&lt;STRONG&gt;&lt;A NAME="item_x20"&gt;x20&lt;/A&gt;&lt;/STRONG&gt;

Start with single-step on.

&lt;/OL&gt;
&lt;P&gt;
Note that some bits may be relevent at compile-time only, some at run-time
only. This is a new mechanism and the details may change.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;&lt;A NAME="item__R"&gt;$^R&lt;/A&gt;&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;
The result of evaluation of the last successful [perlman:perlre] 
regular expression assertion. (Excluding those used as switches.) May be
written to.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;&lt;A NAME="item__S"&gt;$^S&lt;/A&gt;&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;
Current state of the interpreter. Undefined if parsing of the current module/eval is not finished (may happen in 
&lt;FONT SIZE=-1&gt;$SIG{__DIE__}&lt;/FONT&gt; and 
&lt;FONT SIZE=-1&gt;$SIG{__WARN__}&lt;/FONT&gt; handlers). True if inside an eval, otherwise false.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;&lt;A NAME="item__BASETIME"&gt;$BASETIME&lt;/A&gt;&lt;/STRONG&gt;&lt;DD&gt;
&lt;DT&gt;&lt;STRONG&gt;&lt;A NAME="item__T"&gt;$^T&lt;/A&gt;&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;
The time at which the script began running, in seconds since the epoch
(beginning of 1970). The values returned by the &lt;STRONG&gt;-M&lt;/STRONG&gt;, &lt;STRONG&gt;-A&lt;/STRONG&gt;, and &lt;STRONG&gt;-C&lt;/STRONG&gt; filetests are based on this value.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;&lt;A NAME="item__WARNING"&gt;$WARNING&lt;/A&gt;&lt;/STRONG&gt;&lt;DD&gt;
&lt;DT&gt;&lt;STRONG&gt;&lt;A NAME="item__W"&gt;$^W&lt;/A&gt;&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;
The current value of the warning switch, either 
&lt;FONT SIZE=-1&gt;TRUE&lt;/FONT&gt; or 
&lt;FONT SIZE=-1&gt;FALSE.&lt;/FONT&gt; (Mnemonic: related to the
 &lt;STRONG&gt;-w&lt;/STRONG&gt; switch.)

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;&lt;A NAME="item__EXECUTABLE_NAME"&gt;$EXECUTABLE_NAME&lt;/A&gt;&lt;/STRONG&gt;&lt;DD&gt;
&lt;DT&gt;&lt;STRONG&gt;&lt;A NAME="item__X"&gt;$^X&lt;/A&gt;&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;
The name that the Perl binary itself was executed as, from C's &lt;CODE&gt;argv&amp;#091;0&amp;#093;&lt;/CODE&gt;.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;&lt;A NAME="item__ARGV"&gt;$ARGV&lt;/A&gt;&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;
contains the name of the current file when reading from &amp;lt;&amp;gt;.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;&lt;A NAME="item__ARGV"&gt;@ARGV&lt;/A&gt;&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;
The array &lt;CODE&gt;@ARGV&lt;/CODE&gt; contains the command line arguments intended
for the script. Note that &lt;CODE&gt;$#ARGV&lt;/CODE&gt; is the generally number of arguments minus one, because &lt;CODE&gt;$ARGV&amp;#091;0&amp;#093;&lt;/CODE&gt; is the first argument, &lt;EM&gt;NOT&lt;/EM&gt; the command name. See ``&lt;CODE&gt;$0&lt;/CODE&gt;'' for the command name.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;&lt;A NAME="item__INC"&gt;@INC&lt;/A&gt;&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;
The array &lt;CODE&gt;@INC&lt;/CODE&gt; contains the list of places to look for Perl
scripts to be evaluated by the &lt;CODE&gt;do EXPR&lt;/CODE&gt;, [perlfunc:require|require], or [perlfunc:use|use] constructs. It initially consists of the arguments to any &lt;STRONG&gt;-I&lt;/STRONG&gt; command line switches, followed by the default Perl library, probably &lt;EM&gt;/usr/local/lib/perl&lt;/EM&gt;, followed by ``.'', to represent the current directory. If you need to
modify this at runtime, you should use the &lt;CODE&gt;use lib&lt;/CODE&gt; pragma to get the machine-dependent library properly loaded also:

&lt;P&gt;
&lt;PRE&gt;    use lib '/mypath/libdir/';
    use SomeMod;
&lt;/PRE&gt;
&lt;DT&gt;&lt;STRONG&gt;&lt;A NAME="item__"&gt;@_&lt;/A&gt;&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;
Within a subroutine the array &lt;CODE&gt;@_&lt;/CODE&gt; contains the parameters
passed to that subroutine. See [perlman:perlsub|the perlsub manpage].

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;&lt;A NAME="item__INC"&gt;%INC&lt;/A&gt;&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;
The hash &lt;CODE&gt;%INC&lt;/CODE&gt; contains entries for each filename that has been
included via [perlfunc:do|do] or [perlfunc:require|require]. The key is the filename you specified, and the value is the location of
the file actually found. The [perlfunc:require|require] command uses this array to determine whether a given file has already been
included.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;&lt;A NAME="item__ENV"&gt;%ENV  $ENV{expr}&lt;/A&gt;&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;
The hash &lt;CODE&gt;%ENV&lt;/CODE&gt; contains your current environment. Setting a
value in &lt;CODE&gt;ENV&lt;/CODE&gt; changes the environment for child processes.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;&lt;A NAME="item__SIG"&gt;%SIG  $SIG{expr}&lt;/A&gt;&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;
The hash &lt;CODE&gt;%SIG&lt;/CODE&gt; is used to set signal handlers for various
signals. Example:

&lt;P&gt;
&lt;PRE&gt;    sub handler {       # 1st argument is signal name
        my($sig) = @_;
        print &amp;quot;Caught a SIG$sig--shutting down\n&amp;quot;;
        close(LOG);
        exit(0);
    }
&lt;/PRE&gt;
&lt;P&gt;
&lt;PRE&gt;    $SIG{'INT'}  = \&amp;amp;handler;
    $SIG{'QUIT'} = \&amp;amp;handler;
    ...
    $SIG{'INT'} = 'DEFAULT';    # restore default action
    $SIG{'QUIT'} = 'IGNORE';    # ignore SIGQUIT
&lt;/PRE&gt;
&lt;P&gt;
The &lt;CODE&gt;%SIG&lt;/CODE&gt; array contains values for only the signals actually
set within the Perl script. Here are some other examples:

&lt;P&gt;
&lt;PRE&gt;    $SIG{&amp;quot;PIPE&amp;quot;} = Plumber;     # SCARY!!
    $SIG{&amp;quot;PIPE&amp;quot;} = &amp;quot;Plumber&amp;quot;;   # assumes main::Plumber (not recommended)
    $SIG{&amp;quot;PIPE&amp;quot;} = \&amp;amp;Plumber;   # just fine; assume current Plumber
    $SIG{&amp;quot;PIPE&amp;quot;} = Plumber();   # oops, what did Plumber() return??
&lt;/PRE&gt;
&lt;P&gt;
The one marked scary is problematic because it's a bareword, which means
sometimes it's a string representing the function, and sometimes it's going
to call the subroutine call right then and there! Best to be sure and quote
it or take a reference to it. &lt;CODE&gt;*Plumber&lt;/CODE&gt; works too. See [perlman:perlsub|the perlsub manpage].

&lt;P&gt;
If your system has the 
&lt;CODE&gt;sigaction()&lt;/CODE&gt; function then signal handlers are installed using it. This means you get reliable signal handling. If your system has the 
&lt;FONT SIZE=-1&gt;SA_RESTART&lt;/FONT&gt; flag it is used when signals handlers are installed. This means that system calls for which it is supported continue rather than returning when a signal arrives. If you want your system calls to be interrupted by signal delivery then do something like this:

&lt;P&gt;
&lt;PRE&gt;    use POSIX ':signal_h';
&lt;/PRE&gt;
&lt;P&gt;
&lt;PRE&gt;    my $alarm = 0;
    sigaction SIGALRM, new POSIX::SigAction sub { $alarm = 1 }
        or die &amp;quot;Error setting SIGALRM handler: $!\n&amp;quot;;
&lt;/PRE&gt;
&lt;P&gt;
See &lt;U&gt;the POSIX manpage&lt;/U&gt;&lt;!--../lib/POSIX.html--&gt;.

&lt;P&gt;
Certain internal hooks can be also set using the &lt;CODE&gt;%SIG&lt;/CODE&gt; hash.
The routine indicated by &lt;CODE&gt;$SIG{__WARN__}&lt;/CODE&gt; is called when a warning message is about to be printed. The warning message is passed as the first argument. The presence of a 
&lt;FONT SIZE=-1&gt;__WARN__&lt;/FONT&gt; hook causes the ordinary printing of warnings to 
&lt;FONT SIZE=-1&gt;STDERR&lt;/FONT&gt; to be suppressed. You can use this to save warnings in a variable, or turn warnings into fatal errors, like this:

&lt;P&gt;
&lt;PRE&gt;    local $SIG{__WARN__} = sub { die $_&amp;#091;0&amp;#093; };
    eval $proggie;
&lt;/PRE&gt;
&lt;P&gt;
The routine indicated by &lt;CODE&gt;$SIG{__DIE__}&lt;/CODE&gt; is called when a fatal exception is about to be thrown. The error message is passed as the first argument. When a 
&lt;FONT SIZE=-1&gt;__DIE__&lt;/FONT&gt; hook routine returns, the exception processing continues as it would have in the absence of the hook, unless the hook routine itself exits via a
 [perlfunc:goto|goto], a loop exit, or a 
&lt;CODE&gt;die().&lt;/CODE&gt; The &lt;CODE&gt;__DIE__&lt;/CODE&gt; handler is explicitly disabled during the call, so that you can die from a &lt;CODE&gt;__DIE__&lt;/CODE&gt; handler. Similarly for &lt;CODE&gt;__WARN__&lt;/CODE&gt;.

&lt;P&gt;
Note that the &lt;CODE&gt;$SIG{__DIE__}&lt;/CODE&gt; hook is called even inside 
&lt;CODE&gt;eval()ed&lt;/CODE&gt; blocks/strings. See [perlfunc:die|die] and [perlman:perlvar] for how to circumvent this.

&lt;P&gt;
Note that &lt;CODE&gt;__DIE__&lt;/CODE&gt;/&lt;CODE&gt;__WARN__&lt;/CODE&gt; handlers are very special in one respect: they may be called to report
(probable) errors found by the parser. In such a case the parser may be in
inconsistent state, so any attempt to evaluate Perl code from such a
handler will probably result in a segfault. This means that calls which
result/may-result in parsing Perl should be used with extreme causion, like
this:

&lt;P&gt;
&lt;PRE&gt;    require Carp if defined $^S;
    Carp::confess(&amp;quot;Something wrong&amp;quot;) if defined &amp;amp;Carp::confess;
    die &amp;quot;Something wrong, but could not load Carp to give backtrace...
         To see backtrace try starting Perl with -MCarp switch&amp;quot;;
&lt;/PRE&gt;
&lt;P&gt;
Here the first line will load Carp &lt;EM&gt;unless&lt;/EM&gt; it is the parser who called the handler. The second line will print
backtrace and die if Carp was available. The third line will be executed
only if Carp was not available.

&lt;P&gt;
See [perlfunc:die|die], [perlfunc:warn|warn] and [perlfunc:eval|eval] for additional info.

&lt;/DL&gt;
&lt;P&gt;
&lt;HR&gt;
&lt;H2&gt;&lt;A NAME="Error_Indicators"&gt;Error Indicators&lt;/A&gt;&lt;/H2&gt;
&lt;P&gt;
The variables &lt;EM&gt;$@&lt;/EM&gt;, &lt;EM&gt;$!&lt;/EM&gt;, &lt;EM&gt;$^E&lt;/EM&gt;, and &lt;EM&gt;$?&lt;/EM&gt; contain information about different types of error conditions that may appear during execution of Perl script. The variables are shown ordered by the ``distance'' between the subsystem which reported the error and the Perl process, and correspond to errors detected by the Perl interpreter, 
&lt;FONT SIZE=-1&gt;C&lt;/FONT&gt; library, operating system, or an external program, respectively.

&lt;P&gt;
To illustrate the differences between these variables, consider the
following Perl expression:

&lt;P&gt;
&lt;PRE&gt;   eval '
         open PIPE, &amp;quot;/cdrom/install |&amp;quot;;
         @res = &amp;lt;PIPE&amp;gt;;
         close PIPE or die &amp;quot;bad pipe: $?, $!&amp;quot;;
        ';
&lt;/PRE&gt;
&lt;P&gt;
After execution of this statement all 4 variables may have been set.  

&lt;P&gt;
$@ is set if the string to be [perlfunc:eval|eval]-ed did not compile (this may happen if 
[perlfunc:open|open] or [perlfunc:close|close] were imported with bad prototypes), or if Perl code executed during evaluation 
&lt;CODE&gt;die()d&lt;/CODE&gt; (either implicitly, say, if
 [perlfunc:open|open] was imported from module &lt;U&gt;the Fatal manpage&lt;/U&gt;&lt;!--../lib/Fatal.html--&gt;, or the [perlfunc:die|die] after 
[perlfunc:close|close] was triggered). In these cases the value of $@ is the compile error, or &lt;CODE&gt;Fatal&lt;/CODE&gt; error (which will interpolate &lt;CODE&gt;$!&lt;/CODE&gt;!), or the argument to [perlfunc:die|die] (which will interpolate &lt;CODE&gt;$!&lt;/CODE&gt; and &lt;CODE&gt;$?&lt;/CODE&gt;!).

&lt;P&gt;
When the above expression is executed, 
&lt;CODE&gt;open(),&lt;/CODE&gt; &lt;CODE&gt;&amp;lt;PIPE&amp;gt;&lt;/CODE&gt;, and [perlfunc:close|close] 
are translated to 
&lt;FONT SIZE=-1&gt;C&lt;/FONT&gt; run-time library calls. $! is set if one of these calls fails. The value is a symbolic indicator chosen by the 
&lt;FONT SIZE=-1&gt;C&lt;/FONT&gt; run-time library, say
 &lt;CODE&gt;No such file or directory&lt;/CODE&gt;.

&lt;P&gt;
On some systems the above 
&lt;FONT SIZE=-1&gt;C&lt;/FONT&gt; library calls are further translated to calls to the kernel. The kernel may have set more verbose error indicator that one of the handful of standard 
&lt;FONT SIZE=-1&gt;C&lt;/FONT&gt; errors. In such cases 
&lt;FONT SIZE=-1&gt;$^E&lt;/FONT&gt; contains this verbose error indicator, which may be, say,
 &lt;CODE&gt;CDROM tray not
closed&lt;/CODE&gt;. On systems where 
&lt;FONT SIZE=-1&gt;C&lt;/FONT&gt; library calls are identical to system calls 
&lt;FONT SIZE=-1&gt;$^E&lt;/FONT&gt; is a duplicate of $!.

&lt;P&gt;
Finally, $? may be set to non-&lt;CODE&gt;0&lt;/CODE&gt; value if the external program 
&lt;CODE&gt;/cdrom/install&lt;/CODE&gt; fails. Upper bits of the particular value may reflect specific error conditions encountered by this program (this is program-dependent), lower-bits reflect mode of failure (segfault, completion, etc.). Note that in contrast to $@, $!, and 
&lt;FONT SIZE=-1&gt;$^E,&lt;/FONT&gt; which are set only if error condition is detected, the variable $? is set on each
 [perlfunc:wait|wait] or pipe [perlfunc:close|close], overwriting the old value.

&lt;P&gt;
For more details, see the individual descriptions at &lt;EM&gt;$@&lt;/EM&gt;, &lt;EM&gt;$!&lt;/EM&gt;, &lt;EM&gt;$^E&lt;/EM&gt;, and &lt;EM&gt;$?&lt;/EM&gt;.
&lt;HR&gt;
&lt;BR&gt;Return to the [Library]&lt;BR&gt;</field>
</data>
</node>
