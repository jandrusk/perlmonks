<?xml version="1.0" encoding="windows-1252"?>
<node id="410" title="perlman:perlipc" created="1999-08-25 02:51:29" updated="2005-08-15 07:42:59">
<type id="116">
perlman</type>
<author id="114">
gods</author>
<data>
<field name="doctext">
&lt;HR&gt;
&lt;P&gt;
&lt;H1&gt;&lt;A NAME="NAME"&gt;NAME&lt;/A&gt;&lt;/H1&gt;
&lt;P&gt;
perlipc - Perl interprocess communication (signals, fifos, pipes, safe
subprocesses, sockets, and semaphores)

&lt;P&gt;
&lt;HR&gt;
&lt;H1&gt;&lt;A NAME="DESCRIPTION"&gt;DESCRIPTION&lt;/A&gt;&lt;/H1&gt;
&lt;P&gt;
The basic 
&lt;FONT SIZE=-1&gt;IPC&lt;/FONT&gt; facilities of Perl are built out of the good old Unix signals, named pipes, pipe opens, the Berkeley socket routines, and SysV 
&lt;FONT SIZE=-1&gt;IPC&lt;/FONT&gt; calls. Each is used in slightly different situations.

&lt;P&gt;
&lt;HR&gt;
&lt;H1&gt;&lt;A NAME="Signals"&gt;Signals&lt;/A&gt;&lt;/H1&gt;
&lt;P&gt;
Perl uses a simple signal handling model: the &lt;CODE&gt;%SIG&lt;/CODE&gt; hash contains names or references of user-installed signal handlers. These handlers will be called with an argument which is the name of the signal that triggered it. 
&lt;FONT SIZE=-1&gt;A&lt;/FONT&gt; signal may be generated intentionally from a particular keyboard sequence like control-C or control-Z, sent to you from another process, or triggered automatically by the kernel when special events transpire, like a child process exiting, your process running out of stack space, or hitting file size limit.

&lt;P&gt;
For example, to trap an interrupt signal, set up a handler like this. Do as little as you possibly can in your handler; notice how all we do is set a global variable and then raise an exception. That's because on most systems, libraries are not re-entrant; particularly, memory allocation and 
&lt;FONT SIZE=-1&gt;I/O&lt;/FONT&gt; routines are not. That means that doing nearly
 &lt;EM&gt;anything&lt;/EM&gt; in your handler could in theory trigger a memory fault and subsequent core
dump.

&lt;P&gt;
&lt;PRE&gt;    sub catch_zap {
        my $signame = shift;
        $shucks++;
        die &amp;quot;Somebody sent me a SIG$signame&amp;quot;;
    }
    $SIG{INT} = 'catch_zap';  # could fail in modules
    $SIG{INT} = \&amp;amp;catch_zap;  # best strategy
&lt;/PRE&gt;
&lt;P&gt;
The names of the signals are the ones listed out by &lt;CODE&gt;kill -l&lt;/CODE&gt; on your system, or you can retrieve them from the Config module. Set up an
&lt;CODE&gt;@signame&lt;/CODE&gt; list indexed by number to get the name and a
&lt;CODE&gt;%signo&lt;/CODE&gt; table indexed by name to get the number:

&lt;P&gt;
&lt;PRE&gt;    use Config;
    defined $Config{sig_name} || die &amp;quot;No sigs?&amp;quot;;
    foreach $name (split(' ', $Config{sig_name})) {
        $signo{$name} = $i;
        $signame&amp;#091;$i&amp;#093; = $name;
        $i++;
    }
&lt;/PRE&gt;
&lt;P&gt;
So to check whether signal 17 and 
&lt;FONT SIZE=-1&gt;SIGALRM&lt;/FONT&gt; were the same, do just this:

&lt;P&gt;
&lt;PRE&gt;    print &amp;quot;signal #17 = $signame&amp;#091;17&amp;#093;\n&amp;quot;;
    if ($signo{ALRM}) {
        print &amp;quot;SIGALRM is $signo{ALRM}\n&amp;quot;;
    }
&lt;/PRE&gt;
&lt;P&gt;
You may also choose to assign the strings &lt;CODE&gt;'IGNORE'&lt;/CODE&gt; or &lt;CODE&gt;'DEFAULT'&lt;/CODE&gt; as the handler, in which case Perl will try to discard the signal or do the default thing. Some signals can be neither trapped nor ignored, such as the 
&lt;FONT SIZE=-1&gt;KILL&lt;/FONT&gt; and 
&lt;FONT SIZE=-1&gt;STOP&lt;/FONT&gt; (but not the 
&lt;FONT SIZE=-1&gt;TSTP)&lt;/FONT&gt; signals. One strategy for temporarily ignoring signals is to use a 
&lt;CODE&gt;local()&lt;/CODE&gt; statement, which will be automatically restored once your block is exited. (Remember that 
&lt;CODE&gt;local()&lt;/CODE&gt; values are ``inherited'' by functions called from within that block.)

&lt;P&gt;
&lt;PRE&gt;    sub precious {
        local $SIG{INT} = 'IGNORE';
        &amp;amp;more_functions;
    }
    sub more_functions {
        # interrupts still ignored, for now...
    }
&lt;/PRE&gt;
&lt;P&gt;
Sending a signal to a negative process 
&lt;FONT SIZE=-1&gt;ID&lt;/FONT&gt; means that you send the signal to the entire Unix process-group. This code sends a hang-up signal to all processes in the current process group (and sets 
&lt;FONT SIZE=-1&gt;$SIG{HUP}&lt;/FONT&gt; to 
&lt;FONT SIZE=-1&gt;IGNORE&lt;/FONT&gt; so it doesn't kill itself):

&lt;P&gt;
&lt;PRE&gt;    {
        local $SIG{HUP} = 'IGNORE';
        kill HUP =&amp;gt; -$$;
        # snazzy writing of: kill('HUP', -$$)
    }
&lt;/PRE&gt;
&lt;P&gt;
Another interesting signal to send is signal number zero. This doesn't actually affect another process, but instead checks whether it's alive or has changed its 
&lt;FONT SIZE=-1&gt;UID.&lt;/FONT&gt;

&lt;P&gt;
&lt;PRE&gt;    unless (kill 0 =&amp;gt; $kid_pid) {
        warn &amp;quot;something wicked happened to $kid_pid&amp;quot;;
    }
&lt;/PRE&gt;
&lt;P&gt;
You might also want to employ anonymous functions for simple signal
handlers:

&lt;P&gt;
&lt;PRE&gt;    $SIG{INT} = sub { die &amp;quot;\nOutta here!\n&amp;quot; };
&lt;/PRE&gt;
&lt;P&gt;
But that will be problematic for the more complicated handlers that need to reinstall themselves. Because Perl's signal mechanism is currently based on the 
&lt;CODE&gt;signal(3)&lt;/CODE&gt; function from the 
&lt;FONT SIZE=-1&gt;C&lt;/FONT&gt; library, you may sometimes be so misfortunate as to run on systems where that function is ``broken'', that is, it behaves in the old unreliable SysV way rather than the newer, more reasonable 
&lt;FONT SIZE=-1&gt;BSD&lt;/FONT&gt; and 
&lt;FONT SIZE=-1&gt;POSIX&lt;/FONT&gt; fashion. So you'll see defensive people writing signal handlers like this:

&lt;P&gt;
&lt;PRE&gt;    sub REAPER {
        $waitedpid = wait;
        # loathe sysV: it makes us not only reinstate
        # the handler, but place it after the wait
        $SIG{CHLD} = \&amp;amp;REAPER;
    }
    $SIG{CHLD} = \&amp;amp;REAPER;
    # now do something that forks...
&lt;/PRE&gt;
&lt;P&gt;
or even the more elaborate:

&lt;P&gt;
&lt;PRE&gt;    use POSIX &amp;quot;:sys_wait_h&amp;quot;;
    sub REAPER {
        my $child;
        while ($child = waitpid(-1,WNOHANG)) {
            $Kid_Status{$child} = $?;
        }
        $SIG{CHLD} = \&amp;amp;REAPER;  # still loathe sysV
    }
    $SIG{CHLD} = \&amp;amp;REAPER;
    # do something that forks...
&lt;/PRE&gt;
&lt;P&gt;
Signal handling is also used for timeouts in Unix, While safely protected
within an [perlfunc:eval] block, you set a signal handler to trap alarm signals and then schedule to
have one delivered to you in some number of seconds. Then try your blocking
operation, clearing the alarm when it's done but not before you've exited
your [perlfunc:eval] block. If it goes off, you'll use 
&lt;CODE&gt;die()&lt;/CODE&gt; to jump out of the block, much as you might using 
&lt;CODE&gt;longjmp()&lt;/CODE&gt; or 
&lt;CODE&gt;throw()&lt;/CODE&gt; in other languages.

&lt;P&gt;
Here's an example:

&lt;P&gt;
&lt;PRE&gt;    eval {
        local $SIG{ALRM} = sub { die &amp;quot;alarm clock restart&amp;quot; };
        alarm 10;
        flock(FH, 2);   # blocking write lock
        alarm 0;
    };
    if ($@ and $@ !~ /alarm clock restart/) { die }
&lt;/PRE&gt;
&lt;P&gt;
For more complex signal handling, you might see the standard 
&lt;FONT SIZE=-1&gt;POSIX&lt;/FONT&gt; module. Lamentably, this is almost entirely
undocumented, but the &lt;EM&gt;t/lib/posix.t&lt;/EM&gt; file from the Perl source distribution has some examples in it.

&lt;P&gt;
&lt;HR&gt;
&lt;H1&gt;&lt;A NAME="Named_Pipes"&gt;Named Pipes&lt;/A&gt;&lt;/H1&gt;
&lt;P&gt;

&lt;FONT SIZE=-1&gt;A&lt;/FONT&gt; named pipe (often referred to as a 
&lt;FONT SIZE=-1&gt;FIFO)&lt;/FONT&gt; is an old Unix 
&lt;FONT SIZE=-1&gt;IPC&lt;/FONT&gt; mechanism for processes communicating on the same machine. It works just like a regular, connected anonymous pipes, except that the processes rendezvous using a filename and don't have to be related.

&lt;P&gt;
To create a named pipe, use the Unix command 
&lt;CODE&gt;mknod(1)&lt;/CODE&gt; or on some systems, 
&lt;CODE&gt;mkfifo(1).&lt;/CODE&gt; These may not be in your normal path.

&lt;P&gt;
&lt;PRE&gt;    # system return val is backwards, so &amp;amp;&amp;amp; not ||
    #
    $ENV{PATH} .= &amp;quot;:/etc:/usr/etc&amp;quot;;
    if  (      system('mknod',  $path, 'p')
            &amp;amp;&amp;amp; system('mkfifo', $path) )
    {
        die &amp;quot;mk{nod,fifo} $path failed&amp;quot;;
    }
&lt;/PRE&gt;
&lt;P&gt;

&lt;FONT SIZE=-1&gt;A&lt;/FONT&gt; fifo is convenient when you want to connect a
process to an unrelated one. When you open a fifo, the program will block
until there's something on the other end.

&lt;P&gt;
For example, let's say you'd like to have your &lt;EM&gt;.signature&lt;/EM&gt; file be a named pipe that has a Perl program on the other end. Now every
time any program (like a mailer, news reader, finger program, etc.) tries
to read from that file, the reading program will block and your program
will supply the new signature. We'll use the pipe-checking file test &lt;STRONG&gt;-p&lt;/STRONG&gt;
to find out whether anyone (or anything) has accidentally removed our fifo.

&lt;P&gt;
&lt;PRE&gt;    chdir; # go home
    $FIFO = '.signature';
    $ENV{PATH} .= &amp;quot;:/etc:/usr/games&amp;quot;;
&lt;/PRE&gt;
&lt;P&gt;
&lt;PRE&gt;    while (1) {
        unless (-p $FIFO) {
            unlink $FIFO;
            system('mknod', $FIFO, 'p')
                &amp;amp;&amp;amp; die &amp;quot;can't mknod $FIFO: $!&amp;quot;;
        }
&lt;/PRE&gt;
&lt;P&gt;
&lt;PRE&gt;        # next line blocks until there's a reader
        open (FIFO, &amp;quot;&amp;gt; $FIFO&amp;quot;) || die &amp;quot;can't write $FIFO: $!&amp;quot;;
        print FIFO &amp;quot;John Smith (smith\@host.org)\n&amp;quot;, `fortune -s`;
        close FIFO;
        sleep 2;    # to avoid dup signals
    }
&lt;/PRE&gt;
&lt;P&gt;
&lt;HR&gt;
&lt;H2&gt;&lt;A NAME="WARNING"&gt;WARNING&lt;/A&gt;&lt;/H2&gt;
&lt;P&gt;
By installing Perl code to deal with signals, you're exposing yourself to danger from two things. First, few system library functions are re-entrant. If the signal interrupts while Perl is executing one function (like 
&lt;CODE&gt;malloc(3)&lt;/CODE&gt; or 
&lt;CODE&gt;printf(3)),&lt;/CODE&gt; and your signal handler then calls the same function again, you could get unpredictable behavior--often, a core dump. Second, Perl isn't itself re-entrant at the lowest levels. If the signal interrupts Perl while Perl is changing its own internal data structures, similarly unpredictable behaviour may result.

&lt;P&gt;
There are two things you can do, knowing this: be paranoid or be pragmatic.
The paranoid approach is to do as little as possible in your signal
handler. Set an existing integer variable that already has a value, and
return. This doesn't help you if you're in a slow system call, which will
just restart. That means you have to [perlfunc:die|die] to 
&lt;CODE&gt;longjump(3)&lt;/CODE&gt; out of the
handler. Even this is a little cavalier for the true paranoiac, who avoids [perlfunc:die|die] in a handler because the system &lt;EM&gt;is&lt;/EM&gt; out to get you. The pragmatic approach is to say 
&lt;FONT SIZE=-1&gt;``I&lt;/FONT&gt; know the risks, but prefer the convenience'', and
to do anything you want in your signal handler, prepared to clean up core
dumps now and again.

&lt;P&gt;
To forbid signal handlers altogether would bars you from many interesting programs, including virtually everything in this manpage, since you could no longer even write 
&lt;FONT SIZE=-1&gt;SIGCHLD&lt;/FONT&gt; handlers. Their dodginess is expected to be addresses in the 5.005 release.

&lt;P&gt;
&lt;HR&gt;
&lt;H1&gt;&lt;A NAME="Using_open_for_IPC"&gt;Using open() for IPC&lt;/A&gt;&lt;/H1&gt;
&lt;P&gt;
Perl's basic 
&lt;CODE&gt;open()&lt;/CODE&gt; statement can also be used for unidirectional interprocess communication by either appending or prepending a pipe symbol to the second argument to 
&lt;CODE&gt;open().&lt;/CODE&gt; Here's how to start something up in a child process you intend to write to:

&lt;P&gt;
&lt;PRE&gt;    open(SPOOLER, &amp;quot;| cat -v | lpr -h 2&amp;gt;/dev/null&amp;quot;)
                    || die &amp;quot;can't fork: $!&amp;quot;;
    local $SIG{PIPE} = sub { die &amp;quot;spooler pipe broke&amp;quot; };
    print SPOOLER &amp;quot;stuff\n&amp;quot;;
    close SPOOLER || die &amp;quot;bad spool: $! $?&amp;quot;;
&lt;/PRE&gt;
&lt;P&gt;
And here's how to start up a child process you intend to read from:

&lt;P&gt;
&lt;PRE&gt;    open(STATUS, &amp;quot;netstat -an 2&amp;gt;&amp;amp;1 |&amp;quot;)
                    || die &amp;quot;can't fork: $!&amp;quot;;
    while (&amp;lt;STATUS&amp;gt;) {
        next if /^(tcp|udp)/;
        print;
    }
    close STATUS || die &amp;quot;bad netstat: $! $?&amp;quot;;
&lt;/PRE&gt;
&lt;P&gt;
If one can be sure that a particular program is a Perl script that is expecting filenames in 
&lt;FONT SIZE=-1&gt;@ARGV,&lt;/FONT&gt; the clever programmer can write something like this:

&lt;P&gt;
&lt;PRE&gt;    % program f1 &amp;quot;cmd1|&amp;quot; - f2 &amp;quot;cmd2|&amp;quot; f3 &amp;lt; tmpfile
&lt;/PRE&gt;
&lt;P&gt;
and irrespective of which shell it's called from, the Perl program will
read from the file &lt;EM&gt;f1&lt;/EM&gt;, the process &lt;EM&gt;cmd1&lt;/EM&gt;, standard input (&lt;EM&gt;tmpfile&lt;/EM&gt;
in this case), the &lt;EM&gt;f2&lt;/EM&gt; file, the &lt;EM&gt;cmd2&lt;/EM&gt; command, and finally the &lt;EM&gt;f3&lt;/EM&gt;
file. Pretty nifty, eh?

&lt;P&gt;
You might notice that you could use backticks for much the same effect as
opening a pipe for reading:

&lt;P&gt;
&lt;PRE&gt;    print grep { !/^(tcp|udp)/ } `netstat -an 2&amp;gt;&amp;amp;1`;
    die &amp;quot;bad netstat&amp;quot; if $?;
&lt;/PRE&gt;
&lt;P&gt;
While this is true on the surface, it's much more efficient to process the
file one line or record at a time because then you don't have to read the
whole thing into memory at once. It also gives you finer control of the
whole process, letting you to kill off the child process early if you'd
like.

&lt;P&gt;
Be careful to check both the 
&lt;CODE&gt;open()&lt;/CODE&gt; and the 
&lt;CODE&gt;close()&lt;/CODE&gt; return values. If you're
 &lt;EM&gt;writing&lt;/EM&gt; to a pipe, you should also trap 
&lt;FONT SIZE=-1&gt;SIGPIPE.&lt;/FONT&gt; Otherwise, think of what happens when you start up a pipe to a command that doesn't exist: the 
&lt;CODE&gt;open()&lt;/CODE&gt; will in all likelihood succeed (it only reflects the 
&lt;CODE&gt;fork()'s&lt;/CODE&gt; success), but then your output will fail--spectacularly. Perl can't know whether the command worked because your command is actually running in a separate process whose 
&lt;CODE&gt;exec()&lt;/CODE&gt; might have failed. Therefore, while readers of bogus commands return just a quick end of file, writers to bogus command will trigger a signal they'd better be prepared to handle. Consider:

&lt;P&gt;
&lt;PRE&gt;    open(FH, &amp;quot;|bogus&amp;quot;)  or die &amp;quot;can't fork: $!&amp;quot;;
    print FH &amp;quot;bang\n&amp;quot;   or die &amp;quot;can't write: $!&amp;quot;;
    close FH            or die &amp;quot;can't close: $!&amp;quot;;
&lt;/PRE&gt;
&lt;P&gt;
That won't blow up until the close, and it will blow up with a 
&lt;FONT SIZE=-1&gt;SIGPIPE.&lt;/FONT&gt; To catch it, you could use this:

&lt;P&gt;
&lt;PRE&gt;    $SIG{PIPE} = 'IGNORE';
    open(FH, &amp;quot;|bogus&amp;quot;)  or die &amp;quot;can't fork: $!&amp;quot;;
    print FH &amp;quot;bang\n&amp;quot;   or die &amp;quot;can't write: $!&amp;quot;;
    close FH            or die &amp;quot;can't close: status=$?&amp;quot;;
&lt;/PRE&gt;
&lt;P&gt;
&lt;HR&gt;
&lt;H2&gt;&lt;A NAME="Filehandles"&gt;Filehandles&lt;/A&gt;&lt;/H2&gt;
&lt;P&gt;
Both the main process and any child processes it forks share the same 
&lt;FONT SIZE=-1&gt;STDIN,&lt;/FONT&gt; 
&lt;FONT SIZE=-1&gt;STDOUT,&lt;/FONT&gt; and 
&lt;FONT SIZE=-1&gt;STDERR&lt;/FONT&gt; filehandles. If both processes try to access them at once, strange things can happen. You'll certainly want to any stdio flush output buffers before forking. You may also want to close or reopen the filehandles for the child. You can get around this by opening your pipe with 
&lt;CODE&gt;open(),&lt;/CODE&gt; but on some systems this means that the child process cannot outlive the parent.

&lt;P&gt;
&lt;HR&gt;
&lt;H2&gt;&lt;A NAME="Background_Processes"&gt;Background Processes&lt;/A&gt;&lt;/H2&gt;
&lt;P&gt;
You can run a command in the background with:

&lt;P&gt;
&lt;PRE&gt;    system(&amp;quot;cmd &amp;amp;&amp;quot;);
&lt;/PRE&gt;
&lt;P&gt;
The command's 
&lt;FONT SIZE=-1&gt;STDOUT&lt;/FONT&gt; and 
&lt;FONT SIZE=-1&gt;STDERR&lt;/FONT&gt; (and possibly 
&lt;FONT SIZE=-1&gt;STDIN,&lt;/FONT&gt; depending on your shell) will be the same as the parent's. You won't need to catch 
&lt;FONT SIZE=-1&gt;SIGCHLD&lt;/FONT&gt; because of the double-fork taking place (see below for more details).

&lt;P&gt;
&lt;HR&gt;
&lt;H2&gt;&lt;A NAME="Complete_Dissociation_of_Child_f"&gt;Complete Dissociation of Child from Parent&lt;/A&gt;&lt;/H2&gt;
&lt;P&gt;
In some cases (starting server processes, for instance) you'll want to
complete dissociate the child process from the parent. The easiest way is
to use:

&lt;P&gt;
&lt;PRE&gt;    use POSIX qw(setsid);
    setsid()            or die &amp;quot;Can't start a new session: $!&amp;quot;;
&lt;/PRE&gt;
&lt;P&gt;
However, you may not be on 
&lt;FONT SIZE=-1&gt;POSIX.&lt;/FONT&gt; The following process is reported to work on
most Unixish systems. Non-Unix users should check their Your_OS::Process
module for other solutions.

&lt;UL&gt;
&lt;LI&gt;
&lt;P&gt;
Open /dev/tty and use the 
&lt;FONT SIZE=-1&gt;TIOCNOTTY&lt;/FONT&gt; ioctl on it. See &lt;EM&gt;tty(4)&lt;/EM&gt;
for details.

&lt;P&gt;&lt;LI&gt;

Change directory to /

&lt;P&gt;&lt;LI&gt;

Reopen 
&lt;FONT SIZE=-1&gt;STDIN,&lt;/FONT&gt; 
&lt;FONT SIZE=-1&gt;STDOUT,&lt;/FONT&gt; and 
&lt;FONT SIZE=-1&gt;STDERR&lt;/FONT&gt; so they're not connected to the old tty.

&lt;P&gt;&lt;LI&gt;

Background yourself like this:

&lt;P&gt;
&lt;PRE&gt;    fork &amp;amp;&amp;amp; exit;
&lt;/PRE&gt;
&lt;LI&gt;
&lt;P&gt;
Ignore hangup signals in case you're running on a shell that doesn't
automatically no-hup you:

&lt;P&gt;
&lt;PRE&gt;    $SIG{HUP} = 'IGNORE';       # or whatever you'd like
&lt;/PRE&gt;
&lt;/UL&gt;
&lt;P&gt;
&lt;HR&gt;
&lt;H2&gt;&lt;A NAME="Safe_Pipe_Opens"&gt;Safe Pipe Opens&lt;/A&gt;&lt;/H2&gt;
&lt;P&gt;
Another interesting approach to 
&lt;FONT SIZE=-1&gt;IPC&lt;/FONT&gt; is making your single program go multiprocess and communicate between (or even amongst) yourselves. The 
&lt;CODE&gt;open()&lt;/CODE&gt; function will accept a file argument of either
 &lt;CODE&gt;&amp;quot;-|&amp;quot;&lt;/CODE&gt; or &lt;CODE&gt;&amp;quot;|-&amp;quot;&lt;/CODE&gt;
to do a very interesting thing: it forks a child connected to the filehandle you've opened. The child is running the same program as the parent. This is useful for safely opening a file when running under an assumed 
&lt;FONT SIZE=-1&gt;UID&lt;/FONT&gt; or 
&lt;FONT SIZE=-1&gt;GID,&lt;/FONT&gt; for example. If you open a pipe
 &lt;EM&gt;to&lt;/EM&gt; minus, you can write to the filehandle you opened and your kid will find it in his 
&lt;FONT SIZE=-1&gt;STDIN.&lt;/FONT&gt; If you open a pipe
 &lt;EM&gt;from&lt;/EM&gt; minus, you can read from the filehandle you opened whatever your kid writes to his 
&lt;FONT SIZE=-1&gt;STDOUT.&lt;/FONT&gt;

&lt;P&gt;
&lt;PRE&gt;    use English;
    my $sleep_count = 0;
&lt;/PRE&gt;
&lt;P&gt;
&lt;PRE&gt;    do {
        $pid = open(KID_TO_WRITE, &amp;quot;|-&amp;quot;);
        unless (defined $pid) {
            warn &amp;quot;cannot fork: $!&amp;quot;;
            die &amp;quot;bailing out&amp;quot; if $sleep_count++ &amp;gt; 6;
            sleep 10;
        }
    } until defined $pid;
&lt;/PRE&gt;
&lt;P&gt;
&lt;PRE&gt;    if ($pid) {  # parent
        print KID_TO_WRITE @some_data;
        close(KID_TO_WRITE) || warn &amp;quot;kid exited $?&amp;quot;;
    } else {     # child
        ($EUID, $EGID) = ($UID, $GID); # suid progs only
        open (FILE, &amp;quot;&amp;gt; /safe/file&amp;quot;)
            || die &amp;quot;can't open /safe/file: $!&amp;quot;;
        while (&amp;lt;STDIN&amp;gt;) {
            print FILE; # child's STDIN is parent's KID
        }
        exit;  # don't forget this
    }
&lt;/PRE&gt;
&lt;P&gt;
Another common use for this construct is when you need to execute something without the shell's interference. With 
&lt;CODE&gt;system(),&lt;/CODE&gt; it's straightforward, but you can't use a pipe open or backticks safely. That's because there's no way to stop the shell from getting its hands on your arguments. Instead, use lower-level control to call 
&lt;CODE&gt;exec()&lt;/CODE&gt; directly.

&lt;P&gt;
Here's a safe backtick or pipe open for read:

&lt;P&gt;
&lt;PRE&gt;    # add error processing as above
    $pid = open(KID_TO_READ, &amp;quot;-|&amp;quot;);
&lt;/PRE&gt;
&lt;P&gt;
&lt;PRE&gt;    if ($pid) {   # parent
        while (&amp;lt;KID_TO_READ&amp;gt;) {
            # do something interesting
        }
        close(KID_TO_READ) || warn &amp;quot;kid exited $?&amp;quot;;
&lt;/PRE&gt;
&lt;P&gt;
&lt;PRE&gt;    } else {      # child
        ($EUID, $EGID) = ($UID, $GID); # suid only
        exec($program, @options, @args)
            || die &amp;quot;can't exec program: $!&amp;quot;;
        # NOTREACHED
    }
&lt;/PRE&gt;
&lt;P&gt;
And here's a safe pipe open for writing:

&lt;P&gt;
&lt;PRE&gt;    # add error processing as above
    $pid = open(KID_TO_WRITE, &amp;quot;|-&amp;quot;);
    $SIG{ALRM} = sub { die &amp;quot;whoops, $program pipe broke&amp;quot; };
&lt;/PRE&gt;
&lt;P&gt;
&lt;PRE&gt;    if ($pid) {  # parent
        for (@data) {
            print KID_TO_WRITE;
        }
        close(KID_TO_WRITE) || warn &amp;quot;kid exited $?&amp;quot;;
&lt;/PRE&gt;
&lt;P&gt;
&lt;PRE&gt;    } else {     # child
        ($EUID, $EGID) = ($UID, $GID);
        exec($program, @options, @args)
            || die &amp;quot;can't exec program: $!&amp;quot;;
        # NOTREACHED
    }
&lt;/PRE&gt;
&lt;P&gt;
Note that these operations are full Unix forks, which means they may not be
correctly implemented on alien systems. Additionally, these are not true
multithreading. If you'd like to learn more about threading, see the
&lt;EM&gt;modules&lt;/EM&gt; file mentioned below in the 
&lt;FONT SIZE=-1&gt;SEE&lt;/FONT&gt; 
&lt;FONT SIZE=-1&gt;ALSO&lt;/FONT&gt; section.

&lt;P&gt;
&lt;HR&gt;
&lt;H2&gt;&lt;A NAME="Bidirectional_Communication_with"&gt;Bidirectional Communication with Another Process&lt;/A&gt;&lt;/H2&gt;
&lt;P&gt;
While this works reasonably well for unidirectional communication, what
about bidirectional communication? The obvious thing you'd like to do
doesn't actually work:

&lt;P&gt;
&lt;PRE&gt;    open(PROG_FOR_READING_AND_WRITING, &amp;quot;| some program |&amp;quot;)
&lt;/PRE&gt;
&lt;P&gt;
and if you forget to use the &lt;STRONG&gt;-w&lt;/STRONG&gt; flag, then you'll miss out entirely on the diagnostic message:

&lt;P&gt;
&lt;PRE&gt;    Can't do bidirectional pipe at -e line 1.
&lt;/PRE&gt;
&lt;P&gt;
If you really want to, you can use the standard 
&lt;CODE&gt;open2()&lt;/CODE&gt; library function to catch both ends. There's also an 
&lt;CODE&gt;open3()&lt;/CODE&gt; for tridirectional 
&lt;FONT SIZE=-1&gt;I/O&lt;/FONT&gt; so you can also catch your child's 
&lt;FONT SIZE=-1&gt;STDERR,&lt;/FONT&gt; but doing so would then require an awkward 
&lt;CODE&gt;select()&lt;/CODE&gt; loop and wouldn't allow you to use normal Perl input operations.

&lt;P&gt;
If you look at its source, you'll see that 
&lt;CODE&gt;open2()&lt;/CODE&gt; uses low-level primitives like Unix 
&lt;CODE&gt;pipe()&lt;/CODE&gt; and 
&lt;CODE&gt;exec()&lt;/CODE&gt; calls to create all the connections. While it might have been slightly more efficient by using 
&lt;CODE&gt;socketpair(),&lt;/CODE&gt; it would have then been even less portable than it already is. The 
&lt;CODE&gt;open2()&lt;/CODE&gt; and 
&lt;CODE&gt;open3()&lt;/CODE&gt; functions are unlikely to work anywhere except on a Unix system or some other one purporting to be 
&lt;FONT SIZE=-1&gt;POSIX&lt;/FONT&gt; compliant.

&lt;P&gt;
Here's an example of using 
&lt;CODE&gt;open2():&lt;/CODE&gt;

&lt;P&gt;
&lt;PRE&gt;    use FileHandle;
    use IPC::Open2;
    $pid = open2(*Reader, *Writer, &amp;quot;cat -u -n&amp;quot; );
    Writer-&amp;gt;autoflush(); # default here, actually
    print Writer &amp;quot;stuff\n&amp;quot;;
    $got = &amp;lt;Reader&amp;gt;;
&lt;/PRE&gt;
&lt;P&gt;
The problem with this is that Unix buffering is really going to ruin your
day. Even though your &lt;CODE&gt;Writer&lt;/CODE&gt; filehandle is auto-flushed, and the process on the other end will get your
data in a timely manner, you can't usually do anything to force it to give
it back to you in a similarly quick fashion. In this case, we could,
because we gave &lt;EM&gt;cat&lt;/EM&gt; a &lt;STRONG&gt;-u&lt;/STRONG&gt; flag to make it unbuffered. But very few Unix commands are designed to
operate over pipes, so this seldom works unless you yourself wrote the
program on the other end of the double-ended pipe.

&lt;P&gt;

&lt;FONT SIZE=-1&gt;A&lt;/FONT&gt; solution to this is the nonstandard &lt;EM&gt;Comm.pl&lt;/EM&gt; library. It uses pseudo-ttys to make your program behave more reasonably:

&lt;P&gt;
&lt;PRE&gt;    require 'Comm.pl';
    $ph = open_proc('cat -n');
    for (1..10) {
        print $ph &amp;quot;a line\n&amp;quot;;
        print &amp;quot;got back &amp;quot;, scalar &amp;lt;$ph&amp;gt;;
    }
&lt;/PRE&gt;
&lt;P&gt;
This way you don't have to have control over the source code of the program
you're using. The &lt;EM&gt;Comm&lt;/EM&gt; library also has 
&lt;CODE&gt;expect()&lt;/CODE&gt; and 
&lt;CODE&gt;interact()&lt;/CODE&gt; functions. Find the library (and we hope its successor
 &lt;EM&gt;IPC::Chat&lt;/EM&gt;) at your nearest 
&lt;FONT SIZE=-1&gt;CPAN&lt;/FONT&gt; archive as detailed in the 
&lt;FONT SIZE=-1&gt;SEE&lt;/FONT&gt; 
&lt;FONT SIZE=-1&gt;ALSO&lt;/FONT&gt; section below.

&lt;P&gt;
The newer Expect.pm module from 
&lt;FONT SIZE=-1&gt;CPAN&lt;/FONT&gt; also addresses this kind of thing. This module requires two other modules from 
&lt;FONT SIZE=-1&gt;CPAN:&lt;/FONT&gt; IO::Pty and IO::Stty. It sets up a pseudo-terminal to interact with programs that insist on using talking to the terminal device driver. If your system is amongst those supported, this may be your best bet.

&lt;P&gt;
&lt;HR&gt;
&lt;H2&gt;&lt;A NAME="Bidirectional_Communication_with"&gt;Bidirectional Communication with Yourself&lt;/A&gt;&lt;/H2&gt;
&lt;P&gt;
If you want, you may make low-level 
&lt;CODE&gt;pipe()&lt;/CODE&gt; and 
&lt;CODE&gt;fork()&lt;/CODE&gt; to stitch this together by hand. This example only talks to itself, but you could reopen the appropriate handles to 
&lt;FONT SIZE=-1&gt;STDIN&lt;/FONT&gt; and 
&lt;FONT SIZE=-1&gt;STDOUT&lt;/FONT&gt; and call other processes.

&lt;P&gt;
&lt;PRE&gt;    #!/usr/bin/perl -w
    # pipe1 - bidirectional communication using two pipe pairs
    #         designed for the socketpair-challenged
    use IO::Handle;     # thousands of lines just for autoflush :-(
    pipe(PARENT_RDR, CHILD_WTR);                # XXX: failure?
    pipe(CHILD_RDR,  PARENT_WTR);               # XXX: failure?
    CHILD_WTR-&amp;gt;autoflush(1);
    PARENT_WTR-&amp;gt;autoflush(1);
&lt;/PRE&gt;
&lt;P&gt;
&lt;PRE&gt;    if ($pid = fork) {
        close PARENT_RDR; close PARENT_WTR;
        print CHILD_WTR &amp;quot;Parent Pid $$ is sending this\n&amp;quot;;
        chomp($line = &amp;lt;CHILD_RDR&amp;gt;);
        print &amp;quot;Parent Pid $$ just read this: `$line'\n&amp;quot;;
        close CHILD_RDR; close CHILD_WTR;
        waitpid($pid,0);
    } else {
        die &amp;quot;cannot fork: $!&amp;quot; unless defined $pid;
        close CHILD_RDR; close CHILD_WTR;
        chomp($line = &amp;lt;PARENT_RDR&amp;gt;);
        print &amp;quot;Child Pid $$ just read this: `$line'\n&amp;quot;;
        print PARENT_WTR &amp;quot;Child Pid $$ is sending this\n&amp;quot;;
        close PARENT_RDR; close PARENT_WTR;
        exit;
    }
&lt;/PRE&gt;
&lt;P&gt;
But you don't actually have to make two pipe calls. If you have the 
&lt;CODE&gt;socketpair()&lt;/CODE&gt; system call,
it will do this all for you.

&lt;P&gt;
&lt;PRE&gt;    #!/usr/bin/perl -w
    # pipe2 - bidirectional communication using socketpair
    #   &amp;quot;the best ones always go both ways&amp;quot;
&lt;/PRE&gt;
&lt;P&gt;
&lt;PRE&gt;    use Socket;
    use IO::Handle;     # thousands of lines just for autoflush :-(
    # We say AF_UNIX because although *_LOCAL is the
    # POSIX 1003.1g form of the constant, many machines
    # still don't have it.
    socketpair(CHILD, PARENT, AF_UNIX, SOCK_STREAM, PF_UNSPEC)
                                or  die &amp;quot;socketpair: $!&amp;quot;;
&lt;/PRE&gt;
&lt;P&gt;
&lt;PRE&gt;    CHILD-&amp;gt;autoflush(1);
    PARENT-&amp;gt;autoflush(1);
&lt;/PRE&gt;
&lt;P&gt;
&lt;PRE&gt;    if ($pid = fork) {
        close PARENT;
        print CHILD &amp;quot;Parent Pid $$ is sending this\n&amp;quot;;
        chomp($line = &amp;lt;CHILD&amp;gt;);
        print &amp;quot;Parent Pid $$ just read this: `$line'\n&amp;quot;;
        close CHILD;
        waitpid($pid,0);
    } else {
        die &amp;quot;cannot fork: $!&amp;quot; unless defined $pid;
        close CHILD;
        chomp($line = &amp;lt;PARENT&amp;gt;);
        print &amp;quot;Child Pid $$ just read this: `$line'\n&amp;quot;;
        print PARENT &amp;quot;Child Pid $$ is sending this\n&amp;quot;;
        close PARENT;
        exit;
    }
&lt;/PRE&gt;
&lt;P&gt;
&lt;HR&gt;
&lt;H1&gt;&lt;A NAME="Sockets_Client_Server_Communica"&gt;Sockets: Client/Server Communication&lt;/A&gt;&lt;/H1&gt;
&lt;P&gt;
While not limited to Unix-derived operating systems (e.g., WinSock on PCs provides socket support, as do some 
&lt;FONT SIZE=-1&gt;VMS&lt;/FONT&gt; libraries), you may not have sockets on your system, in which case this section probably isn't going to do you much good. With sockets, you can do both virtual circuits (i.e., 
&lt;FONT SIZE=-1&gt;TCP&lt;/FONT&gt; streams) and datagrams (i.e., 
&lt;FONT SIZE=-1&gt;UDP&lt;/FONT&gt; packets). You may be able to do even more depending on your system.

&lt;P&gt;
The Perl function calls for dealing with sockets have the same names as the corresponding system calls in 
&lt;FONT SIZE=-1&gt;C,&lt;/FONT&gt; but their arguments tend to differ for two reasons: first, Perl filehandles work differently than 
&lt;FONT SIZE=-1&gt;C&lt;/FONT&gt; file descriptors. Second, Perl already knows the length of its strings, so you don't need to pass that information.

&lt;P&gt;
One of the major problems with old socket code in Perl was that it used
hard-coded values for some of the constants, which severely hurt
portability. If you ever see code that does anything like explicitly
setting &lt;CODE&gt;$AF_INET = 2&lt;/CODE&gt;, you know you're in for big trouble: An immeasurably superior approach is
to use the &lt;CODE&gt;Socket&lt;/CODE&gt; module, which more reliably grants access to various constants and
functions you'll need.

&lt;P&gt;
If you're not writing a server/client for an existing protocol like 
&lt;FONT SIZE=-1&gt;NNTP&lt;/FONT&gt; or 
&lt;FONT SIZE=-1&gt;SMTP,&lt;/FONT&gt; you should give some thought to how your server will know when the client has finished talking, and vice-versa. Most protocols are based on one-line messages and responses (so one party knows the other has finished when a ``\n'' is received) or multi-line messages and responses that end with a period on an empty line (``\n.\n'' terminates a message/response).

&lt;P&gt;
&lt;HR&gt;
&lt;H2&gt;&lt;A NAME="Internet_Line_Terminators"&gt;Internet Line Terminators&lt;/A&gt;&lt;/H2&gt;
&lt;P&gt;
The Internet line terminator is ``\015\012''. Under 
&lt;FONT SIZE=-1&gt;ASCII&lt;/FONT&gt; variants of Unix, that could usually be written
as ``\r\n'', but under other systems, ``\r\n'' might at times be
``\015\015\012'', ``\012\012\015'', or something completely different. The
standards specify writing ``\015\012'' to be conformant (be strict in what
you provide), but they also recommend accepting a lone ``\012'' on input
(but be lenient in what you require). We haven't always been very good
about that in the code in this manpage, but unless you're on a Mac, you'll
probably be ok.

&lt;P&gt;
&lt;HR&gt;
&lt;H2&gt;&lt;A NAME="Internet_TCP_Clients_and_Servers"&gt;Internet TCP Clients and Servers&lt;/A&gt;&lt;/H2&gt;
&lt;P&gt;
Use Internet-domain sockets when you want to do client-server communication
that might extend to machines outside of your own system.

&lt;P&gt;
Here's a sample 
&lt;FONT SIZE=-1&gt;TCP&lt;/FONT&gt; client using Internet-domain sockets:

&lt;P&gt;
&lt;PRE&gt;    #!/usr/bin/perl -w
    use strict;
    use Socket;
    my ($remote,$port, $iaddr, $paddr, $proto, $line);
&lt;/PRE&gt;
&lt;P&gt;
&lt;PRE&gt;    $remote  = shift || 'localhost';
    $port    = shift || 2345;  # random port
    if ($port =~ /\D/) { $port = getservbyname($port, 'tcp') }
    die &amp;quot;No port&amp;quot; unless $port;
    $iaddr   = inet_aton($remote)               || die &amp;quot;no host: $remote&amp;quot;;
    $paddr   = sockaddr_in($port, $iaddr);
&lt;/PRE&gt;
&lt;P&gt;
&lt;PRE&gt;    $proto   = getprotobyname('tcp');
    socket(SOCK, PF_INET, SOCK_STREAM, $proto)  || die &amp;quot;socket: $!&amp;quot;;
    connect(SOCK, $paddr)    || die &amp;quot;connect: $!&amp;quot;;
    while (defined($line = &amp;lt;SOCK&amp;gt;)) {
        print $line;
    }
&lt;/PRE&gt;
&lt;P&gt;
&lt;PRE&gt;    close (SOCK)            || die &amp;quot;close: $!&amp;quot;;
    exit;
&lt;/PRE&gt;
&lt;P&gt;
And here's a corresponding server to go along with it. We'll leave the address as 
&lt;FONT SIZE=-1&gt;INADDR_ANY&lt;/FONT&gt; so that the kernel can choose the appropriate interface on multihomed hosts. If you want sit on a particular interface (like the external side of a gateway or firewall machine), you should fill this in with your real address instead.

&lt;P&gt;
&lt;PRE&gt;    #!/usr/bin/perl -Tw
    use strict;
    BEGIN { $ENV{PATH} = '/usr/ucb:/bin' }
    use Socket;
    use Carp;
    $EOL = &amp;quot;\015\012&amp;quot;;
&lt;/PRE&gt;
&lt;P&gt;
&lt;PRE&gt;    sub logmsg { print &amp;quot;$0 $$: @_ at &amp;quot;, scalar localtime, &amp;quot;\n&amp;quot; }
&lt;/PRE&gt;
&lt;P&gt;
&lt;PRE&gt;    my $port = shift || 2345;
    my $proto = getprotobyname('tcp');
    $port = $1 if $port =~ /(\d+)/; # untaint port number
&lt;/PRE&gt;
&lt;P&gt;
&lt;PRE&gt;    socket(Server, PF_INET, SOCK_STREAM, $proto)        || die &amp;quot;socket: $!&amp;quot;;
    setsockopt(Server, SOL_SOCKET, SO_REUSEADDR,
                                        pack(&amp;quot;l&amp;quot;, 1))   || die &amp;quot;setsockopt: $!&amp;quot;;
    bind(Server, sockaddr_in($port, INADDR_ANY))        || die &amp;quot;bind: $!&amp;quot;;
    listen(Server,SOMAXCONN)                            || die &amp;quot;listen: $!&amp;quot;;
&lt;/PRE&gt;
&lt;P&gt;
&lt;PRE&gt;    logmsg &amp;quot;server started on port $port&amp;quot;;
&lt;/PRE&gt;
&lt;P&gt;
&lt;PRE&gt;    my $paddr;
&lt;/PRE&gt;
&lt;P&gt;
&lt;PRE&gt;    $SIG{CHLD} = \&amp;amp;REAPER;
&lt;/PRE&gt;
&lt;P&gt;
&lt;PRE&gt;    for ( ; $paddr = accept(Client,Server); close Client) {
        my($port,$iaddr) = sockaddr_in($paddr);
        my $name = gethostbyaddr($iaddr,AF_INET);
&lt;/PRE&gt;
&lt;P&gt;
&lt;PRE&gt;        logmsg &amp;quot;connection from $name &amp;#091;&amp;quot;,
                inet_ntoa($iaddr), &amp;quot;&amp;#093;
                at port $port&amp;quot;;
&lt;/PRE&gt;
&lt;P&gt;
&lt;PRE&gt;        print Client &amp;quot;Hello there, $name, it's now &amp;quot;,
                        scalar localtime, $EOL;
    }
&lt;/PRE&gt;
&lt;P&gt;
And here's a multithreaded version. It's multithreaded in that like most
typical servers, it spawns (forks) a slave server to handle the client
request so that the master server can quickly go back to service a new
client.

&lt;P&gt;
&lt;PRE&gt;    #!/usr/bin/perl -Tw
    use strict;
    BEGIN { $ENV{PATH} = '/usr/ucb:/bin' }
    use Socket;
    use Carp;
    $EOL = &amp;quot;\015\012&amp;quot;;
&lt;/PRE&gt;
&lt;P&gt;
&lt;PRE&gt;    sub spawn;  # forward declaration
    sub logmsg { print &amp;quot;$0 $$: @_ at &amp;quot;, scalar localtime, &amp;quot;\n&amp;quot; }
&lt;/PRE&gt;
&lt;P&gt;
&lt;PRE&gt;    my $port = shift || 2345;
    my $proto = getprotobyname('tcp');
    $port = $1 if $port =~ /(\d+)/; # untaint port number
&lt;/PRE&gt;
&lt;P&gt;
&lt;PRE&gt;    socket(Server, PF_INET, SOCK_STREAM, $proto)        || die &amp;quot;socket: $!&amp;quot;;
    setsockopt(Server, SOL_SOCKET, SO_REUSEADDR,
                                        pack(&amp;quot;l&amp;quot;, 1))   || die &amp;quot;setsockopt: $!&amp;quot;;
    bind(Server, sockaddr_in($port, INADDR_ANY))        || die &amp;quot;bind: $!&amp;quot;;
    listen(Server,SOMAXCONN)                            || die &amp;quot;listen: $!&amp;quot;;
&lt;/PRE&gt;
&lt;P&gt;
&lt;PRE&gt;    logmsg &amp;quot;server started on port $port&amp;quot;;
&lt;/PRE&gt;
&lt;P&gt;
&lt;PRE&gt;    my $waitedpid = 0;
    my $paddr;
&lt;/PRE&gt;
&lt;P&gt;
&lt;PRE&gt;    sub REAPER {
        $waitedpid = wait;
        $SIG{CHLD} = \&amp;amp;REAPER;  # loathe sysV
        logmsg &amp;quot;reaped $waitedpid&amp;quot; . ($? ? &amp;quot; with exit $?&amp;quot; : '');
    }
&lt;/PRE&gt;
&lt;P&gt;
&lt;PRE&gt;    $SIG{CHLD} = \&amp;amp;REAPER;
&lt;/PRE&gt;
&lt;P&gt;
&lt;PRE&gt;    for ( $waitedpid = 0;
          ($paddr = accept(Client,Server)) || $waitedpid;
          $waitedpid = 0, close Client)
    {
        next if $waitedpid and not $paddr;
        my($port,$iaddr) = sockaddr_in($paddr);
        my $name = gethostbyaddr($iaddr,AF_INET);
&lt;/PRE&gt;
&lt;P&gt;
&lt;PRE&gt;        logmsg &amp;quot;connection from $name &amp;#091;&amp;quot;,
                inet_ntoa($iaddr), &amp;quot;&amp;#093;
                at port $port&amp;quot;;
&lt;/PRE&gt;
&lt;P&gt;
&lt;PRE&gt;        spawn sub {
            print &amp;quot;Hello there, $name, it's now &amp;quot;, scalar localtime, $EOL;
            exec '/usr/games/fortune'           # XXX: `wrong' line terminators
                or confess &amp;quot;can't exec fortune: $!&amp;quot;;
        };
&lt;/PRE&gt;
&lt;P&gt;
&lt;PRE&gt;    }
&lt;/PRE&gt;
&lt;P&gt;
&lt;PRE&gt;    sub spawn {
        my $coderef = shift;
&lt;/PRE&gt;
&lt;P&gt;
&lt;PRE&gt;        unless (@_ == 0 &amp;amp;&amp;amp; $coderef &amp;amp;&amp;amp; ref($coderef) eq 'CODE') {
            confess &amp;quot;usage: spawn CODEREF&amp;quot;;
        }
&lt;/PRE&gt;
&lt;P&gt;
&lt;PRE&gt;        my $pid;
        if (!defined($pid = fork)) {
            logmsg &amp;quot;cannot fork: $!&amp;quot;;
            return;
        } elsif ($pid) {
            logmsg &amp;quot;begat $pid&amp;quot;;
            return; # I'm the parent
        }
        # else I'm the child -- go spawn
&lt;/PRE&gt;
&lt;P&gt;
&lt;PRE&gt;        open(STDIN,  &amp;quot;&amp;lt;&amp;amp;Client&amp;quot;)   || die &amp;quot;can't dup client to stdin&amp;quot;;
        open(STDOUT, &amp;quot;&amp;gt;&amp;amp;Client&amp;quot;)   || die &amp;quot;can't dup client to stdout&amp;quot;;
        ## open(STDERR, &amp;quot;&amp;gt;&amp;amp;STDOUT&amp;quot;) || die &amp;quot;can't dup stdout to stderr&amp;quot;;
        exit &amp;amp;$coderef();
    }
&lt;/PRE&gt;
&lt;P&gt;
This server takes the trouble to clone off a child version via 
&lt;CODE&gt;fork()&lt;/CODE&gt; for each incoming request. That way it can handle many requests at once, which you might not always want. Even if you don't 
&lt;CODE&gt;fork(),&lt;/CODE&gt; the 
&lt;CODE&gt;listen()&lt;/CODE&gt; will allow that many pending connections. Forking servers have to be particularly careful about cleaning up their dead children (called ``zombies'' in Unix parlance), because otherwise you'll quickly fill up your process table.

&lt;P&gt;
We suggest that you use the &lt;STRONG&gt;-T&lt;/STRONG&gt; flag to use taint checking (see [perlman:perlsec|the perlsec manpage]) even if we aren't running setuid or setgid. This is always a good idea for servers and other programs run on behalf of someone else (like 
&lt;FONT SIZE=-1&gt;CGI&lt;/FONT&gt; scripts), because it lessens the chances that people from the outside will be able to compromise your system.

&lt;P&gt;
Let's look at another 
&lt;FONT SIZE=-1&gt;TCP&lt;/FONT&gt; client. This one connects to the 
&lt;FONT SIZE=-1&gt;TCP&lt;/FONT&gt; ``time'' service on a number of different machines and shows how far their clocks differ from the system on which it's being run:

&lt;P&gt;
&lt;PRE&gt;    #!/usr/bin/perl  -w
    use strict;
    use Socket;
&lt;/PRE&gt;
&lt;P&gt;
&lt;PRE&gt;    my $SECS_of_70_YEARS = 2208988800;
    sub ctime { scalar localtime(shift) }
&lt;/PRE&gt;
&lt;P&gt;
&lt;PRE&gt;    my $iaddr = gethostbyname('localhost');
    my $proto = getprotobyname('tcp');
    my $port = getservbyname('time', 'tcp');
    my $paddr = sockaddr_in(0, $iaddr);
    my($host);
&lt;/PRE&gt;
&lt;P&gt;
&lt;PRE&gt;    $| = 1;
    printf &amp;quot;%-24s %8s %s\n&amp;quot;,  &amp;quot;localhost&amp;quot;, 0, ctime(time());
&lt;/PRE&gt;
&lt;P&gt;
&lt;PRE&gt;    foreach $host (@ARGV) {
        printf &amp;quot;%-24s &amp;quot;, $host;
        my $hisiaddr = inet_aton($host)     || die &amp;quot;unknown host&amp;quot;;
        my $hispaddr = sockaddr_in($port, $hisiaddr);
        socket(SOCKET, PF_INET, SOCK_STREAM, $proto)   || die &amp;quot;socket: $!&amp;quot;;
        connect(SOCKET, $hispaddr)          || die &amp;quot;bind: $!&amp;quot;;
        my $rtime = '    ';
        read(SOCKET, $rtime, 4);
        close(SOCKET);
        my $histime = unpack(&amp;quot;N&amp;quot;, $rtime) - $SECS_of_70_YEARS ;
        printf &amp;quot;%8d %s\n&amp;quot;, $histime - time, ctime($histime);
    }
&lt;/PRE&gt;
&lt;P&gt;
&lt;HR&gt;
&lt;H2&gt;&lt;A NAME="Unix_Domain_TCP_Clients_and_Serv"&gt;Unix-Domain TCP Clients and Servers&lt;/A&gt;&lt;/H2&gt;
&lt;P&gt;
That's fine for Internet-domain clients and servers, but what about local communications? While you can use the same setup, sometimes you don't want to. Unix-domain sockets are local to the current host, and are often used internally to implement pipes. Unlike Internet domain sockets, Unix domain sockets can show up in the file system with an 
&lt;CODE&gt;ls(1)&lt;/CODE&gt; listing.

&lt;P&gt;
&lt;PRE&gt;    % ls -l /dev/log
    srw-rw-rw-  1 root            0 Oct 31 07:23 /dev/log
&lt;/PRE&gt;
&lt;P&gt;
You can test for these with Perl's &lt;STRONG&gt;-S&lt;/STRONG&gt; file test:

&lt;P&gt;
&lt;PRE&gt;    unless ( -S '/dev/log' ) {
        die &amp;quot;something's wicked with the print system&amp;quot;;
    }
&lt;/PRE&gt;
&lt;P&gt;
Here's a sample Unix-domain client:

&lt;P&gt;
&lt;PRE&gt;    #!/usr/bin/perl -w
    use Socket;
    use strict;
    my ($rendezvous, $line);
&lt;/PRE&gt;
&lt;P&gt;
&lt;PRE&gt;    $rendezvous = shift || '/tmp/catsock';
    socket(SOCK, PF_UNIX, SOCK_STREAM, 0)       || die &amp;quot;socket: $!&amp;quot;;
    connect(SOCK, sockaddr_un($rendezvous))     || die &amp;quot;connect: $!&amp;quot;;
    while (defined($line = &amp;lt;SOCK&amp;gt;)) {
        print $line;
    }
    exit;
&lt;/PRE&gt;
&lt;P&gt;
And here's a corresponding server. You don't have to worry about silly
network terminators here because Unix domain sockets are guaranteed to be
on the localhost, and thus everything works right.

&lt;P&gt;
&lt;PRE&gt;    #!/usr/bin/perl -Tw
    use strict;
    use Socket;
    use Carp;
&lt;/PRE&gt;
&lt;P&gt;
&lt;PRE&gt;    BEGIN { $ENV{PATH} = '/usr/ucb:/bin' }
    sub logmsg { print &amp;quot;$0 $$: @_ at &amp;quot;, scalar localtime, &amp;quot;\n&amp;quot; }
&lt;/PRE&gt;
&lt;P&gt;
&lt;PRE&gt;    my $NAME = '/tmp/catsock';
    my $uaddr = sockaddr_un($NAME);
    my $proto = getprotobyname('tcp');
&lt;/PRE&gt;
&lt;P&gt;
&lt;PRE&gt;    socket(Server,PF_UNIX,SOCK_STREAM,0)        || die &amp;quot;socket: $!&amp;quot;;
    unlink($NAME);
    bind  (Server, $uaddr)                      || die &amp;quot;bind: $!&amp;quot;;
    listen(Server,SOMAXCONN)                    || die &amp;quot;listen: $!&amp;quot;;
&lt;/PRE&gt;
&lt;P&gt;
&lt;PRE&gt;    logmsg &amp;quot;server started on $NAME&amp;quot;;
&lt;/PRE&gt;
&lt;P&gt;
&lt;PRE&gt;    my $waitedpid;
&lt;/PRE&gt;
&lt;P&gt;
&lt;PRE&gt;    sub REAPER {
        $waitedpid = wait;
        $SIG{CHLD} = \&amp;amp;REAPER;  # loathe sysV
        logmsg &amp;quot;reaped $waitedpid&amp;quot; . ($? ? &amp;quot; with exit $?&amp;quot; : '');
    }
&lt;/PRE&gt;
&lt;P&gt;
&lt;PRE&gt;    $SIG{CHLD} = \&amp;amp;REAPER;
&lt;/PRE&gt;
&lt;P&gt;
&lt;PRE&gt;    for ( $waitedpid = 0;
          accept(Client,Server) || $waitedpid;
          $waitedpid = 0, close Client)
    {
        next if $waitedpid;
        logmsg &amp;quot;connection on $NAME&amp;quot;;
        spawn sub {
            print &amp;quot;Hello there, it's now &amp;quot;, scalar localtime, &amp;quot;\n&amp;quot;;
            exec '/usr/games/fortune' or die &amp;quot;can't exec fortune: $!&amp;quot;;
        };
    }
&lt;/PRE&gt;
&lt;P&gt;
As you see, it's remarkably similar to the Internet domain 
&lt;FONT SIZE=-1&gt;TCP&lt;/FONT&gt; server, so much so, in fact, that we've omitted several duplicate functions--spawn(), 
&lt;CODE&gt;logmsg(),&lt;/CODE&gt; 
&lt;CODE&gt;ctime(),&lt;/CODE&gt; and 
&lt;CODE&gt;REAPER()--which&lt;/CODE&gt; are exactly the same as in the other server.

&lt;P&gt;
So why would you ever want to use a Unix domain socket instead of a simpler named pipe? Because a named pipe doesn't give you sessions. You can't tell one process's data from another's. With socket programming, you get a separate session for each client: that's why 
&lt;CODE&gt;accept()&lt;/CODE&gt; takes two arguments.

&lt;P&gt;
For example, let's say that you have a long running database server daemon that you want folks from the World Wide Web to be able to access, but only if they go through a 
&lt;FONT SIZE=-1&gt;CGI&lt;/FONT&gt; interface. You'd have a small, simple 
&lt;FONT SIZE=-1&gt;CGI&lt;/FONT&gt; program that does whatever checks and logging you feel like, and then acts as a Unix-domain client and connects to your private server.

&lt;P&gt;
&lt;HR&gt;
&lt;H1&gt;&lt;A NAME="TCP_Clients_with_IO_Socket"&gt;TCP Clients with IO::Socket&lt;/A&gt;&lt;/H1&gt;
&lt;P&gt;
For those preferring a higher-level interface to socket programming, the IO::Socket module provides an object-oriented approach. IO::Socket is included as part of the standard Perl distribution as of the 5.004 release. If you're running an earlier version of Perl, just fetch IO::Socket from 
&lt;FONT SIZE=-1&gt;CPAN,&lt;/FONT&gt; where you'll also find find modules providing easy interfaces to the following systems: 
&lt;FONT SIZE=-1&gt;DNS,&lt;/FONT&gt; 
&lt;FONT SIZE=-1&gt;FTP,&lt;/FONT&gt; Ident 
&lt;FONT SIZE=-1&gt;(RFC&lt;/FONT&gt; 931), 
&lt;FONT SIZE=-1&gt;NIS&lt;/FONT&gt; and NISPlus, 
&lt;FONT SIZE=-1&gt;NNTP,&lt;/FONT&gt; Ping, 
&lt;FONT SIZE=-1&gt;POP3,&lt;/FONT&gt; 
&lt;FONT SIZE=-1&gt;SMTP,&lt;/FONT&gt; 
&lt;FONT SIZE=-1&gt;SNMP,&lt;/FONT&gt; SSLeay, Telnet, and Time--just to name a few.

&lt;P&gt;
&lt;HR&gt;
&lt;H2&gt;&lt;A NAME="A_Simple_Client"&gt;A Simple Client&lt;/A&gt;&lt;/H2&gt;
&lt;P&gt;
Here's a client that creates a 
&lt;FONT SIZE=-1&gt;TCP&lt;/FONT&gt; connection to the ``daytime'' service at port 13
of the host name ``localhost'' and prints out everything that the server
there cares to provide.

&lt;P&gt;
&lt;PRE&gt;    #!/usr/bin/perl -w
    use IO::Socket;
    $remote = IO::Socket::INET-&amp;gt;new(
                        Proto    =&amp;gt; &amp;quot;tcp&amp;quot;,
                        PeerAddr =&amp;gt; &amp;quot;localhost&amp;quot;,
                        PeerPort =&amp;gt; &amp;quot;daytime(13)&amp;quot;,
                    )
                  or die &amp;quot;cannot connect to daytime port at localhost&amp;quot;;
    while ( &amp;lt;$remote&amp;gt; ) { print }
&lt;/PRE&gt;
&lt;P&gt;
When you run this program, you should get something back that looks like
this:

&lt;P&gt;
&lt;PRE&gt;    Wed May 14 08:40:46 MDT 1997
&lt;/PRE&gt;
&lt;P&gt;
Here are what those parameters to the &lt;CODE&gt;new&lt;/CODE&gt; constructor mean:

&lt;DL&gt;
&lt;DT&gt;&lt;STRONG&gt;&lt;A NAME="item_Proto"&gt;Proto&lt;/A&gt;&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;
This is which protocol to use. In this case, the socket handle returned will be connected to a 
&lt;FONT SIZE=-1&gt;TCP&lt;/FONT&gt; socket, because we want a stream-oriented connection, that is, one that acts pretty much like a plain old file. Not all sockets are this of this type. For example, the 
&lt;FONT SIZE=-1&gt;UDP&lt;/FONT&gt; protocol can be used to make a datagram socket, used for message-passing.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;&lt;A NAME="item_PeerAddr"&gt;PeerAddr&lt;/A&gt;&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;
This is the name or Internet address of the remote host the server is
running on. We could have specified a longer name like &lt;CODE&gt;&amp;quot;www.perl.com&amp;quot;&lt;/CODE&gt;, or an address like &lt;CODE&gt;&amp;quot;204.148.40.9&amp;quot;&lt;/CODE&gt;. For demonstration purposes, we've used the special hostname &lt;CODE&gt;&amp;quot;localhost&amp;quot;&lt;/CODE&gt;, which should always mean the current machine you're running on. The
corresponding Internet address for localhost is &lt;CODE&gt;&amp;quot;127.1&amp;quot;&lt;/CODE&gt;, if you'd rather use that.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;&lt;A NAME="item_PeerPort"&gt;PeerPort&lt;/A&gt;&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;
This is the service name or port number we'd like to connect to. We could
have gotten away with using just &lt;CODE&gt;&amp;quot;daytime&amp;quot;&lt;/CODE&gt; on systems with a well-configured system services file,&amp;#091;FOOTNOTE: The
system services file is in &lt;EM&gt;/etc/services&lt;/EM&gt; under Unix&amp;#093; but just in case, we've specified the port number (13) in
parentheses. Using just the number would also have worked, but constant
numbers make careful programmers nervous.

&lt;/DL&gt;
&lt;P&gt;
Notice how the return value from the &lt;CODE&gt;new&lt;/CODE&gt; constructor is used as a filehandle in the &lt;CODE&gt;while&lt;/CODE&gt; loop? That's what's called an indirect filehandle, a scalar variable
containing a filehandle. You can use it the same way you would a normal
filehandle. For example, you can read one line from it this way:

&lt;P&gt;
&lt;PRE&gt;    $line = &amp;lt;$handle&amp;gt;;
&lt;/PRE&gt;
&lt;P&gt;
all remaining lines from is this way:

&lt;P&gt;
&lt;PRE&gt;    @lines = &amp;lt;$handle&amp;gt;;
&lt;/PRE&gt;
&lt;P&gt;
and send a line of data to it this way:

&lt;P&gt;
&lt;PRE&gt;    print $handle &amp;quot;some data\n&amp;quot;;
&lt;/PRE&gt;
&lt;P&gt;
&lt;HR&gt;
&lt;H2&gt;&lt;A NAME="A_Webget_Client"&gt;A Webget Client&lt;/A&gt;&lt;/H2&gt;
&lt;P&gt;
Here's a simple client that takes a remote host to fetch a document from,
and then a list of documents to get from that host. This is a more
interesting client than the previous one because it first sends something
to the server before fetching the server's response.

&lt;P&gt;
&lt;PRE&gt;    #!/usr/bin/perl -w
    use IO::Socket;
    unless (@ARGV &amp;gt; 1) { die &amp;quot;usage: $0 host document ...&amp;quot; }
    $host = shift(@ARGV);
    $EOL = &amp;quot;\015\012&amp;quot;;
    $BLANK = $EOL x 2;
    foreach $document ( @ARGV ) {
        $remote = IO::Socket::INET-&amp;gt;new( Proto     =&amp;gt; &amp;quot;tcp&amp;quot;,
                                         PeerAddr  =&amp;gt; $host,
                                         PeerPort  =&amp;gt; &amp;quot;http(80)&amp;quot;,
                                        );
        unless ($remote) { die &amp;quot;cannot connect to http daemon on $host&amp;quot; }
        $remote-&amp;gt;autoflush(1);
        print $remote &amp;quot;GET $document HTTP/1.0&amp;quot; . $BLANK;
        while ( &amp;lt;$remote&amp;gt; ) { print }
        close $remote;
    }
&lt;/PRE&gt;
&lt;P&gt;
The web server handing the ``http'' service, which is assumed to be at its
standard port, number 80. If your the web server you're trying to connect
to is at a different port (like 1080 or 8080), you should specify as the
named-parameter pair, &lt;CODE&gt;PeerPort =&amp;gt; 8080&lt;/CODE&gt;. The [perlman:perlvar]
method is used on the socket because otherwise the system would buffer up
the output we sent it. (If you're on a Mac, you'll also need to change
every &lt;CODE&gt;&amp;quot;\n&amp;quot;&lt;/CODE&gt; in your code that sends data over the network to be a &lt;CODE&gt;&amp;quot;\015\012&amp;quot;&lt;/CODE&gt; instead.)

&lt;P&gt;
Connecting to the server is only the first part of the process: once you have the connection, you have to use the server's language. Each server on the network has its own little command language that it expects as input. The string that we send to the server starting with 
&lt;FONT SIZE=-1&gt;``GET''&lt;/FONT&gt; is in 
&lt;FONT SIZE=-1&gt;HTTP&lt;/FONT&gt; syntax. In this case, we simply request each specified document. Yes, we really are making a new connection for each document, even though it's the same host. That's the way you always used to have to speak 
&lt;FONT SIZE=-1&gt;HTTP.&lt;/FONT&gt; Recent versions of web browsers may request that the remote server leave the connection open a little while, but the server doesn't have to honor such a request.

&lt;P&gt;
Here's an example of running that program, which we'll call &lt;EM&gt;webget&lt;/EM&gt;:

&lt;P&gt;
&lt;PRE&gt;    % webget www.perl.com /guanaco.html
    HTTP/1.1 404 File Not Found
    Date: Thu, 08 May 1997 18:02:32 GMT
    Server: Apache/1.2b6
    Connection: close
    Content-type: text/html
&lt;/PRE&gt;
&lt;P&gt;
&lt;PRE&gt;    &amp;lt;HEAD&amp;gt;&amp;lt;TITLE&amp;gt;404 File Not Found&amp;lt;/TITLE&amp;gt;&amp;lt;/HEAD&amp;gt;
    &amp;lt;BODY&amp;gt;&amp;lt;H1&amp;gt;File Not Found&amp;lt;/H1&amp;gt;
    The requested URL /guanaco.html was not found on this server.&amp;lt;P&amp;gt;
    &amp;lt;/BODY&amp;gt;
&lt;/PRE&gt;
&lt;P&gt;
Ok, so that's not very interesting, because it didn't find that particular
document. But a long response wouldn't have fit on this page.

&lt;P&gt;
For a more fully-featured version of this program, you should look to the &lt;EM&gt;lwp-request&lt;/EM&gt; program included with the 
&lt;FONT SIZE=-1&gt;LWP&lt;/FONT&gt; modules from 
&lt;FONT SIZE=-1&gt;CPAN.&lt;/FONT&gt;

&lt;P&gt;
&lt;HR&gt;
&lt;H2&gt;&lt;A NAME="Interactive_Client_with_IO_Sock"&gt;Interactive Client with IO::Socket&lt;/A&gt;&lt;/H2&gt;
&lt;P&gt;
Well, that's all fine if you want to send one command and get one answer,
but what about setting up something fully interactive, somewhat like the
way &lt;EM&gt;telnet&lt;/EM&gt; works? That way you can type a line, get the answer, type a line, get the
answer, etc.

&lt;P&gt;
This client is more complicated than the two we've done so far, but if
you're on a system that supports the powerful [perlfunc:fork|fork] call, the solution isn't that rough. Once you've made the connection to
whatever service you'd like to chat with, call [perlfunc:fork|fork] to clone your process. Each of these two identical process has a very
simple job to do: the parent copies everything from the socket to standard
output, while the child simultaneously copies everything from standard
input to the socket. To accomplish the same thing using just one process
would be &lt;EM&gt;much&lt;/EM&gt;
harder, because it's easier to code two processes to do one thing than it
is to code one process to do two things. (This keep-it-simple principle a
cornerstones of the Unix philosophy, and good software engineering as well,
which is probably why it's spread to other systems.)

&lt;P&gt;
Here's the code:

&lt;P&gt;
&lt;PRE&gt;    #!/usr/bin/perl -w
    use strict;
    use IO::Socket;
    my ($host, $port, $kidpid, $handle, $line);
&lt;/PRE&gt;
&lt;P&gt;
&lt;PRE&gt;    unless (@ARGV == 2) { die &amp;quot;usage: $0 host port&amp;quot; }
    ($host, $port) = @ARGV;
&lt;/PRE&gt;
&lt;P&gt;
&lt;PRE&gt;    # create a tcp connection to the specified host and port
    $handle = IO::Socket::INET-&amp;gt;new(Proto     =&amp;gt; &amp;quot;tcp&amp;quot;,
                                    PeerAddr  =&amp;gt; $host,
                                    PeerPort  =&amp;gt; $port)
           or die &amp;quot;can't connect to port $port on $host: $!&amp;quot;;
&lt;/PRE&gt;
&lt;P&gt;
&lt;PRE&gt;    $handle-&amp;gt;autoflush(1);              # so output gets there right away
    print STDERR &amp;quot;&amp;#091;Connected to $host:$port&amp;#093;\n&amp;quot;;
&lt;/PRE&gt;
&lt;P&gt;
&lt;PRE&gt;    # split the program into two processes, identical twins
    die &amp;quot;can't fork: $!&amp;quot; unless defined($kidpid = fork());
&lt;/PRE&gt;
&lt;P&gt;
&lt;PRE&gt;    # the if{} block runs only in the parent process
    if ($kidpid) {
        # copy the socket to standard output
        while (defined ($line = &amp;lt;$handle&amp;gt;)) {
            print STDOUT $line;
        }
        kill(&amp;quot;TERM&amp;quot;, $kidpid);                  # send SIGTERM to child
    }
    # the else{} block runs only in the child process
    else {
        # copy standard input to the socket
        while (defined ($line = &amp;lt;STDIN&amp;gt;)) {
            print $handle $line;
        }
    }
&lt;/PRE&gt;
&lt;P&gt;
The [perlfunc:kill|kill] function in the parent's &lt;CODE&gt;if&lt;/CODE&gt; block is there to send a signal to our child process (current running in
the &lt;CODE&gt;else&lt;/CODE&gt; block) as soon as the remote server has closed its end of the connection.

&lt;P&gt;
If the remote server sends data a byte at time, and you need that data
immediately without waiting for a newline (which might not happen), you may
wish to replace the &lt;CODE&gt;while&lt;/CODE&gt; loop in the parent with the following:

&lt;P&gt;
&lt;PRE&gt;    my $byte;
    while (sysread($handle, $byte, 1) == 1) {
        print STDOUT $byte;
    }
&lt;/PRE&gt;
&lt;P&gt;
Making a system call for each byte you want to read is not very efficient
(to put it mildly) but is the simplest to explain and works reasonably
well.

&lt;P&gt;
&lt;HR&gt;
&lt;H1&gt;&lt;A NAME="TCP_Servers_with_IO_Socket"&gt;TCP Servers with IO::Socket&lt;/A&gt;&lt;/H1&gt;
&lt;P&gt;
As always, setting up a server is little bit more involved than running a
client. The model is that the server creates a special kind of socket that
does nothing but listen on a particular port for incoming connections. It
does this by calling the &lt;CODE&gt;IO::Socket::INET-&amp;gt;new()&lt;/CODE&gt; method with slightly different arguments than the client did.

&lt;DL&gt;
&lt;DT&gt;&lt;STRONG&gt;Proto&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;
This is which protocol to use. Like our clients, we'll still specify &lt;CODE&gt;&amp;quot;tcp&amp;quot;&lt;/CODE&gt; here.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;&lt;A NAME="item_LocalPort"&gt;LocalPort&lt;/A&gt;&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;
We specify a local port in the &lt;CODE&gt;LocalPort&lt;/CODE&gt; argument, which we didn't do for the client. This is service name or port
number for which you want to be the server. (Under Unix, ports under 1024
are restricted to the superuser.) In our sample, we'll use port 9000, but
you can use any port that's not currently in use on your system. If you try
to use one already in used, you'll get an ``Address already in use''
message. Under Unix, the &lt;CODE&gt;netstat -a&lt;/CODE&gt; command will show which services current have servers.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;&lt;A NAME="item_Listen"&gt;Listen&lt;/A&gt;&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;
The &lt;CODE&gt;Listen&lt;/CODE&gt; parameter is set to the maximum number of pending connections we can accept until we turn away incoming clients. Think of it as a call-waiting queue for your telephone. The low-level Socket module has a special symbol for the system maximum, which is 
&lt;FONT SIZE=-1&gt;SOMAXCONN.&lt;/FONT&gt;

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;&lt;A NAME="item_Reuse"&gt;Reuse&lt;/A&gt;&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;
The &lt;CODE&gt;Reuse&lt;/CODE&gt; parameter is needed so that we restart our server manually without waiting
a few minutes to allow system buffers to clear out.

&lt;/DL&gt;
&lt;P&gt;
Once the generic server socket has been created using the parameters listed
above, the server then waits for a new client to connect to it. The server
blocks in the [perlfunc:accept|accept] method, which eventually an bidirectional connection to the remote client.
(Make sure to autoflush this handle to circumvent buffering.)

&lt;P&gt;
To add to user-friendliness, our server prompts the user for commands. Most
servers don't do this. Because of the prompt without a newline, you'll have
to use the [perlfunc:sysread|sysread] variant of the interactive client above.

&lt;P&gt;
This server accepts one of five different commands, sending output back to
the client. Note that unlike most network servers, this one only handles
one incoming client at a time. Multithreaded servers are covered in Chapter
6 of the Camel as well as later in this manpage.

&lt;P&gt;
Here's the code. We'll

&lt;P&gt;
&lt;PRE&gt; #!/usr/bin/perl -w
 use IO::Socket;
 use Net::hostent;              # for OO version of gethostbyaddr
&lt;/PRE&gt;
&lt;P&gt;
&lt;PRE&gt; $PORT = 9000;                  # pick something not in use
&lt;/PRE&gt;
&lt;P&gt;
&lt;PRE&gt; $server = IO::Socket::INET-&amp;gt;new( Proto     =&amp;gt; 'tcp',
                                  LocalPort =&amp;gt; $PORT,
                                  Listen    =&amp;gt; SOMAXCONN,
                                  Reuse     =&amp;gt; 1);
&lt;/PRE&gt;
&lt;P&gt;
&lt;PRE&gt; die &amp;quot;can't setup server&amp;quot; unless $server;
 print &amp;quot;&amp;#091;Server $0 accepting clients&amp;#093;\n&amp;quot;;
&lt;/PRE&gt;
&lt;P&gt;
&lt;PRE&gt; while ($client = $server-&amp;gt;accept()) {
   $client-&amp;gt;autoflush(1);
   print $client &amp;quot;Welcome to $0; type help for command list.\n&amp;quot;;
   $hostinfo = gethostbyaddr($client-&amp;gt;peeraddr);
   printf &amp;quot;&amp;#091;Connect from %s&amp;#093;\n&amp;quot;, $hostinfo-&amp;gt;name || $client-&amp;gt;peerhost;
   print $client &amp;quot;Command? &amp;quot;;
   while ( &amp;lt;$client&amp;gt;) {
     next unless /\S/;       # blank line
     if    (/quit|exit/i)    { last;                                     }
     elsif (/date|time/i)    { printf $client &amp;quot;%s\n&amp;quot;, scalar localtime;  }
     elsif (/who/i )         { print  $client `who 2&amp;gt;&amp;amp;1`;                }
     elsif (/cookie/i )      { print  $client `/usr/games/fortune 2&amp;gt;&amp;amp;1`; }
     elsif (/motd/i )        { print  $client `cat /etc/motd 2&amp;gt;&amp;amp;1`;      }
     else {
       print $client &amp;quot;Commands: quit date who cookie motd\n&amp;quot;;
     }
   } continue {
      print $client &amp;quot;Command? &amp;quot;;
   }
   close $client;
 }
&lt;/PRE&gt;
&lt;P&gt;
&lt;HR&gt;
&lt;H1&gt;&lt;A NAME="UDP_Message_Passing"&gt;UDP: Message Passing&lt;/A&gt;&lt;/H1&gt;
&lt;P&gt;
Another kind of client-server setup is one that uses not connections, but messages. 
&lt;FONT SIZE=-1&gt;UDP&lt;/FONT&gt; communications involve much lower overhead but also provide less reliability, as there are no promises that messages will arrive at all, let alone in order and unmangled. Still, 
&lt;FONT SIZE=-1&gt;UDP&lt;/FONT&gt; offers some advantages over 
&lt;FONT SIZE=-1&gt;TCP,&lt;/FONT&gt; including being able to ``broadcast'' or ``multicast'' to a whole bunch of destination hosts at once (usually on your local subnet). If you find yourself overly concerned about reliability and start building checks into your message system, then you probably should use just 
&lt;FONT SIZE=-1&gt;TCP&lt;/FONT&gt; to start with.

&lt;P&gt;
Here's a 
&lt;FONT SIZE=-1&gt;UDP&lt;/FONT&gt; program similar to the sample Internet 
&lt;FONT SIZE=-1&gt;TCP&lt;/FONT&gt; client given earlier. However, instead of checking one host at a time, the 
&lt;FONT SIZE=-1&gt;UDP&lt;/FONT&gt; version will check many of them asynchronously by simulating a multicast and then using 
&lt;CODE&gt;select()&lt;/CODE&gt; to do a timed-out wait for 
&lt;FONT SIZE=-1&gt;I/O.&lt;/FONT&gt; To do something similar with 
&lt;FONT SIZE=-1&gt;TCP,&lt;/FONT&gt; you'd have to use a different socket handle for each host.

&lt;P&gt;
&lt;PRE&gt;    #!/usr/bin/perl -w
    use strict;
    use Socket;
    use Sys::Hostname;
&lt;/PRE&gt;
&lt;P&gt;
&lt;PRE&gt;    my ( $count, $hisiaddr, $hispaddr, $histime,
         $host, $iaddr, $paddr, $port, $proto,
         $rin, $rout, $rtime, $SECS_of_70_YEARS);
&lt;/PRE&gt;
&lt;P&gt;
&lt;PRE&gt;    $SECS_of_70_YEARS      = 2208988800;
&lt;/PRE&gt;
&lt;P&gt;
&lt;PRE&gt;    $iaddr = gethostbyname(hostname());
    $proto = getprotobyname('udp');
    $port = getservbyname('time', 'udp');
    $paddr = sockaddr_in(0, $iaddr); # 0 means let kernel pick
&lt;/PRE&gt;
&lt;P&gt;
&lt;PRE&gt;    socket(SOCKET, PF_INET, SOCK_DGRAM, $proto)   || die &amp;quot;socket: $!&amp;quot;;
    bind(SOCKET, $paddr)                          || die &amp;quot;bind: $!&amp;quot;;
&lt;/PRE&gt;
&lt;P&gt;
&lt;PRE&gt;    $| = 1;
    printf &amp;quot;%-12s %8s %s\n&amp;quot;,  &amp;quot;localhost&amp;quot;, 0, scalar localtime time;
    $count = 0;
    for $host (@ARGV) {
        $count++;
        $hisiaddr = inet_aton($host)    || die &amp;quot;unknown host&amp;quot;;
        $hispaddr = sockaddr_in($port, $hisiaddr);
        defined(send(SOCKET, 0, 0, $hispaddr))    || die &amp;quot;send $host: $!&amp;quot;;
    }
&lt;/PRE&gt;
&lt;P&gt;
&lt;PRE&gt;    $rin = '';
    vec($rin, fileno(SOCKET), 1) = 1;
&lt;/PRE&gt;
&lt;P&gt;
&lt;PRE&gt;    # timeout after 10.0 seconds
    while ($count &amp;amp;&amp;amp; select($rout = $rin, undef, undef, 10.0)) {
        $rtime = '';
        ($hispaddr = recv(SOCKET, $rtime, 4, 0))        || die &amp;quot;recv: $!&amp;quot;;
        ($port, $hisiaddr) = sockaddr_in($hispaddr);
        $host = gethostbyaddr($hisiaddr, AF_INET);
        $histime = unpack(&amp;quot;N&amp;quot;, $rtime) - $SECS_of_70_YEARS ;
        printf &amp;quot;%-12s &amp;quot;, $host;
        printf &amp;quot;%8d %s\n&amp;quot;, $histime - time, scalar localtime($histime);
        $count--;
    }
&lt;/PRE&gt;
&lt;P&gt;
&lt;HR&gt;
&lt;H1&gt;&lt;A NAME="SysV_IPC"&gt;SysV IPC&lt;/A&gt;&lt;/H1&gt;
&lt;P&gt;
While System 
&lt;FONT SIZE=-1&gt;V&lt;/FONT&gt; 
&lt;FONT SIZE=-1&gt;IPC&lt;/FONT&gt; isn't so widely used as sockets, it still has some interesting uses. You can't, however, effectively use SysV 
&lt;FONT SIZE=-1&gt;IPC&lt;/FONT&gt; or Berkeley 
&lt;CODE&gt;mmap()&lt;/CODE&gt; to have shared memory so as to share a variable amongst several processes. That's because Perl would reallocate your string when you weren't wanting it to.

&lt;P&gt;
Here's a small example showing shared memory usage.

&lt;P&gt;
&lt;PRE&gt;    use IPC::SysV qw(IPC_PRIVATE IPC_RMID S_IRWXU S_IRWXG S_IRWXO);
&lt;/PRE&gt;
&lt;P&gt;
&lt;PRE&gt;    $size = 2000;
    $key = shmget(IPC_PRIVATE, $size, S_IRWXU|S_IRWXG|S_IRWXO) || die &amp;quot;$!&amp;quot;;
    print &amp;quot;shm key $key\n&amp;quot;;
&lt;/PRE&gt;
&lt;P&gt;
&lt;PRE&gt;    $message = &amp;quot;Message #1&amp;quot;;
    shmwrite($key, $message, 0, 60) || die &amp;quot;$!&amp;quot;;
    print &amp;quot;wrote: '$message'\n&amp;quot;;
    shmread($key, $buff, 0, 60) || die &amp;quot;$!&amp;quot;;
    print &amp;quot;read : '$buff'\n&amp;quot;;
&lt;/PRE&gt;
&lt;P&gt;
&lt;PRE&gt;    # the buffer of shmread is zero-character end-padded.
    substr($buff, index($buff, &amp;quot;\0&amp;quot;)) = '';
    print &amp;quot;un&amp;quot; unless $buff eq $message;
    print &amp;quot;swell\n&amp;quot;;
&lt;/PRE&gt;
&lt;P&gt;
&lt;PRE&gt;    print &amp;quot;deleting shm $key\n&amp;quot;;
    shmctl($key, IPC_RMID, 0) || die &amp;quot;$!&amp;quot;;
&lt;/PRE&gt;
&lt;P&gt;
Here's an example of a semaphore:

&lt;P&gt;
&lt;PRE&gt;    use IPC::SysV qw(IPC_CREAT);
&lt;/PRE&gt;
&lt;P&gt;
&lt;PRE&gt;    $IPC_KEY = 1234;
    $key = semget($IPC_KEY, 10, 0666 | IPC_CREAT ) || die &amp;quot;$!&amp;quot;;
    print &amp;quot;shm key $key\n&amp;quot;;
&lt;/PRE&gt;
&lt;P&gt;
Put this code in a separate file to be run in more than one process. Call
the file &lt;EM&gt;take&lt;/EM&gt;:

&lt;P&gt;
&lt;PRE&gt;    # create a semaphore
&lt;/PRE&gt;
&lt;P&gt;
&lt;PRE&gt;    $IPC_KEY = 1234;
    $key = semget($IPC_KEY,  0 , 0 );
    die if !defined($key);
&lt;/PRE&gt;
&lt;P&gt;
&lt;PRE&gt;    $semnum = 0;
    $semflag = 0;
&lt;/PRE&gt;
&lt;P&gt;
&lt;PRE&gt;    # 'take' semaphore
    # wait for semaphore to be zero
    $semop = 0;
    $opstring1 = pack(&amp;quot;sss&amp;quot;, $semnum, $semop, $semflag);
&lt;/PRE&gt;
&lt;P&gt;
&lt;PRE&gt;    # Increment the semaphore count
    $semop = 1;
    $opstring2 = pack(&amp;quot;sss&amp;quot;, $semnum, $semop,  $semflag);
    $opstring = $opstring1 . $opstring2;
&lt;/PRE&gt;
&lt;P&gt;
&lt;PRE&gt;    semop($key,$opstring) || die &amp;quot;$!&amp;quot;;
&lt;/PRE&gt;
&lt;P&gt;
Put this code in a separate file to be run in more than one process. Call
this file &lt;EM&gt;give&lt;/EM&gt;:

&lt;P&gt;
&lt;PRE&gt;    # 'give' the semaphore
    # run this in the original process and you will see
    # that the second process continues
&lt;/PRE&gt;
&lt;P&gt;
&lt;PRE&gt;    $IPC_KEY = 1234;
    $key = semget($IPC_KEY, 0, 0);
    die if !defined($key);
&lt;/PRE&gt;
&lt;P&gt;
&lt;PRE&gt;    $semnum = 0;
    $semflag = 0;
&lt;/PRE&gt;
&lt;P&gt;
&lt;PRE&gt;    # Decrement the semaphore count
    $semop = -1;
    $opstring = pack(&amp;quot;sss&amp;quot;, $semnum, $semop, $semflag);
&lt;/PRE&gt;
&lt;P&gt;
&lt;PRE&gt;    semop($key,$opstring) || die &amp;quot;$!&amp;quot;;
&lt;/PRE&gt;
&lt;P&gt;
The SysV 
&lt;FONT SIZE=-1&gt;IPC&lt;/FONT&gt; code above was written long ago, and it's
definitely clunky looking. For a more modern look, see the IPC::SysV module
which is included with Perl starting from Perl 5.005.

&lt;P&gt;
&lt;HR&gt;
&lt;H1&gt;&lt;A NAME="NOTES"&gt;NOTES&lt;/A&gt;&lt;/H1&gt;
&lt;P&gt;
Most of these routines quietly but politely return [perlfunc:undef|undef] when they fail instead of causing your program to die right then and there
due to an uncaught exception. (Actually, some of the new &lt;EM&gt;Socket&lt;/EM&gt; conversion functions 
&lt;CODE&gt;croak()&lt;/CODE&gt; on bad arguments.) It
is therefore essential to check return values from these functions. Always
begin your socket programs this way for optimal success, and don't forget
to add &lt;STRONG&gt;-T&lt;/STRONG&gt;
taint checking flag to the #! line for servers:

&lt;P&gt;
&lt;PRE&gt;    #!/usr/bin/perl -Tw
    use strict;
    use sigtrap;
    use Socket;
&lt;/PRE&gt;
&lt;P&gt;
&lt;HR&gt;
&lt;H1&gt;&lt;A NAME="BUGS"&gt;BUGS&lt;/A&gt;&lt;/H1&gt;
&lt;P&gt;
All these routines create system-specific portability problems. As noted elsewhere, Perl is at the mercy of your 
&lt;FONT SIZE=-1&gt;C&lt;/FONT&gt; libraries for much of its system behaviour. It's probably safest to assume broken SysV semantics for signals and to stick with simple 
&lt;FONT SIZE=-1&gt;TCP&lt;/FONT&gt; and 
&lt;FONT SIZE=-1&gt;UDP&lt;/FONT&gt; socket operations; e.g., don't try to pass open file descriptors over a local 
&lt;FONT SIZE=-1&gt;UDP&lt;/FONT&gt; datagram socket if you want your code to stand a chance of being portable.

&lt;P&gt;
As mentioned in the signals section, because few vendors provide 
&lt;FONT SIZE=-1&gt;C&lt;/FONT&gt; libraries that are safely re-entrant, the prudent programmer will do little else within a handler beyond setting a numeric variable that already exists; or, if locked into a slow (restarting) system call, using 
&lt;CODE&gt;die()&lt;/CODE&gt; to raise an exception and 
&lt;CODE&gt;longjmp(3)&lt;/CODE&gt; out. In fact, even these may in some cases cause a core dump. It's probably best to avoid signals except where they are absolutely inevitable. This will be addressed in a future release of Perl.

&lt;P&gt;
&lt;HR&gt;
&lt;H1&gt;&lt;A NAME="AUTHOR"&gt;AUTHOR&lt;/A&gt;&lt;/H1&gt;
&lt;P&gt;
Tom Christiansen, with occasional vestiges of Larry Wall's original version
and suggestions from the Perl Porters.

&lt;P&gt;
&lt;HR&gt;
&lt;BR&gt;[perlman:perlipc2|More...]&lt;BR&gt;
&lt;BR&gt;Return to the [Library]&lt;BR&gt;</field>
</data>
</node>
