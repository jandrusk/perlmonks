<?xml version="1.0" encoding="windows-1252"?>
<node id="422" title="perlman:perldiag2" created="1999-08-25 03:20:10" updated="2005-08-14 21:24:50">
<type id="116">
perlman</type>
<author id="114">
gods</author>
<data>
<field name="doctext">
&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;&lt;A NAME="item_Ill"&gt;Ill-formed logical name |%s| in prime_env_iter&lt;/A&gt;&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(W)&lt;/FONT&gt; 
&lt;FONT SIZE=-1&gt;A&lt;/FONT&gt; warning peculiar to 
&lt;FONT SIZE=-1&gt;VMS.&lt;/FONT&gt; 
&lt;FONT SIZE=-1&gt;A&lt;/FONT&gt; logical name was encountered when preparing to iterate over &lt;CODE&gt;%ENV&lt;/CODE&gt; which violates the syntactic rules governing logical names. Because it cannot be translated normally, it is skipped, and will not appear in 
&lt;FONT SIZE=-1&gt;%ENV.&lt;/FONT&gt; This may be a benign occurrence, as some software packages might directly modify logical name tables and introduce nonstandard names, or it may indicate that a logical name table has been corrupted.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;&lt;A NAME="item_Illegal"&gt;Illegal character %s (carriage return)&lt;/A&gt;&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(F)&lt;/FONT&gt; 
&lt;FONT SIZE=-1&gt;A&lt;/FONT&gt; carriage return character was found in the input. This is an error, and not a warning, because carriage return characters can break multi-line strings, including here documents (e.g.,
 &lt;CODE&gt;print &amp;lt;&amp;lt;EOF;&lt;/CODE&gt;).

&lt;P&gt;
Under Unix, this error is usually caused by executing Perl code -- either
the main program, a module, or an eval'd string -- that was transferred
over a network connection from a non-Unix system without properly
converting the text file format.

&lt;P&gt;
Under systems that use something other than '\n' to delimit lines of text,
this error can also be caused by reading Perl code from a file handle that
is in binary mode (as set by the [perlfunc:binmode|binmode] operator).

&lt;P&gt;
In either case, the Perl code in question will probably need to be
converted with something like &lt;CODE&gt;s/\x0D\x0A?/\n/g&lt;/CODE&gt; before it can be executed.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;Illegal division by zero&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(F)&lt;/FONT&gt; You tried to divide a number by 0. Either
something was wrong in your logic, or you need to put a conditional in to
guard against meaningless input.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;Illegal modulus zero&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(F)&lt;/FONT&gt; You tried to divide a number by 0 to get the
remainder. Most numbers don't take to this kindly.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;Illegal octal digit&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(F)&lt;/FONT&gt; You used an 8 or 9 in a octal number.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;Illegal octal digit ignored&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(W)&lt;/FONT&gt; You may have tried to use an 8 or 9 in a octal
number. Interpretation of the octal number stopped before the 8 or 9.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;Illegal hex digit ignored&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(W)&lt;/FONT&gt; You may have tried to use a character other than 0 - 9 or 
&lt;FONT SIZE=-1&gt;A&lt;/FONT&gt; - 
&lt;FONT SIZE=-1&gt;F&lt;/FONT&gt; in a hexadecimal number. Interpretation of the hexadecimal number stopped before the illegal character.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;Illegal switch in PERL5OPT: %s&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(X)&lt;/FONT&gt; The 
&lt;FONT SIZE=-1&gt;PERL5OPT&lt;/FONT&gt; environment variable may only be used to set the following switches:
 &lt;STRONG&gt;-&amp;#091;DIMUdmw&amp;#093;&lt;/STRONG&gt;.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;&lt;A NAME="item_In"&gt;In string, @%s now must be written as \@%s&lt;/A&gt;&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(F)&lt;/FONT&gt; It used to be that Perl would try to guess whether
you wanted an array interpolated or a literal @. It did this when the
string was first used at runtime. Now strings are parsed at compile time,
and ambiguous instances of @ must be disambiguated, either by prepending a
backslash to indicate a literal, or by declaring (or using) the array
within the program before the string (lexically). (Someday it will simply
assume that an unbackslashed @ interpolates an array.)

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;&lt;A NAME="item_Insecure"&gt;Insecure dependency in %s&lt;/A&gt;&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(F)&lt;/FONT&gt; You tried to do something that the tainting
mechanism didn't like. The tainting mechanism is turned on when you're
running setuid or setgid, or when you specify &lt;STRONG&gt;-T&lt;/STRONG&gt; to turn it on explicitly. The tainting mechanism labels all data that's
derived directly or indirectly from the user, who is considered to be
unworthy of your trust. If any such data is used in a ``dangerous''
operation, you get this error. See [perlman:perlsec|the perlsec manpage]
for more information.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;Insecure directory in %s&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(F)&lt;/FONT&gt; You can't use 
&lt;CODE&gt;system(),&lt;/CODE&gt; 
&lt;CODE&gt;exec(),&lt;/CODE&gt; or a piped open in a setuid or setgid script if
 &lt;CODE&gt;$ENV{PATH}&lt;/CODE&gt; contains a directory that is writable by the world. See [perlman:perlsec|the perlsec manpage].

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;Insecure $ENV{%s} while running %s&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(F)&lt;/FONT&gt; You can't use 
&lt;CODE&gt;system(),&lt;/CODE&gt; 
&lt;CODE&gt;exec(),&lt;/CODE&gt; or a piped open in a setuid or setgid script if any of
 &lt;CODE&gt;$ENV{PATH}&lt;/CODE&gt;, &lt;CODE&gt;$ENV{IFS}&lt;/CODE&gt;, &lt;CODE&gt;$ENV{CDPATH}&lt;/CODE&gt;,
&lt;CODE&gt;$ENV{ENV}&lt;/CODE&gt; or &lt;CODE&gt;$ENV{BASH_ENV}&lt;/CODE&gt; are derived from data supplied (or potentially supplied) by the user. The
script must set the path to a known value, using trustworthy data. See [perlman:perlsec|the perlsec manpage].

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;&lt;A NAME="item_Integer"&gt;Integer overflow in hex number&lt;/A&gt;&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(S)&lt;/FONT&gt; The literal hex number you have specified is too
big for your architecture. On a 32-bit architecture the largest hex literal
is 0xFFFFFFFF.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;Integer overflow in octal number&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(S)&lt;/FONT&gt; The literal octal number you have specified is too
big for your architecture. On a 32-bit architecture the largest octal
literal is 037777777777.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;&lt;A NAME="item_Internal"&gt;Internal inconsistency in tracking vforks&lt;/A&gt;&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(S)&lt;/FONT&gt; 
&lt;FONT SIZE=-1&gt;A&lt;/FONT&gt; warning peculiar to 
&lt;FONT SIZE=-1&gt;VMS.&lt;/FONT&gt; Perl keeps track of the number of times you've called
 [perlfunc:fork|fork] and [perlfunc:exec|exec], to determine whether the current call to [perlfunc:exec|exec] should affect the current script or a subprocess (see &lt;U&gt;exec&lt;/U&gt;). Somehow, this count has become scrambled, so Perl is making a guess and
treating this [perlfunc:exec|exec] as a request to terminate the Perl script and execute the specified
command.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;&lt;A NAME="item_internal"&gt;internal disaster in regexp&lt;/A&gt;&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(P)&lt;/FONT&gt; Something went badly wrong in the regular
expression parser.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;internal error: glob failed&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(P)&lt;/FONT&gt; Something went wrong with the external 
&lt;CODE&gt;program(s)&lt;/CODE&gt; used for
 [perlfunc:glob|glob]
and &lt;CODE&gt;&amp;lt;*.c&amp;gt;&lt;/CODE&gt;. This may mean that your csh 
&lt;FONT SIZE=-1&gt;(C&lt;/FONT&gt; shell) is broken. If so, you should change all of
the csh-related variables in config.sh: If you have tcsh, make the
variables refer to it as if it were csh (e.g. &lt;CODE&gt;full_csh='/usr/bin/tcsh'&lt;/CODE&gt;); otherwise, make them all empty (except that &lt;CODE&gt;d_csh&lt;/CODE&gt; should be [perlfunc:undef]) so that Perl will think csh is missing. In either case, after editing
config.sh, run
&lt;CODE&gt;./Configure -S&lt;/CODE&gt; and rebuild Perl.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;internal urp in regexp at /%s/&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(P)&lt;/FONT&gt; Something went badly awry in the regular
expression parser.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;&lt;A NAME="item_invalid"&gt;invalid &amp;#091;&amp;#093; range in regexp&lt;/A&gt;&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(F)&lt;/FONT&gt; The range specified in a character class had a
minimum character greater than the maximum character. See [perlman:perlre|the perlre manpage].

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;&lt;A NAME="item_Invalid"&gt;Invalid conversion in %s: &amp;quot;%s&amp;quot;&lt;/A&gt;&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(W)&lt;/FONT&gt; Perl does not understand the given format
conversion. See [perlfunc:sprintf|sprintf].

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;Invalid type in pack: '%s'&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(F)&lt;/FONT&gt; The given character is not a valid pack type. See [perlfunc:pack|pack]. 
&lt;FONT SIZE=-1&gt;(W)&lt;/FONT&gt; The given character is not a valid pack type but
used to be silently ignored.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;Invalid type in unpack: '%s'&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(F)&lt;/FONT&gt; The given character is not a valid unpack type.
See [perlfunc:unpack|unpack]. 
&lt;FONT SIZE=-1&gt;(W)&lt;/FONT&gt; The given character is not a valid unpack type but
used to be silently ignored.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;&lt;A NAME="item_ioctl"&gt;ioctl is not implemented&lt;/A&gt;&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(F)&lt;/FONT&gt; Your machine apparently doesn't implement 
&lt;CODE&gt;ioctl(),&lt;/CODE&gt; which is pretty strange for a machine that supports 
&lt;FONT SIZE=-1&gt;C.&lt;/FONT&gt;

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;&lt;A NAME="item_junk"&gt;junk on end of regexp&lt;/A&gt;&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(P)&lt;/FONT&gt; The regular expression parser is confused.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;&lt;A NAME="item_Label"&gt;Label not found for &amp;quot;last %s&amp;quot;&lt;/A&gt;&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(F)&lt;/FONT&gt; You named a loop to break out of, but you're not
currently in a loop of that name, not even if you count where you were
called from. See [perlfunc:last|last].

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;Label not found for &amp;quot;next %s&amp;quot;&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(F)&lt;/FONT&gt; You named a loop to continue, but you're not
currently in a loop of that name, not even if you count where you were
called from. See
[perlfunc:last|last].

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;Label not found for &amp;quot;redo %s&amp;quot;&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(F)&lt;/FONT&gt; You named a loop to restart, but you're not
currently in a loop of that name, not even if you count where you were
called from. See
[perlfunc:last|last].

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;&lt;A NAME="item_listen"&gt;listen() on closed fd&lt;/A&gt;&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(W)&lt;/FONT&gt; You tried to do a listen on a closed socket. Did you forget to check the return value of your 
&lt;CODE&gt;socket()&lt;/CODE&gt; call? See
 [perlfunc:listen|listen].

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;&lt;A NAME="item_Method"&gt;Method for operation %s not found in package %s during blessing&lt;/A&gt;&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(F)&lt;/FONT&gt; An attempt was made to specify an entry in an
overloading table that doesn't resolve to a valid subroutine. See &lt;U&gt;the overload manpage&lt;/U&gt;&lt;!--../lib/overload.html--&gt;.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;&lt;A NAME="item_Might"&gt;Might be a runaway multi-line %s string starting on line %d&lt;/A&gt;&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(S)&lt;/FONT&gt; An advisory indicating that the previous error may
have been caused by a missing delimiter on a string or pattern, because it
eventually ended earlier on the current line.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;&lt;A NAME="item_Misplaced"&gt;Misplaced _ in number&lt;/A&gt;&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(W)&lt;/FONT&gt; An underline in a decimal constant wasn't on a
3-digit boundary.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;&lt;A NAME="item_Missing"&gt;Missing $ on loop variable&lt;/A&gt;&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(F)&lt;/FONT&gt; Apparently you've been programming in &lt;STRONG&gt;csh&lt;/STRONG&gt; too much. Variables are always mentioned with the $ in Perl, unlike in the
shells, where it can vary from one line to the next.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;Missing comma after first argument to %s function&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(F)&lt;/FONT&gt; While certain functions allow you to specify a
filehandle or an ``indirect object'' before the argument list, this ain't
one of them.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;Missing operator before %s?&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(S)&lt;/FONT&gt; This is an educated guess made in conjunction with
the message ``%s found where operator expected''. Often the missing
operator is a comma.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;Missing right bracket&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(F)&lt;/FONT&gt; The lexer counted more opening curly brackets
(braces) than closing ones. As a general rule, you'll find it's missing
near the place you were last editing.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;&lt;A NAME="item_Modification"&gt;Modification of a read-only value attempted&lt;/A&gt;&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(F)&lt;/FONT&gt; You tried, directly or indirectly, to change the
value of a constant. You didn't, of course, try ``2 = 1'', because the
compiler catches that. But an easy way to do the same thing is:

&lt;P&gt;
&lt;PRE&gt;    sub mod { $_&amp;#091;0&amp;#093; = 1 }
    mod(2);
&lt;/PRE&gt;
&lt;P&gt;
Another way is to assign to a 
&lt;CODE&gt;substr()&lt;/CODE&gt; that's off the end
of the string.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;Modification of non-creatable array value attempted, subscript %d&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(F)&lt;/FONT&gt; You tried to make an array value spring into
existence, and the subscript was probably negative, even counting from end
of the array backwards.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;Modification of non-creatable hash value attempted, subscript &amp;quot;%s&amp;quot;&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(P)&lt;/FONT&gt; You tried to make a hash value spring into
existence, and it couldn't be created for some peculiar reason.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;&lt;A NAME="item_Module"&gt;Module name must be constant&lt;/A&gt;&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(F)&lt;/FONT&gt; Only a bare module name is allowed as the first
argument to a ``use''.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;&lt;A NAME="item_msg"&gt;msg%s not implemented&lt;/A&gt;&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(F)&lt;/FONT&gt; You don't have System 
&lt;FONT SIZE=-1&gt;V&lt;/FONT&gt; message 
&lt;FONT SIZE=-1&gt;IPC&lt;/FONT&gt; on your system.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;&lt;A NAME="item_Multidimensional"&gt;Multidimensional syntax %s not supported&lt;/A&gt;&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(W)&lt;/FONT&gt; Multidimensional arrays aren't written like &lt;CODE&gt;$foo&amp;#091;1,2,3&amp;#093;&lt;/CODE&gt;. They're written like &lt;CODE&gt;$foo&amp;#091;1&amp;#093;&amp;#091;2&amp;#093;&amp;#091;3&amp;#093;&lt;/CODE&gt;, as in 
&lt;FONT SIZE=-1&gt;C.&lt;/FONT&gt;

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;&lt;A NAME="item_Name"&gt;Name &amp;quot;%s::%s&amp;quot; used only once: possible typo&lt;/A&gt;&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(W)&lt;/FONT&gt; Typographical errors often show up as unique
variable names. If you had a good reason for having a unique name, then
just mention it again somehow to suppress the message. The &lt;CODE&gt;use vars&lt;/CODE&gt; pragma is provided for just this purpose.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;&lt;A NAME="item_Negative"&gt;Negative length&lt;/A&gt;&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(F)&lt;/FONT&gt; You tried to do a read/write/send/recv operation
with a buffer length that is less than 0. This is difficult to imagine.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;&lt;A NAME="item_nested"&gt;nested *?+ in regexp&lt;/A&gt;&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(F)&lt;/FONT&gt; You can't quantify a quantifier without
intervening parentheses. So things like ** or +* or ?* are illegal.

&lt;P&gt;
Note, however, that the minimal matching quantifiers, &lt;CODE&gt;*?&lt;/CODE&gt;, &lt;CODE&gt;+?&lt;/CODE&gt;, and &lt;CODE&gt;??&lt;/CODE&gt; appear to be nested quantifiers, but aren't. See [perlman:perlre|the perlre manpage].

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;&lt;A NAME="item_No"&gt;No #! line&lt;/A&gt;&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(F)&lt;/FONT&gt; The setuid emulator requires that scripts have a
well-formed #! line even on machines that don't support the #! construct.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;No %s allowed while running setuid&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(F)&lt;/FONT&gt; Certain operations are deemed to be too insecure
for a setuid or setgid script to even be allowed to attempt. Generally
speaking there will be another way to do what you want that is, if not
secure, at least securable. See [perlman:perlsec|the perlsec manpage].

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;No -e allowed in setuid scripts&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(F)&lt;/FONT&gt; 
&lt;FONT SIZE=-1&gt;A&lt;/FONT&gt; setuid script can't be specified by the user.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;No comma allowed after %s&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(F)&lt;/FONT&gt; 
&lt;FONT SIZE=-1&gt;A&lt;/FONT&gt; list operator that has a filehandle or ``indirect object'' is not allowed to have a comma between that and the following arguments. Otherwise it'd be just another one of the arguments.

&lt;P&gt;
One possible cause for this is that you expected to have imported a
constant to your name space with &lt;STRONG&gt;use&lt;/STRONG&gt; or &lt;STRONG&gt;import&lt;/STRONG&gt; while no such importing took place, it may for example be that your
operating system does not support that particular constant. Hopefully you
did use an explicit import list for the constants you expect to see, please
see
[perlfunc:use|use] and [perlfunc:import|import]. While an explicit import list would probably have caught this error
earlier it naturally does not remedy the fact that your operating system
still does not support that constant. Maybe you have a typo in the
constants of the symbol import list of &lt;STRONG&gt;use&lt;/STRONG&gt; or &lt;STRONG&gt;import&lt;/STRONG&gt; or in the constant name at the line where this error was triggered?

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;No command into which to pipe on command line&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(F)&lt;/FONT&gt; An error peculiar to 
&lt;FONT SIZE=-1&gt;VMS.&lt;/FONT&gt; Perl handles its own command line redirection, and found a '|' at the end of the command line, so it doesn't know where you want to pipe the output from this command.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;No DB::DB routine defined&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(F)&lt;/FONT&gt; The currently executing code was compiled with the &lt;STRONG&gt;-d&lt;/STRONG&gt; switch, but for some reason the perl5db.pl file (or some facsimile thereof)
didn't define a routine to be called at the beginning of each statement.
Which is odd, because the file should have been required automatically, and
should have blown up the require if it didn't parse right.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;No dbm on this machine&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(P)&lt;/FONT&gt; This is counted as an internal error, because every machine should supply dbm nowadays, because Perl comes with 
&lt;FONT SIZE=-1&gt;SDBM.&lt;/FONT&gt; See
 &lt;U&gt;the SDBM_File manpage&lt;/U&gt;&lt;!--../lib/SDBM_File.html--&gt;.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;No DBsub routine&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(F)&lt;/FONT&gt; The currently executing code was compiled with the &lt;STRONG&gt;-d&lt;/STRONG&gt; switch, but for some reason the perl5db.pl file (or some facsimile thereof)
didn't define a DB::sub routine to be called at the beginning of each
ordinary subroutine call.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;No error file after 2gt or 2gtgt on command line&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(F)&lt;/FONT&gt; An error peculiar to 
&lt;FONT SIZE=-1&gt;VMS.&lt;/FONT&gt; Perl handles its own command line redirection, and found a '2&amp;gt;' or a '2&amp;gt;&amp;gt;' on the command line, but can't find the name of the file to which to write data destined for stderr.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;No input file after lt on command line&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(F)&lt;/FONT&gt; An error peculiar to 
&lt;FONT SIZE=-1&gt;VMS.&lt;/FONT&gt; Perl handles its own command line redirection, and found a '&amp;lt;' on the command line, but can't find the name of the file from which to read data for stdin.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;No output file after gt on command line&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(F)&lt;/FONT&gt; An error peculiar to 
&lt;FONT SIZE=-1&gt;VMS.&lt;/FONT&gt; Perl handles its own command line redirection, and found a lone '&amp;gt;' at the end of the command line, so it doesn't know where you wanted to redirect stdout.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;No output file after gt or gtgt on command line&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(F)&lt;/FONT&gt; An error peculiar to 
&lt;FONT SIZE=-1&gt;VMS.&lt;/FONT&gt; Perl handles its own command line redirection, and found a '&amp;gt;' or a '&amp;gt;&amp;gt;' on the command line, but can't find the name of the file to which to write data destined for stdout.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;No Perl script found in input&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(F)&lt;/FONT&gt; You called &lt;CODE&gt;perl -x&lt;/CODE&gt;, but no line was found in the file beginning with #! and containing the
word ``perl''.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;No setregid available&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(F)&lt;/FONT&gt; Configure didn't find anything resembling the 
&lt;CODE&gt;setregid()&lt;/CODE&gt; call for your system.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;No setreuid available&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(F)&lt;/FONT&gt; Configure didn't find anything resembling the 
&lt;CODE&gt;setreuid()&lt;/CODE&gt; call for your system.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;No space allowed after -I&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(F)&lt;/FONT&gt; The argument to &lt;STRONG&gt;-I&lt;/STRONG&gt; must follow the &lt;STRONG&gt;-I&lt;/STRONG&gt; immediately with no intervening space.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;No such array field&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(F)&lt;/FONT&gt; You tried to access an array as a hash, but the
field name used is not defined. The hash at index 0 should map all valid
field names to array indices for that to work.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;No such field &amp;quot;%s&amp;quot; in variable %s of type %s&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(F)&lt;/FONT&gt; You tried to access a field of a typed variable
where the type does not know about the field name. The field names are
looked up in the &lt;CODE&gt;%FIELDS&lt;/CODE&gt; hash in the type package at compile
time. The &lt;CODE&gt;%FIELDS&lt;/CODE&gt; hash is usually set up with the 'fields'
pragma.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;No such pipe open&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(P)&lt;/FONT&gt; An error peculiar to 
&lt;FONT SIZE=-1&gt;VMS.&lt;/FONT&gt; The internal routine 
&lt;CODE&gt;my_pclose()&lt;/CODE&gt; tried to close a pipe which hadn't been opened. This should have been caught earlier as an attempt to close an unopened filehandle.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;No such signal: SIG%s&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(W)&lt;/FONT&gt; You specified a signal name as a subscript to
&lt;CODE&gt;%SIG&lt;/CODE&gt; that was not recognized. Say &lt;CODE&gt;kill -l&lt;/CODE&gt; in your shell to see the valid signal names on your system.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;&lt;A NAME="item_Not"&gt;Not a CODE reference&lt;/A&gt;&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(F)&lt;/FONT&gt; Perl was trying to evaluate a reference to a code value (that is, a subroutine), but found a reference to something else instead. You can use the 
&lt;CODE&gt;ref()&lt;/CODE&gt; function to find out what kind of ref it really was. See also
 [perlman:perlref|the perlref manpage].

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;Not a format reference&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(F)&lt;/FONT&gt; I'm not sure how you managed to generate a
reference to an anonymous format, but this indicates you did, and that it
didn't exist.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;Not a GLOB reference&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(F)&lt;/FONT&gt; Perl was trying to evaluate a reference to a
``typeglob'' (that is, a symbol table entry that looks like &lt;CODE&gt;*foo&lt;/CODE&gt;), but found a reference to something else instead. You can use the 
&lt;CODE&gt;ref()&lt;/CODE&gt; function to find out what
kind of ref it really was. See [perlman:perlref|the perlref manpage].

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;Not a HASH reference&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(F)&lt;/FONT&gt; Perl was trying to evaluate a reference to a hash value, but found a reference to something else instead. You can use the 
&lt;CODE&gt;ref()&lt;/CODE&gt; function to find out what kind of ref it really was. See
 [perlman:perlref|the perlref manpage].

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;Not a perl script&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(F)&lt;/FONT&gt; The setuid emulator requires that scripts have a
well-formed #! line even on machines that don't support the #! construct.
The line must mention perl.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;Not a SCALAR reference&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(F)&lt;/FONT&gt; Perl was trying to evaluate a reference to a scalar value, but found a reference to something else instead. You can use the 
&lt;CODE&gt;ref()&lt;/CODE&gt; function to find out what kind of ref it really was. See
 [perlman:perlref|the perlref manpage].

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;Not a subroutine reference&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(F)&lt;/FONT&gt; Perl was trying to evaluate a reference to a code value (that is, a subroutine), but found a reference to something else instead. You can use the 
&lt;CODE&gt;ref()&lt;/CODE&gt; function to find out what kind of ref it really was. See also
 [perlman:perlref|the perlref manpage].

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;Not a subroutine reference in overload table&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(F)&lt;/FONT&gt; An attempt was made to specify an entry in an
overloading table that doesn't somehow point to a valid subroutine. See &lt;U&gt;the overload manpage&lt;/U&gt;&lt;!--../lib/overload.html--&gt;.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;Not an ARRAY reference&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(F)&lt;/FONT&gt; Perl was trying to evaluate a reference to an array value, but found a reference to something else instead. You can use the 
&lt;CODE&gt;ref()&lt;/CODE&gt; function to find out what kind of ref it really was. See
 [perlman:perlref|the perlref manpage].

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;Not enough arguments for %s&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(F)&lt;/FONT&gt; The function requires more arguments than you
specified.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;Not enough format arguments&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(W)&lt;/FONT&gt; 
&lt;FONT SIZE=-1&gt;A&lt;/FONT&gt; format specified more picture fields than the next line supplied. See
 [perlman:perlform|the perlform manpage].

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;&lt;A NAME="item_Null"&gt;Null filename used&lt;/A&gt;&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(F)&lt;/FONT&gt; You can't require the null filename, especially
because on many machines that means the current directory! See [perlfunc:require|require].

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;Null picture in formline&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(F)&lt;/FONT&gt; The first argument to formline must be a valid
format picture specification. It was found to be empty, which probably
means you supplied it an uninitialized value. See [perlman:perlform|the perlform manpage].

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;&lt;A NAME="item_NULL"&gt;NULL OP IN RUN&lt;/A&gt;&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(P)&lt;/FONT&gt; Some internal routine called 
&lt;CODE&gt;run()&lt;/CODE&gt; with a null opcode pointer.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;Null realloc&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(P)&lt;/FONT&gt; An attempt was made to realloc 
&lt;FONT SIZE=-1&gt;NULL.&lt;/FONT&gt;

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;NULL regexp argument&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(P)&lt;/FONT&gt; The internal pattern matching routines blew it big
time.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;NULL regexp parameter&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(P)&lt;/FONT&gt; The internal pattern matching routines are out of
their gourd.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;&lt;A NAME="item_Number"&gt;Number too long&lt;/A&gt;&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(F)&lt;/FONT&gt; Perl limits the representation of decimal numbers
in programs to about about 250 characters. You've exceeded that length.
Future versions of Perl are likely to eliminate this arbitrary limitation.
In the meantime, try using scientific notation (e.g. ``1e6'' instead of
``1_000_000'').

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;&lt;A NAME="item_Odd"&gt;Odd number of elements in hash assignment&lt;/A&gt;&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(S)&lt;/FONT&gt; You specified an odd number of elements to
initialize a hash, which is odd, because hashes come in key/value pairs.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;&lt;A NAME="item_Offset"&gt;Offset outside string&lt;/A&gt;&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(F)&lt;/FONT&gt; You tried to do a read/write/send/recv operation
with an offset pointing outside the buffer. This is difficult to imagine.
The sole exception to this is that [perlfunc:sysread|sysread()]ing past the buffer will extend the buffer and zero pad the new area.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;&lt;A NAME="item_oops"&gt;oops: oopsAV&lt;/A&gt;&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(S)&lt;/FONT&gt; An internal warning that the grammar is screwed
up.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;oops: oopsHV&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(S)&lt;/FONT&gt; An internal warning that the grammar is screwed
up.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;&lt;A NAME="item_Operation"&gt;Operation `%s': no method found, %s&lt;/A&gt;&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(F)&lt;/FONT&gt; An attempt was made to perform an overloaded
operation for which no handler was defined. While some handlers can be
autogenerated in terms of other handlers, there is no default handler for
any operation, unless &lt;CODE&gt;fallback&lt;/CODE&gt; overloading key is specified to be true. See &lt;U&gt;the overload manpage&lt;/U&gt;&lt;!--../lib/overload.html--&gt;.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;&lt;A NAME="item_Operator"&gt;Operator or semicolon missing before %s&lt;/A&gt;&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(S)&lt;/FONT&gt; You used a variable or subroutine call where the
parser was expecting an operator. The parser has assumed you really meant
to use an operator, but this is highly likely to be incorrect. For example,
if you say ``*foo *foo'' it will be interpreted as if you said ``*foo *
'foo'''.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;&lt;A NAME="item_Out"&gt;Out of memory for yacc stack&lt;/A&gt;&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(F)&lt;/FONT&gt; The yacc parser wanted to grow its stack so it could continue parsing, but 
&lt;CODE&gt;realloc()&lt;/CODE&gt; wouldn't give it more memory, virtual or otherwise.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;Out of memory during request for %s&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(X|F)&lt;/FONT&gt; The 
&lt;CODE&gt;malloc()&lt;/CODE&gt; function returned 0, indicating there was insufficient remaining memory (or virtual memory) to satisfy the request.

&lt;P&gt;
The request was judged to be small, so the possibility to trap it depends
on the way perl was compiled. By default it is not trappable. However, if
compiled for this, Perl may use the contents of &lt;CODE&gt;$^M&lt;/CODE&gt; as an emergency pool after 
&lt;CODE&gt;die()ing&lt;/CODE&gt; with this message.
In this case the error is trappable &lt;EM&gt;once&lt;/EM&gt;.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;Out of memory during &amp;quot;large&amp;quot; request for %s&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(F)&lt;/FONT&gt; The 
&lt;CODE&gt;malloc()&lt;/CODE&gt; function returned 0, indicating there was insufficient remaining memory (or virtual memory) to satisfy the request. However, the request was judged large enough (compile-time default is 
&lt;FONT SIZE=-1&gt;64K),&lt;/FONT&gt; so a possibility to shut down by trapping this error is granted.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;Out of memory during ridiculously large request&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(F)&lt;/FONT&gt; You can't allocate more than 2^31+``small amount''
bytes. This error is most likely to be caused by a typo in the Perl
program. e.g., &lt;CODE&gt;$arr&amp;#091;time&amp;#093;&lt;/CODE&gt;
instead of &lt;CODE&gt;$arr&amp;#091;$time&amp;#093;&lt;/CODE&gt;.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;&lt;A NAME="item_page"&gt;page overflow&lt;/A&gt;&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(W)&lt;/FONT&gt; 
&lt;FONT SIZE=-1&gt;A&lt;/FONT&gt; single call to 
&lt;CODE&gt;write()&lt;/CODE&gt; produced more lines than can fit on a page. See
 [perlman:perlform|the perlform manpage].

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;&lt;A NAME="item_panic"&gt;panic: ck_grep&lt;/A&gt;&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(P)&lt;/FONT&gt; Failed an internal consistency check trying to
compile a grep.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;panic: ck_split&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(P)&lt;/FONT&gt; Failed an internal consistency check trying to
compile a split.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;panic: corrupt saved stack index&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(P)&lt;/FONT&gt; The savestack was requested to restore more
localized values than there are in the savestack.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;panic: die %s&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(P)&lt;/FONT&gt; We popped the context stack to an eval context,
and then discovered it wasn't an eval context.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;panic: do_match&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(P)&lt;/FONT&gt; The internal 
&lt;CODE&gt;pp_match()&lt;/CODE&gt; routine was called with invalid operational data.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;panic: do_split&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(P)&lt;/FONT&gt; Something terrible went wrong in setting up for
the split.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;panic: do_subst&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(P)&lt;/FONT&gt; The internal 
&lt;CODE&gt;pp_subst()&lt;/CODE&gt; routine was called with invalid operational data.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;panic: do_trans&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(P)&lt;/FONT&gt; The internal 
&lt;CODE&gt;do_trans()&lt;/CODE&gt; routine was called with invalid operational data.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;panic: frexp&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(P)&lt;/FONT&gt; The library function 
&lt;CODE&gt;frexp()&lt;/CODE&gt; failed, making 
&lt;CODE&gt;printf(``%f'')&lt;/CODE&gt; impossible.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;panic: goto&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(P)&lt;/FONT&gt; We popped the context stack to a context with the
specified label, and then discovered it wasn't a context we know how to do
a goto in.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;panic: INTERPCASEMOD&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(P)&lt;/FONT&gt; The lexer got into a bad state at a case modifier.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;panic: INTERPCONCAT&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(P)&lt;/FONT&gt; The lexer got into a bad state parsing a string
with brackets.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;panic: last&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(P)&lt;/FONT&gt; We popped the context stack to a block context,
and then discovered it wasn't a block context.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;panic: leave_scope clearsv&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(P)&lt;/FONT&gt; 
&lt;FONT SIZE=-1&gt;A&lt;/FONT&gt; writable lexical variable became read-only somehow within the scope.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;panic: leave_scope inconsistency&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(P)&lt;/FONT&gt; The savestack probably got out of sync. At least,
there was an invalid enum on the top of it.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;panic: malloc&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(P)&lt;/FONT&gt; Something requested a negative number of bytes of
malloc.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;panic: mapstart&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(P)&lt;/FONT&gt; The compiler is screwed up with respect to the 
&lt;CODE&gt;map()&lt;/CODE&gt; function.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;panic: null array&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(P)&lt;/FONT&gt; One of the internal array routines was passed a null 
&lt;FONT SIZE=-1&gt;AV&lt;/FONT&gt; pointer.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;panic: pad_alloc&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(P)&lt;/FONT&gt; The compiler got confused about which scratch pad
it was allocating and freeing temporaries and lexicals from.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;panic: pad_free curpad&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(P)&lt;/FONT&gt; The compiler got confused about which scratch pad
it was allocating and freeing temporaries and lexicals from.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;panic: pad_free po&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(P)&lt;/FONT&gt; An invalid scratch pad offset was detected
internally.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;panic: pad_reset curpad&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(P)&lt;/FONT&gt; The compiler got confused about which scratch pad
it was allocating and freeing temporaries and lexicals from.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;panic: pad_sv po&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(P)&lt;/FONT&gt; An invalid scratch pad offset was detected
internally.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;panic: pad_swipe curpad&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(P)&lt;/FONT&gt; The compiler got confused about which scratch pad
it was allocating and freeing temporaries and lexicals from.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;panic: pad_swipe po&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(P)&lt;/FONT&gt; An invalid scratch pad offset was detected
internally.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;panic: pp_iter&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(P)&lt;/FONT&gt; The foreach iterator got called in a non-loop
context frame.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;panic: realloc&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(P)&lt;/FONT&gt; Something requested a negative number of bytes of
realloc.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;panic: restartop&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(P)&lt;/FONT&gt; Some internal routine requested a goto (or
something like it), and didn't supply the destination.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;panic: return&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(P)&lt;/FONT&gt; We popped the context stack to a subroutine or
eval context, and then discovered it wasn't a subroutine or eval context.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;panic: scan_num&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(P)&lt;/FONT&gt; 
&lt;CODE&gt;scan_num()&lt;/CODE&gt; got called on something that wasn't a number.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;panic: sv_insert&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(P)&lt;/FONT&gt; The 
&lt;CODE&gt;sv_insert()&lt;/CODE&gt; routine was told to remove more string than there was string.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;panic: top_env&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(P)&lt;/FONT&gt; The compiler attempted to do a goto, or something
weird like that.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;panic: yylex&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(P)&lt;/FONT&gt; The lexer got into a bad state while processing a
case modifier.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;&lt;A NAME="item_Parentheses"&gt;Parentheses missing around &amp;quot;%s&amp;quot; list&lt;/A&gt;&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(W)&lt;/FONT&gt; You said something like

&lt;P&gt;
&lt;PRE&gt;    my $foo, $bar = @_;
&lt;/PRE&gt;
&lt;P&gt;
when you meant

&lt;P&gt;
&lt;PRE&gt;    my ($foo, $bar) = @_;
&lt;/PRE&gt;
&lt;P&gt;
Remember that ``my'' and ``local'' bind closer than comma.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;&lt;A NAME="item_Perl"&gt;Perl %3.3f required--this is only version %s, stopped&lt;/A&gt;&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(F)&lt;/FONT&gt; The module in question uses features of a version
of Perl more recent than the currently running version. How long has it
been since you upgraded, anyway? See [perlfunc:require|require].

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;&lt;A NAME="item_Permission"&gt;Permission denied&lt;/A&gt;&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(F)&lt;/FONT&gt; The setuid emulator in suidperl decided you were
up to no good.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;&lt;A NAME="item_pid"&gt;pid %d not a child&lt;/A&gt;&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(W)&lt;/FONT&gt; 
&lt;FONT SIZE=-1&gt;A&lt;/FONT&gt; warning peculiar to 
&lt;FONT SIZE=-1&gt;VMS.&lt;/FONT&gt; 
&lt;CODE&gt;Waitpid()&lt;/CODE&gt; was asked to wait for a process which isn't a subprocess of the current process. While this is fine from 
&lt;FONT SIZE=-1&gt;VMS'&lt;/FONT&gt; perspective, it's probably not what you intended.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;&lt;A NAME="item_POSIX"&gt;POSIX getpgrp can't take an argument&lt;/A&gt;&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(F)&lt;/FONT&gt; Your 
&lt;FONT SIZE=-1&gt;C&lt;/FONT&gt; compiler uses 
&lt;FONT SIZE=-1&gt;POSIX&lt;/FONT&gt; 
&lt;CODE&gt;getpgrp(),&lt;/CODE&gt; which takes no argument, unlike the 
&lt;FONT SIZE=-1&gt;BSD&lt;/FONT&gt; version, which takes a pid.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;&lt;A NAME="item_Possible"&gt;Possible attempt to put comments in qw() list&lt;/A&gt;&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(W)&lt;/FONT&gt; 
&lt;CODE&gt;qw()&lt;/CODE&gt; lists contain items separated by whitespace; as with literal strings, comment characters are not ignored, but are instead treated as literal data. (You may have used different delimiters than the parentheses shown here; braces are also frequently used.)

&lt;P&gt;
You probably wrote something like this:

&lt;P&gt;
&lt;PRE&gt;    @list = qw(
        a # a comment
        b # another comment
    );
&lt;/PRE&gt;
&lt;P&gt;
when you should have written this:

&lt;P&gt;
&lt;PRE&gt;    @list = qw(
        a
        b
    );
&lt;/PRE&gt;
&lt;P&gt;
If you really want comments, build your list the old-fashioned way, with
quotes and commas:

&lt;P&gt;
&lt;PRE&gt;    @list = (
        'a',    # a comment
        'b',    # another comment
    );
&lt;/PRE&gt;
&lt;DT&gt;&lt;STRONG&gt;Possible attempt to separate words with commas&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(W)&lt;/FONT&gt; 
&lt;CODE&gt;qw()&lt;/CODE&gt; lists contain items separated by whitespace; therefore commas aren't needed to separate the items. (You may have used different delimiters than the parentheses shown here; braces are also frequently used.)

&lt;P&gt;
You probably wrote something like this:

&lt;P&gt;
&lt;PRE&gt;    qw! a, b, c !;
&lt;/PRE&gt;
&lt;P&gt;
which puts literal commas into some of the list items. Write it without
commas if you don't want them to appear in your data:

&lt;P&gt;
&lt;PRE&gt;    qw! a b c !;
&lt;/PRE&gt;
&lt;DT&gt;&lt;STRONG&gt;Possible memory corruption: %s overflowed 3rd argument&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(F)&lt;/FONT&gt; An 
&lt;CODE&gt;ioctl()&lt;/CODE&gt; or 
&lt;CODE&gt;fcntl()&lt;/CODE&gt; returned more than Perl was bargaining for. Perl guesses a reasonable buffer size, but puts a sentinel byte at the end of the buffer just in case. This sentinel byte got clobbered, and Perl assumes that memory is now corrupted. See
 [perlfunc:ioctl|ioctl].

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;&lt;A NAME="item_Precedence"&gt;Precedence problem: open %s should be open(%s)&lt;/A&gt;&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(S)&lt;/FONT&gt; The old irregular construct

&lt;P&gt;
&lt;PRE&gt;    open FOO || die;
&lt;/PRE&gt;
&lt;P&gt;
is now misinterpreted as

&lt;P&gt;
&lt;PRE&gt;    open(FOO || die);
&lt;/PRE&gt;
&lt;P&gt;
because of the strict regularization of Perl 5's grammar into unary and
list operators. (The old open was a little of both.) You must put
parentheses around the filehandle, or use the new ``or'' operator instead
of ``||''.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;&lt;A NAME="item_print"&gt;print on closed filehandle %s&lt;/A&gt;&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(W)&lt;/FONT&gt; The filehandle you're printing on got itself
closed sometime before now. Check your logic flow.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;&lt;A NAME="item_printf"&gt;printf on closed filehandle %s&lt;/A&gt;&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(W)&lt;/FONT&gt; The filehandle you're writing to got itself closed
sometime before now. Check your logic flow.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;&lt;A NAME="item_Probable"&gt;Probable precedence problem on %s&lt;/A&gt;&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(W)&lt;/FONT&gt; The compiler found a bareword where it expected a
conditional, which often indicates that an || or &amp;amp;&amp;amp; was parsed as
part of the last argument of the previous construct, for example:

&lt;P&gt;
&lt;PRE&gt;    open FOO || die;
&lt;/PRE&gt;
&lt;DT&gt;&lt;STRONG&gt;&lt;A NAME="item_Prototype"&gt;Prototype mismatch: %s vs %s&lt;/A&gt;&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(S)&lt;/FONT&gt; The subroutine being declared or defined had
previously been declared or defined with a different function prototype.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;&lt;A NAME="item_Range"&gt;Range iterator outside integer range&lt;/A&gt;&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(F)&lt;/FONT&gt; One (or both) of the numeric arguments to the
range operator ``..'' are outside the range which can be represented by
integers internally. One possible workaround is to force Perl to use
magical string increment by prepending ``0'' to your numbers.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;&lt;A NAME="item_Read"&gt;Read on closed filehandle lt%sgt&lt;/A&gt;&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(W)&lt;/FONT&gt; The filehandle you're reading from got itself
closed sometime before now. Check your logic flow.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;&lt;A NAME="item_Reallocation"&gt;Reallocation too large: %lx&lt;/A&gt;&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(F)&lt;/FONT&gt; You can't allocate more than 
&lt;FONT SIZE=-1&gt;64K&lt;/FONT&gt; on an 
&lt;FONT SIZE=-1&gt;MS-DOS&lt;/FONT&gt; machine.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;&lt;A NAME="item_Recompile"&gt;Recompile perl with -DDEBUGGING to use -D switch&lt;/A&gt;&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(F)&lt;/FONT&gt; You can't use the &lt;STRONG&gt;-D&lt;/STRONG&gt; option unless the code to produce the desired output is compiled into Perl,
which entails some overhead, which is why it's currently left out of your
copy.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;&lt;A NAME="item_Recursive"&gt;Recursive inheritance detected in package '%s'&lt;/A&gt;&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(F)&lt;/FONT&gt; More than 100 levels of inheritance were used.
Probably indicates an unintended loop in your inheritance hierarchy.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;Recursive inheritance detected while looking for method '%s' in package '%s'&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(F)&lt;/FONT&gt; More than 100 levels of inheritance were
encountered while invoking a method. Probably indicates an unintended loop
in your inheritance hierarchy.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;&lt;A NAME="item_Reference"&gt;Reference found where even-sized list expected&lt;/A&gt;&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(W)&lt;/FONT&gt; You gave a single reference where Perl was
expecting a list with an even number of elements (for assignment to a
hash). This usually means that you used the anon hash constructor when you
meant to use parens. In any case, a hash requires key/value &lt;STRONG&gt;pairs&lt;/STRONG&gt;.

&lt;P&gt;
&lt;PRE&gt;    %hash = { one =&amp;gt; 1, two =&amp;gt; 2, };    # WRONG
    %hash = &amp;#091; qw/ an anon array / &amp;#093;;    # WRONG
    %hash = ( one =&amp;gt; 1, two =&amp;gt; 2, );    # right
    %hash = qw( one 1 two 2 );                  # also fine
&lt;/PRE&gt;
&lt;DT&gt;&lt;STRONG&gt;Reference miscount in sv_replace()&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(W)&lt;/FONT&gt; The internal 
&lt;CODE&gt;sv_replace()&lt;/CODE&gt; function was handed a new 
&lt;FONT SIZE=-1&gt;SV&lt;/FONT&gt; with a reference count of other than 1.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;&lt;A NAME="item_regexp"&gt;regexp *+ operand could be empty&lt;/A&gt;&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(F)&lt;/FONT&gt; The part of the regexp subject to either the * or
+ quantifier could match an empty string.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;regexp memory corruption&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(P)&lt;/FONT&gt; The regular expression engine got confused by what
the regular expression compiler gave it.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;regexp out of space&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(P)&lt;/FONT&gt; 
&lt;FONT SIZE=-1&gt;A&lt;/FONT&gt; ``can't happen'' error, because 
&lt;CODE&gt;safemalloc()&lt;/CODE&gt; should have caught it earlier.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;regexp too big&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(F)&lt;/FONT&gt; The current implementation of regular expressions
uses shorts as address offsets within a string. Unfortunately this means
that if the regular expression compiles to longer than 32767, it'll blow
up. Usually when you want a regular expression this big, there is a better
way to do it with multiple statements. See [perlman:perlre|the perlre manpage].

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;&lt;A NAME="item_Reversed"&gt;Reversed %s= operator&lt;/A&gt;&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(W)&lt;/FONT&gt; You wrote your assignment operator backwards. The
= must always comes last, to avoid ambiguity with subsequent unary
operators.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;&lt;A NAME="item_Runaway"&gt;Runaway format&lt;/A&gt;&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(F)&lt;/FONT&gt; Your format contained the ~~ repeat-until-blank
sequence, but it produced 200 lines at once, and the 200th line looked
exactly like the 199th line. Apparently you didn't arrange for the
arguments to exhaust themselves, either by using ^ instead of @ (for scalar
variables), or by shifting or popping (for array variables). See [perlman:perlform|the perlform manpage].

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;&lt;A NAME="item_Scalar"&gt;Scalar value @%s&amp;#091;%s&amp;#093; better written as $%s&amp;#091;%s&amp;#093;&lt;/A&gt;&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(W)&lt;/FONT&gt; You've used an array slice (indicated by @) to
select a single element of an array. Generally it's better to ask for a
scalar value (indicated by $). The difference is that &lt;CODE&gt;$foo&amp;#091;&amp;amp;bar&amp;#093;&lt;/CODE&gt; always behaves like a scalar, both when assigning to it and when evaluating
its argument, while &lt;CODE&gt;@foo&amp;#091;&amp;amp;bar&amp;#093;&lt;/CODE&gt; behaves like a list when you assign to it, and provides a list context to
its subscript, which can do weird things if you're expecting only one
subscript.

&lt;P&gt;
On the other hand, if you were actually hoping to treat the array element
as a list, you need to look into how references work, because Perl will not
magically convert between scalars and lists for you. See
[perlman:perlref|the perlref manpage].

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;Scalar value @%s{%s} better written as $%s{%s}&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(W)&lt;/FONT&gt; You've used a hash slice (indicated by @) to
select a single element of a hash. Generally it's better to ask for a
scalar value (indicated by $). The difference is that &lt;CODE&gt;$foo{&amp;amp;bar}&lt;/CODE&gt; always behaves like a scalar, both when assigning to it and when evaluating
its argument, while &lt;CODE&gt;@foo{&amp;amp;bar}&lt;/CODE&gt; behaves like a list when you assign to it, and provides a list context to
its subscript, which can do weird things if you're expecting only one
subscript.

&lt;P&gt;
On the other hand, if you were actually hoping to treat the hash element as
a list, you need to look into how references work, because Perl will not
magically convert between scalars and lists for you. See
[perlman:perlref|the perlref manpage].

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;&lt;A NAME="item_Script"&gt;Script is not setuid/setgid in suidperl&lt;/A&gt;&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(F)&lt;/FONT&gt; Oddly, the suidperl program was invoked on a
script without a setuid or setgid bit set. This doesn't make much sense.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;&lt;A NAME="item_Search"&gt;Search pattern not terminated&lt;/A&gt;&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(F)&lt;/FONT&gt; The lexer couldn't find the final delimiter of a
// or m{} construct. Remember that bracketing delimiters count nesting
level. Missing the leading &lt;CODE&gt;$&lt;/CODE&gt; from a variable [perlman:perlop] may cause this error.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;&lt;A NAME="item__sseek_"&gt;%sseek() on unopened file&lt;/A&gt;&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(W)&lt;/FONT&gt; You tried to use the 
&lt;CODE&gt;seek()&lt;/CODE&gt; or 
&lt;CODE&gt;sysseek()&lt;/CODE&gt; function on a filehandle that was either never opened or has since been closed.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;&lt;A NAME="item_select"&gt;select not implemented&lt;/A&gt;&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(F)&lt;/FONT&gt; This machine doesn't implement the 
&lt;CODE&gt;select()&lt;/CODE&gt; system call.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;&lt;A NAME="item_sem"&gt;sem%s not implemented&lt;/A&gt;&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(F)&lt;/FONT&gt; You don't have System 
&lt;FONT SIZE=-1&gt;V&lt;/FONT&gt; semaphore 
&lt;FONT SIZE=-1&gt;IPC&lt;/FONT&gt; on your system.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;&lt;A NAME="item_semi"&gt;semi-panic: attempt to dup freed string&lt;/A&gt;&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(S)&lt;/FONT&gt; The internal 
&lt;CODE&gt;newSVsv()&lt;/CODE&gt; routine was called to duplicate a scalar that had previously been marked as free.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;&lt;A NAME="item_Semicolon"&gt;Semicolon seems to be missing&lt;/A&gt;&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(W)&lt;/FONT&gt; 
&lt;FONT SIZE=-1&gt;A&lt;/FONT&gt; nearby syntax error was probably caused by a missing semicolon, or possibly some other missing operator, such as a comma.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;&lt;A NAME="item_Send"&gt;Send on closed socket&lt;/A&gt;&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(W)&lt;/FONT&gt; The filehandle you're sending to got itself closed
sometime before now. Check your logic flow.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;&lt;A NAME="item_Sequence"&gt;Sequence (? incomplete&lt;/A&gt;&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(F)&lt;/FONT&gt; 
&lt;FONT SIZE=-1&gt;A&lt;/FONT&gt; regular expression ended with an incomplete extension (?. See
 [perlman:perlre|the perlre manpage].

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;Sequence (?#... not terminated&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(F)&lt;/FONT&gt; 
&lt;FONT SIZE=-1&gt;A&lt;/FONT&gt; regular expression comment must be terminated by a closing parenthesis. Embedded parentheses aren't allowed. See
 [perlman:perlre|the perlre manpage].

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;Sequence (?%s...) not implemented&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(F)&lt;/FONT&gt; 
&lt;FONT SIZE=-1&gt;A&lt;/FONT&gt; proposed regular expression extension has the character reserved but has not yet been written. See
 [perlman:perlre|the perlre manpage].

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;Sequence (?%s...) not recognized&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(F)&lt;/FONT&gt; You used a regular expression extension that
doesn't make sense. See [perlman:perlre|the perlre manpage].

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;&lt;A NAME="item_Server"&gt;Server error&lt;/A&gt;&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;
Also known as ``500 Server error''.

&lt;P&gt;
&lt;STRONG&gt;This is a CGI error, not a Perl error&lt;/STRONG&gt;.

&lt;P&gt;
You need to make sure your script is executable, is accessible by the user 
&lt;FONT SIZE=-1&gt;CGI&lt;/FONT&gt; is running the script under (which is probably not the user account you tested it under), does not rely on any environment variables (like 
&lt;FONT SIZE=-1&gt;PATH)&lt;/FONT&gt; from the user it isn't running under, and isn't in a location where the 
&lt;FONT SIZE=-1&gt;CGI&lt;/FONT&gt; server can't find it, basically, more or less. Please see the following for more information:

&lt;P&gt;
&lt;PRE&gt;        &lt;A HREF="http://www.perl.com/perl/faq/idiots-guide.html"&gt;http://www.perl.com/perl/faq/idiots-guide.html&lt;/A&gt;
        &lt;A HREF="http://www.perl.com/perl/faq/perl-cgi-faq.html"&gt;http://www.perl.com/perl/faq/perl-cgi-faq.html&lt;/A&gt;
        &lt;U&gt;ftp://rtfm.mit.edu/pub/usenet/news.answers/www/cgi-faq&lt;/U&gt;&lt;!--ftp://rtfm.mit.edu/pub/usenet/news.answers/www/cgi-faq--&gt;
        &lt;A HREF="http://hoohoo.ncsa.uiuc.edu/cgi/interface.html"&gt;http://hoohoo.ncsa.uiuc.edu/cgi/interface.html&lt;/A&gt;
        &lt;A HREF="http://www-genome.wi.mit.edu/WWW/faqs/www-security-faq.html"&gt;http://www-genome.wi.mit.edu/WWW/faqs/www-security-faq.html&lt;/A&gt;
&lt;/PRE&gt;
&lt;DT&gt;&lt;STRONG&gt;&lt;A NAME="item_setegid"&gt;setegid() not implemented&lt;/A&gt;&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(F)&lt;/FONT&gt; You tried to assign to &lt;CODE&gt;$)&lt;/CODE&gt;, and your operating system doesn't support the 
&lt;CODE&gt;setegid()&lt;/CODE&gt; system call (or
equivalent), or at least Configure didn't think so.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;&lt;A NAME="item_seteuid"&gt;seteuid() not implemented&lt;/A&gt;&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(F)&lt;/FONT&gt; You tried to assign to &lt;CODE&gt;$&amp;gt;&lt;/CODE&gt;, and your operating system doesn't support the 
&lt;CODE&gt;seteuid()&lt;/CODE&gt; system call (or
equivalent), or at least Configure didn't think so.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;&lt;A NAME="item_setrgid"&gt;setrgid() not implemented&lt;/A&gt;&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(F)&lt;/FONT&gt; You tried to assign to &lt;CODE&gt;$(&lt;/CODE&gt;, and your operating system doesn't support the 
&lt;CODE&gt;setrgid()&lt;/CODE&gt; system call (or
equivalent), or at least Configure didn't think so.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;&lt;A NAME="item_setruid"&gt;setruid() not implemented&lt;/A&gt;&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(F)&lt;/FONT&gt; You tried to assign to &lt;CODE&gt;$&amp;lt;&lt;/CODE&gt;, and your operating system doesn't support the 
&lt;CODE&gt;setruid()&lt;/CODE&gt; system call (or
equivalent), or at least Configure didn't think so.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;&lt;A NAME="item_Setuid"&gt;Setuid/gid script is writable by world&lt;/A&gt;&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(F)&lt;/FONT&gt; The setuid emulator won't run a script that is
writable by the world, because the world might have written on it already.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;&lt;A NAME="item_shm"&gt;shm%s not implemented&lt;/A&gt;&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(F)&lt;/FONT&gt; You don't have System 
&lt;FONT SIZE=-1&gt;V&lt;/FONT&gt; shared memory 
&lt;FONT SIZE=-1&gt;IPC&lt;/FONT&gt; on your system.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;&lt;A NAME="item_shutdown"&gt;shutdown() on closed fd&lt;/A&gt;&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(W)&lt;/FONT&gt; You tried to do a shutdown on a closed socket.
Seems a bit superfluous.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;&lt;A NAME="item_SIG"&gt;SIG%s handler &amp;quot;%s&amp;quot; not defined&lt;/A&gt;&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(W)&lt;/FONT&gt; The signal handler named in &lt;CODE&gt;%SIG&lt;/CODE&gt;
doesn't, in fact, exist. Perhaps you put it into the wrong package?

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;&lt;A NAME="item_sort"&gt;sort is now a reserved word&lt;/A&gt;&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(F)&lt;/FONT&gt; An ancient error message that almost nobody ever
runs into anymore. But before sort was a keyword, people sometimes used it
as a filehandle.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;&lt;A NAME="item_Sort"&gt;Sort subroutine didn't return a numeric value&lt;/A&gt;&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(F)&lt;/FONT&gt; 
&lt;FONT SIZE=-1&gt;A&lt;/FONT&gt; sort comparison routine must return a number. You probably blew it by not using
 &lt;CODE&gt;&amp;lt;=&amp;gt;&lt;/CODE&gt; or &lt;CODE&gt;cmp&lt;/CODE&gt;, or by not using them correctly. See [perlfunc:sort|sort].

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;Sort subroutine didn't return single value&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(F)&lt;/FONT&gt; 
&lt;FONT SIZE=-1&gt;A&lt;/FONT&gt; sort comparison subroutine may not return a list value with more or less than one element. See
 [perlfunc:sort|sort].

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;&lt;A NAME="item_Split"&gt;Split loop&lt;/A&gt;&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(P)&lt;/FONT&gt; The split was looping infinitely. (Obviously, a
split shouldn't iterate more times than there are characters of input,
which is what happened.) See [perlfunc:split|split].

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;&lt;A NAME="item_Stat"&gt;Stat on unopened file lt%sgt&lt;/A&gt;&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(W)&lt;/FONT&gt; You tried to use the 
&lt;CODE&gt;stat()&lt;/CODE&gt; function (or an equivalent file test) on a filehandle that was either never opened or has since been closed.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;&lt;A NAME="item_Statement"&gt;Statement unlikely to be reached&lt;/A&gt;&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(W)&lt;/FONT&gt; You did an 
&lt;CODE&gt;exec()&lt;/CODE&gt; with some statement after it other than a 
&lt;CODE&gt;die().&lt;/CODE&gt; This is almost always an error, because 
&lt;CODE&gt;exec()&lt;/CODE&gt; never returns unless there was a failure. You probably wanted to use 
&lt;CODE&gt;system()&lt;/CODE&gt; instead, which does return. To suppress this warning, put the 
&lt;CODE&gt;exec()&lt;/CODE&gt; in a block by itself.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;&lt;A NAME="item_Stub"&gt;Stub found while resolving method `%s' overloading `%s' in package `%s'&lt;/A&gt;&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(P)&lt;/FONT&gt; Overloading resolution over &lt;CODE&gt;@ISA&lt;/CODE&gt; tree
may be broken by importation stubs. Stubs should never be implicitely
created, but explicit calls to &lt;CODE&gt;can&lt;/CODE&gt;
may break this.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;&lt;A NAME="item_Subroutine"&gt;Subroutine %s redefined&lt;/A&gt;&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(W)&lt;/FONT&gt; You redefined a subroutine. To suppress this
warning, say

&lt;P&gt;
&lt;PRE&gt;    {
        local $^W = 0;
        eval &amp;quot;sub name { ... }&amp;quot;;
    }
&lt;/PRE&gt;
&lt;DT&gt;&lt;STRONG&gt;&lt;A NAME="item_Substitution"&gt;Substitution loop&lt;/A&gt;&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(P)&lt;/FONT&gt; The substitution was looping infinitely.
(Obviously, a substitution shouldn't iterate more times than there are
characters of input, which is what happened.) See the discussion of
substitution in
[perlman:perlop].

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;Substitution pattern not terminated&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(F)&lt;/FONT&gt; The lexer couldn't find the interior delimiter of
a s/// or s{}{} construct. Remember that bracketing delimiters count
nesting level. Missing the leading &lt;CODE&gt;$&lt;/CODE&gt; from variable [perlman:perlop] may cause this error.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;Substitution replacement not terminated&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(F)&lt;/FONT&gt; The lexer couldn't find the final delimiter of a
s/// or s{}{} construct. Remember that bracketing delimiters count nesting
level. Missing the leading &lt;CODE&gt;$&lt;/CODE&gt; from variable [perlman:perlop] may cause this error.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;&lt;A NAME="item_substr"&gt;substr outside of string&lt;/A&gt;&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(S),(W)&lt;/FONT&gt; You tried to reference a 
&lt;CODE&gt;substr()&lt;/CODE&gt; that pointed outside of a string. That is, the absolute value of the offset was larger than the length of the string. See
 [perlfunc:substr|substr]. This warning is mandatory if substr is used in an lvalue context (as the
left hand side of an assignment or as a subroutine argument for example).

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;&lt;A NAME="item_suidperl"&gt;suidperl is no longer needed since %s&lt;/A&gt;&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(F)&lt;/FONT&gt; Your Perl was compiled with &lt;STRONG&gt;-D&lt;/STRONG&gt;
&lt;FONT SIZE=-1&gt;SETUID_SCRIPTS_ARE_SECURE_NOW,&lt;/FONT&gt; but a version of the
setuid emulator somehow got run anyway.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;&lt;A NAME="item_syntax"&gt;syntax error&lt;/A&gt;&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(F)&lt;/FONT&gt; Probably means you had a syntax error. Common
reasons include:

&lt;P&gt;
&lt;PRE&gt;    A keyword is misspelled.
    A semicolon is missing.
    A comma is missing.
    An opening or closing parenthesis is missing.
    An opening or closing brace is missing.
    A closing quote is missing.
&lt;/PRE&gt;
&lt;P&gt;
Often there will be another error message associated with the syntax error
giving more information. (Sometimes it helps to turn on &lt;STRONG&gt;-w&lt;/STRONG&gt;.) The error message itself often tells you where it was in the line when
it decided to give up. Sometimes the actual error is several tokens before
this, because Perl is good at understanding random input. Occasionally the
line number may be misleading, and once in a blue moon the only way to
figure out what's triggering the error is to call
&lt;CODE&gt;perl -c&lt;/CODE&gt; repeatedly, chopping away half the program each time to see if the error
went away. Sort of the cybernetic version of 20&amp;nbsp;questions.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;syntax error at line %d: `%s' unexpected&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(A)&lt;/FONT&gt; You've accidentally run your script through the
Bourne shell instead of Perl. Check the #! line, or manually feed your
script into Perl yourself.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;&lt;A NAME="item_System"&gt;System V %s is not implemented on this machine&lt;/A&gt;&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(F)&lt;/FONT&gt; You tried to do something with a function beginning with ``sem'', ``shm'', or ``msg'' but that System 
&lt;FONT SIZE=-1&gt;V&lt;/FONT&gt; 
&lt;FONT SIZE=-1&gt;IPC&lt;/FONT&gt; is not implemented in your machine. In some machines the functionality can exist but be unconfigured. Consult your system support.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;&lt;A NAME="item_Syswrite"&gt;Syswrite on closed filehandle&lt;/A&gt;&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(W)&lt;/FONT&gt; The filehandle you're writing to got itself closed
sometime before now. Check your logic flow.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;&lt;A NAME="item_Target"&gt;Target of goto is too deeply nested&lt;/A&gt;&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(F)&lt;/FONT&gt; You tried to use [perlfunc:goto|goto] to reach a label that was too deeply nested for Perl to reach. Perl is
doing you a favor by refusing.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;&lt;A NAME="item_tell"&gt;tell() on unopened file&lt;/A&gt;&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(W)&lt;/FONT&gt; You tried to use the 
&lt;CODE&gt;tell()&lt;/CODE&gt; function on a filehandle that was either never opened or has since been closed.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;&lt;A NAME="item_Test"&gt;Test on unopened file lt%sgt&lt;/A&gt;&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(W)&lt;/FONT&gt; You tried to invoke a file test operator on a
filehandle that isn't open. Check your logic. See also [perlfunc:_X|-X].

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;&lt;A NAME="item_That"&gt;That use of $&amp;#091; is unsupported&lt;/A&gt;&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(F)&lt;/FONT&gt; Assignment to &lt;CODE&gt;$&amp;#091;&lt;/CODE&gt; is now strictly circumscribed, and interpreted as a compiler directive. You
may say only one of

&lt;P&gt;
&lt;PRE&gt;    $&amp;#091; = 0;
    $&amp;#091; = 1;
    ...
    local $&amp;#091; = 0;
    local $&amp;#091; = 1;
    ...
&lt;/PRE&gt;
&lt;P&gt;
This is to prevent the problem of one module changing the array base out
from under another module inadvertently. See [perlman:perlvar].

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;&lt;A NAME="item_The"&gt;The %s function is unimplemented&lt;/A&gt;&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;
The function indicated isn't implemented on this architecture, according to
the probings of Configure.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;The crypt() function is unimplemented due to excessive paranoia&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(F)&lt;/FONT&gt; Configure couldn't find the 
&lt;CODE&gt;crypt()&lt;/CODE&gt; function on your machine, probably because your vendor didn't supply it, probably because they think the 
&lt;FONT SIZE=-1&gt;U.S.&lt;/FONT&gt; Government thinks it's a secret, or at least that they will continue to pretend that it is. And if you quote me on that, 
&lt;FONT SIZE=-1&gt;I&lt;/FONT&gt; will deny it.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;The stat preceding -l _ wasn't an lstat&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(F)&lt;/FONT&gt; It makes no sense to test the current stat buffer
for symbolic linkhood if the last stat that wrote to the stat buffer
already went past the symlink to get to the real file. Use an actual
filename instead.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;&lt;A NAME="item_times"&gt;times not implemented&lt;/A&gt;&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(F)&lt;/FONT&gt; Your version of the 
&lt;FONT SIZE=-1&gt;C&lt;/FONT&gt; library apparently doesn't do 
&lt;CODE&gt;times().&lt;/CODE&gt; 
&lt;FONT SIZE=-1&gt;I&lt;/FONT&gt; suspect you're not running on Unix.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;&lt;A NAME="item_Too"&gt;Too few args to syscall&lt;/A&gt;&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(F)&lt;/FONT&gt; There has to be at least one argument to 
&lt;CODE&gt;syscall()&lt;/CODE&gt; to specify the system call to call, silly dilly.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;Too late for &amp;quot;-T&amp;quot; option&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(X)&lt;/FONT&gt; The #! line (or local equivalent) in a Perl script
contains the
&lt;STRONG&gt;-T&lt;/STRONG&gt; option, but Perl was not invoked with &lt;STRONG&gt;-T&lt;/STRONG&gt; in its command line. This is an error because, by the time Perl discovers a &lt;STRONG&gt;-T&lt;/STRONG&gt; in a script, it's too late to properly taint everything from the
environment. So Perl gives up.

&lt;P&gt;
If the Perl script is being executed as a command using the #! mechanism
(or its local equivalent), this error can usually be fixed by editing the
#! line so that the &lt;STRONG&gt;-T&lt;/STRONG&gt; option is a part of Perl's first argument: e.g. change &lt;CODE&gt;perl -n -T&lt;/CODE&gt; to &lt;CODE&gt;perl -T -n&lt;/CODE&gt;.

&lt;P&gt;
If the Perl script is being executed as &lt;CODE&gt;perl scriptname&lt;/CODE&gt;, then the
&lt;STRONG&gt;-T&lt;/STRONG&gt; option must appear on the command line: &lt;CODE&gt;perl -T scriptname&lt;/CODE&gt;.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;Too late for &amp;quot;-%s&amp;quot; option&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(X)&lt;/FONT&gt; The #! line (or local equivalent) in a Perl script
contains the
&lt;STRONG&gt;-M&lt;/STRONG&gt; or &lt;STRONG&gt;-m&lt;/STRONG&gt; option. This is an error because &lt;STRONG&gt;-M&lt;/STRONG&gt; and &lt;STRONG&gt;-m&lt;/STRONG&gt; options are not intended for use inside scripts. Use the [perlfunc:use|use] pragma instead.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;Too many ('s&lt;/STRONG&gt;&lt;DD&gt;
&lt;DT&gt;&lt;STRONG&gt;Too many )'s&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(A)&lt;/FONT&gt; You've accidentally run your script through &lt;STRONG&gt;csh&lt;/STRONG&gt; instead of Perl. Check the #! line, or manually feed your script into Perl
yourself.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;Too many args to syscall&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(F)&lt;/FONT&gt; Perl supports a maximum of only 14 args to 
&lt;CODE&gt;syscall().&lt;/CODE&gt;

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;Too many arguments for %s&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(F)&lt;/FONT&gt; The function requires fewer arguments than you
specified.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;&lt;A NAME="item_trailing"&gt;trailing \ in regexp&lt;/A&gt;&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(F)&lt;/FONT&gt; The regular expression ends with an unbackslashed
backslash. Backslash it. See [perlman:perlre|the perlre manpage].

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;&lt;A NAME="item_Transliteration"&gt;Transliteration pattern not terminated&lt;/A&gt;&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(F)&lt;/FONT&gt; The lexer couldn't find the interior delimiter of
a tr/// or tr&amp;#091;&amp;#093;&amp;#091;&amp;#093; or y/// or y&amp;#091;&amp;#093;&amp;#091;&amp;#093; construct. Missing the leading &lt;CODE&gt;$&lt;/CODE&gt; from variables
[perlman:perlop] or [perlman:perlop] may cause this error.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;Transliteration replacement not terminated&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(F)&lt;/FONT&gt; The lexer couldn't find the final delimiter of a
tr/// or tr&amp;#091;&amp;#093;&amp;#091;&amp;#093; construct.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;&lt;A NAME="item_truncate"&gt;truncate not implemented&lt;/A&gt;&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(F)&lt;/FONT&gt; Your machine doesn't implement a file truncation
mechanism that Configure knows about.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;&lt;A NAME="item_Type"&gt;Type of arg %d to %s must be %s (not %s)&lt;/A&gt;&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;(F)&lt;/FONT&gt; This function requires the argument in that
position to be of a certain type. Arrays must be &lt;CODE&gt;@NAME&lt;/CODE&gt; or &lt;CODE&gt;@{EXPR}&lt;/CODE&gt;. Hashes must be &lt;CODE&gt;%NAME&lt;/CODE&gt; or &lt;CODE&gt;%{EXPR}&lt;/CODE&gt;. No implicit dereferencing is allowed--use the 
&lt;FONT SIZE=-1&gt;{EXPR}&lt;/FONT&gt; forms as an explicit dereference. See [perlman:perlref|the perlref manpage].

&lt;/DL&gt;
&lt;BR&gt;[perlman:perldiag3|More...]&lt;BR&gt;
&lt;BR&gt;Return to the [Library]&lt;BR&gt;
</field>
</data>
</node>
