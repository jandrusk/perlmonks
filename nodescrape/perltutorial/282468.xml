<?xml version="1.0" encoding="windows-1252"?>
<node id="282468" title="An introduction to POE" created="2003-08-09 16:05:16" updated="2005-08-15 14:11:35">
<type id="956">
perltutorial</type>
<author id="151991">
RMGir</author>
<data>
<field name="doctext">
[http://poe.perl.org|POE] is the Perl Object Environment, a
cooperative multitasking framework that makes it easy to answer
questions like [id://282322|How do I make STDIN time out].
&lt;p&gt;
I only started looking at POE this week, because the [id://281219]
thread piqued my interest.  That thread points to 
[http://axkit.org/docs/presentations/tpc2002/poe.axp/poe.pdf|several] 
[http://www.perl.com/pub/a/2001/01/poe.html|good]
[http://poe.perl.org/?Evolution_of_a_poe_server|tutorials]
on POE,but I thought we should have one here as well.  Also, putting this together is helping me figure POE a bit better, and giving me ideas for more fun areas to explore.   I think POE and (Tk|Curses) will be next...
&lt;p&gt;
POE lets you write programs that handle input from multiple
asynchronous sources.  Those are big words, but they just mean
you'll get the info when it's available, and you don't have
to worry about waiting for it. :)
&lt;p&gt;
The cooperation is done by creating a set of states, which
are invoked by events.  Events are generated by input engines
(called Wheels), by timers, or by other states.
&lt;br /&gt;&lt;readmore&gt;&lt;br /&gt;
At the heart of POE lies to POE kernel.  It keeps a queue of
timed events, and uses the OS's select or poll functionality
to watch any file handles or sockets you're interested in
for activity.  When it's time for an event to fire, or data
is available, the associated state handler is invoked. Other event
loops are also available, making it possible to have POE
programs that have [id://278704|Tk] or curses GUIs, for instance.
&lt;p&gt;
The sample this tutorial is built around is my answer to the
STDIN timeout question asked above.  You'll see that it's very
easy to write an interactive application in POE with command-line
editing and history.
&lt;p&gt;
The first step in any POE program is using the POE module.
Since POE programs often need to use other modules from the
POE:: namespace, you can do
&lt;p&gt;
&lt;pre&gt;
	use POE qw/Wheel::ReadLine Component::Client::HTTP::SSL/;
&lt;/pre&gt;
as a shortcut for
&lt;pre&gt;
	use POE;
	use POE::Wheel::ReadLine;
	use POE::Component::Client::HTTP::SSL;
&lt;/pre&gt;
&lt;p&gt;
In this case, we only need POE::Wheel::ReadLine, which will handle
our input requirements.
&lt;p&gt;
Each program consists of one or more POE Sessions, which
hold a set of states.
&lt;code&gt;
#!/usr/bin/perl -w
use strict;

# Use POE!
use POE qw/Wheel::ReadLine/;

# Need to do this on Cygwin
#$/="\n\r";

# flush STDOUT automatically
$|++;


  POE::Session-&gt;create(
    inline_states =&gt;
      { _start    =&gt; \&amp;handler_start,
        gotLine   =&gt; \&amp;handler_gotLine,
        prompt    =&gt; \&amp;handler_prompt,
        timeout   =&gt; \&amp;handler_timeout,
        #_stop     =&gt; \&amp;handler_stop,
      }
  );
&lt;/code&gt;
In the session's constructor, we specify a hash of state names, and the
state handlers associated with them.  The subroutines can be named, as they
are here, or they can be anonymous sub references.
&lt;p&gt;
The _start and _stop states are special; they are invoked by the kernel when
the session is created, or just before it's destroyed.
&lt;p&gt;
In this case, we don't need to do anything special to handle
_stop, so that state is commented out, and the handler isn't implemented.
&lt;p&gt;
That means that your _start handler will be invoked before 
POE::Session-&amp;gt;create returns.
&lt;p&gt;
The next step is to start the kernel running, and exit the program once
it's done.
&lt;p&gt;
&lt;code&gt;
$poe_kernel-&gt;run();
exit;
&lt;/code&gt;
$poe_kernel is exported by POE automatically.
&lt;p&gt;
Of course, we haven't DEFINED any state handlers yet, so our program won't
even compile, let alone run.
&lt;p&gt;
Every POE state handler is passed a large number of arguments in @_.  The
most interesting ones are the heap, kernel, and session associated with this
state.
&lt;p&gt;
The poe heap is just a scalar, which usually is used as a hash reference.
&lt;p&gt;
These values can be accessed using an array slice on @_ to initialize
scope variables, or explicitly referred to as $_&amp;#091;HEAP&amp;#093;, $_&amp;#091;KERNEL&amp;#093;, or $_&amp;#091;SESSION&amp;#093;. POE exports HEAP, KERNEL,
SESSION, and several other constants automatically.
&lt;p&gt;
The first handler we'll see is our start handler:
&lt;code&gt;
sub handler_start {
  my ($kernel, $heap, $session) = @_[KERNEL, HEAP, SESSION];

  # POE::Wheel::ReadLine gets you terminal input with command line
  # history.  whenever a line is input, the 'gotLine' event
  # will run
  $heap-&gt;{wheel} = POE::Wheel::ReadLine-&gt;new
  	(
		InputEvent =&gt; 'gotLine',
	);

  # ask for the prompt event to get run next
  $kernel-&gt;yield('prompt');
}
&lt;/code&gt;
POE's wheels are modules which handle the hassle of gluing outside
event generators, like sockets or file handles, to POE states.
&lt;p&gt;
POE::Wheel::ReadLine is a special wheel which invokes states when
data is input on the console.  It also handles command line editing
and history, with a bit of help from us.
&lt;p&gt;
Note that we save the wheel in our %{$heap} hash.  Otherwise, the wheel would
be immediately destroyed, since there would be no outstanding references
to it.  We'll use that trick later, when it's time to exit.  For now,
we just associate the wheel's InputEvent with our 'gotLine' state (handled 
by handler_gotLine).  Then, we use "yield" to ask the kernel to schedule the 
prompt state as soon as possible.
&lt;code&gt;
sub handler_prompt {
  my ($kernel, $heap, $session) = @_[KERNEL, HEAP, SESSION];

  print "You have 10 seconds to enter something, or I'll quit!$/";
  $heap-&gt;{wheel}-&gt;get('Type fast: ');

  # this will make the timeout event fire in 10 seconds
  $kernel-&gt;delay('timeout',10);
}
&lt;/code&gt;
All this handler does is use the get method on our Wheel to prompt the user
for input, and then schedule a timeout event in 10 seconds.
&lt;p&gt;
Even if this isn't the first time this handler is invoked, calling delay
removes the old event, and schedules a new one 10 seconds out.
&lt;p&gt;
From here, things are in the hands of the kernel.  If the user does nothing,
in 10 seconds (or so, timeouts are approximate) the timeout state will be
triggered:
&lt;code&gt;
sub handler_timeout {
  my ($kernel, $heap, $session) = @_[KERNEL, HEAP, SESSION];

  # taunt (or inform) the user
  print "You took too long, game over$/";

  # setting this to undef will make our Wheel get shutdown
  # with no wheel, and no pending delay event, the kernel
  # queue is empty resulting in shutdown
  $heap-&gt;{wheel}=undef;
}
&lt;/code&gt;
When the wheel member is undefined in handler_timeout, the wheel is destroyed,
and since there are no pending events and no event sources, the kernel exits.
&lt;p&gt;
If the user does enter something, or hits Ctrl-C, the gotLine handler is called.
&lt;code&gt;
sub handler_gotLine {
  my ($kernel, $heap, $session, $arg, $exception) = 
			@_[KERNEL, HEAP, SESSION, ARG0, ARG1];

  if(defined $arg) {
    $heap-&gt;{wheel}-&gt;addhistory($arg);
    print "Very good, you entered '$arg'.  You get another 10 seconds.$/";
  }
  else {
    print "Got input exception '$exception'.  Exiting...$/";

    # setting this to undef will make our Wheel get shutdown
    $heap-&gt;{wheel}=undef;
    # setting a delay without a timeout number clears the event
    $kernel-&gt;delay('timeout');

    return;
  }

  # run the prompt event again to reset timeout and print
  # new prompt
  $kernel-&gt;yield('prompt');
}
&lt;/code&gt;
One thing that's interesting here is that we read the ARG0 and ARG1 members
of @_.  POE passes the arguments last in @_, ranging from ARG0 to $#_.  In
the case of an InputHandler for this wheel, ARG0 is the text input, and
if ARG0 is undef, ARG1 is the exception code.
&lt;p&gt;
After "handling" the input, this handler yields back to the prompt handler, 
which reschedules the timeout and prompts the user again.
&lt;/readmore&gt;&lt;p&gt;
I hope this quick walkthru of a simple POE program will help you understand
how POE operates.  The other tutorials and beginners guides I linked up above
are even better, so you should be up and running from state to state in no
time. :)
&lt;p&gt;&lt;small&gt;Edit by [tye], add READMORE&lt;/small&gt;&lt;/p&gt;</field>
</data>
</node>
