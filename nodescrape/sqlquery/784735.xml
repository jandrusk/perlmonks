<?xml version="1.0" encoding="windows-1252"?>
<node id="784735" title="Live-patched nodes" created="2009-07-30 16:53:11" updated="2009-07-30 16:53:11">
<type id="397475">
sqlquery</type>
<author id="518801">
Co-Rion</author>
<sqlqueryresult><rows_affected>195</rows_affected>
<record><htmlcode_id>485870</htmlcode_id>
<patch_code>return   if  $USER-&gt;{node_id} eq $HTMLVARS{guest_user};
my $CLONER = getNode( 'node cloner', 'superdoc' );
my $PARAMS = {
   srcnode_id =&gt; $NODE-&gt;{node_id},
   node_id    =&gt; $CLONER-&gt;{node_id},
   newname    =&gt; 'NEWNAME'
};

my $url = urlGen($PARAMS);
my $js_title=quotemeta($NODE-&gt;{title});
my $str =&lt;&lt;"END";
   &lt;script language="javascript"&gt;
      function cloneNode() {
         var newname = prompt(
            'Cloning node "$js_title"\\nEnter a new name:',
            ''
         );
         if(newname) {
            var url = $url;
            url = url.replace(/NEWNAME/, newname);
            url = url.replace(/ /g, "%20");
            parent.location = url;
         }
      }
   &lt;/script&gt;
END

my $disp = $query-&gt;param('displaytype') || '';

for(  getPages( $NODE )  ) {
   if(    'edit' ne $_-&gt;{displaytype}
      or  canUpdateNode( $USER, $NODE )
   ) {
      $str .= "re"
         if  $disp eq $_-&gt;{displaytype};
      $str .= linkNode(
         $NODE,
         $_-&gt;{displaytype},
         { displaytype =&gt; $_-&gt;{displaytype} }
      ) . ' ';
   }
}

if(     $query-&gt;param("displaytype") ne "voteview"
   and      $NODE-&gt;{votescast}
        ||  $NODE-&gt;{reputation}
        ||  'user' eq $NODE-&gt;{type}{title}
) {
   $str .= ' ' . linkNode(
      $NODE, 'votes', { displaytype =&gt; 'voteview' }
   ) . $/;
}

$str .= linkNode(
   153451, "dump", { dumpid =&gt; $NODE-&gt;{node_id} }
) . $/;


$str .= qq(&lt;a href="javascript: cloneNode();"&gt;clone&lt;/a&gt;(js)\n);
$str .= ' ' . htmlcode('clonetotype') . "\n";

if(  $VARS-&gt;{group}  ) {
   my $GR = $DB-&gt;getNodeById( $VARS-&gt;{group}, 'light' );
   if(  canUpdateNode( $USER, $GR )  ) {
   $str .= sprintf qq[
         &lt;a href="javascript:window.open( '%s', '$VARS-&gt;{group}', '' )"&gt;
            add to &amp;quot;$GR-&gt;{title}&amp;quot;
         &lt;/a&gt;
         &lt;br /&gt;
      ],
      urlGen(
         {
            node_id     =&gt; $VARS-&gt;{group},
            displaytype =&gt; 'editor',
            add         =&gt; getId( $NODE ),
         },
         'noquotes'
      );
   }
}
$_ = $NODE-&gt;{type_nodetype};
$VARS-&gt;{group} = getId($NODE) if $_ eq 8 or $_ eq 10;
#$str .= '(test)' if $_ eq 8 or $_ eq 10;
return $str   unless  isGod($USER);

# htmlcode( 'reapnode', getId($NODE) )
#    if # $query-&gt;param('reap') eq 'yes';
# $str . sprintf qq(      &lt;a href=%s&gt;REAP NODE&lt;/a&gt;\n),
#               urlGen( { node_id =&gt; getId($NODE), reap =&gt; # 'yes' } );

$str .= linkNode( $NODE, "unreap", { op=&gt;'unreap' } )
   if  $DB-&gt;sqlSelect(
         'node_id', 'reapednode', 'node_id = ' . getId($NODE)
       );

return $str;</patch_code>
<applied>2005-08-23 06:57:53</applied>
<htmlcode_id>26</htmlcode_id>
<live_code>return ''  unless  isGod($USER);

my $CLONER = getNode( 'node cloner', 'superdoc' );
my $PARAMS = {
   srcnode_id =&gt; $NODE-&gt;{node_id},
   node_id    =&gt; $CLONER-&gt;{node_id},
   newname    =&gt; 'NEWNAME'
};

my @links;

my $url = urlGen($PARAMS);
my $js_title=quotemeta($NODE-&gt;{title});
my $js = &lt;&lt;"END";
   &lt;script language="javascript"&gt;
      function cloneNode() {
         var newname = prompt(
            'Cloning node "$js_title"\\nEnter a new name:',
            ''
         );
         if(newname) {
            var url = $url;
            url = url.replace(/NEWNAME/, newname);
            url = url.replace(/ /g, "%20");
            parent.location = url;
         }
      }
   &lt;/script&gt;
END

my $disp = $query-&gt;param('displaytype') || '';

for(  getPages( $NODE )  ) {
   if(    'edit' ne $_-&gt;{displaytype}
      or  canUpdateNode( $USER, $NODE )
   ) {
      push @links, 
         ( $disp eq $_-&gt;{displaytype} ? 're' : '' )
         . linkNode(
            $NODE,
            $_-&gt;{displaytype},
            { displaytype =&gt; $_-&gt;{displaytype} }
         );
   }
}

if(     $query-&gt;param("displaytype") ne "voteview"
   and      $NODE-&gt;{votescast}
        ||  $NODE-&gt;{reputation}
        ||  'user' eq $NODE-&gt;{type}{title}
) {
   push @links, linkNode(
      $NODE, 'votes', { displaytype =&gt; 'voteview' }
   );
}

push @links, linkNode(
   153451, "dump", { dumpid =&gt; $NODE-&gt;{node_id} }
);


push @links, '&lt;a href="javascript: cloneNode();"&gt;clone&lt;/a&gt;(js)';
push @links, htmlcode('clonetotype');


# htmlcode( 'reapnode', getId($NODE) )
#    if # $query-&gt;param('reap') eq 'yes';
# push @links, sprintf qq(      &lt;a href=%s&gt;REAP NODE&lt;/a&gt;\n),
#               urlGen( { node_id =&gt; getId($NODE), reap =&gt; # 'yes' } );

push @links, linkNode( $NODE, "unreap", { op=&gt;'unreap' } )
   if  $DB-&gt;sqlSelect(
         'node_id', 'reapednode', 'node_id = ' . getId($NODE)
       );

return join "\n", $js, map '&lt;li&gt;'.$_.'&lt;/li&gt;', @links;
</live_code>
<reason>superdoc related</reason>
<field>code</field>
</record>
<record><htmlcode_id>702960</htmlcode_id>
<patch_code>my( $field, $oneline )= @_;
my $text = $NODE-&gt;{$field}||'';

$text = encodeHTML($text, 1);

my $lnt= sub {
    my( $title, $type )= @_;
    $title =~ s/&amp;nbsp;/ /g;
    return genLink( $q-&gt;escapeHTML($title), { node=&gt;$title, type=&gt;$type } );
};

# Search for [{text}] and replace the text with a link:
$text =~ s&lt; ( &amp;\#91;{ ) ([^:{}]*?) ( : | }&amp;\#93; ) &gt;{
    $1 . $lnt-&gt;( $2, 'htmlcode' ) . $3
}xegs;

my $sp= qr/\s|&amp;nbsp;/;
my $qt= qr/&amp;quot;/;
# Search for 'getNode( "text", "text" )' and replace
# the text with a link to the appropriate node:
$text =~ s{
    (                          # 1
      (getNode $sp*[(]$sp*)    # 2
      ( "[^"]*"
       |'[^']*'
       |$qt(?:(?!$qt).)*$qt
      )                        # 3
      ($sp*,$sp*)              # 4
      ( "[^"]*"
       |'[^']*'
       |$qt(?:(?!$qt).)*$qt
      )                        # 5
      ($sp*[)])                 # 6
    )
}{
    my( $full, $open, $title, $comma, $type, $close )=
        ( $1, $2, $3, $4, $5, $6 );
    $title =~ s/^(['"]|$qt)?//;
    my $q1= $1;
    $title =~ s/\Q$q1\E$//;
    $type =~ s/^(['"]|$qt)?//;
    my $q2= $1;
    $type =~ s/\Q$q2\E$//;
    $open . $q1 . $lnt-&gt;( $title, $type ) . $q1
        . $comma . $q2 . $lnt-&gt;( $type, 'nodetype' ) . $q2 . $close;
}xegs;

# Search for 'htmlcode( "text", params... )' and replace
#            'getNode( "text", params... )'
#            'getType( "text" )'
# the text with a link to the referenced node:
$text =~ s{
    (                            # 1
      (htmlcode|getNode|getType) # 2
      ($sp*[(]$sp*)              # 3
      ( "[^"&lt;&gt;]*"
       |'[^'&lt;&gt;]*'
       |$qt(?:(?!$qt)[^&lt;&gt;])*$qt
      )                          # 4
      ($sp*[,)])                 # 5
    )
}{
    my( $full, $name, $open, $title, $close )=
        ( $1, $2, $3, $4, $5 );
    $title =~ s/^(['"]|$qt)?//;
    my $quote= $1;
    $title =~ s/\Q$quote\E$//;
    my $type= { htmlcode=&gt;'htmlcode', getType=&gt;'nodetype' }-&gt;{$name} || '';
    $name . $open . $quote . $lnt-&gt;( $title, $type ) . $quote . $close;
}xegs;

# add line numbers:
my $count = 1;
$text =~ s/^/ sprintf "%4d: ",$count++ /meg;

$text = &lt;&lt;EOF;
&lt;!-- Begin Code View --&gt;
&lt;div class="listcode"&gt;
&lt;pre&gt;
$text
&lt;/pre&gt;
&lt;/div&gt;
&lt;!--  End Code View  --&gt;
EOF

return $text
    if  'edit' eq $q-&gt;param('displaytype')
    or  'print' eq $q-&gt;param('displaytype')
    or  'patch' eq $NODE-&gt;{type}{title};

# Breaks the form on code edit pages and patching a patch
# may get confusing.

if(  $DB-&gt;isApproved(
        $USER,
        getNode('pmdev','usergroup') )
) {
   $text .= qq[
      &lt;b&gt;Submit a patch&lt;/b&gt;
      ];

   $text .= htmlcode( 'open_new_patch_form', '', $field, "display" );
   $text .= qq[
      &lt;br /&gt;Reason for patch: ] . $q-&gt;textfield(
         -name=&gt;'patch_reason', -maxlength=&gt;80 ) . qq[&lt;br /&gt;
      ];
   $text .= $q-&gt;textfield(
             'patch_code', $NODE-&gt;{$field} )
      if  $oneline;
   $text .= $q-&gt;textarea(
             'patch_code', $NODE-&gt;{$field}, 20, 60 )
      if  ! $oneline;
   $text .= qq[&lt;br /&gt;
      ] . htmlcode('closeform','','Submit Patch');
}

return $text;
</patch_code>
<applied>2008-08-10 05:12:15</applied>
<htmlcode_id>37</htmlcode_id>
<live_code>my( $field, $oneline )= @_;
my $html= $NODE-&gt;{$field} || '';
$html= encodeHTML( $html, 1 );

my $lnt= sub {
    my( $title, $type )= @_;
    $title =~ s/&amp;nbsp;/ /g;
    return genLink( $q-&gt;escapeHTML($title), { node=&gt;$title, type=&gt;$type } );
};

# Search for [{name}] and replace the name with a link:
$html =~ s&lt; ( &amp;\#91;{ ) ([^:{}]*?) ( : | }&amp;\#93; ) &gt;{
    $1 . $lnt-&gt;( $2, 'htmlcode' ) . $3
}xegs;

my $sp= qr/\s|&amp;nbsp;/;
my $qt= qr/&amp;quot;/;
# Search for 'getNode( "text", "text" )' and replace
# the text with a link to the appropriate node:
$html =~ s{
    (                          # 1
      (getNode $sp*[(]$sp*)    # 2
      ( "[^"]*"
       |'[^']*'
       |$qt(?:(?!$qt).)*$qt
      )                        # 3
      ($sp*,$sp*)              # 4
      ( "[^"]*"
       |'[^']*'
       |$qt(?:(?!$qt).)*$qt
      )                        # 5
      ($sp*[)])                 # 6
    )
}{
    my( $full, $open, $title, $comma, $type, $close )=
        ( $1, $2, $3, $4, $5, $6 );
    $title =~ s/^(['"]|$qt)?//;
    my $q1= $1;
    $title =~ s/\Q$q1\E$//;
    $type =~ s/^(['"]|$qt)?//;
    my $q2= $1;
    $type =~ s/\Q$q2\E$//;
    $open . $q1 . $lnt-&gt;( $title, $type ) . $q1
        . $comma . $q2 . $lnt-&gt;( $type, 'nodetype' ) . $q2 . $close;
}xegs;

# Search for 'htmlcode( "text", params... )' and replace
#            'getNode( "text", params... )'
#            'getType( "text" )'
# the text with a link to the referenced node:
$html =~ s{
    (                            # 1
      (htmlcode|getNode|getType) # 2
      ($sp*[(]$sp*)              # 3
      ( "[^"&lt;&gt;]*"
       |'[^'&lt;&gt;]*'
       |$qt(?:(?!$qt)[^&lt;&gt;])*$qt
      )                          # 4
      ($sp*[,)])                 # 5
    )
}{
    my( $full, $name, $open, $title, $close )=
        ( $1, $2, $3, $4, $5 );
    $title =~ s/^(['"]|$qt)?//;
    my $quote= $1;
    $title =~ s/\Q$quote\E$//;
    my $type= { htmlcode=&gt;'htmlcode', getType=&gt;'nodetype' }-&gt;{$name} || '';
    $name . $open . $quote . $lnt-&gt;( $title, $type ) . $quote . $close;
}xegs;

# add line numbers:
my $count= 1;
$html =~ s/^/ sprintf "%4d: ",$count++ /meg;

my $FIND= $NODE;
$FIND= selectNode( $NODE-&gt;{for_node} )
    if  'patch' eq $NODE-&gt;{type}{title};

$html= join "\n",
    '&lt;!-- Begin Code View --&gt;',
    '&lt;div class="listcode"&gt;&lt;pre&gt;',
    $html,
    '&lt;/pre&gt;&lt;/div&gt;',
    '&lt;!--  End Code View  --&gt;',
    '&lt;p&gt;Search for',
    genLink(
        "uses of " . $q-&gt;escapeHTML( $FIND-&gt;{title} ),
        {
            # node_id =&gt; 157620,
            node =&gt; 'search internal code',
            type =&gt; 'superdoc',
            searchterms =&gt; $FIND-&gt;{title},
            sic_dogrep =&gt; 1,
        },
    ),
    '&lt;/p&gt;',
'';

return $html
    if  'edit' eq $q-&gt;param('displaytype')
    ||  'print' eq $q-&gt;param('displaytype')
    ||  'patch' eq $NODE-&gt;{type}{title};

# Breaks the form on code edit pages and patching a patch
# may get confusing.

if(  $DB-&gt;isApproved( $USER, 'pmdev' )  ) {
    $html .= join "\n",
        "&lt;b&gt;Submit a patch&lt;/b&gt;",
        htmlcode( 'open_new_patch_form','', $field, "display" ),
        "&lt;br /&gt;Reason for patch:",
        $q-&gt;textfield(
            -name =&gt; 'patch_reason', -size =&gt; 80, -maxlength =&gt; 80 ),
        '&lt;br /&gt;',
        $oneline
            ?   $q-&gt;textfield( 'patch_code', $NODE-&gt;{$field} )
            :   $q-&gt;textarea( 'patch_code', $NODE-&gt;{$field}, 20, 60 ),
        '&lt;br /&gt;',
        htmlcode( 'closeform','', 'Submit Patch' ),
    '';
}

return $html;
</live_code>
<reason>disuse listCode from Ev/HTML, so we can add line numbers last</reason>
<field>code</field>
</record>
<record><htmlcode_id>720868</htmlcode_id>
<patch_code>return "&lt;!-- you have nodelets turned off --&gt;"
  if $VARS-&gt;{nodelets_off};

my @nodelets;
@nodelets = split ',', $VARS-&gt;{nodelets} if exists $VARS-&gt;{nodelets};

if( getId($NODE) == $HTMLVARS{default_node} or $VARS-&gt;{fpeqnonfp} ) {
  @nodelets = split ',', $VARS-&gt;{fpnodelets} if exists $VARS-&gt;{fpnodelets};
}

if ( @nodelets ) {
  my( $hasApp, $hasStat, $hasEd, $hasXp )= map {
    0 &lt;= index( " @nodelets ", " $_ " )
  } my( $approve, $status, $editors, $xp )= map {
    getId( getNode($_,'nodelet') )
  } 'Approval Nodelet', 'Node Status', 'Editors Nodelet', 'XP Nodelet';
  # $VARS-&gt;{approvalnodelet} is a defunct setting:
  unshift @nodelets, $approve
    if  $VARS-&gt;{approvalnodelet}  &amp;&amp;  ! $hasApp;
  unshift @nodelets, $status
      unless  $hasApp  ||  $hasStat;
  # $VARS-&gt;{editorsnodelet} is a defunct setting:
  unshift @nodelets, $editors
    if  $VARS-&gt;{editorsnodelet}  &amp;&amp;  ! $hasEd;
  unshift @nodelets, $xp
    if  ! $hasXp;
}

my ($NODELETGROUP) = $VARS-&gt;{nodelet_group}
                   ? $DB-&gt;getNodeById( $VARS-&gt;{nodelet_group} )
                   : {};

if ( $NODELETGROUP-&gt;{type}{title} eq 'nodeletgroup') {
  @nodelets =  @{ $NODELETGROUP-&gt;{group} } unless @nodelets;
}

unless ( @nodelets ) {
  my( $DEFAULT ) = $DB-&gt;getNodeById( $HTMLVARS{default_nodeletgroup} );
  @nodelets      = @{ $DEFAULT-&gt;{group} };
}
return "&lt;!-- no nodelets! --&gt;" unless @nodelets;

my %seen;
my $nlts;
for my $node (grep { ! $seen{$_}++ } grep /\d/, @nodelets) {
  $nlts .= insertNodelet( $DB-&gt;getNodeById($node) );
}
my $elem = $VARS-&gt;{'nodelets_as_div'} ? 'div' : 'table';
&lt;&lt;END;
&lt;$elem class="nodelet_container" id="nodelet_container"&gt;
$nlts
&lt;/$elem&gt;
END</patch_code>
<applied>2008-11-01 13:19:16</applied>
<htmlcode_id>40</htmlcode_id>
<live_code>return "&lt;!-- you have nodelets turned off --&gt;"
    if  $VARS-&gt;{nodelets_off};

my @nodelets;
@nodelets= split ',', $VARS-&gt;{nodelets}
    if  exists $VARS-&gt;{nodelets};
if(  getId($NODE) == $HTMLVARS{default_node}  ||  $VARS-&gt;{fpeqnonfp}  ) {
    @nodelets= split ',', $VARS-&gt;{fpnodelets}
        if  exists $VARS-&gt;{fpnodelets};
}

if(  ! @nodelets  &amp;&amp;  $VARS-&gt;{nodelet_group}  ) {
    my( $NODELETGROUP )= $DB-&gt;getNodeById( $VARS-&gt;{nodelet_group} );
    @nodelets= @{ $NODELETGROUP-&gt;{group} }
        if  $NODELETGROUP-&gt;{type}{title} eq 'nodeletgroup';
}
if(  ! @nodelets  ) {
    my( $DEFAULT )= $DB-&gt;getNodeById( $HTMLVARS{default_nodeletgroup} );
    @nodelets= @{ $DEFAULT-&gt;{group} };
}
return "&lt;!-- no nodelets! --&gt;"
    if  ! @nodelets;

my( $hasApp, $hasStat, $hasEd, $hasXp, $hasLogin )= map {
    0 &lt;= index( " @nodelets ", " $_ " )
} my( $approve, $status, $editors, $xp, $login )= map {
    getId( getNode($_,'nodelet') )
}   'Approval Nodelet', 'Node Status', 'Editors Nodelet',
    'XP Nodelet', 'Log In';
# $VARS-&gt;{approvalnodelet} is a defunct setting:
unshift @nodelets, $approve
    if  $VARS-&gt;{approvalnodelet}  &amp;&amp;  ! $hasApp;
unshift @nodelets, $status
    if  ! $hasApp  &amp;&amp;  ! $hasStat;
# $VARS-&gt;{editorsnodelet} is a defunct setting:
unshift @nodelets, $editors
    if  $VARS-&gt;{editorsnodelet}  &amp;&amp;  ! $hasEd;
unshift @nodelets, $xp
    if  ! $hasXp  &amp;&amp;  getId($USER) != $HTMLVARS{guest_user};
unshift @nodelets, $login
    if  ! $hasLogin  &amp;&amp;  getId($USER) == $HTMLVARS{guest_user};

my( %seen, $nlts );
for my $node (  @nodelets  ) {
    next
        if  $node !~ /\d/
        ||  $seen{$node}++;
    $nlts .= insertNodelet( $DB-&gt;getNodeById($node) );
}

my $elem= $VARS-&gt;{'nodelets_as_div'} ? 'div' : 'table';
return join "\n",
    "&lt;$elem class='nodelet_container' id='nodelet_container'&gt;",
    $nlts,
    "&lt;/$elem&gt;",
'';</live_code>
<reason>switch on nodelets_as_div. this should be all.</reason>
<field>code</field>
</record>
<record><htmlcode_id>680591</htmlcode_id>
<patch_code>my( $field, $readmore_remove)= @_;
  
return htmlcode( 'ParseLinksInContent', '', $NODE-&gt;{$field},
                  id=&gt; $NODE-&gt;{node_id}, 
                  parsecode=&gt; 1,
                  readmore_remove =&gt; $readmore_remove,
                  no_dl =&gt; 1,
                  nodetype=&gt; $NODE-&gt;{type}{title},
                  overridefilter=&gt;'override' );</patch_code>
<applied>2008-04-15 13:39:54</applied>
<htmlcode_id>43</htmlcode_id>
<live_code>my( $field, $readmore_remove )= @_;

return htmlcode(
    'ParseLinksInContent','',
    $NODE-&gt;{$field},
    id =&gt; $NODE-&gt;{node_id},
    parsecode =&gt; 1,
    readmore_remove =&gt; $readmore_remove,
    no_dl =&gt; 1,
    nodetype =&gt; $NODE-&gt;{type}{title},
    overridefilter =&gt; 'override',
);
</live_code>
<reason>Clean up names to make them case sensitive</reason>
<field>code</field>
</record>
<record><htmlcode_id>483338</htmlcode_id>
<patch_code>   my( $field, $overridefilter )= @_;
   $field||='doctext';
   return htmlcode ( 'ParseLinksInContent', '', 
     $NODE-&gt;{$field}, 
     id =&gt; $NODE-&gt;{node_id},
     readmore_remove =&gt; 1,
     overridefilter =&gt; $overridefilter,
   ) unless $q-&gt;param('oldparselinks');

   my $text= $NODE-&gt;{$field};
   $HTMLVARS{buybook}= $text =~ /(book)|(reference)/i;
   $text =~ s[(&lt;code&gt;(.*?)&lt;/code&gt;)]{
      my $whole= $1;
      my $code= $2;
      $HTMLVARS{code} .= $code;
      if(  $HTMLVARS{codereplaceoff}  ) {
         $whole;
      } else {
         htmlcode( 'wrapcode','', $code );
      }
   }gies;

   $text=htmlcode('handle_readmore','',$NODE-&gt;{node_id},$text,0,1);
   htmlcode( "perlfuncadder" );
   if(  getId($NODE) == 142755  ) { # [tye&amp;nbsp;] for testing
      $text =~ s#\[([^\[\]]{0,4096})\]#
         my $x= $1;
         htmlcode( 'linkHandler','', $x, getId($NODE) )#eg;
   } else {
      $text =~ s#\[(.*?)\]#handleLinks($1,getId($NODE))#egs;
   }
   my $APPROVED= getVars( getNode('approved html tags','setting') );
   if( ref $overridefilter ) {
      @{$APPROVED}{keys %$overridefilter} = values %$overridefilter;
   } elsif( $overridefilter eq 'allowImg' ) {
      $$APPROVED{img} = 'alt,border,height,src,width'
         unless exists $$APPROVED{img};
   }
   $text= htmlScreen( $text, $APPROVED )
      unless  $overridefilter eq "override";
   return $text;
</patch_code>
<applied>2005-08-12 12:49:23</applied>
<htmlcode_id>44</htmlcode_id>
<live_code>my( $field, $overridefilter )= @_;
return htmlcode( 'ParseLinksInContent','',
    $NODE-&gt;{ $field || 'doctext' },
    id =&gt; $NODE-&gt;{node_id},
    readmore_remove =&gt; 1,
    overridefilter =&gt; $overridefilter,
);
</live_code>
<reason>default to use doctext</reason>
<field>code</field>
</record>
<record><htmlcode_id>329244</htmlcode_id>
<patch_code>my ($field) = @_;

#like all good password fields, we should have a confirm
my $name = "$$NODE{type}{title}_$field";

my ($p1, $p2) = ($query-&gt;param($name.'1'), $query-&gt;param($name.'2'));
my $str;

if ($p1 or $p2) {
	if ($p1 eq $p2) {
		#update the node
		$$NODE{$field} = $p1;
		updateNode $NODE, $USER;	
		
		$str .= "Passwords updated.  Please ".linkNodeTitle("login", "", {user =&gt; $$USER{title}})." with this new password&lt;br&gt;";
	} else {
		$str .= "Passwords don't match!&lt;br&gt;";
	}
}


$str . $query-&gt;password_field($name."1", "",8,8) .
	'&lt;br&gt;' .$query-&gt;password_field($name."2", "",8,8); </patch_code>
<applied>2004-02-16 10:01:58</applied>
<htmlcode_id>46</htmlcode_id>
<live_code>my( $field )= @_;

my $name= "$NODE-&gt;{type}{title}_$field";
my( $pold, $p1, $p2 )= map {
    '' . ( $q-&gt;param("$name-$_") )[-1]
} qw/ old 1 2 /;

my $html= '';
if(  '' eq $p1  &amp;&amp;  '' eq $p2  ) {
    ;
} elsif(  $p1 ne $p2  ||  $pold ne $NODE-&gt;{$field}  ) {
    my $what=  $p1 ne $p2
        ?  "New passwords do"  :  "Old password does";
    $html .= join ' ',
        '&lt;p class="error"',
        'style="color: #c00; background-color: #fff;"&gt;',
        "&lt;strong&gt;$what not match!&lt;/strong&gt;&lt;/p&gt;\n";
} else {
    $q-&gt;param( "$name-$_", '' )
        for  qw&lt; old 1 2 &gt;;
    $NODE-&gt;{$field}= $p1;
    updateNode( $NODE, $USER );
    $html .= join ' ',
        '&lt;strong&gt;Passwords updated.&lt;/strong&gt;  Please',
        genLink( 'login',
            { node =&gt; 'login', user =&gt; $USER-&gt;{title} } ),
        "with this new password.&lt;br /&gt;";
}

return join "\n",
    $html,
    '&lt;table&gt;&lt;tr&gt;&lt;td&gt;',
    'Current password:&amp;nbsp;&lt;/td&gt;&lt;td&gt;',
    $q-&gt;password_field( "$name-old", '', 8, 8 ),
    '&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;',
    'New password:&amp;nbsp;&lt;/td&gt;&lt;td&gt;',
    $q-&gt;password_field( "$name-1", '', 8, 8 ),
    '&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;',
    'New password again:&amp;nbsp;&lt;/td&gt;&lt;td&gt;',
    $q-&gt;password_field( "$name-2", '', 8, 8 ),
    '&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;',
'';
</live_code>
<reason>Dont send current password..</reason>
<field>code</field>
</record>
<record><htmlcode_id>756674</htmlcode_id>
<patch_code>my @quips = (
  "Welcome to the Monastery",
  "Perl Monk, Perl Meditation.",
  "Think about Loose Coupling",
  "There's more than one way to do things.",
  "laziness, impatience, and hubris",
  "Pathologically Eclectic Rubbish Lister",
  "Perl Sensitive Sunglasses",
  "P is for Practical",
  "go ahead... be a heretic",
  q("be consistent."),
  "Keep It Simple, Stupid",
  "more &lt;b&gt;useful&lt;/b&gt; options",
  "good chemistry is complicated,&lt;br /&gt;and a little bit messy-LW",
  "Just another Perl shrine",
  "Syntactic Confectionary Delight",
  "Your skill will accomplish&lt;br /&gt;what the force of many cannot",
  "Perl: the Markov chain saw",
  "XP is just a number",
  "No such thing as a small change."
);

my $rnd = rand(@quips);
&lt;&lt;"END";

    &lt;font size = "2"&gt;
      $quips[$rnd]
    &lt;/font&gt;
END</patch_code>
<applied>2009-04-09 14:35:49</applied>
<htmlcode_id>444</htmlcode_id>
<live_code>my @quips = (
  "Welcome to the Monastery",
  "Perl Monk, Perl Meditation",
  "Think about Loose Coupling",
  "There's more than one way to do things",
  "laziness, impatience, and hubris",
  "Pathologically Eclectic Rubbish Lister",
  "Perl-Sensitive Sunglasses",
  "P is for Practical",
  "go ahead... be a heretic",
  q("be consistent"),
  "Keep It Simple, Stupid",
  "more &lt;b&gt;useful&lt;/b&gt; options",
  "good chemistry is complicated,&lt;br /&gt;and a little bit messy -LW",
  "Just another Perl shrine",
  "Syntactic Confectionery Delight",
  "Your skill will accomplish&lt;br /&gt;what the force of many cannot",
  "Perl: the Markov chain saw",
  "XP is just a number",
  "No such thing as a small change",
  "The stupid question is the question not asked",
  "Don't ask to ask, just ask",
  "We don't bite newbies here... much",
  "Clear questions and runnable code&lt;br /&gt;get the best and fastest answer",
  "Do you know where your variables are?",
);

$quips[ rand @quips ]

</live_code>
<reason>add "small change". (have to try, you applied my stupid xp quip as well)</reason>
<field>code</field>
</record>
<record><htmlcode_id>545946</htmlcode_id>
<patch_code>my @special;
if(  getId($USER) == $HTMLVARS{guest_user}  ) {
  push @special, 
     linkNode( 109, 'Log&amp;nbsp;in' ),
     linkNode( 101, "Create&amp;nbsp;a&amp;nbsp;new&amp;nbsp;user" );
} else {
  push @special,linkNode(
    109,
    "log&amp;nbsp;" . $q-&gt;escapeHTML($USER-&gt;{title}) . "&amp;nbsp;out",
    { op =&gt; 'logout' },
  ), ($q-&gt;cookie('userpass')=~/%(?:u00)?7C(.)$/i &amp;&amp; $1 ? '&lt;span class="cloaked"&gt;#' : '')
     .linkNode($USER);
}

my $i;
return '&lt;font size="2" class="topnavmenu"&gt;'.
  join('&lt;span class="link-sep"&gt;&lt;span class="navmenu-link-sep"&gt;&amp;nbsp;|&amp;nbsp;&lt;/span&gt;&lt;/span&gt;',
  map { (!$_ || /&lt;br/) ? $_ 
              : sprintf "&lt;span id='titlebar-link-%03d'&gt;%s&lt;/span&gt;", $i++, 
                 /^\s*&lt;span/ ? $_."&lt;/span&gt;" 
                             : /^\s*&lt;/ ? $_ 
                                       : linkNodeTitle($_) }
  (
    '',
    @special,
    linkNode( $HTMLVARS{default_node},
    'The&amp;nbsp;Monastery&amp;nbsp;Gates' ),
    'Super Search|Super&amp;nbsp;Search',
    "&lt;br /&gt;\n",
    'Seekers of Perl Wisdom|Seekers&amp;nbsp;of&amp;nbsp;Perl&amp;nbsp;Wisdom',
    'Meditations',
    'Perl Monks Discussion|PerlMonks&amp;nbsp;Discussion',
    'Snippets Section|Snippets',
    "&lt;br /&gt;\n",
    'Obfuscated Code|Obfuscation',
    'Reviews',
    'Cool Uses for Perl|Cool&amp;nbsp;Uses&amp;nbsp;For&amp;nbsp;Perl',
    'Perl News|Perl&amp;nbsp;News',
    'Categorized Questions and Answers|Q&amp;amp;A',
    'Tutorials',
    "&lt;br /&gt;\n",
    'Code Catacombs|Code',
    'Perl Poetry|Poetry',
    'Recently Active Threads|Recent&amp;nbsp;Threads',
    'Newest Nodes|Newest&amp;nbsp;Nodes',
    'Offering Plate|Donate',
    "Tidings|What's&amp;nbsp;New",
    '')
    )."&lt;/font&gt;&lt;br /&gt;\n";



</patch_code>
<applied>2006-04-27 11:11:07</applied>
<htmlcode_id>494</htmlcode_id>
<live_code>  my $userlink = linkNode($USER);
  $userlink = '&lt;span class="cloaked"&gt;#' . $userlink . '&lt;/span&gt;'
    if  $q-&gt;cookie('userpass') =~ /%(?:u00)?7C(.)$/i &amp;&amp; $1;

  htmlcode( 'get_sitedoclet', 'monktitlebar sitedoclet',
    -TOPNAV_SPECIAL =&gt;
      getId($USER) == $HTMLVARS{guest_user}
        ? 
          '&lt;li&gt;' . linkNode( 109, 'Log&amp;nbsp;in' ) . '&lt;/li&gt;' .
          '&lt;li&gt;' . linkNode( 101, "Create&amp;nbsp;a&amp;nbsp;new&amp;nbsp;user" ) . '&lt;/li&gt;'
        :
          '&lt;li&gt;' . linkNode( 109, "log&amp;nbsp;" . $q-&gt;escapeHTML($USER-&gt;{title}) . "&amp;nbsp;out", { op =&gt; 'logout' } ) . '&lt;/li&gt;' .
          '&lt;li&gt;' . $userlink . '&lt;/li&gt;'
  )
</live_code>
<reason>add Tidings</reason>
<field>code</field>
</record>
<record><htmlcode_id>768429</htmlcode_id>
<patch_code>my( $date, $timezone, $user, $fmt ) = @_;
my $args;
if ( ref $date ) {
   $args = $date;
   ( $date, $timezone, $fmt ) = @$args{ qw/ string timezone format / };
}

$timezone= $VARS-&gt;{timezone}
   if  "" eq $timezone;

my( $yy, $mm, $dd, $hrs, $min, $sec, $gmforced );
if(  '' ne $date  ) {
   my $cc;
   ( $cc, $yy, $mm, $dd, $hrs, $min, $sec )=
      $date =~ /(\d\d)/g;
   $yy= $cc.$yy;
   if ($user) { $gmforced = $date =~ /UTC|GM/gi; }
} else {
   ( $sec, $min, $hrs, $dd, $mm, $yy )= localtime();
   $yy += 1900;
   ++$mm;
}

return "&lt;i&gt;never&lt;/i&gt;"   unless  0 &lt; $yy  &amp;&amp;  0 &lt; $mm  &amp;&amp;  0 &lt; $dd;

use Time::Local 'timelocal', 'timegm_nocheck', 'timelocal_nocheck';
use POSIX 'strftime';

my $epoch_secs;
if ($yy &gt; 2038) {
   if ($user) {
       return "Year $yy out of range!";
   } else {
       die "Year $yy out of range!";
   }
}
if ($user) {
   if ($gmforced) {
     $epoch_secs = timegm_nocheck( $sec, $min, $hrs, $dd, $mm-1, $yy );
   } else {   
      $epoch_secs = timelocal_nocheck( $sec, $min, $hrs, $dd, $mm-1, $yy );
   }
} else {
     $epoch_secs = timelocal( $sec, $min, $hrs, $dd, $mm-1, $yy );
}

my $format= $fmt || $VARS-&gt;{timeformat} || '%b %d, %Y at %H:%M&amp;nbsp;%Z';
$format =~ s/^short\z|%{short}/
   $VARS-&gt;{shorttimeformat} || '%Y&amp;#8209;%m&amp;#8209;%d %H:%M' /ge;
$format =~ s/^ISO\z|%{ISO}/%Y&amp;#8209;%m&amp;#8209;%d %H:%M:%S&amp;nbsp;%Z/g;
$format =~ s/^RFC822\z|%{RFC822}/%a, %d %b %Y %H:%M:%S %z/gi;


my $dele= ! exists $ENV{TZ};
my $nicetime;
{
   $timezone= sprintf 'Etc/GMT%+d', -$timezone
      if  $timezone =~ /^-?\d+$/;
   $timezone= "Etc/UTC"
      if  $timezone !~ /\S/;
   local( $ENV{TZ} )= $timezone;
   $nicetime= strftime( $format, localtime($epoch_secs) );
}
delete $ENV{TZ}   if  "" eq $ENV{TZ}; #TEMPORARY# $dele;
return $nicetime;</patch_code>
<applied>2009-06-04 11:36:04</applied>
<htmlcode_id>1613</htmlcode_id>
<live_code>my( $date, $timezone, $user, $fmt ) = @_;
my $args;
if ( ref $date ) {
   $args = $date;
   ( $date, $timezone, $fmt ) = @$args{ qw/ string timezone format / };
}

$timezone= $VARS-&gt;{timezone}
   if  "" eq $timezone;

my( $yy, $mm, $dd, $hrs, $min, $sec, $gmforced );
if(  '' ne $date  ) {
   my $cc;
   ( $cc, $yy, $mm, $dd, $hrs, $min, $sec )=
      $date =~ /(\d\d)/g;
   $yy= $cc.$yy;
   if ($user) { $gmforced = $date =~ /UTC|GM/gi; }
} else {
   ( $sec, $min, $hrs, $dd, $mm, $yy )= localtime();
   $yy += 1900;
   ++$mm;
}

return "&lt;i&gt;never&lt;/i&gt;"   unless  0 &lt; $yy  &amp;&amp;  0 &lt; $mm  &amp;&amp;  0 &lt; $dd;

use Time::Local 'timelocal', 'timegm_nocheck', 'timelocal_nocheck';

my $epoch_secs;
if ($yy &gt; 2038) {
   if ($user) {
       return "Year $yy out of range!";
   } else {
       die "Year $yy out of range!";
   }
}
if ($user) {
   if ($gmforced) {
     $epoch_secs = timegm_nocheck( $sec, $min, $hrs, $dd, $mm-1, $yy );
   } else {   
      $epoch_secs = timelocal_nocheck( $sec, $min, $hrs, $dd, $mm-1, $yy );
   }
} else {
     $epoch_secs = timelocal( $sec, $min, $hrs, $dd, $mm-1, $yy );
}

my $format= $fmt || $VARS-&gt;{timeformat} || '%b %d, %Y at %H:%M&amp;nbsp;%Z';
$format =~ s/^short\z|%{short}/
   $VARS-&gt;{shorttimeformat} || '%Y-%m-%d %H:%M' /ge;
$format =~ s/^ISO\z|%{ISO}/%Y-%m-%d %H:%M:%S&amp;nbsp;%Z/g;
$format =~ s/^RFC822\z|%{RFC822}/%a, %d %b %Y %H:%M:%S %z/gi;


$timezone= sprintf 'Etc/GMT%+d', -$timezone
   if  $timezone =~ /^-?\d+$/;
$timezone= "Etc/UTC"
   if  $timezone !~ /\S/;
my $nicetime= htmlcode( 'strftime_localtime', '', $format, $timezone, $epoch_secs );

return $nicetime;</live_code>
<reason>Restore (real) blank for RFC822; fixes Newest Nodes XML ticker</reason>
<field>code</field>
</record>
<record><htmlcode_id>669746</htmlcode_id>
<patch_code>my $type="snippet";
my($title,$nodetitle);
$title="Add your code snippet";
my $str.=qq(&lt;BR&gt;&lt;TABLE width="100%"&gt;&lt;TR class="titlebar"&gt;);
$str.="&lt;TD&gt;&lt;B&gt;$title&lt;/B&gt;&lt;/TD&gt;&lt;/TR&gt;&lt;TR&gt;&lt;TD&gt;\n";
$str.=htmlcode('openform');
$str.=$query-&gt;hidden("type", $type);
$str.="&lt;INPUT TYPE=\"hidden\" NAME=\"lastnode_id\", VALUE=\"".getId($NODE)."\"&gt;";
if($type=~/note/i){
   $str.=$query-&gt;hidden("parent_node",getId($NODE));
   $nodetitle="Re: $nodetitle";
}
$str.="&lt;INPUT TYPE=\"hidden\" NAME=\"op\" VALUE=\"new\"&gt;";
#$str.=$query-&gt;hidden("op","new");
$str.="&lt;font size=2&gt;&lt;b&gt;Title:&lt;/b&gt;&lt;/font&gt;";
$str.="&lt;INPUT TYPE=\"text\" name=\"node\" value=\"$nodetitle\"&gt;&lt;BR&gt;";
$str.="&lt;font size=2&gt;&lt;b&gt;&lt;br&gt;Short description:&lt;br&gt;&lt;/b&gt;&lt;/font&gt;";
$str.=$query-&gt;textarea("$type\_snippetdesc","",5,60)."&lt;BR&gt;";
$str.="&lt;font size=2&gt;&lt;b&gt;&lt;br&gt;Your code: (Place code sections between &amp;lt;CODE&amp;gt; and &amp;lt;/CODE&amp;gt; tags&lt;br&gt;&lt;/b&gt;&lt;/font&gt;";
$str.=$query-&gt;textarea("$type\_snippetcode","&lt;CODE&gt;\n\n&lt;/CODE&gt;",10,60)."&lt;BR&gt;";
$str.=$query-&gt;submit("create");
$str.=$query-&gt;endform;
$str.="&lt;/TD&gt;&lt;/TR&gt;&lt;/TABLE&gt;";
$str;</patch_code>
<applied>2008-03-17 16:50:59</applied>
<htmlcode_id>1982</htmlcode_id>
<live_code>die "addnewsnippet is not used!";</live_code>
<reason>replace titlebgcolor with css</reason>
<field>code</field>
</record>
<record><htmlcode_id>378142</htmlcode_id>
<patch_code>my $str;
if($ENV{HTTP_USER_AGENT}){
   my $bob=$ENV{HTTP_USER_AGENT};
   if($ENV{HTTP_USER_AGENT}=~/linux/i){$ENV{HTTP_USER_AGENT}="Linux"}
   elsif($ENV{HTTP_USER_AGENT}=~/sun/i){$ENV{HTTP_USER_AGENT}="SunOS/Solaris"}
   elsif($ENV{HTTP_USER_AGENT}=~/macintosh/i){$ENV{HTTP_USER_AGENT}="Macintosh"}
   elsif($ENV{HTTP_USER_AGENT}=~/win/i and $ENV{HTTP_USER_AGENT}=~/98/){$ENV{HTTP_USER_AGENT}="Windows 98"}
   elsif($ENV{HTTP_USER_AGENT}=~/win/i and $ENV{HTTP_USER_AGENT}=~/95/){$ENV{HTTP_USER_AGENT}="Windows 95"}   
   elsif($ENV{HTTP_USER_AGENT}=~/win/i and $ENV{HTTP_USER_AGENT}=~/NT/){$ENV{HTTP_USER_AGENT}="Windows NT"}
   elsif($ENV{HTTP_USER_AGENT}=~/win/i and $ENV{HTTP_USER_AGENT}=~/2000/){$ENV{HTTP_USER_AGENT}="Windows 2000"}
   elsif($ENV{HTTP_USER_AGENT}=~/beos/i){$ENV{HTTP_USER_AGENT}="BeOS"}


   my $csr = $DB-&gt;getDatabaseHandle()-&gt;prepare("SELECT * FROM HTTP_USER_AGENT WHERE browser=\"$ENV{HTTP_USER_AGENT}\"");
   $csr-&gt;execute or return "SHIT";
    if(my $N = $csr-&gt;fetchrow_hashref){
      $str=++$$N{numhits};
      #updateNode($N,-1);
      $csr = $DB-&gt;getDatabaseHandle()-&gt;prepare("UPDATE HTTP_USER_AGENT set numhits=$$N{numhits} where browser=\"$ENV{HTTP_USER_AGENT}\"");
      $csr-&gt;execute or return "SHIT" unless($ENV{REMOTER_ADDR}=~/(198\.110\.103\.250)|(208\.163\.7\.212)/);
   } else{
     $csr = $DB-&gt;getDatabaseHandle()-&gt;prepare("INSERT INTO HTTP_USER_AGENT (browser) VALUES(\"$ENV{HTTP_USER_AGENT}\")");
   $csr-&gt;execute or return "SHIT" unless($ENV{REMOTE_ADDR}=~/198\.110\.103\.250/);
   }
}
</patch_code>
<applied>2004-07-28 14:09:44</applied>
<htmlcode_id>2062</htmlcode_id>
<live_code>return;
# This code was never used</live_code>
<reason>backup</reason>
<field>code</field>
</record>
<record><htmlcode_id>731793</htmlcode_id>
<patch_code>my( $type, $days, $descon, $authoron, $optsref )= @_;
my $maxdays= 60;

$days = 1  if $days !~ /^\d+$/;
$days = $maxdays
  if  $maxdays &lt; $days;

return "&lt;i&gt;Skipping huge list of notes&lt;/i&gt;"
   if $days &gt; 7  &amp;&amp;  $type eq 'note';

my $tid = getId( getType($type) );

my $nodereaper = $HTMLVARS{NodeReaperID};

my @tables = ( 'node pn' );
my @wheres = ( "pn.type_nodetype = $tid" );

if ( $type eq 'patch' ) {
  push @tables, 'patch p';
  push @wheres, 'p.patch_id = pn.node_id';
}

my $limit = "pn.createtime &gt;= DATE_ADD(NOW(),INTERVAL -$days DAY)";

if ( my $when= $VARS-&gt;{lastviewednewestnodes} ) {
  return "&lt;i&gt;Skipping huge list of notes&lt;/i&gt;"
    if  $type eq 'note'
    and $when &lt; time()-7*24*60*60;

  # limit when generally? Let them do super search if they really want?
  $when= time() - $maxdays*24*60*60
    if  $when &lt; time() - $maxdays*24*60*60;

  $limit = "pn.createtime &gt;= FROM_UNIXTIME($when)";
}

my $more_order = '';
$more_order = "$VARS-&gt;{order_nn_by} ASC,"
  if $VARS-&gt;{order_nn_by} &amp;&amp;
     $VARS-&gt;{order_nn_by} ne 'createtime';

my $sql = 'SELECT * FROM '
  . join(', ',@tables)
  . ' WHERE '
  . join(' AND ',$limit,@wheres)
  . " ORDER BY $more_order pn.createtime DESC";

my $sth = $DB-&gt;getDatabaseHandle-&gt;prepare($sql);

return 'OOPS'
  unless $sth-&gt;execute;

my @nodes;
while ( my $node = $sth-&gt;fetchrow_hashref ) {
  push @nodes, $node;
}

@nodes= grep {
    $_-&gt;{author_user} != $nodereaper
  } @nodes
  if  ! $VARS-&gt;{showreaped};

$optsref-&gt;{count}=@nodes;

my $row_num = 0;
return $q-&gt;table(
    ( $descon ? $q-&gt;Tr(
      { colspan =&gt; 2 },
      $q-&gt;td( $type )
    ) : () ),
    map {
      $q-&gt;Tr(
        $row_num++ % 2 ? { class =&gt; 'NN-highlight' } : {},
        $q-&gt;td(
          { class =&gt; "node-from-" . $_-&gt;{author_user} },
          join $/,
            linkNode( $_ ),
            $type ne 'patch' ? '' : htmlcode(
              'parselinksinchatter','', $_-&gt;{reason}, 1, 40, 20 ),
        ),
        !$authoron ? () : $q-&gt;td(
          { class =&gt; "node-from-" . $_-&gt;{author_user} },
          'by ',
          linkNode( $_-&gt;{author_user} )
        )
      )
    } @nodes
) if @nodes;

return '';</patch_code>
<applied>2008-12-20 15:08:08</applied>
<htmlcode_id>3627</htmlcode_id>
<live_code>my( $type, $days, $descon, $authoron, $hdr, $optsref )= @_;
my $maxdays= 60;

$days = 1  if $days !~ /^\d+$/;
$days = $maxdays
  if  $maxdays &lt; $days;

$hdr= '&lt;h3&gt;'.$hdr.'&lt;/h3&gt;' 
  if $hdr;

return $hdr."&lt;i&gt;Skipping huge list of notes&lt;/i&gt;"
   if $days &gt; 7  &amp;&amp;  $type eq 'note';

my $tid = getId( getType($type) );

my $nodereaper = $HTMLVARS{NodeReaperID};

my @tables = ( 'node pn' );
my @wheres = ( "pn.type_nodetype = $tid" );

if ( $type eq 'patch' ) {
  push @tables, 'patch p';
  push @wheres, 'p.patch_id = pn.node_id';
}

my $limit = "pn.createtime &gt;= DATE_ADD(NOW(),INTERVAL -$days DAY)";

if ( my $when= $VARS-&gt;{lastviewednewestnodes} ) {
  return $hdr."&lt;i&gt;Skipping huge list of notes&lt;/i&gt;"
    if  $type eq 'note'
    and $when &lt; time()-7*24*60*60;

  # limit when generally? Let them do super search if they really want?
  $when= time() - $maxdays*24*60*60
    if  $when &lt; time() - $maxdays*24*60*60;

  $limit = "pn.createtime &gt;= FROM_UNIXTIME($when)";
}

my $more_order = '';
$more_order = "$VARS-&gt;{order_nn_by} ASC,"
  if $VARS-&gt;{order_nn_by} &amp;&amp;
     $VARS-&gt;{order_nn_by} ne 'createtime';

my $sql = 'SELECT * FROM '
  . join(', ',@tables)
  . ' WHERE '
  . join(' AND ',$limit,@wheres)
  . " ORDER BY $more_order pn.createtime DESC";

my $sth = $DB-&gt;getDatabaseHandle-&gt;prepare($sql);

return $hdr.'OOPS'
  unless $sth-&gt;execute;

my @nodes;
while ( my $node = $sth-&gt;fetchrow_hashref ) {
  push @nodes, $node;
}

@nodes= grep {
    $_-&gt;{author_user} != $nodereaper
  } @nodes
  if  ! $VARS-&gt;{showreaped};

$optsref-&gt;{count}=@nodes;

my $row_num = 0;
return $hdr . $q-&gt;table(
    ( $descon ? $q-&gt;Tr(
      { colspan =&gt; 2 },
      $q-&gt;td( $type )
    ) : () ),
    map {
      $q-&gt;Tr(
        $row_num++ % 2 ? { class =&gt; 'NN-highlight' } : {},
        $q-&gt;td(
          { class =&gt; "node-from-" . $_-&gt;{author_user} },
          join $/,
            linkNode( $_, '', { -title =&gt; $_-&gt;{createtime} } ),
            $type ne 'patch' ? '' : htmlcode(
              'parselinksinchatter','', $_-&gt;{reason}, 1, 40, 20 ),
        ),
        !$authoron ? () : $q-&gt;td(
          { class =&gt; "node-from-" . $_-&gt;{author_user} },
          'by ',
          linkNode( $_-&gt;{author_user} )
        )
      )
    } @nodes
) if @nodes;

return $optsref-&gt;{return_header_anyway} ? $hdr : '';</live_code>
<reason>Don't search back more than 60 days, make days= limit 60 also (not 14)</reason>
<field>code</field>
</record>
<record><htmlcode_id>403850</htmlcode_id>
<patch_code>my($type,$title,$texttag,$nodetitle)=@_;
my $str;
my $starttext;
my $preview;
my @params=$query-&gt;param();
foreach(@params){
   $str.=$_;
   $str.=$query-&gt;param($_)."&lt;BR&gt;";
}
$preview=1 if($query-&gt;param('op') eq 'preview');
$nodetitle||=$query-&gt;param('preview_node') if $preview;
$starttext=$$VARS{signature} if($type eq 'note' or $type eq 'monkdiscuss');
$starttext=$query-&gt;param("preview_".$type."_doctext") if $preview;
$texttag||="Your text";
$str.="&lt;BR&gt;&lt;TABLE width=100%&gt;&lt;TR BGCOLOR=";
if($$VARS{titlebgcolor}){
    $str.=$$THEME{titlebgcolor}; 
} else{
    $str.="b64234";
}
$str.="&gt;&lt;TD&gt;";
$str.="&lt;FONT COLOR=ffffff&gt;&lt;B&gt;$title&lt;/B&gt;&lt;/FONT&gt;&lt;/TD&gt;&lt;/TR&gt;&lt;TR&gt;&lt;TD&gt;";
$str.="\n".htmlcode('openform','',-method =&gt; 'get');
$str.=$query-&gt;hidden("type", $type);
$str.="&lt;INPUT TYPE=\"hidden\" NAME=\"lastnode_id\", VALUE=\"".getId($NODE)."\"&gt;";
if($type=~/note/i){
   $str.=$query-&gt;hidden("parent_node",getId($NODE));
   $nodetitle="Re: $nodetitle" unless $preview;
}

$str.="&lt;font size=2&gt;&lt;b&gt;Title:&lt;/b&gt;&lt;/font&gt;";
$str.="&lt;INPUT TYPE=\"text\" name=\"node\" value=\"$nodetitle\"&gt;&lt;BR&gt;";
$str.="&lt;font size=2&gt;&lt;b&gt;&lt;br&gt;$texttag&lt;br&gt;&lt;/b&gt;&lt;/font&gt;";
$str.="&lt;TEXTAREA name=$type\_doctext rows=10 cols=60)&gt;$starttext&lt;/textarea&gt;&lt;BR&gt;";
$str.=$query-&gt;submit("op","preview");
$str.=$query-&gt;submit("op","new");
$str.=$query-&gt;endform;
$str.="&lt;/TD&gt;&lt;/TR&gt;&lt;/TABLE&gt;";
$str;</patch_code>
<applied>2004-10-29 14:17:19</applied>
<htmlcode_id>4588</htmlcode_id>
<live_code>die "addnewform2 is not used!"</live_code>
<reason>use openform</reason>
<field>code</field>
</record>
<record><htmlcode_id>775140</htmlcode_id>
<patch_code>my( $type, $linktype, $title, $length, @options )= @_;
$length ||= 10;

use lib $HTMLVARS{uselib};
use Everything::Experience;
my $canconsider= Everything::isApproved( $USER, 'CanConsider' );

my $html= '';
my( $showall, $navbaron, $showunapproved, $linkto );
my $lt_id= getId( getNode($linktype,"linktype") );

my $SETTING= getNode('listapproved settings','setting');
my $LAS= getVars $SETTING;

my $outercontainer=
        $LAS-&gt;{"outerContainerForType_".$type}
    ||  $LAS-&gt;{defaultOuterContainer};
my $innercontainer=
        $LAS-&gt;{"innerContainerForType_".$type}
    ||  $LAS-&gt;{defaultInnerContainer};
my $innerhtmlcode=
        $LAS-&gt;{"innerHtmlcodeForType_".$type}
    ||  $LAS-&gt;{defaultInnerHtmlcode};

my $count= $query-&gt;param("next") || 0;
my $start= $count;
my $max= $count + $length;
my $numshown= 0;
my $showreaped= $VARS-&gt;{showreaped};

foreach( @options ) {
    my $opt= lc( $_ );
    if(  "navbaron" eq $opt  ) {
        $navbaron= 1;
    } elsif(  "showunapproved" eq $opt  ) {
        $showunapproved= 1;
    } elsif(  "showall" eq $opt  ) {
        $showall= 1;
    } elsif(  "showreaped" eq $opt  ) {
        $showreaped= 1;
    } elsif(  /^linkto\|(.*?)\|(.*)/i  ) {
        $HTMLVARS{listapproved}{linkto_node_id}= getId( getNode($1,$2) );
    } elsif(  /^outerContainerOverride:(.*)/i  ) {
        $outercontainer= $LAS-&gt;{$1};
    } elsif(  /^innerContainerOverride:(.*)/i  ) {
        $innercontainer= $LAS-&gt;{$1};
    } elsif(  /^innerHtmlcodeOverride:(.*)/i  ) {
        $innerhtmlcode= $LAS-&gt;{$1};
    }
}

if(  defined $query-&gt;param("showreaped")  ) {
    $showreaped= $query-&gt;param("showreaped");
}

my %approved;
my @unapproved;
my @sql_hide_reaped= ( -author_user =&gt; '! ' . $HTMLVARS{NodeReaperID} );

if(  $showreaped  ) {
    @sql_hide_reaped= ();
}

if(  ! $showall  ) {
    my $links= selectLinks( $NODE );
    foreach(  @$links  ) {
        if(  $_-&gt;{linktype} == $lt_id  ) {
            $approved{ $_-&gt;{to_node} }= 1;
        }
    }
}

$HTMLVARS{listapproved}{title}= $title;

my $ref= selectNodeWhere(
    {
        @sql_hide_reaped,
        type_nodetype =&gt; getType($type),
    },
    "",
    "createtime desc limit 300",
);
return
    if(  ! $ref  );

my $mysqltime;
if(  $VARS-&gt;{lastviewednewestnodes}  ) {
    my( $sec, $min, $hour, $mday, $mon, $year )=
        localtime( $VARS-&gt;{lastviewednewestnodes} );
    $mysqltime= sprintf(
        "%04d-%02d-%02d %02d:%02d:%02d",
        1900 + $year, 1 + $mon, $mday, $hour, $min, $sec );
}

my $i;
my $j= 0;
my $innerstr= '';
for(  $i= $count;  $i &lt; @$ref &amp;&amp; $numshown &lt; $length;  $i++  ) {
    $HTMLVARS{embed_node}= selectNode( $ref-&gt;[$i] );
    if(     $approved{ getId( $HTMLVARS{embed_node} ) }
        ||  $VARS-&gt;{unapprovedcontent}  &amp;&amp;  $showunapproved
        ||  $showall
        ||      $HTMLVARS{embed_node}{author_user} == $USER-&gt;{node_id}
            &amp;&amp;  $HTMLVARS{embed_node}{author_user} != $HTMLVARS{guest_user}
    ) {
        $numshown++;

        my $Q= {
            directreplies =&gt; $DB-&gt;sqlSelect(
                'COUNT(*)',
                'note',
                'parent_node = ' . getId( $HTMLVARS{embed_node} ),
            ),
            repliesbelow  =&gt; $DB-&gt;sqlSelect(
                'COUNT(*)',
                'note',
                'root_node = ' . getId( $HTMLVARS{embed_node} ),
            ),
            parent =&gt; getId( $HTMLVARS{embed_node} ),
        };

        my $typeofreplies= $VARS-&gt;{repliesdisplay} || "directreplies";
        $HTMLVARS{embed_node}{numreplies}= $Q-&gt;{$typeofreplies} || '0';
        $HTMLVARS{embed_node}{classprefix}= 
          $mysqltime &amp;&amp; $mysqltime lt $HTMLVARS{embed_node}{createtime}
            ? 'new-' : '';
        $innerstr .= containHtml( $innercontainer, htmlcode($innerhtmlcode) );
        $j++;
    }
    if(     $canconsider
        &amp;&amp;  ! $approved{ getId( $HTMLVARS{embed_node} ) }
    ) {
        push @unapproved, $HTMLVARS{embed_node};
    }
}


$HTMLVARS{unapproved}= \@unapproved;
$html .= containHtml( $outercontainer, $innerstr );

if(  $navbaron  ) {
    $html .= join '',
        '&lt;table width="100%" class="highlight" border="0"',
        ' cellpadding="2" cellspacing="0"&gt;', $/,
        '&lt;tr&gt;&lt;td align="left" width="100"&gt;', $/;
    my $next= $count - $length;
    $next= 0
        if(  $count - $length &lt; 0  );
    $html .= join '',
        "&lt;a href=",
        urlGen( {
            node_id =&gt; getId($NODE),
            next =&gt; $count-$length,
        } ),
        "&gt;&lt;--Previous&amp;nbsp;entries&lt;/a&gt;", $/
        if(  0 &lt; $count  );
    $html .= "&amp;nbsp;";

    $html .= '&lt;/td&gt;&lt;td align="center"&gt;';
    $html .= join '', "(", $count+1, "-$max) of "
        if(  $max &lt; @$ref  );
    $html .= join '',
        '&amp;nbsp;&lt;/td&gt;&lt;td align="center"&gt;(', $count+1, "-", 0+@$ref, ") of "
        if(  @$ref &lt;= $max  );
    $html .= join '', 0+@$ref, '&lt;/td&gt;&lt;td align="right" width="100"&gt;', $/;
    $next= $count + $length;
    my $num= $length;
    if(  @$ref &lt; $next + $length  ) {
        $num= @$ref - $next;
    }
    $html .= join '',
        "&lt;a href=",
        urlGen( {
            node_id =&gt; getId($NODE),
            next =&gt; $max,
        } ),
        "&gt;Next&amp;nbsp;entries--&gt;&lt;/a&gt;"
        if(  $max &lt; @$ref  );
    $html .= "&amp;nbsp;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/center&gt;\n";
}
return $html;
</patch_code>
<applied>2009-06-26 14:47:04</applied>
<htmlcode_id>4692</htmlcode_id>
<live_code>use lib $HTMLVARS{uselib};
use Everything::Experience;

my( $type, $linktype, $title, $length, @options )= @_;
$length ||= 10;

my $html= '';
my( $showall, $navbaron, $showunapproved, $linkto );
my $lt_id= getId( getNode($linktype,'linktype') );

my $SETTING= getNode('listapproved settings','setting');
my $LAS= getVars $SETTING;

my $outercontainer= $LAS-&gt;{"outerContainerForType_".$type}  ||  $LAS-&gt;{defaultOuterContainer};
my $innercontainer= $LAS-&gt;{"innerContainerForType_".$type}  ||  $LAS-&gt;{defaultInnerContainer};
my $innerhtmlcode=  $LAS-&gt;{"innerHtmlcodeForType_".$type}   ||  $LAS-&gt;{defaultInnerHtmlcode};

my $start= my $count= $q-&gt;param('next') || 0;
my $max= $count + $length;
my $numshown= 0;
my $showreaped= $VARS-&gt;{showreaped};

foreach( @options ) {
    my $opt= lc( $_ );
    if(  "navbaron" eq $opt  ) {
        $navbaron= 1;
    } elsif(  "showunapproved" eq $opt  ) {
        $showunapproved= 1;
    } elsif(  "showall" eq $opt  ) {
        $showall= 1;
    } elsif(  "showreaped" eq $opt  ) {
        $showreaped= 1;
    } elsif(  /^linkto\|(.*?)\|(.*)/i  ) {
        $HTMLVARS{listapproved}{linkto_node_id}= getId( getNode($1,$2) );
    } elsif(  /^outerContainerOverride:(.*)/i  ) {
        $outercontainer= $LAS-&gt;{$1};
    } elsif(  /^innerContainerOverride:(.*)/i  ) {
        $innercontainer= $LAS-&gt;{$1};
    } elsif(  /^innerHtmlcodeOverride:(.*)/i  ) {
        $innerhtmlcode= $LAS-&gt;{$1};
    }
}

my( %approved, @unapproved );

my @sql_hide_reaped= ( -author_user =&gt; '! ' . $HTMLVARS{NodeReaperID} );
if(  defined $q-&gt;param("showreaped")  ) {
    $showreaped= $q-&gt;param("showreaped");
}
if(  $showreaped  ) {
    @sql_hide_reaped= ();
}

if(  ! $showall  ) {
    my $links= selectLinks( $NODE );
    $approved{ $_-&gt;{to_node} }= 1
        for grep $_-&gt;{linktype} == $lt_id, @$links;
}

$HTMLVARS{listapproved}{title}= $title;

my $ref= selectNodeWhere(
    {
        @sql_hide_reaped,
        type_nodetype =&gt; getType($type),
    },
    "",
    "createtime desc limit 300",
);
return
    if(  ! $ref  );

my $mysqltime;
if(  $VARS-&gt;{lastviewednewestnodes}  ) {
    my( $sec, $min, $hour, $mday, $mon, $year )=
        localtime( $VARS-&gt;{lastviewednewestnodes} );
    $mysqltime= sprintf(
        "%04d-%02d-%02d %02d:%02d:%02d",
        1900 + $year, 1 + $mon, $mday, $hour, $min, $sec );
}

my $i;
my $j= 0;
my $innerstr= '';
my $canconsider= Everything::isApproved( $USER, 'CanConsider' );
for(  $i= $count;  $i &lt; @$ref &amp;&amp; $numshown &lt; $length;  $i++  ) {
    my $node= $HTMLVARS{embed_node}= selectNode( $ref-&gt;[$i] );
    if(     $approved{ getId( $node ) }
        ||  $VARS-&gt;{unapprovedcontent}  &amp;&amp;  $showunapproved
        ||  $showall
        ||      $node-&gt;{author_user} == $USER-&gt;{node_id}
            &amp;&amp;  $node-&gt;{author_user} != $HTMLVARS{guest_user}
    ) {
        $numshown++;

        my $Q= {
            directreplies =&gt; $DB-&gt;sqlSelect(
                'COUNT(*)',
                'note',
                'parent_node = ' . getId( $node ),
            ),
            repliesbelow  =&gt; $DB-&gt;sqlSelect(
                'COUNT(*)',
                'note',
                'root_node = ' . getId( $node ),
            ),
            parent =&gt; getId( $node ),
        };

        my $typeofreplies= $VARS-&gt;{repliesdisplay} || "directreplies";
        $node-&gt;{numreplies}= $Q-&gt;{$typeofreplies} || '0';
        $node-&gt;{classprefix}=
            $mysqltime &amp;&amp; $mysqltime lt $node-&gt;{createtime}
                ? 'new-' : '';
        $innerstr .= containHtml( $innercontainer, htmlcode($innerhtmlcode) );
        $j++;
    }
    if(     $canconsider
        &amp;&amp;  ! $approved{ getId( $node ) }
    ) {
        push @unapproved, $node;
    }
}


$HTMLVARS{unapproved}= \@unapproved;
$html .= containHtml( $outercontainer, $innerstr );

if(  $navbaron  ) {
    $html .= join '',
        '&lt;table width="100%" class="highlight" border="0"',
        ' cellpadding="2" cellspacing="0"&gt;', $/,
        '&lt;tr&gt;&lt;td align="left" width="100"&gt;', $/;
    my $next= $count - $length;
    $next= 0
        if(  $count - $length &lt; 0  );
    $html .= join '',
        "&lt;a href=",
        urlGen( {
            node_id =&gt; getId($NODE),
            next =&gt; $count-$length,
        } ),
        "&gt;&lt;--Previous&amp;nbsp;entries&lt;/a&gt;", $/
        if(  0 &lt; $count  );
    $html .= "&amp;nbsp;";

    $html .= '&lt;/td&gt;&lt;td align="center"&gt;';
    $html .= join '', "(", $count+1, "-$max) of "
        if(  $max &lt; @$ref  );
    $html .= join '',
        '&amp;nbsp;&lt;/td&gt;&lt;td align="center"&gt;(', $count+1, "-", 0+@$ref, ") of "
        if(  @$ref &lt;= $max  );
    $html .= join '', 0+@$ref, '&lt;/td&gt;&lt;td align="right" width="100"&gt;', $/;
    $next= $count + $length;
    my $num= $length;
    if(  @$ref &lt; $next + $length  ) {
        $num= @$ref - $next;
    }
    $html .= join '',
        "&lt;a href=",
        urlGen( {
            node_id =&gt; getId($NODE),
            next =&gt; $max,
        } ),
        "&gt;Next&amp;nbsp;entries--&gt;&lt;/a&gt;"
        if(  $max &lt; @$ref  );
    $html .= "&amp;nbsp;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/center&gt;\n";
}
return $html;
</live_code>
<reason>add class to roots to distinguish new from old. code yoinked from [shownote]</reason>
<field>code</field>
</record>
<record><htmlcode_id>403849</htmlcode_id>
<patch_code>my($type,$title,$texttag,$nodetitle)=@_;
my $str;
my $starttext;
my $preview;
my $parent_node=$query-&gt;param('preview_parent_node');
$preview=1 if($query-&gt;param('op') eq 'preview');
$nodetitle||=$query-&gt;param('preview_node') if $preview;
$starttext=$$VARS{signature} if($type eq 'note' or $type eq 'monkdiscuss');
$texttag||="Your text";
$str.="&lt;BR&gt;&lt;TABLE width=100%&gt;&lt;TR BGCOLOR=";
if($$VARS{titlebgcolor}){
    $str.=$$THEME{titlebgcolor}; 
} else{
    $str.="b64234";
}
$str.="&gt;&lt;TD&gt;";
$str.="&lt;FONT COLOR=ffffff&gt;&lt;B&gt;$title&lt;/B&gt;&lt;/FONT&gt;&lt;/TD&gt;&lt;/TR&gt;&lt;TR&gt;&lt;TD&gt;";
$str.="\n".htmlcode('openform','',-method =&gt; 'get');
$str.=$query-&gt;hidden("type", $type);
$str.="&lt;INPUT TYPE=\"hidden\" NAME=\"lastnode_id\", VALUE=\"".getId($NODE)."\"&gt;";
if($type=~/note/i){
   $str.=$query-&gt;hidden("parent_node",getId($NODE)) unless $preview;
   $str.=$query-&gt;hidden("parent_node",$parent_node);
   $nodetitle="Re: $nodetitle" unless $preview;
}
$str.="&lt;INPUT TYPE=\"hidden\" NAME=\"op\" VALUE=\"new\"&gt;";
#$str.=$query-&gt;hidden("op","new");
$str.="&lt;font size=2&gt;&lt;b&gt;Title:&lt;/b&gt;&lt;/font&gt;";
$str.="&lt;INPUT TYPE=\"text\" name=\"node\" value=\"$nodetitle\"&gt;&lt;BR&gt;";
$str.="&lt;font size=2&gt;&lt;b&gt;&lt;br&gt;$texttag&lt;br&gt;&lt;/b&gt;&lt;/font&gt;";
$str.=$query-&gt;textarea("$type\_doctext",$starttext,10,60)."&lt;BR&gt;";
$str.=$query-&gt;submit("Submit");
$str.=$query-&gt;endform;
$str.="&lt;/TD&gt;&lt;/TR&gt;&lt;/TABLE&gt;";
$str;</patch_code>
<applied>2004-10-29 14:11:04</applied>
<htmlcode_id>4697</htmlcode_id>
<live_code>die "addnewform3 is not used!"</live_code>
<reason>use openform</reason>
<field>code</field>
</record>
<record><htmlcode_id>477883</htmlcode_id>
<patch_code>return ''
    if  getId($USER) == $HTMLVARS{default_user};

my( $N )= @_;
$N= $NODE unless $N;
getRef($N);

# for contributed nodes (e.g. Q&amp;A questions and answers), get real author
my $A= getNodeById( $N-&gt;{original_author}  ||  $N-&gt;{author_user} );
my $VSETTINGS= getVars( getNode('vote settings','setting') );
my $str= '';

use Everything::Experience qw( hasVoted );
if(  getId($USER) == getId($A)  ||  hasVoted($N,$USER)
   ||  ( $A-&gt;{nick} || $A-&gt;{title} ) eq ( $USER-&gt;{nick} || $USER-&gt;{title} ) ) {

    $str = 'Reputation: ' . $N-&gt;{reputation};

    if ( $VARS-&gt;{nodetension} ) {
        my $up   = ($N-&gt;{reputation} + $N-&gt;{votescast}) / 2;
        my $down = $up - $N-&gt;{reputation};

        # don't show node tension if non-negative rep and just a few downvotes
        if ( $down &lt;= $up &amp;&amp; $down &lt;= int( $VSETTINGS-&gt;{norm} / 2 ) )  {
            $str .= ' (no significant downvotes)&lt;sup&gt;&lt;a href="?node_id=453652"&gt;?&lt;/a&gt;&lt;/sup&gt;'
                if ! $VARS-&gt;{nodetensionquiet};
        } else {
           $str .= " (+$up -$down)";
        }
    }
}

return $VSETTINGS-&gt;{showRepHeader} . $str . $VSETTINGS-&gt;{showRepFooter}
    if $str;

return ''
    if  ! $USER-&gt;{votesleft}  ||  'print' eq $q-&gt;param('displaytype');

if(  $VARS-&gt;{dropdownvote}  ) {
    $str .= $q-&gt;popup_menu(
        -name    =&gt; 'vote__' . getId($N),
        -values  =&gt; [ 0, 1, -1 ],
        -labels  =&gt; { 0 =&gt; '0', 1 =&gt; '+1', -1 =&gt; '-1' },
        -default =&gt; 0
    );
} else {
    my $labels= {
         1 =&gt; $VSETTINGS-&gt;{upLabel} || 'up',
        -1 =&gt; $VSETTINGS-&gt;{downLabel} || 'down'
    };
    my $values= [ 1, -1 ];
    if(  'on' eq $VARS-&gt;{nullvote}  ) {
        $labels-&gt;{0}= $VSETTINGS-&gt;{nullLabel} || 'none';
        push @$values, 0;
    } elsif(  'mid' eq $VARS-&gt;{nullvote}  ) {
        $labels-&gt;{0}= $VSETTINGS-&gt;{nullLabel} || 'none';
        splice @$values, 1, 0, 0;
    }
    $str .= join " &amp;nbsp; &amp;nbsp; ", map "&lt;label&gt;$_&lt;/label&gt;",
        $q-&gt;radio_group(
            -name    =&gt; 'vote__' . getId($N),
            -values  =&gt; $values,
            -labels  =&gt; $labels,
            -default =&gt; '0',
        );
}

return $VSETTINGS-&gt;{voteHeader} . $str . $VSETTINGS-&gt;{voteFooter};</patch_code>
<applied>2008-12-24 22:39:26</applied>
<htmlcode_id>5765</htmlcode_id>
<live_code>return ''
    if  getId($USER) == $HTMLVARS{default_user};

my( $N )= @_;
$N= $NODE unless $N;
getRef($N);

# for contributed nodes (e.g. Q&amp;A questions and answers), get real author
my $A= getNodeById( $N-&gt;{original_author}  ||  $N-&gt;{author_user} );
my $VSETTINGS= getVars( getNode('vote settings','setting') );
my $str= '';

use Everything::Experience qw( hasVoted );
if(  getId($USER) == getId($A)  ||  hasVoted($N,$USER)
   ||  ( $A-&gt;{nick} || $A-&gt;{title} ) eq ( $USER-&gt;{nick} || $USER-&gt;{title} ) ) {

    $str = 'Reputation: ' . $N-&gt;{reputation};

    if ( $VARS-&gt;{nodetension} ) {
        my $up   = ($N-&gt;{reputation} + $N-&gt;{votescast}) / 2;
        my $down = $up - $N-&gt;{reputation};

        # don't show node tension if non-negative rep and just a few downvotes
        if ( $down &lt;= $up &amp;&amp; $down &lt;= int( $VSETTINGS-&gt;{norm} / 2 ) )  {
            $str .= ' (no significant downvotes)&lt;sup&gt;&lt;a href="?node_id=453652"&gt;?&lt;/a&gt;&lt;/sup&gt;'
                if ! $VARS-&gt;{nodetensionquiet};
        } else {
           $str .= " (+$up -$down)";
        }
    }
}

return $VSETTINGS-&gt;{showRepHeader} . $str . $VSETTINGS-&gt;{showRepFooter}
    if $str;

return ''
    if  ! $USER-&gt;{votesleft}  ||  'print' eq $q-&gt;param('displaytype');

if(  $VARS-&gt;{dropdownvote}  ) {
    $str .= $q-&gt;popup_menu(
        -name    =&gt; 'vote__' . getId($N),
        -values  =&gt; [ 0, 1, -1 ],
        -labels  =&gt; { 0 =&gt; '0', 1 =&gt; '+1', -1 =&gt; '-1' },
        -default =&gt; 0
    );
} else {
    my $labels= {
         1 =&gt; $VSETTINGS-&gt;{upLabel} || 'up',
        -1 =&gt; $VSETTINGS-&gt;{downLabel} || 'down'
    };
    my $values= [ 1, -1 ];
    if(  'on' eq $VARS-&gt;{nullvote}  ) {
        $labels-&gt;{0}= $VSETTINGS-&gt;{nullLabel} || 'none';
        push @$values, 0;
    } elsif(  'mid' eq $VARS-&gt;{nullvote}  ) {
        $labels-&gt;{0}= $VSETTINGS-&gt;{nullLabel} || 'none';
        splice @$values, 1, 0, 0;
    }
    $str .= join " &amp;nbsp; &amp;nbsp; ",
        $q-&gt;radio_group(
            -name    =&gt; 'vote__' . getId($N),
            -values  =&gt; $values,
            -labels  =&gt; $labels,
            -default =&gt; '0',
        );
}

return $VSETTINGS-&gt;{voteHeader} . $str . $VSETTINGS-&gt;{voteFooter};</live_code>
<reason>node tension take 2</reason>
<field>code</field>
</record>
<record><htmlcode_id>778976</htmlcode_id>
<patch_code>my( $shownumbers )= @_;
# send FALSE if you want people to see gain/loss w/o exact numbers

return ""
    if  getId($USER) eq $HTMLVARS{default_user};

my $curexp= $USER-&gt;{experience};
my $oldexp= $VARS-&gt;{oldexp};
$oldexp= $curexp
    if  ! defined $oldexp;
my $difexp= $curexp - $oldexp;
$VARS-&gt;{oldexp}= $curexp;
return ""
    if  0 == $difexp;

my $html= '';
my $endquip= '.';
my @quips= (
    " (this feature is experimental).",
    " (at least it looks that way from here).",
    " (due to an accounting error).",
    " (pending committee approval, of course).",
    ", and not a sheep in sight.",
    ", and the price of tea in China remains unchanged.",
    ", as if it mattered.",
    ", as the prophecy predicted.",
    ", but you should see what the other guy got.",
    ", do you care?",
    ", for being silly.",
    ", for whatever it's worth.",
    ", if you can believe that.",
    ", or so.",
    ". (But it really doesn't matter.)",
    ". &lt;em&gt;What&lt;/em&gt; did you say?",
    ". And your lucky number is " . int(rand 20) . ".",
    ". Are you sure they're all yours?",
    ". Blame [ar0n].", # Might cause clueless newbie to blame [ar0n]?
    ". But that's not important right now.",
    ". C'est la vie.",
    ". Call your mom; I'll wait.",
    ". Can I borrow some?",
    ". Can I finish my sandwich now?",
    ". Dang.",
    ". Despite all your rage, you are still just a rat in a cage.",
    ". Didn't see that coming did ya?",
    ". Do you &lt;em&gt;feel&lt;/em&gt; that?!",
    ". Don't let it bother you.",
    ". Don't look at me like that!",
    ". Don't panic!",
    ". Easy come, easy go.",
    ". I'm speechless.",
    ". I've got a million of them.",
    ". I advised against it.",
    ". I can't even keep track anymore.",
    ". I hate you.",
    ". I won't tell anyone.",
    ". It's the best we could do on such short notice.",
    ". It happens to the best of us.",
    ". Just now; not altogether.",
    ". Maybe you should blog about it.",
    ". Nice socks.",
    ". No, you'll never know why.",
    ". Now get back to work!",
    ". Oops, the boss is watching.",
    ". She's gonna blow!",
    ". That's it; I quit!",
    ". That one looks like an antique!",
    ". That reminds me of a funny story...",
    ". There's no accounting for taste.",
    ". This space intentionally left blank.",
    ". Those things happen.",
    ". Um, I can't think of anything funny to add.",
    ". We'll get someone right on that.",
    ". We've got to warn somebody!",
    ". We can't control it!",
    ". We have plenty of leads and the perpetrator &lt;em&gt;will&lt;/em&gt; be caught!",
    ". Welcome to the club.",
    ". What's that behind you?!",
    ". What does 'XP' stand for anyway?",
    ". Whee!",
    ". You are now on dish-cleaning duty.",
    "... just for being you!",
    "... what&lt;i&gt;ever&lt;/i&gt;.",
    " due to a quantum fluctuation.",
    " due to Brownian motion.",
    " due to radio active decay.",
    " since you last refreshed.",
    ". Sorry the e-bay portal is not running yet.",
    ". Sorry, no refund available.",
    q!. &lt;span class="error" style="color: #cc0000;"&gt;No quip found.&lt;/span&gt;!,
);

my @upquips= (
    '. That, and $5, will buy you a coffee.',
    " (Will you donate it to a good cause?)",
    ", and we're proud!",
    ", but do I ever get a 'Thank You'?",
    ", but I eated it.",
    ", even after what you did.",
    ", good for you.",
    ", isn't that nice?",
    ", so stop pouting.",
    ". (Ah, mozzarella today.)",
    ". (Good thing they aren't fattening.)",
    ". &lt;small&gt;Void where prohibited.&lt;/small&gt;",
    ". &lt;tt&gt;You are a unique snowflake.&lt;/tt&gt;",
    ". A journey of a thousand XP begins with a single step.",
    ". Do you want a medal, too?",
    ". Don't let it go to your head.",
    ". For more information, please contact your local XP dealership.",
    ". Goes down smooth.",
    ". I'm not sure how much longer we can afford this.",
    ". I think she likes you.",
    ". Isn't that so &lt;em&gt;nice&lt;/em&gt; for you?",
    ". It's part of this healthy breakfast.",
    ". It tastes just like chicken.",
    ". Keep up the good work.",
    ". Let's toast!",
    ". Made fresh daily.",
    ". No cash value.",
    ". No expiration date.",
    ". No, don't put it there!",
    ". O frabjous day! Callooh! Callay!",
    ". Refrigerate after opening.",
    ". They feel nice under your pillow.",
    ". They make excellent bookmarks.",
    ". They really complement your eyes.",
    ". Whatever you did, keep doing it.",
    ". Where will you keep them all?",
    ". Who did you pay off?",
    ". You're going to need a bigger wallet.",
    ". You can fool some of the people, some of the time...",
    ". Your mother would be so &lt;em&gt;proud&lt;/em&gt;!",
    "... and &lt;em&gt;a new car&lt;/em&gt;!",
    "... that's one small step for... oh, wait.",
    " and it's payday too.",
);

my @downquips= (
    '. Do not pass Go. Do not receive $200.',
    "! What's that Lassie? It's in the abandoned well?",
    ", but I promise not to tell.",
    ". [antivroom] is so proud of you!",
    ". &lt;em&gt;You&lt;/em&gt; did. Not me.",
    ". At least I think it was you.",
    ". Be glad you're not [thepen].",
    ". Check for holes in your pocket?",
    ". Didn't know you had electrodes installed while you were asleep, did you?",
    ". Don't worry; it &lt;em&gt;may&lt;/em&gt; not mean that someone hates you.",
    ". Feel empathy, or ELSE!",
    ". Go help somebody and earn it back!",
    ". Have you been pushing the wrong buttons?",
    ". Have you checked between the couch cushions?",
    ". I feel your pain. Really.",
    ". I think I saw them on eBay.",
    ". It was right there just a minute ago.",
    ". Maybe you'll find them in the morning.",
    ". Oops.",
    ". Poor little XP.",
    ". Rotating clockwise at near light speed may regain it.",
    ". Study more my child...",
    ". Suck it up.",
    ". There's just no pleasing some people...",
    ". There, there.",
    ". They probably fell behind the refrigerator.",
    ". Try not to obsess, OK?",
    ". Well, you didn't like that one much anyway.",
    ". What were you saying about karma?",
    ". Whatever you did, stop doing it.",
    ". You didn't want that one, did you?",
    ". You gotta problem wit dat?",
    "... unless... someone &lt;em&gt;stole&lt;/em&gt; it?!",
    ". Oh, and your taxes are due.",
    #". ...but you can't fool all of the people all of the time.",
    #Not enough context
    q!...&lt;a href="http://xkcd.com/c189.html"&gt;work on it&lt;/a&gt;.!,
);

if(  0 &lt; $difexp  ) {
    $html .= "You gained ";
    push @quips, @upquips;
} else {
    $html .= "You lost ";
    $difexp= -$difexp;
    push @quips, @downquips;
}
if(  $VARS-&gt;{xpquips}  &amp;&amp;  rand &gt; .4  ) {
    $endquip= $quips[ rand @quips ];
}

my $oldlvl= do {
    local( $USER-&gt;{experience} )= $oldexp;
    getLevel($USER); # cant accessrule
};
my $newlvl= getLevel($USER); # cant accessrule

if(  ! $shownumbers  ) {
    $html .= "experience";
} elsif(  1 == $difexp  ) {
    $html .= "1 experience point";
} else {
    $html .= "$difexp experience points";
}
$html .= $endquip;

# Node IDs to level-power FAQs:
my %lvpowers= ( 2=&gt;17643,  5=&gt;198665, 9=&gt;17645, 13=&gt;504005, 26=&gt;244022 );
my $LVLS= getVars( getNode('level experience','setting') );
my $TITLES= getVars( getNode('level titles','setting') );

if(  $oldlvl &lt; $newlvl  ) {
    my $now= $DB-&gt;sqlSelect( "now()" );
    $VARS-&gt;{levelchange} .= ";"
        if  $VARS-&gt;{levelchange};
    $VARS-&gt;{levelchange} .= "$oldlvl-$newlvl " . $now;
    if(  exists $lvpowers{$newlvl}  ) {
        my $newpower= linkNode( $lvpowers{$newlvl} );
        $html .= "&lt;br /&gt;Your new level imbues you with super-powers!";
        $html .= " Check out $newpower for the details!";
    } else {
        $html .= join '',
            "&lt;br /&gt;Congratulations, you have been promoted to ",
            "$TITLES-&gt;{$newlvl}!";
    }
}

my $expleft= $LVLS-&gt;{1+$newlvl} - $USER-&gt;{experience};
if(  0 &lt; $expleft  ) {
    my $s= 1==$expleft ? '' : 's';
    $html .= join '',
        "&lt;br /&gt;You have $expleft point$s until level ",
        1+$newlvl,
        " - ",
        $TITLES-&gt;{1+$newlvl},
        ".";
} else {
    my $VROOM= getNode('vroom','user');

    my $diff= $VROOM-&gt;{experience} - $USER-&gt;{experience};
    $html .= "&lt;br /&gt;You have $diff points until level " . linkNode($VROOM)
        if  0 &lt; $diff;
}

if(  $VARS-&gt;{xpquips}  &amp;&amp;  .25 &lt; rand  ) {
    # work in progress - bobf
    # "Happy Monkday" message

    my @bdayadjs= qw(
        beneficial      breathtaking    enlivening      exciting
        exhilarating    fruitful        inspiring       intoxicating
        invigorating    rewarding       stimulating     successful
        thrilling       agonizing       arduous         difficult
        distressing     dreadful        excruciating    harrowing
        laborious       long            overwhelming    painful
        tedious         troublesome
    );

    my @bdayquips= (
        "Has it really been that long?",
        "It seems like you were an Initiate only yesterday!",
        "How quickly they grow up...",
        "You're &lt;i&gt;old&lt;/i&gt;...",
        "We're glad you're here.",
        "Did you make a wish?",
        "Now blow out your candles before the wax gets on the frosting.",
        "Time for cake!",
        "No, you don't get any presents.",
        "Another year gone...",
        "Have you updated your home node recently?",
        "Don't panic!",
        "You're not growing older, you're growing wiser.",
        "The funny hat suits you.",
        "The price of tea in China remains unchanged.",
        "If you ask nicely, someone might sing to you.",
        "You look &lt;i&gt;marvelous!&lt;/i&gt;",
        "Do you want ice cream with your cake?",
        "'Happy Monkday' doesn't sound the same in Gregorian chant.",
        "A monk &lt;i&gt;may&lt;/i&gt; jump out of your cake,"
            . " but I won't tell you which one.",
        "Haven't you grown up yet?",
        "Thank you for your support.",
        "Are you out of technical debt yet?",
        "Why wasn't I invited to the party?",

        "You are only young once, but you can be immature for a"
            . " lifetime. &lt;i&gt;John P. Grier&lt;/i&gt;",
        "Youth comes but once in a lifetime. &lt;i&gt;Henry W. Longfellow&lt;/i&gt;",
        "Keep true to the dream of thy youth. &lt;i&gt;Friedrich Von Schiller&lt;/i&gt;",
        "We are always the same age inside. &lt;i&gt;Gertrude Stein&lt;/i&gt;",
        "You know you are getting old when the candles cost more than"
            . " the cake. &lt;i&gt;Bob Hope&lt;/i&gt;",
        "Youth has no age. &lt;i&gt;Pablo Picasso&lt;/i&gt;",
        "Time flies like an arrow. Fruit flies like a banana."
            . " &lt;i&gt;Groucho Marx&lt;/i&gt;",
    );

    my( $create_m, $create_d, $create_y )= split( /\//,
        htmlcode(
            'parseTimeInString','',
            $USER-&gt;{createtime}, '', '', '%x' ),
    );
    my( $today_m, $today_d, $today_y )= split( /\//,
        htmlcode(
            'parseTimeInString','',
            '', '', '', '%x' ),
    );

    if(     $create_m == $today_m
        &amp;&amp;  $create_d == $today_d
        &amp;&amp;  $create_y != $today_y
    ) {
        my $adjective= '';
        if(  $VARS-&gt;{xpquips}  ) {
            $adjective= $bdayadjs[ rand @bdayadjs ] . ' ';
        }

        my $yrs_old= $today_y - $create_y;
        my $s= 1==$yrs_old ? '' : 's';

        $html .= join '',
            "&lt;br /&gt;&lt;br /&gt;Happy Monkday!!&lt;br /&gt;",
            "You've been here $yrs_old ${adjective}year$s.";

        if(  $VARS-&gt;{xpquips}  &amp;&amp;  .25 &lt; rand  ) {
            $html .= '&lt;br /&gt; ' . $bdayquips[ rand @bdayquips ];
        }
    }

    # another idea: user could have a chance to gain 1 XP if they log
    # in on their monkday (only once per year)
}

return $html;
</patch_code>
<applied>2009-07-10 23:09:09</applied>
<htmlcode_id>5766</htmlcode_id>
<live_code>my( $shownumbers )= @_;
# send FALSE if you want people to see gain/loss w/o exact numbers

return ""
    if  getId($USER) eq $HTMLVARS{default_user};

my $curexp= $USER-&gt;{experience};
my $oldexp= $VARS-&gt;{oldexp};
$oldexp= $curexp
    if  ! defined $oldexp;
my $difexp= $curexp - $oldexp;
$VARS-&gt;{oldexp}= $curexp;
return ""
    if  0 == $difexp;

my $html= '';
my $endquip= '.';
my @quips= (
    " (this feature is experimental).",
    " (at least it looks that way from here).",
    " (due to an accounting error).",
    " (pending committee approval, of course).",
    ", and not a sheep in sight.",
    ", and the price of tea in China remains unchanged.",
    ", as if it mattered.",
    ", as foretold by the prophets.",
    ", but you should see what the other guy got.",
    ", do you care?",
    ", for being silly.",
    ", for whatever it's worth.",
    ", if you can believe that.",
    ", or so.",
    ". (But it really doesn't matter.)",
    ". &lt;em&gt;What&lt;/em&gt; did you say?",
    ". And your lucky number is " . int(rand 20) . ".",
    ". Are you sure they're all yours?",
    ". Blame [ar0n].", # Might cause clueless newbie to blame [ar0n]?
    ". But that's not important right now.",
    ". C'est la vie.",
    ". Call your mom; I'll wait.",
    ". Can I borrow some?",
    ". Can I finish my sandwich now?",
    ". Dang.",
    ". Despite all your rage, you are still just a rat in a cage.",
    ". Didn't see that coming did ya?",
    ". Do you &lt;em&gt;feel&lt;/em&gt; that?!",
    ". Don't let it bother you.",
    ". Don't look at me like that!",
    ". Don't panic!",
    ". Easy come, easy go.",
    ". I'm speechless.",
    ". I've got a million of them.",
    ". I advised against it.",
    ". I can't even keep track anymore.",
    ". I hate you.",
    ". I won't tell anyone.",
    ". It's the best we could do on such short notice.",
    ". It happens to the best of us.",
    ". Just now; not altogether.",
    ". Maybe you should blog about it.",
    ". Nice socks.",
    ". No, you'll never know why.",
    ". Now get back to work!",
    ". Oops, the boss is watching.",
    ". She's gonna blow!",
    ". That's it; I quit!",
    ". That one looks like an antique!",
    ". That reminds me of a funny story...",
    ". There's no accounting for taste.",
    ". This space intentionally left blank.",
    ". Those things happen.",
    ". Um, I can't think of anything funny to add.",
    ". We'll get someone right on that.",
    ". We've got to warn somebody!",
    ". We can't control it!",
    ". We have plenty of leads and the perpetrator &lt;em&gt;will&lt;/em&gt; be caught!",
    ". Welcome to the club.",
    ". What's that behind you?!",
    ". What does 'XP' stand for anyway?",
    ". Whee!",
    ". You are now on dish-cleaning duty.",
    "... just for being you!",
    "... what&lt;i&gt;ever&lt;/i&gt;.",
    " due to a quantum fluctuation.",
    " due to Brownian motion.",
    " due to cosmic rays.",
    " since you last refreshed.",
    ". Sorry the e-bay portal is not running yet.",
    ". Sorry, no refund available.",
    q!. &lt;span class="error" style="color: #cc0000;"&gt;No quip found.&lt;/span&gt;!,
);

my @upquips= (
    '. That and 3 quid will get you a pint.',
    " (Will you donate it to a good cause?)",
    ", and we're proud!",
    ", but do I ever get a 'Thank You'?",
    ", but I eated it.",
    ", even after what you did.",
    ", good for you.",
    ", isn't that nice?",
    ", so stop pouting.",
    ". (Ah, mozzarella today.)",
    ". (Good thing they aren't fattening.)",
    ". &lt;small&gt;Void where prohibited.&lt;/small&gt;",
    ". &lt;tt&gt;You are a unique snowflake.&lt;/tt&gt;",
    ". A journey of a thousand XP begins with a single step.",
    ". Do you want a medal, too?",
    ". Don't let it go to your head.",
    ". For more information, please contact your local XP dealership.",
    ". Goes down smooth.",
    ". I'm not sure how much longer we can afford this.",
    ". I think she likes you.",
    ". Isn't that so &lt;em&gt;nice&lt;/em&gt; for you?",
    ". It's part of this healthy breakfast.",
    ". It tastes just like chicken.",
    ". Keep up the good work.",
    ". Let's toast!",
    ". Made fresh daily.",
    ". No cash value.",
    ". No expiration date.",
    ". No, don't put it there!",
    ". O frabjous day! Callooh! Callay!",
    ". Refrigerate after opening.",
    ". They feel nice under your pillow.",
    ". They make excellent bookmarks.",
    ". They really complement your eyes.",
    ". Whatever you did, keep doing it.",
    ". Where will you keep them all?",
    ". Who did you pay off?",
    ". You're going to need a bigger wallet.",
    ". You can fool some of the people, some of the time...",
    ". Your mother would be so &lt;em&gt;proud&lt;/em&gt;!",
    "... and &lt;em&gt;a new car&lt;/em&gt;!",
    "... that's one small step for... oh, wait.",
    " and it's payday too.",
);

my @downquips= (
    '. Do not pass Go. Do not receive $200.',
    "! What's that Lassie? It's in the abandoned well?",
    ", but I promise not to tell.",
    ". [antivroom] is so proud of you!",
    ". &lt;em&gt;You&lt;/em&gt; did. Not me.",
    ". At least I think it was you.",
    ". Be glad you're not [thepen].",
    ". Check for holes in your pocket?",
    ". Didn't know you had electrodes installed while you were asleep, did you?",
    ". Don't worry; it &lt;em&gt;may&lt;/em&gt; not mean that someone hates you.",
    ". Feel empathy, or ELSE!",
    ". Go help somebody and earn it back!",
    ". Have you been pushing the wrong buttons?",
    ". Have you checked between the couch cushions?",
    ". I feel your pain. Really.",
    ". I think I saw them on eBay.",
    ". It was right there just a minute ago.",
    ". Maybe you'll find them in the morning.",
    ". Oops.",
    ". Poor little XP.",
    ". Rotating clockwise at near light speed may regain it.",
    ". Study more my child...",
    ". Suck it up.",
    ". There's just no pleasing some people...",
    ". There, there.",
    ". They probably fell behind the refrigerator.",
    ". Try not to obsess, OK?",
    ". Well, you didn't like that one much anyway.",
    ". What were you saying about karma?",
    ". Whatever you did, stop doing it.",
    ". You didn't want that one, did you?",
    ". You gotta problem wit dat?",
    "... unless... someone &lt;em&gt;stole&lt;/em&gt; it?!",
    ". Oh, and your taxes are due.",
    #". ...but you can't fool all of the people all of the time.",
    #Not enough context
    q!...&lt;a href="http://xkcd.com/c189.html"&gt;work on it&lt;/a&gt;.!,
);

if(  0 &lt; $difexp  ) {
    $html .= "You gained ";
    push @quips, @upquips;
} else {
    $html .= "You lost ";
    $difexp= -$difexp;
    push @quips, @downquips;
}
if(  $VARS-&gt;{xpquips}  &amp;&amp;  rand &gt; .4  ) {
    $endquip= $quips[ rand @quips ];
}

my $oldlvl= do {
    local( $USER-&gt;{experience} )= $oldexp;
    getLevel($USER); # cant accessrule
};
my $newlvl= getLevel($USER); # cant accessrule

if(  ! $shownumbers  ) {
    $html .= "experience";
} elsif(  1 == $difexp  ) {
    $html .= "1 experience point";
} else {
    $html .= "$difexp experience points";
}
$html .= $endquip;

# Node IDs to level-power FAQs:
my %lvpowers= ( 2=&gt;17643,  5=&gt;198665, 9=&gt;17645, 13=&gt;504005, 26=&gt;244022 );
my $LVLS= getVars( getNode('level experience','setting') );
my $TITLES= getVars( getNode('level titles','setting') );

if(  $oldlvl &lt; $newlvl  ) {
    my $now= $DB-&gt;sqlSelect( "now()" );
    $VARS-&gt;{levelchange} .= ";"
        if  $VARS-&gt;{levelchange};
    $VARS-&gt;{levelchange} .= "$oldlvl-$newlvl " . $now;
    if(  exists $lvpowers{$newlvl}  ) {
        my $newpower= linkNode( $lvpowers{$newlvl} );
        $html .= "&lt;br /&gt;Your new level imbues you with super-powers!";
        $html .= " Check out $newpower for the details!";
    } else {
        $html .= join '',
            "&lt;br /&gt;Congratulations, you have been promoted to ",
            "$TITLES-&gt;{$newlvl}!";
    }
}

my $expleft= $LVLS-&gt;{1+$newlvl} - $USER-&gt;{experience};
if(  0 &lt; $expleft  ) {
    my $s= 1==$expleft ? '' : 's';
    $html .= join '',
        "&lt;br /&gt;You have $expleft point$s until level ",
        1+$newlvl,
        " - ",
        $TITLES-&gt;{1+$newlvl},
        ".";
} else {
    my $VROOM= getNode('vroom','user');

    my $diff= $VROOM-&gt;{experience} - $USER-&gt;{experience};
    $html .= "&lt;br /&gt;You have $diff points until level " . linkNode($VROOM)
        if  0 &lt; $diff;
}

if(  $VARS-&gt;{xpquips}  &amp;&amp;  .25 &lt; rand  ) {
    # work in progress - bobf
    # "Happy Monkday" message

    my @bdayadjs= qw(
        beneficial      breathtaking    enlivening      exciting
        exhilarating    fruitful        inspiring       intoxicating
        invigorating    rewarding       stimulating     successful
        thrilling       agonizing       arduous         difficult
        distressing     dreadful        excruciating    harrowing
        laborious       long            overwhelming    painful
        tedious         troublesome
    );

    my @bdayquips= (
        "Has it really been that long?",
        "It seems like you were an Initiate only yesterday!",
        "How quickly they grow up...",
        "You're &lt;i&gt;old&lt;/i&gt;...",
        "We're glad you're here.",
        "Did you make a wish?",
        "Now blow out your candles before the wax gets on the frosting.",
        "Time for cake!",
        "No, you don't get any presents.",
        "Another year gone...",
        "Have you updated your home node recently?",
        "Don't panic!",
        "You're not growing older, you're growing wiser.",
        "The funny hat suits you.",
        "The price of tea in China remains unchanged.",
        "If you ask nicely, someone might sing to you.",
        "You look &lt;i&gt;marvelous!&lt;/i&gt;",
        "Do you want ice cream with your cake?",
        "'Happy Monkday' doesn't sound the same in Gregorian chant.",
        "A monk &lt;i&gt;may&lt;/i&gt; jump out of your cake,"
            . " but I won't tell you which one.",
        "Haven't you grown up yet?",
        "Thank you for your support.",
        "Are you out of technical debt yet?",
        "Why wasn't I invited to the party?",

        "You are only young once, but you can be immature for a"
            . " lifetime. &lt;i&gt;John P. Grier&lt;/i&gt;",
        "Youth comes but once in a lifetime. &lt;i&gt;Henry W. Longfellow&lt;/i&gt;",
        "Keep true to the dream of thy youth. &lt;i&gt;Friedrich Von Schiller&lt;/i&gt;",
        "We are always the same age inside. &lt;i&gt;Gertrude Stein&lt;/i&gt;",
        "You know you are getting old when the candles cost more than"
            . " the cake. &lt;i&gt;Bob Hope&lt;/i&gt;",
        "Youth has no age. &lt;i&gt;Pablo Picasso&lt;/i&gt;",
        "Time flies like an arrow. Fruit flies like a banana."
            . " &lt;i&gt;Groucho Marx&lt;/i&gt;",
    );

    my( $create_m, $create_d, $create_y )= split( /\//,
        htmlcode(
            'parseTimeInString','',
            $USER-&gt;{createtime}, '', '', '%x' ),
    );
    my( $today_m, $today_d, $today_y )= split( /\//,
        htmlcode(
            'parseTimeInString','',
            '', '', '', '%x' ),
    );

    if(     $create_m == $today_m
        &amp;&amp;  $create_d == $today_d
        &amp;&amp;  $create_y != $today_y
    ) {
        my $adjective= '';
        if(  $VARS-&gt;{xpquips}  ) {
            $adjective= $bdayadjs[ rand @bdayadjs ] . ' ';
        }

        my $yrs_old= $today_y - $create_y;
        my $s= 1==$yrs_old ? '' : 's';

        $html .= join '',
            "&lt;br /&gt;&lt;br /&gt;Happy Monkday!!&lt;br /&gt;",
            "You've been here $yrs_old ${adjective}year$s.";

        if(  $VARS-&gt;{xpquips}  &amp;&amp;  .25 &lt; rand  ) {
            $html .= '&lt;br /&gt; ' . $bdayquips[ rand @bdayquips ];
        }
    }

    # another idea: user could have a chance to gain 1 XP if they log
    # in on their monkday (only once per year)
}

return $html;
</live_code>
<reason>add a quip</reason>
<field>code</field>
</record>
<record><htmlcode_id>676043</htmlcode_id>
<patch_code>return unless $$USER{votesleft};
return if getId($USER) == $HTMLVARS{default_user};
$HTMLVARS{votebot}=$$USER{title} if $$USER{title} eq "vroom";
my @params = reverse $query-&gt;param();

use Everything::Experience;
use Digest::MD5 qw(md5_base64);

my $nid= $query-&gt;param('node_id');
my $votebot= ! $nid;
if(  $nid  ) {
    $votebot= 1
        if  $query-&gt;param('vc') ne md5_base64(($nid+42).$$USER{title});
}
$votebot ||= $ENV{HTTP_USER_AGENT}=~/UA libwww/;
my $votestr;

foreach (  @params  ) {
    next  unless  /^vote\_\_(.*)$/;
    my $N = $1;
    my $val = $query-&gt;param($_);
    getRef($N);  
    next if $$N{author_user} == getId($USER);
    next unless $val == 1 or $val == -1;
    $votestr .= $val&gt;0 ? "+" : "-";
    $votestr .= getId($N) . " ";
    $query-&gt;param( 'test', $val );
    my $A= getNodeById($N-&gt;{author_user});
    castVote( $N, $USER, $val, $ENV{REMOTE_ADDR} )
        unless $USER-&gt;{nick} eq $A-&gt;{title};
}

if(  $$USER{votesleft} == 0  ) {
    my $lvl = getLevel($USER); # can`t accessrule
    my $VOTES = getVars(getNode('level votes','setting'));
    my $bonus = int( (5+$$VOTES{$lvl}) / 6 )
        if  Everything::isApproved( $USER,'GetsVoteBonus' );
    adjustExp( $USER, $bonus );
}

if(  $votebot  ) {
    Everything::printLog(
        "votebot alert: $$USER{title} : RA $ENV{REMOTE_ADDR}"
      . " : UA $ENV{HTTP_USER_AGENT}: node_id=$nid : $votestr"
    )   if  $votestr;
    $$USER{experience} -= 5;
    --$$USER{votesleft}   if  $$USER{votesleft} &gt; 0;
    Everything::printLog("votebot lost xp $$USER{title} -5 $$USER{experience}");
    updateNode($USER,-1);
}
</patch_code>
<applied>2008-03-26 13:32:04</applied>
<htmlcode_id>5769</htmlcode_id>
<live_code>return
    if  getId($USER) == $HTMLVARS{default_user}
    ||  ! $USER-&gt;{votesleft};
my @params= reverse $q-&gt;param();

use Everything::Experience;
use Digest::MD5 qw&lt; md5_base64 &gt;;

my $nid= $q-&gt;param('node_id');
my $votebot= 0;
if(     ! $nid
    ||  $q-&gt;param('vc') ne md5_base64( ($nid+42) . $USER-&gt;{title} )
    ||  $ENV{HTTP_USER_AGENT} =~ /UA libwww/
) {
    $votebot= 1;
}

my $votestr= '';
foreach (  @params  ) {
    next
        if  ! /^vote\_\_(.*)$/;
    my $N= $1;
    my $val= $q-&gt;param($_);
    getRef( $N );
    next
        if  $N-&gt;{author_user} == getId($USER)
        ||  $val !~ /^-?1$/;
    my $A= getNodeById( $N-&gt;{author_user} );
    next
        if  $USER-&gt;{nick} eq $A-&gt;{title};
    $votestr .= 0&lt;$val ? "+" : "-";
    $votestr .= getId($N) . " ";
    castVote( $N, $USER, $val, $ENV{REMOTE_ADDR} )
        if  ! $votebot;
}

if(  ! $USER-&gt;{votesleft}  ) {
    my $lvl= getLevel($USER); # can't accessrule
    my $VOTES= getVars( getNode('level votes','setting') );
    my $bonus= int( ( 5 + $VOTES-&gt;{$lvl} ) / 6 )
        if  Everything::isApproved( $USER,'GetsVoteBonus' );
    adjustExp( $USER, $bonus );
}

if(  $votebot  &amp;&amp;  $votestr  ) {
    $USER-&gt;{experience} -= 5;
    --$USER-&gt;{votesleft}
        if  0 &lt; $USER-&gt;{votesleft};
    Everything::printLog( join ' ',
        "votebot alert: $USER-&gt;{title} -5 = $USER-&gt;{experience}",
        ": node_id=$nid : $ENV{REMOTE_ADDR}",
        ": UA $ENV{HTTP_USER_AGENT} : $votestr",
    );
    updateNode( $USER, -1 );
}
</live_code>
<reason>Plug small hole</reason>
<field>code</field>
</record>
<record><htmlcode_id>203059</htmlcode_id>
<patch_code>return ''
    if  getId($USER) eq $HTMLVARS{default_user}
    ||  'print' eq $q-&gt;param('displaytype');
# The following breaks [editinvote] cases:
#    ||  ! $USER-&gt;{votesleft};

my $str= '';
$str .= $query-&gt;submit('sexisgreat',"vote!")
    if  $USER-&gt;{votesleft};
#if $query-&gt;param("numvoteit");
$str .= $query-&gt;end_form();
return "&lt;center&gt;$str&lt;/center&gt;";</patch_code>
<applied>2002-10-05 13:01:16</applied>
<htmlcode_id>5909</htmlcode_id>
<live_code>return ''
    if  getId($USER) eq $HTMLVARS{default_user}
    ||  'print' eq $q-&gt;param('displaytype');
# The following breaks [editinvote] cases:
#    ||  ! $USER-&gt;{votesleft};

my $str= '';
$str .= $query-&gt;submit('sexisgreat',"vote!")
    if  $USER-&gt;{votesleft};
#if $query-&gt;param("numvoteit");
return "&lt;div class='voteit'&gt;&lt;center&gt;$str&lt;/center&gt;&lt;/div&gt;"
 . $query-&gt;end_form();
</live_code>
<reason>No empty form for AnonyMonk; clean up</reason>
<field>code</field>
</record>
<record><htmlcode_id>680871</htmlcode_id>
<patch_code># Version of [shownote] for the css.perlmonks.* site.

my $settings=getVars(getNode('shownote settings', getType('setting')));

my $sth  = $DB-&gt;getDatabaseHandle-&gt;prepare_cached('
  SELECT note_id
    FROM note
   WHERE parent_node = ?
');

# Get replies for the given nodeid (don't pass a hash!),
# as an arrayref of node_id's.
my $get_replies = sub {
  $sth-&gt;execute($_[0]);
  [ @{ $sth-&gt;fetchall_arrayref || [] } ];
};

# Gets a tree of replies to the given node id 
# (do not pass a hash)
# TODO: Document structure.
# TODO: Work with .
my $get_tree; $get_tree = sub {
  my $parent = shift;
  my $replies = $get_replies-&gt;($parent);
  return [] unless @$replies;
  my $tree = [];
  for my $reply ( @$replies ) {
    my $subtree = $get_tree-&gt;( $reply-&gt;[0] );
    push @$tree, @$subtree ? [ @$reply, $subtree ] : $reply;
  }
  $tree;
};

my $make_list; $make_list = sub {
  my $dsc  = shift;
  my $list = [];
  for ( @$dsc ) {
    my $replies = $q-&gt;ul( $make_list-&gt;( @$_[1..$#$_] ) ) if @$_ &gt; 1;
    my $reply = getNodeById( $_-&gt;[0] );
    push @$list, map { s/&gt;/&gt;\n/g; $_ } $q-&gt;li(
      { class =&gt; 'reply', id =&gt; 'r' . getId($reply) },
      $q-&gt;div(
        { class =&gt; 'header', id =&gt; 'rh' . getId($reply) },
        $q-&gt;span(
          { class =&gt; 'title' },
          linkNode( $reply )
        ),
        $q-&gt;span(
          { class =&gt; 'voterep' },
          $settings-&gt;{votingon} ? htmlcode('voteit',getId($reply)) : ''
        ),  
        '(', $q-&gt;a(
          {
            href    =&gt; 'javascript:doNothing()',
            onClick =&gt; "javascript:toggleReply('" . getId($reply) . "')"
          }, 'hide/show'
        ), ')',
        $q-&gt;br,
        ' by ',
        $q-&gt;span(
          { class =&gt; 'author' },
          linkNode( $reply-&gt;{author_user} )
        ),
        ' on ',
        $q-&gt;span(
          { class =&gt; 'date' },
          htmlcode( 'parseTimeInString', $reply-&gt;{createtime} )
        )
      ),
      $q-&gt;div(
        { class =&gt; 'body', id =&gt;  'rb' . getId($reply) },
        htmlcode( 'parseLinksInString', 1, getId($reply), $reply-&gt;{doctext} )
      ),
      $replies || ''
    );
  }
  $list;
};

my $tree = $get_tree-&gt;( getId($NODE) );
return '' unless @$tree;
my $replies = $make_list-&gt;( $tree );
return '' unless @$replies;
return $q-&gt;ul( { class =&gt; 'replies' }, @$replies );</patch_code>
<applied>2008-06-07 16:19:31</applied>
<htmlcode_id>5936</htmlcode_id>
<live_code># Version of [shownote] for the css.perlmonks.* site.

my $settings=getVars(getNode('shownote settings', getType('setting')));

my $sth  = $DB-&gt;getDatabaseHandle-&gt;prepare_cached('
  SELECT note_id
    FROM note
   WHERE parent_node = ?
');

# Get replies for the given nodeid (don't pass a hash!),
# as an arrayref of node_id's.
my $get_replies = sub {
  $sth-&gt;execute($_[0]);
  [ @{ $sth-&gt;fetchall_arrayref || [] } ];
};

# Gets a tree of replies to the given node id 
# (do not pass a hash)
# TODO: Document structure.
# TODO: Work with .
my $get_tree; $get_tree = sub {
  my $parent = shift;
  my $replies = $get_replies-&gt;($parent);
  return [] unless @$replies;
  my $tree = [];
  for my $reply ( @$replies ) {
    my $subtree = $get_tree-&gt;( $reply-&gt;[0] );
    push @$tree, @$subtree ? [ @$reply, $subtree ] : $reply;
  }
  $tree;
};

my $make_list; $make_list = sub {
  my $dsc  = shift;
  my $list = [];
  for ( @$dsc ) {
    my $replies = $q-&gt;ul( { class =&gt; 'replies' }, $make_list-&gt;( @$_[1..$#$_] ) ) if @$_ &gt; 1;
    my $reply = getNodeById( $_-&gt;[0] );
    my $id = getId($reply);

    my @links;
    htmlcode( 'downloadcode','',
      $reply,
      '[d/l]',
      '[select]',
      \@links
    );

    if (  $HTMLVARS{guest_user} != $reply-&gt;{author_user}
      and $HTMLVARS{guest_user} != getId($USER)
    ) {
      my $author= getNodeById( $reply-&gt;{author_user}, 'light' )-&gt;{title};
      my $lnk = linkNode( 762476, # Message Outbox
        '/msg',
        {
          sendto =&gt; $author,
          replytotext =&gt; "Re: [id://$id] - ",
        },
        {
          trusted =&gt; 'yes',
        }
      );
      $lnk =~ s/a href/a title="Send private \/msg" href/;
      unshift @links, $lnk;
    }

    unshift @links,
      genLink( 'reply', {
        node_id =&gt; 3333, # Comment On
        parent  =&gt; $id,
      }, { title =&gt; 'Comment on' } );

    push @$list, $q-&gt;li(
      { class =&gt; 'reply', id =&gt; 'r'.$id },
      $q-&gt;div(
        { class =&gt; 'header', id =&gt; 'rh'.$id },
        $q-&gt;span(
          { class =&gt; 'title' },
          linkNode( $reply )
        ),
        $q-&gt;span(
          { class =&gt; 'voterep' },
          $settings-&gt;{votingon} ? htmlcode('voteit',$id) : ''
        ),  
        ( $VARS-&gt;{threads_as_div} ? () : (
          '(', $q-&gt;a(
            {
              href    =&gt; 'javascript:doNothing()',
              onClick =&gt; "javascript:toggleReply('$id')"
            }, 'hide/show'
          ), ')',
        ) ),
        $q-&gt;br,
        ' by ',
        $q-&gt;span(
          { class =&gt; 'author' },
          linkNode( $reply-&gt;{author_user} )
        ),
        ' on ',
        $q-&gt;span(
          { class =&gt; 'date' },
          htmlcode( 'parseTimeInString', $reply-&gt;{createtime} )
        )
      ),
      $q-&gt;div(
        { class =&gt; 'body', id =&gt; 'rb'.$id },
        htmlcode( 'parseLinksInString', 1, $id, $reply-&gt;{doctext} )
      ),
      $q-&gt;div(
        { class =&gt; 'footer', id =&gt; 'rf'.$id },
        '&lt;ul class="inline-list"&gt;'
          .join( '', map '&lt;li&gt;'.$_.'&lt;/li&gt;', @links ).
        '&lt;/ul&gt;'
      ),
      $replies || ''
    );
  }
  $list;
};

my $tree = $get_tree-&gt;( getId($NODE) );
return '' unless @$tree;
my $replies = $make_list-&gt;( $tree );
return '' unless @$replies;
return $q-&gt;ul( { class =&gt; 'replies' }, @$replies );
</live_code>
<reason>add class to voteit</reason>
<field>code</field>
</record>
<record><htmlcode_id>620254</htmlcode_id>
<patch_code>my( $texttag, $fieldname )= @_;
$fieldname ||= 'doctext';
my $str= '';

if(  getId($USER) != $HTMLVARS{default_user}
 &amp;&amp;  canUpdateNode($USER,$NODE)
 &amp;&amp;  'print' ne $q-&gt;param('displaytype')
) {
   return "&lt;br /&gt;&lt;b&gt;Can't edit right now; it's locked by "
     . linkNode($NODE-&gt;{lockedby_user})
     . "&lt;/b&gt;&lt;p&gt;"
     unless  htmlcode('isLockFree');
   $str .= "&lt;br /&gt;&lt;br /&gt;Title:&lt;br /&gt;";
   $str .= htmlcode('textfield','title');
   $str .= "&lt;br /&gt;&lt;br /&gt;\n";
   $str .= $texttag . ":";
   $str .= "&lt;br /&gt;\n";
   $str .= htmlcode('textarea',$fieldname) . " ";
   $str .= $query-&gt;submit("sexisgood","update");
}
return $str;</patch_code>
<applied>2007-06-10 01:42:10</applied>
<htmlcode_id>6036</htmlcode_id>
<live_code>my( $texttag, $fieldname )= @_;
$fieldname ||= 'doctext';
my $str= '';

if(  getId($USER) != $HTMLVARS{default_user}
 &amp;&amp;  canUpdateNode($USER,$NODE)
 &amp;&amp;  'print' ne $q-&gt;param('displaytype')
) {
   return "&lt;br /&gt;&lt;b&gt;Can't edit right now; it's locked by "
     . linkNode($NODE-&gt;{lockedby_user})
     . "&lt;/b&gt;&lt;p&gt;"
     unless  htmlcode('isLockFree');
   $str .= "&lt;br /&gt;&lt;br /&gt;Title:&lt;br /&gt;";
   $str .= htmlcode('textfield','title');
   $str .= "&lt;br /&gt;&lt;br /&gt;\n";
   $str .= $texttag . ":";
   $str .= "&lt;br /&gt;\n";
   $str .= htmlcode('textarea',$fieldname) . " ";
   $str .= $query-&gt;submit("sexisgood","update");
   $str = '&lt;p&gt;&lt;div class="editnodetext"&gt;'
        . $str . '&lt;/div&gt;&lt;/p&gt;';

}
return $str;</live_code>
<reason>add fieldname param</reason>
<field>code</field>
</record>
<record><htmlcode_id>403759</htmlcode_id>
<patch_code>my($type,$title,$texttag,$nodetitle)=@_;
my $str;
my $starttext;
my $preview;


$preview=1 if($query-&gt;param('op') eq 'preview');
$nodetitle||=$query-&gt;param('preview_node') if $preview;
$starttext=$$VARS{signature} if($type eq 'note' or $type eq 'monkdiscuss');
$starttext=$query-&gt;param("preview_".$type."_doctext") if $preview;
$texttag||="Your text";
$str.="&lt;BR&gt;&lt;TABLE width=100%&gt;&lt;TR BGCOLOR=";
if($$VARS{titlebgcolor}){
    $str.=$$THEME{titlebgcolor}; 
} else{
    $str.="b64234";
}
$str.="&gt;&lt;TD&gt;";
$str.="&lt;FONT COLOR=ffffff&gt;&lt;B&gt;$title&lt;/B&gt;&lt;/FONT&gt;&lt;/TD&gt;&lt;/TR&gt;&lt;TR&gt;&lt;TD&gt;";
$str.="\n".htmlcode('openform');
$str.=$query-&gt;hidden("type", $type);
$str.="&lt;INPUT TYPE=\"hidden\" NAME=\"lastnode_id\" VALUE=\"".getId($NODE)."\"&gt;" unless $preview;
$str.="&lt;INPUT TYPE=\"hidden\" NAME=\"lastnode_id\" VALUE=\"".$query-&gt;param('preview_parent_node')."\"&gt;" if $preview;
if($type=~/note/i){
   if($query-&gt;param('preview_parent_node')){
      $str.=$query-&gt;hidden("parent_node",$query-&gt;param('preview_parent_node'));
   } elsif($query-&gt;param('parent_node')){
      $str.=$query-&gt;hidden("parent_node",$query-&gt;param('parent_node'));
   } else {
      $str.=$query-&gt;hidden("parent_node",getId($NODE));
   }
   
   $nodetitle="Re: $nodetitle" unless $preview;
}

$str.="&lt;font size=2&gt;&lt;b&gt;Title:&lt;/b&gt;&lt;/font&gt;";
$str.="&lt;INPUT TYPE=\"text\" name=\"node\" value=\"$nodetitle\"&gt;&lt;BR&gt;";
$str.="&lt;font size=2&gt;&lt;b&gt;&lt;br&gt;$texttag&lt;br&gt;&lt;/b&gt;&lt;/font&gt;";
$str.="&lt;TEXTAREA name=$type\_doctext rows=10 cols=60)&gt;$starttext&lt;/textarea&gt;&lt;BR&gt;";
$str.=$query-&gt;submit("op","preview");
$str.=$query-&gt;submit("op","new");
$str.=$query-&gt;endform;
$str.="&lt;/TD&gt;&lt;/TR&gt;&lt;/TABLE&gt;";
$str;</patch_code>
<applied>2004-10-29 10:34:04</applied>
<htmlcode_id>6865</htmlcode_id>
<live_code>die "supernewform is not used!";</live_code>
<reason>use openform</reason>
<field>code</field>
</record>
<record><htmlcode_id>403747</htmlcode_id>
<patch_code>my($type,$title,$texttag,$nodetitle)=@_;
my $str;
my $starttext;
my $preview;


$preview=1 if($query-&gt;param('op') eq 'preview');
$nodetitle||=$query-&gt;param('preview_node') if $preview;
$starttext=$$VARS{signature} if($type eq 'note' or $type eq 'monkdiscuss');
$starttext=$query-&gt;param("preview_".$type."_doctext") if $preview;
$texttag||="Your text";
$str.="&lt;BR&gt;&lt;TABLE width=100%&gt;&lt;TR BGCOLOR=";
if($$VARS{titlebgcolor}){
    $str.=$$THEME{titlebgcolor}; 
} else{
    $str.="b64234";
}
$str.="&gt;&lt;TD&gt;";
$str.="&lt;FONT COLOR=ffffff&gt;&lt;B&gt;$title&lt;/B&gt;&lt;/FONT&gt;&lt;/TD&gt;&lt;/TR&gt;&lt;TR&gt;&lt;TD&gt;";
$str.="\n".htmlcode('openform');
$str.=$query-&gt;hidden("type", $type);
$str.="&lt;INPUT TYPE=\"hidden\" NAME=\"lastnode_id\" VALUE=\"".getId($NODE)."\"&gt;" unless $preview;
$str.="&lt;INPUT TYPE=\"hidden\" NAME=\"lastnode_id\" VALUE=\"".$query-&gt;param('preview_parent_node')."\"&gt;" if $preview;
if($type=~/note/i){
   if($query-&gt;param('preview_parent_node')){
      $str.=$query-&gt;hidden("parent_node",$query-&gt;param('preview_parent_node'));
   } elsif($query-&gt;param('parent_node')){
      $str.=$query-&gt;hidden("parent_node",$query-&gt;param('parent_node'));
   } else {
      $str.=$query-&gt;hidden("parent_node",getId($NODE));
   }
   
   $nodetitle="Re: $nodetitle" unless $preview;
}

$str.="&lt;font size=2&gt;&lt;b&gt;Title:&lt;/b&gt;&lt;/font&gt;";
$str.="&lt;INPUT TYPE=\"text\" name=\"node\" value=\"$nodetitle\"&gt;&lt;BR&gt;";
$str.="&lt;font size=2&gt;&lt;b&gt;&lt;br&gt;$texttag&lt;br&gt;&lt;/b&gt;&lt;/font&gt;";
$str.="&lt;TEXTAREA name=$type\_doctext rows=10 cols=60)&gt;$starttext&lt;/textarea&gt;&lt;BR&gt;";
$str.=$query-&gt;submit("op","preview");
$str.=$query-&gt;submit("op","new");
$str.=$query-&gt;endform;
$str.="&lt;/TD&gt;&lt;/TR&gt;&lt;/TABLE&gt;";
$str;</patch_code>
<applied>2004-10-29 10:37:26</applied>
<htmlcode_id>7337</htmlcode_id>
<live_code>die "addnewformnew is not used!";</live_code>
<reason>use openfrom</reason>
<field>code</field>
</record>
<record><htmlcode_id>403839</htmlcode_id>
<patch_code>my($type,$title,$texttag,$nodetitle)=@_;
my $str;
my $starttext;
my $preview;
my %parentedTypes;
my %signatureWithTypes;
my $typeforprefix=$type;
$typeforprefix=~s/ /_/g;
my $parentId;

$nodetitle||=$query-&gt;param('nodetitle');

   my $SETTING=getNode('preview settings','setting');
   my $PS=getVars $SETTING;
   my $prefix=$$PS{"prefixForType_"."$typeforprefix"} ? $$PS{"prefixForType_"."$typeforprefix"} : $$PS{defaultPrefix};
   %parentedTypes=map{$_=&gt;1}(split(/,/,$$PS{parentedTypes}));
   %signatureWithTypes=map{$_=&gt;1}(split(/,/,$$PS{signatureWithTypes}));


$preview=1 if($query-&gt;param('op') eq 'preview');

if(!$preview and !$query-&gt;param('parent_node')){$parentId=getId($NODE)}
elsif($preview){$parentId=$query-&gt;param('preview_parent_node')}
elsif($query-&gt;param('parent_node')){$parentId=$query-&gt;param('parent_node')}

if($preview) {$nodetitle||=$query-&gt;param('preview_node')}

$starttext=$$VARS{signature} if($signatureWithTypes{$type});
$starttext=$query-&gt;param("preview_".$type."_doctext") if $preview;
$texttag||="Your text";
$str.="&lt;BR&gt;&lt;TABLE width=100%&gt;&lt;TR BGCOLOR=";
if($$VARS{titlebgcolor}){
    $str.=$$THEME{titlebgcolor}; 
} else{
    $str.="b64234";
}
$str.="&gt;&lt;TD&gt;";
$str.="&lt;FONT COLOR=ffffff&gt;&lt;B&gt;$title&lt;/B&gt;&lt;/FONT&gt;&lt;/TD&gt;&lt;/TR&gt;&lt;TR&gt;&lt;TD&gt;";
#$str.="\n".htmlcode('openform') unless (getId($USER)==$HTMLVARS{default_user});


$str.="\n".htmlcode('openform');
$str.=$query-&gt;hidden("type", $type);
if($parentedTypes{$type}){
      $str.=$query-&gt;hidden("parent_node",$parentId);
      $str.=$query-&gt;hidden("lastnode_id",$parentId);
}
$nodetitle="$prefix$nodetitle" unless $preview;

$str.="&lt;font size=2&gt;&lt;b&gt;Title:&lt;/b&gt;&lt;/font&gt;";
$str.="&lt;INPUT TYPE=\"text\" name=\"node\" value=\"$nodetitle\"&gt;&lt;BR&gt;";
$str.="&lt;font size=2&gt;&lt;b&gt;&lt;br&gt;$texttag&lt;br&gt;&lt;/b&gt;&lt;/font&gt;";
$str.="&lt;TEXTAREA name=$type\_doctext rows=10 cols=60)&gt;$starttext&lt;/textarea&gt;&lt;BR&gt;";
$str.=$query-&gt;submit("op","preview");
$str.=$query-&gt;submit("op","new");
$str.=$query-&gt;endform;
$str.="&lt;/TD&gt;&lt;/TR&gt;&lt;/TABLE&gt;";
$str;</patch_code>
<applied>2004-10-29 14:07:10</applied>
<htmlcode_id>10950</htmlcode_id>
<live_code>die "newaddnewform is not used!"</live_code>
<reason>use openform 2</reason>
<field>code</field>
</record>
<record><htmlcode_id>403756</htmlcode_id>
<patch_code>my($type,$title,$texttag,$nodetitle)=@_;
my $str;
my $starttext;
my $preview;


$preview=1 if($query-&gt;param('op') eq 'preview');
$nodetitle||=$query-&gt;param('preview_node') if $preview;
$starttext=$$VARS{signature} if($type eq 'note' or $type eq 'monkdiscuss');
$starttext=$query-&gt;param("preview_".$type."_doctext") if $preview;
$texttag||="Your text";
$str.="&lt;BR&gt;&lt;TABLE width=100%&gt;&lt;TR BGCOLOR=";
if($$VARS{titlebgcolor}){
    $str.=$$THEME{titlebgcolor}; 
} else{
    $str.="000066";
}
$str.="&gt;&lt;TD&gt;";
$str.="&lt;FONT COLOR=ffffff&gt;&lt;B&gt;$title&lt;/B&gt;&lt;/FONT&gt;&lt;/TD&gt;&lt;/TR&gt;&lt;TR&gt;&lt;TD&gt;";
#$str.="\n".htmlcode('openform') unless (getId($USER)==$HTMLVARS{default_user});


$str.="\n".htmlcode('openform','',-method =&gt; 'get');
$str.=$query-&gt;hidden("type", $type);
$str.="&lt;INPUT TYPE=\"hidden\" NAME=\"lastnode_id\" VALUE=\"".getId($NODE)."\"&gt;" unless $preview;
$str.="&lt;INPUT TYPE=\"hidden\" NAME=\"lastnode_id\" VALUE=\"".$query-&gt;param('preview_parent_node')."\"&gt;" if $preview;
if($type=~/note/i){
   if($query-&gt;param('preview_parent_node')){
      $str.=$query-&gt;hidden("parent_node",$query-&gt;param('preview_parent_node'));
   } elsif($query-&gt;param('parent_node')){
      $str.=$query-&gt;hidden("parent_node",$query-&gt;param('parent_node'));
   } else {
      $str.=$query-&gt;hidden("parent_node",getId($NODE));
   }
   
   $nodetitle="Re: $nodetitle" unless $preview;
}

$str.="&lt;font size=2&gt;&lt;b&gt;Title:&lt;/b&gt;&lt;/font&gt;";
$str.="&lt;INPUT TYPE=\"text\" name=\"node\" value=\"$nodetitle\"&gt;&lt;BR&gt;";
$str.="&lt;font size=2&gt;&lt;b&gt;&lt;br&gt;$texttag&lt;br&gt;&lt;/b&gt;&lt;/font&gt;";
$str.="&lt;TEXTAREA name=$type\_doctext rows=10 cols=60)&gt;$starttext&lt;/textarea&gt;&lt;BR&gt;";
$str.=$query-&gt;submit("op","preview");
$str.=$query-&gt;submit("op","new");
$str.=$query-&gt;endform;
$str.="&lt;/TD&gt;&lt;/TR&gt;&lt;/TABLE&gt;";
$str;</patch_code>
<applied>2004-10-29 14:10:32</applied>
<htmlcode_id>11896</htmlcode_id>
<live_code>die "'backup addnewform' is not used!"</live_code>
<reason>use openform (what about GET forms?)</reason>
<field>code</field>
</record>
<record><htmlcode_id>676507</htmlcode_id>
<patch_code># [addnewform]
# be careful, changes made here should be sync'ed to [addnewnoteform]
# at least until that node and this one are refactored

#  a large chunk of this code was refactored into [add_signature]
# demerphq

my( $type, $title, $texttag, $nodetitle, $group )= @_;

my $html="&lt;!--( $type, $title, $texttag, $nodetitle, $group )--&gt;\n";

return $html if $group and !$DB-&gt;isApproved($USER,getNode($group,'usergroup'));

my $PS= getVars( getNode('preview settings','setting') );
my %signatureTypes;
$signatureTypes{$_}= 1   for  split /,/, $PS-&gt;{signatureWithTypes};

my $preview=  $q-&gt;param('op') eq 'preview';
$nodetitle ||= $q-&gt;param('preview_node')
   if  $preview;

my $text=$preview ? $q-&gt;param( "preview_".$type."_doctext" ) : '';

my $warning=htmlcode('add_signature','',\$text,do_add=&gt;$signatureTypes{$type});

$texttag ||= "Your text";

my $lastnode_id=$preview ? $q-&gt;param('preview_parent_node') : getId($NODE);

$html .= qq[&lt;br /&gt;&lt;table width="100%" class="addnewform"&gt;]
       . qq[&lt;tr class="titlebar add-root-blurb"&gt;]
       . qq[&lt;td&gt;&lt;b&gt;&lt;a name="post"&gt;] . $q-&gt;escapeHTML($title)
       . qq[&lt;/a&gt;&lt;/b&gt;&lt;/td&gt;&lt;/tr&gt;\n&lt;tr&gt;&lt;td&gt;]
       . htmlcode('openform') . "\n"
       . $q-&gt;hidden( "type", $type, 1 ) . "\n"
       . $q-&gt;hidden( "lastnode_id", $lastnode_id, 1) . "\n"
;

if(  $type =~ /note/i  ) {
     # does this code ever fire? demerphq
    my $id=   $q-&gt;param('preview_parent_node')
           || $q-&gt;param('parent_node')
           || getId($NODE)
           ;

    $html .= $q-&gt;hidden( "parent_node",$id , 1 )."\n";

    $nodetitle = htmlcode('add_re_to_title','',$nodetitle)
        unless  $preview;
}

my $single_word_title = !!$preview &amp;&amp; $nodetitle !~ /\S\s+\S/;

my $spoilerbox = '';
if ( $q-&gt;param($type."_doctext") =~ m{&lt;spoiler&gt;.*&lt;/spoiler&gt;}si ) {
   $spoilerbox = $q-&gt;checkbox( 'spoil', '', '1', 'Preview spoil' );
}

$html .= qq[&lt;span class="add-title"&gt;Title:&lt;/span&gt;]
        . $q-&gt;textfield( -name=&gt;"node", -value=&gt;$nodetitle, -force=&gt;1 )
        . ($single_word_title &amp;&amp; qq[ &lt;span class="add-title"&gt;Must be more than one word!&lt;/span&gt;])
        . qq[&lt;br/&gt;\n&lt;span class="add-text"&gt;$texttag&lt;/span&gt;&lt;br/&gt;\n]
        . $warning
        . $q-&gt;textarea( $type."_doctext", $text, 10, 60 )
        . qq[\n&lt;br /&gt;] . $spoilerbox . $query-&gt;submit( "op", "preview" )."\n"
        ;

if  (($preview || $VARS-&gt;{previewfirstoff}) &amp;&amp; ! $single_word_title) {
    $html .= $query-&gt;submit( 'op', 'create' )."\n";
}

return $html. $query-&gt;endform(). qq[\n&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;];
</patch_code>
<applied>2008-12-06 19:38:05</applied>
<htmlcode_id>11910</htmlcode_id>
<live_code># [addnewform]
# Be careful, changes made here should be sync'ed to [addnewnoteform]
# at least until that node and this one are refactored.
# A large chunk of this code was refactored into [add_signature].

my( $type, $heading, $texttag, $title, $group )= @_;
my $html="&lt;!--( $type, $heading, $texttag, $title, $group )--&gt;\n";
$texttag ||= "Your text";
$texttag =~ s/:?$/:/;

return ''
    if  ! canCreateNode( $USER, getType($type) );

return $html
    if  $group  &amp;&amp;  ! $DB-&gt;isApproved( $USER, getNode($group,'usergroup') );

my $PS= getVars( getNode('preview settings','setting') );
my %signatureTypes;
$signatureTypes{$_}= 1
    for  split /,/, $PS-&gt;{signatureWithTypes};

my $text= '';
my $preview= $q-&gt;param('op') eq 'preview';
if(  $preview  ) {

    $title ||= $q-&gt;param('preview_node');
    $text= $q-&gt;param( 'preview_' . $type . '_doctext' );
}

my $warning= htmlcode(
    'add_signature','',
    \$text,
    do_add =&gt; $signatureTypes{$type},
);

my $lastnode_id= $preview ? $q-&gt;param('preview_parent_node') : getId($NODE);

$html .= join "\n",
    "&lt;br /&gt;&lt;table width='100%' class='addnewform'&gt;",
    "&lt;tr class='titlebar add-root-blurb'&gt;",
    "&lt;td&gt;&lt;b&gt;&lt;a name='post'&gt;",
    $q-&gt;escapeHTML($heading),
    "&lt;/a&gt;&lt;/b&gt;&lt;/td&gt;&lt;/tr&gt;\n&lt;tr&gt;&lt;td&gt;",
    htmlcode('openform'),
    $q-&gt;sethidden( "type", $type ),
    $q-&gt;sethidden( "lastnode_id", $lastnode_id ),
'';

if(  $type =~ /note/i  ) {
    # does this code ever fire? demerphq
    my $id= $q-&gt;param('preview_parent_node')
        ||  $q-&gt;param('parent_node')
        ||  getId($NODE);

    $html .= $q-&gt;sethidden( "parent_node", $id ) . "\n";

    $title= htmlcode( 'add_re_to_title','', $title )
        if  ! $preview;
}

my $single_word_title=  $preview  &amp;&amp;  $title !~ /\S\s+\S/;

my $spoilerbox = '';
if(  $q-&gt;param($type."_doctext") =~ m{&lt;spoiler&gt;.*&lt;/spoiler&gt;}si  ) {
    $spoilerbox = $q-&gt;checkbox( 'spoil','', '1', 'Preview spoil' );
}

$html .= join "\n",
    "&lt;span class='add-title'&gt;Title:&lt;/span&gt;",
    $q-&gt;textfield( -name =&gt; 'node', -value =&gt; $title, -force =&gt; 1 ),
    ! $single_word_title ? '' :
        "&lt;br /&gt;&lt;strong&gt;Title must be more than one word!&lt;/strong&gt;",
    "&lt;br /&gt;&lt;span class='add-text'&gt;$texttag&lt;/span&gt;&lt;br/&gt;",
    $warning,
    "Use:&amp;nbsp; &lt;tt&gt;&amp;lt;p&amp;gt; text here (a &lt;b&gt;p&lt;/b&gt;aragraph) &amp;lt;/p&amp;gt;&lt;/tt&gt;",
    "&lt;br /&gt;and:&amp;nbsp; &lt;tt&gt;&amp;lt;code&amp;gt; code here &amp;lt;/code&amp;gt;&lt;/tt&gt;&lt;br /&gt;",
    "to format your post; it's \"PerlMonks-approved HTML\": &lt;br /&gt;",
    $q-&gt;textarea( $type."_doctext", $text, 10, 60 ),
    "&lt;br /&gt;$spoilerbox",
    $q-&gt;submit( 'op', 'preview' ),
'';

if(     (   $preview
        ||  $VARS-&gt;{previewfirstoff}  )
    &amp;&amp;  ! $single_word_title
) {
    $html .= $q-&gt;submit( 'op', 'create' ) . "\n";
}

return join "\n",
    "&lt;div class='editnodetext'&gt;",
    $html,
    $q-&gt;end_form(),
    "&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;",
    "&lt;/div&gt;",
    htmlcode( 'showhints' ),
'';
</live_code>
<reason>replace hard-coded font styling with css</reason>
<field>code</field>
</record>
<record><htmlcode_id>461442</htmlcode_id>
<patch_code>my ($varname,$scrub,$begwrap,$endwrap) = @_;
my $NODE_SETTINGS = getVars $NODE;

my $str = $NODE_SETTINGS-&gt;{$varname} ?   
  $NODE_SETTINGS-&gt;{$varname} : $NODE-&gt;{$varname};

$str = '&lt;i&gt;n/a&lt;/i&gt;' unless $str;

$begwrap ||= '';
$endwrap ||= '';
$str = "$begwrap$str$endwrap";

if ($scrub) {
   my $APPROVED= getVars( getNode('approved html tags','setting') );
   $APPROVED-&gt;{form}='method';
   $APPROVED-&gt;{input}='name,type,value,/';
   $APPROVED-&gt;{select} = 'name';
   $APPROVED-&gt;{option} = 'selected,value';
   $str=~s/(s)(crip)(t)/$1&amp;#x200E;$2&amp;#x200E;$3/gi;
   $str= htmlScreen($str,$APPROVED);
}
return $str;</patch_code>
<applied>2005-05-28 21:49:36</applied>
<htmlcode_id>12151</htmlcode_id>
<live_code># This is now only used for 'location' on [user display page]
# and probably should be renamed to something more like
# 'filterHomeNodeHTML' and used on both 'location' and 'doctext'

my( $varname, $scrub, $begwrap, $endwrap )= @_;
$begwrap ||= '';
$endwrap ||= '';

my $html= getVars($NODE)-&gt;{$varname} || '&lt;i&gt;n/a&lt;/i&gt;';
$html = "$begwrap$html$endwrap";

if(  $scrub  ) {
   my $APPROVED= getVars( getNode('approved html tags','setting') );
   $APPROVED-&gt;{form}= 'method';
   $APPROVED-&gt;{input}= 'name,type,value,/';
   $APPROVED-&gt;{select}= 'name';
   $APPROVED-&gt;{option}= 'selected,value';
   $html =~ s/(s)(crip)(t)/$1&amp;#x200E;$2&amp;#x200E;$3/gi;
   $html= htmlScreen( $html, $APPROVED );
}
return $html;
</live_code>
<reason>INPUT is empty</reason>
<field>code</field>
</record>
<record><htmlcode_id>568607</htmlcode_id>
<patch_code>#converts epochseconds plus user-defined timezone offset into a nicelooking datetime
use POSIX qw(strftime);

my ($epoch_secs)=@_;

my $timezone = $VARS-&gt;{timezone};
my $nicetime;
my $format = $VARS-&gt;{timeformat} || '%b %d, %Y at %H:%M';
$format =~ s/\bISO\b/%Y-%m-%d %H:%M:%S %Z/g;
$format =~ s/\bRFC822\b/%a, %d %b %Y %H:%M:%S %z/gi;

{
  $timezone= sprintf 'Etc/GMT%+d', -$timezone
    if  $timezone =~ /^-?\d+$/;
  local( $ENV{TZ} )= $timezone;
  $nicetime= strftime( $format, localtime($epoch_secs) );
}
$nicetime</patch_code>
<applied>2006-08-21 12:42:34</applied>
<htmlcode_id>14219</htmlcode_id>
<live_code>#converts epochseconds plus user-defined timezone offset into a nicelooking datetime

my ($epoch_secs)=@_;

my $timezone = $VARS-&gt;{timezone};
my $format = $VARS-&gt;{timeformat} || '%b %d, %Y at %H:%M';
$format =~ s/\bISO\b/%Y-%m-%d %H:%M:%S %Z/g;
$format =~ s/\bRFC822\b/%a, %d %b %Y %H:%M:%S %z/gi;

$timezone= sprintf 'Etc/GMT%+d', -$timezone
   if  $timezone =~ /^-?\d+$/;
my $nicetime= htmlcode( 'strftime_localtime', '', $format, $timezone, $epoch_secs );

$nicetime</live_code>
<reason>add rfc822 format macro</reason>
<field>code</field>
</record>
<record><htmlcode_id>493234</htmlcode_id>
<patch_code>my $str;
use lib $HTMLVARS{uselib};
use Everything::Experience;
my $innerstr;
my ($type,$linktype,$title,$length,@options)=@_;
my ($showall,$navbaron,$showunapproved,$linkto);
my ($tempkey);
my $lt_id=getId(getNode($linktype,"linktype"));

my $updateinterval=180;
my $daysBeforeExpire=7;
my $expireTime=$DB-&gt;sqlSelect("from_unixtime(unix_timestamp(now())-86400*$daysBeforeExpire)");
my $SETTING=getNode('listapproved settings','setting');
my $LAS=getVars $SETTING;

my $outercontainer= $$LAS{"outerContainerForType_".$type} ? $$LAS{"outerContainerForType_".$type} : $$LAS{defaultOuterContainer};
my $innercontainer= $$LAS{"innerContainerForType_".$type} ? $$LAS{"innerContainerForType_".$type} : $$LAS{defaultInnerContainer};
my $innerhtmlcode=  $$LAS{"innerHtmlcodeForType_".$type} ? $$LAS{"innerHtmlcodeForType_".$type} : $$LAS{defaultInnerHtmlcode};

my $count = $query-&gt;param("next");
$count ||= 0;
$length ||=10;
my $start=$count;
my $max = $count + $length;
my $numshown=0;
my $maxlength=$length;

foreach(@options){
  if(lc($_) eq "navbaron"){$navbaron=1}
  elsif(lc($_) eq "showunapproved"){$showunapproved=1}
  elsif(lc($_) eq "showall"){$showall=1;}
  elsif(/linkto\|(.*)\|(.*)/){
     $HTMLVARS{listapproved}{linkto_node_id}=getId(getNode($1,$2));  
  }
  elsif(/outerContainerOverride:(.*)/){
     $tempkey=$1;
     $outercontainer=$$LAS{$tempkey};
  } elsif(/innerContainerOverride:(.*)/){
     $tempkey=$1;
     $innercontainer=$$LAS{$tempkey};
  } elsif(/innerHtmlcodeOverride:(.*)/){
     $tempkey=$1;
     $innerhtmlcode=$$LAS{tempkey};
  } elsif(/updateinterval:(.*)/){
     $updateinterval=$1;
  } elsif(/maxlength:(.*)/){
     $maxlength=$1;
  }
}

my %approved;
my @unapproved;
my @approved;
my @list;

my $htmlcode_id=getId(getNode('cachedlistapproved','htmlcode'));
my $cachekey=getId($NODE).":".$type.":".$linktype.":".$length.":".$showunapproved.":".$$VARS{unapprovedcontent}.":".$showall;
my $csr=$DB-&gt;getDatabaseHandle()-&gt;prepare_cached("select updateinterval,unix_timestamp(lastupdate),cachedata from cachedinfo where code_id=? and cachekey=?");
$csr-&gt;execute($htmlcode_id,$cachekey);
my $RESULT=$csr-&gt;fetchrow_hashref;
$csr-&gt;finish;
if(!$RESULT or (time-$$RESULT{'unix_timestamp(lastupdate)'})&gt;$$RESULT{updateinterval}){

    my $links=selectLinks $NODE;
    foreach(@$links){
        if($_-&gt;{linktype}==$lt_id){
            $approved{$_-&gt;{to_node}}=1;     
        }
    }

    my $ref=selectNodeWhere({type_nodetype=&gt;getType($type)},""
    #unix_timestamp(now())&lt;(unix_timestamp createtime+7*24*60*60)"
    ,"createtime desc limit 100");
  
    my $i;
    my $j=0;
    for($i=$count; $i&lt;@$ref and $numshown&lt;$maxlength; $i++){
        if($approved{$$ref[$i]}){
            $numshown++;
            push @approved,$$ref[$i];
            push @list, $$ref[$i];
        } else{
            push @unapproved,$$ref[$i];
            push @list, -$$ref[$i];
        }
   }
   my $cachedata=join(',',@list);
   if($RESULT){
       $DB-&gt;getDatabaseHandle()-&gt;do("update cachedinfo set lastupdate=now(), cachedata=\"$cachedata\" 
         where cachekey=\"$cachekey\" and code_id=$htmlcode_id");
   } else {
       $DB-&gt;getDatabaseHandle()-&gt;do("insert into cachedinfo 
      (code_id,cachedata,updateinterval,lastupdate,cachekey)
      values ($htmlcode_id,\"$cachedata\",$updateinterval,now(),\"$cachekey\")");
   }
} else{
   
   @list=split(/,/,$$RESULT{cachedata});
}
   
   
$HTMLVARS{listapproved}{title}=$title;
my $innerstr;
$numshown=0;
my $canconsider= Everything::isApproved($USER,'CanConsider');
foreach(@list){
    $HTMLVARS{embed_node}=selectNode $_;
    next if $expireTime gt $HTMLVARS{embed_node}{createtime};
    if($_&gt;0 or ($$VARS{unapprovedcontent}) and $showunapproved or $showall){
        $numshown++;

        my $csr=$DB-&gt;getDatabaseHandle-&gt;prepare_cached('select * from repliesinfo where parent=?');
        $csr-&gt;execute(getId($HTMLVARS{embed_node}));
        my $Q=$csr-&gt;fetchrow_hashref;
        $csr-&gt;finish;

        my $typeofreplies=$$VARS{repliesdisplay};
        $typeofreplies||="directreplies";
        $HTMLVARS{embed_node}{numreplies}=$$Q{$typeofreplies};
        $HTMLVARS{embed_node}{numreplies}||="0";
        $innerstr.=containHtml($innercontainer,htmlcode($innerhtmlcode));
        last if $numshown==$length;
    } 
    
    if($canconsider and !$approved{getId($HTMLVARS{embed_node})}){
        push @unapproved, -$_;
    }
}

$HTMLVARS{unapproved}=\@unapproved;
$str.=containHtml($outercontainer,$innerstr);
return $str if $numshown&gt;0;
"";</patch_code>
<applied>2005-09-19 14:37:56</applied>
<htmlcode_id>16955</htmlcode_id>
<live_code>use lib $HTMLVARS{uselib};
use Everything::Experience;

my( $type, $linktype, $title, $length, @options )= @_;
my( $showall, $showunapproved, $tempkey );
my $lt_id = getId( getNode( $linktype, 'linktype' ) );

my $updateinterval   = 180;
my $daysBeforeExpire = 7;
my $expireTime = $DB-&gt;sqlSelect("from_unixtime(unix_timestamp(now())-86400*$daysBeforeExpire)");
my $SETTING = getNode('listapproved settings','setting');
my $LAS = getVars $SETTING;

my $outercontainer = $LAS-&gt;{"outerContainerForType_".$type} || $LAS-&gt;{defaultOuterContainer};
my $innercontainer = $LAS-&gt;{"innerContainerForType_".$type} || $LAS-&gt;{defaultInnerContainer};
my $innerhtmlcode  = $LAS-&gt;{"innerHtmlcodeForType_".$type}  || $LAS-&gt;{defaultInnerHtmlcode};

my $start = my $count = $q-&gt;param('next') || 0;
my $maxlength = $length ||= 10;
my $max = $count + $length;
my $numshown = 0;

foreach(@options){
    if(lc($_) eq "showunapproved"){$showunapproved=1}
    elsif(lc($_) eq "showall"){$showall=1;}
    elsif(/linkto\|(.*)\|(.*)/){
        $HTMLVARS{listapproved}{linkto_node_id}=getId(getNode($1,$2));  
    }
    elsif(/outerContainerOverride:(.*)/){
        $tempkey=$1;
        $outercontainer=$$LAS{$tempkey};
    } elsif(/innerContainerOverride:(.*)/){
        $tempkey=$1;
        $innercontainer=$$LAS{$tempkey};
    } elsif(/innerHtmlcodeOverride:(.*)/){
        $tempkey=$1;
        $innerhtmlcode=$$LAS{tempkey};
    } elsif(/updateinterval:(.*)/){
        $updateinterval=$1;
    } elsif(/maxlength:(.*)/){
        $maxlength=$1;
    }
}

my( %approved, @unapproved, @approved, @list );
my $htmlcode_id = getId(getNode('cachedlistapproved','htmlcode'));

my $cachekey = join ':',
    getId($NODE), $type, $linktype, $length, $showunapproved,
    $VARS-&gt;{unapprovedcontent}, $showall;
my $csr = $DB-&gt;getDatabaseHandle()-&gt;prepare_cached( join ' ',
    "select updateinterval,",
    "unix_timestamp(lastupdate),",
    "cachedata",
    "from   cachedinfo",
    "where  code_id  = ?",
    "and    cachekey = ?",
    "order by lastupdate desc limit 1",
);

$csr-&gt;execute($htmlcode_id,$cachekey);
my $RESULT = $csr-&gt;fetchrow_hashref;
$csr-&gt;finish;
if(! $RESULT or ( time - $RESULT-&gt;{'unix_timestamp(lastupdate)'} ) &gt; $RESULT-&gt;{updateinterval} ) {
    my $links = selectLinks $NODE;
    $approved{$_-&gt;{to_node}} = 1
        for grep $_-&gt;{linktype} == $lt_id, @$links;
    my $ref = selectNodeWhere( {type_nodetype =&gt; getType($type) }, '', 'createtime desc limit 100');
    #unix_timestamp(now())&lt;(unix_timestamp createtime+7*24*60*60)"

    for( @$ref[$count..$#$ref] ) {
        if($approved{$_}){
            push @approved,   $_;
            push @list,       $_;
            last if ++$numshown &gt;= $maxlength;
        } else {
            push @unapproved, $_;
            push @list,      -$_;
        }
    }
    my $cachedata = join ',', @list;

    my $sql = $RESULT
        ?   join( ' ',
                "update cachedinfo set",
                "lastupdate = now(),",
                "cachedata  = '$cachedata'",
                "where cachekey = '$cachekey'",
                "and code_id = $htmlcode_id",
            )
        :   join( ' ',
                "insert into cachedinfo",
                "( code_id, cachedata, updateinterval, lastupdate, cachekey )",
                "values( $htmlcode_id, '$cachedata', $updateinterval, now(),",
                "'$cachekey' )",
            )
    ;
    $DB-&gt;getDatabaseHandle()-&gt;do( $sql );
} else {
    @list = split /,/, $RESULT-&gt;{cachedata};
}

$HTMLVARS{listapproved}{title} = $title;
my $innerstr;
$numshown = 0;
my $canconsider= Everything::isApproved($USER,'CanConsider');
for( @list ) {
    $HTMLVARS{embed_node} = selectNode $_;
    next if $expireTime gt $HTMLVARS{embed_node}{createtime};
    if($_ &gt; 0 or ($VARS-&gt;{unapprovedcontent}) and $showunapproved or $showall){
        $numshown++;

        my $node= $HTMLVARS{embed_node};
        $node-&gt;{replies}= htmlcode( 'formatRepliesInfo','', $node );
        $node-&gt;{numreplies} = 0 + $node-&gt;{replies}; # temp backward compat

        $innerstr .= containHtml($innercontainer, htmlcode($innerhtmlcode));
        last if $numshown == $length;
    }
    if($canconsider and !$approved{getId($HTMLVARS{embed_node})}){
        push @unapproved, -$_;
    }
}

$HTMLVARS{unapproved} = \@unapproved;
return '' if ! $numshown;
return containHtml($outercontainer,$innerstr);
</live_code>
<reason>lose getLevel</reason>
<field>code</field>
</record>
<record><htmlcode_id>493239</htmlcode_id>
<patch_code>my $str;
use Everything::Experience;
my $innerstr;
my ($type,$linktype,$title,$length,@options)=@_;
my ($showall,$navbaron,$showunapproved,$linkto);
my ($tempkey);
my $canconsider=Everything::isApproved($USER,'CanConsider');
my $lt_id=getId(getNode($linktype,"linktype"));
my $updateinterval=180;

my $SETTING=getNode('listapproved settings','setting');
my $LAS=getVars $SETTING;

my $outercontainer= $$LAS{"outerContainerForType_".$type} ? $$LAS{"outerContainerForType_".$type} : $$LAS{defaultOuterContainer};
my $innercontainer= $$LAS{"innerContainerForType_".$type} ? $$LAS{"innerContainerForType_".$type} : $$LAS{defaultInnerContainer};
my $innerhtmlcode=  $$LAS{"innerHtmlcodeForType_".$type} ? $$LAS{"innerHtmlcodeForType_".$type} : $$LAS{defaultInnerHtmlcode};

my $count = $query-&gt;param("next");
$count ||= 0;
$length ||=10;
my $start=$count;
my $max = $count + $length;
my $numshown=0;
my $maxlength=$length;

foreach(@options){
  if(lc($_) eq "navbaron"){$navbaron=1}
  elsif(lc($_) eq "showunapproved"){$showunapproved=1}
  elsif(lc($_) eq "showall"){$showall=1;}
  elsif(/linkto\|(.*)\|(.*)/){
     $HTMLVARS{listapproved}{linkto_node_id}=getId(getNode($1,$2));  
  }
  elsif(/outerContainerOverride:(.*)/){
     $tempkey=$1;
     $outercontainer=$$LAS{$tempkey};
  } elsif(/innerContainerOverride:(.*)/){
     $tempkey=$1;
     $innercontainer=$$LAS{$tempkey};
  } elsif(/innerHtmlcodeOverride:(.*)/){
     $tempkey=$1;
     $innerhtmlcode=$$LAS{tempkey};
  } elsif(/updateinterval:(.*)/){
     $updateinterval=$1;
  } elsif(/maxlength:(.*)/){
     $maxlength=$1;
  }
}

my %approved;
my @unapproved;
my @approved;
my @list;

my $htmlcode_id=getId(getNode('cachedlistapproved','htmlcode'));
my $cachekey=getId($NODE).":".$type.":".$linktype.":".$length.":".$showunapproved.":".$$VARS{unapprovedcontent}.":".$showall;
my $csr=$DB-&gt;getDatabaseHandle()-&gt;prepare_cached("select updateinterval,unix_timestamp(lastupdate),cachedata from cachedinfo where code_id=? and cachekey=?");
$csr-&gt;execute($htmlcode_id,$cachekey);
my $RESULT=$csr-&gt;fetchrow_hashref;
$csr-&gt;finish;
if(!$RESULT or (time-$$RESULT{'unix_timestamp(lastupdate)'})&gt;$$RESULT{updateinterval}){

   my $links=selectLinks $NODE;
   foreach(@$links){
   if($_-&gt;{linktype}==$lt_id){
      $approved{$_-&gt;{to_node}}=1;     
      }
   }

   my $ref=selectNodeWhere({type_nodetype=&gt;getType($type)},"","createtime desc");
   my $i;
   my $j=0;
   for($i=$count; $i&lt;@$ref and $numshown&lt;$maxlength; $i++){
       if($approved{$$ref[$i]}){
            $numshown++;
            push @approved,$$ref[$i];
            push @list, $$ref[$i];
        } else{
           push @unapproved,$$ref[$i];
           push @list, -$$ref[$i];
        }
   }
   my $cachedata=join(',',@list);
   if($RESULT){
       $DB-&gt;getDatabaseHandle()-&gt;do("update cachedinfo set lastupdate=now(), cachedata=\"$cachedata\" 
         where cachekey=\"$cachekey\" and code_id=$htmlcode_id");
   } else{
       $DB-&gt;getDatabaseHandle()-&gt;do("insert into cachedinfo 
      (code_id,cachedata,updateinterval,lastupdate,cachekey)
      values ($htmlcode_id,\"$cachedata\",$updateinterval,now(),\"$cachekey\")");
   }
} else{
   
   @list=split(/,/,$$RESULT{cachedata});
}
$HTMLVARS{listapproved}{title}=$title;
   my $innerstr;
   $numshown=0;
   foreach(@list){
    $HTMLVARS{embed_node}=selectNode $_;
    if($_&gt;0 or ($$VARS{unapprovedcontent}) and $showunapproved or $showall){
       $numshown++;

       my $csr=$DB-&gt;getDatabaseHandle-&gt;prepare_cached('select * from repliesinfo where parent=?');
       $csr-&gt;execute(getId($HTMLVARS{embed_node}));
       my $Q=$csr-&gt;fetchrow_hashref;
       $csr-&gt;finish;

       my $typeofreplies=$$VARS{repliesdisplay};
       $typeofreplies||="directreplies";
       $HTMLVARS{embed_node}{numreplies}=$$Q{$typeofreplies};
       $HTMLVARS{embed_node}{numreplies}||="0";
       $innerstr.=containHtml($innercontainer,htmlcode($innerhtmlcode));
       last if $numshown==$length;
    } 
    if($canconsider and !$approved{getId($HTMLVARS{embed_node})}){
       push @unapproved, -$_;
    }
   }


$HTMLVARS{unapproved}=\@unapproved;
$str.=containHtml($outercontainer,$innerstr);</patch_code>
<applied>2005-09-19 14:44:40</applied>
<htmlcode_id>17139</htmlcode_id>
<live_code>die "navcachedlistapproved is never used!";</live_code>
<reason>lose getLevel</reason>
<field>code</field>
</record>
<record><htmlcode_id>680617</htmlcode_id>
<patch_code>htmlcode('parseLinksInNodeField',"$HTMLVARS{embed_node}{node_id},codedescription");</patch_code>
<applied>2008-04-15 14:28:00</applied>
<htmlcode_id>26623</htmlcode_id>
<live_code>htmlcode(
    'parseLinksInContent','',
    $HTMLVARS{embed_node}{codedescription},
    id =&gt; $HTMLVARS{embed_node}{node_id},
);
</live_code>
<reason>Clean up names to make them case sensitive</reason>
<field>code</field>
</record>
<record><htmlcode_id>565986</htmlcode_id>
<patch_code>my $str;
my($type,$linktype,$title,$length,$navbaron,$allowunmoderated,$linksto)=@_;
my @lt=getNodeWhere({title=&gt;$linktype});
my $lt_id=getId($lt[0]);
my $numshown=0;
     
my $gods=canUpdateNode($USER,$NODE);
my @flt=getNodeWhere({title=&gt;'frontpage linktype'});
my $frontpagelinktype=getId($flt[0]);
my $frontpageid=getId($HTMLVARS{default_node});

my $count = $query-&gt;param("next");
$count ||= 0;
$length ||=10;
my $start=$count;
my $max = $count + $length;


if($gods){
   my(@params)=$query-&gt;param();   
   my $nodeid=getId($NODE);

      foreach(@params){
         my $curid=$_;
         if(/\d+/){
            my(@operations)=$query-&gt;param($curid);
            foreach(@operations){
               if($_ eq "frontpage"){
                   updateLinks($curid,$frontpageid,$frontpagelinktype);
                   updateLinks($curid,$nodeid,$lt_id);
               }
               if($_ eq "ok"){
                   updateLinks($curid,$nodeid,$lt_id);
               }
               if($_ eq "delete"){
                  my $ref=selectNodeWhere({node_id=&gt;$curid},"","");
                  foreach(@$ref){
                     nukeNode($_,$USER);
                  }
               }
            }
         }
      }
}

$str.="&lt;TABLE width=\"100%\"&gt;";
$str.="&lt;TR BGCOLOR=\"";
if($$THEME{titlebgcolor}){
   $str.=$$THEME{titlebgcolor}; 
} else{
   $str.="b64234";
}
if($linksto){
   $str.="\"&gt;&lt;TD&gt;&lt;a href=\"index.pl?node=$linksto\"&gt;&lt;font color=white size=\"+1\"&gt;&lt;B&gt;$title&lt;/B&gt;&lt;/font&gt;&lt;/A&gt;&lt;/TD&gt;&lt;/TR&gt;&lt;TR&gt;&lt;TD&gt;";
} else{
$str.="&gt;&lt;TD&gt;&lt;font color=white size=\"+1\"&gt;&lt;B&gt;$title&lt;/B&gt;&lt;/font&gt;&lt;/TD&gt;&lt;/TR&gt;&lt;TR&gt;&lt;TD&gt;";
}
my %approved;
my @unapproved;
my $links=selectLinks $NODE;

foreach(@$links){
   if($_-&gt;{linktype}==$lt_id){
      $approved{$_-&gt;{to_node}}=1;     
   }
}

my $ref=selectNodeWhere({type_nodetype=&gt;getType($type)},"","createtime desc");

if($ref){
my (@nl)=getNodeWhere({title=&gt;"embed node"},getType('nodelet'));
my $nodelet;
foreach(@nl){
   $nodelet=selectNode $_;
}
$str.="&lt;TABLE width=\"100%\" border=0 cellspacing=0 cellpadding=2&gt;";
my $j=0;
my $i;
for($i=$count; $i&lt;@$ref and $numshown&lt;$length; $i++){
    $HTMLVARS{embed_node}=selectNode $$ref[$i];
    if($approved{getId($HTMLVARS{embed_node})} or ($$VARS{unapprovedcontent}) and $allowunmoderated){
       $numshown++;
       my (@notes)=();

#my $csr=$DB-&gt;getDatabaseHandle-&gt;prepare_cached('select count(parent_node) from note where parent_node=?');

my $csr=$DB-&gt;getDatabaseHandle-&gt;prepare_cached('select * from repliesinfo where parent=?');
$csr-&gt;execute(getId($HTMLVARS{embed_node}));
my $Q=$csr-&gt;fetchrow_hashref;
my $typeofreplies=$$VARS{repliesdisplay};
$typeofreplies||="directreplies";

$HTMLVARS{embed_node}{numreplies}=$$Q{$typeofreplies};
$csr-&gt;finish;
       #getNodeWhere({'parent_node' =&gt; getId($HTMLVARS{embed_node})}, getType('note'));
       #my $csr=$DB-&gt;getDatabaseHandle-&gt;prepare_cached(&lt;&lt;SQL");
#select count(note_id) from note where note_id=?
#SQL
       #$csr-&gt;execute(getId($HTMLVARS{embed_node}));
       #$HTMLVARS{embed_node}{numreplies}=($csr-&gt;fetchrow_hashref)-&gt;{'count(note_id)'};
       #$HTMLVARS{embed_node}{numreplies}=scalar(@notes);
       $HTMLVARS{embed_node}{numreplies}||="0";
       $str.=insertNodelet($nodelet) if($nodelet);
       $j++;
    } elsif($gods){
       push @unapproved, $HTMLVARS{embed_node};
    }
}
if($gods){
   for(; $i&lt;@$ref; $i++){
       unless($approved{getId($$ref[$i])}){
           push @unapproved, $$ref[$i];
       }
   }
}
$str.="&lt;/TABLE&gt;";
$str.="&lt;CENTER&gt;";

if($navbaron){
   $str.= "&lt;table width=\"100%\" bgcolor=";
   if($$THEME{clr_highlight}){$str.=$$THEME{clr_highlight}}
   else {$str.="EEDDDD"}
   $str.=" border=0 cellpadding=2 cellspacing=0&gt;&lt;tr&gt;&lt;td align=left width=100&gt;";
   my $next = $count - $length;     
   $next = 0 if ($count - $length &lt; 0);
   $str.= "&lt;a href=".urlGen ({node_id =&gt; getId ($NODE), next =&gt; $count-$length})."&gt;&lt;--Previous entries&lt;/a&gt;" if ($count &gt; 0);
   $str.="&amp;nbsp;";
   $str.="" if($count&lt;=0);   

   $str.="&lt;/td&gt;&lt;td align=center&gt;";
   $str.="(".($count+1)."-$max) of " if($max&lt;int @$ref);
   $str.="&amp;nbsp;&lt;/td&gt;&lt;td align=center&gt;(".($count+1)."-".(int @$ref).") of " if($max&gt;=int @$ref);
   $str.=int (@$ref)."&lt;/td&gt;&lt;td align=right width=100&gt;";
   $next = $count+$length; 
   my $num = $length;
   if ($next + $length &gt; @$ref) {
       $num = @$ref - $next;
   }
   $str .= "&lt;a href=" 
   .urlGen ({node_id =&gt; getId ($NODE),next =&gt; $max}) 
   ."&gt;Next entries--&gt;&lt;/a&gt;" if ($max &lt; @$ref);
   $str .= "&amp;nbsp;&lt;/td&gt;&lt;/tr&gt;";
   $str.="&lt;/table&gt;&lt;/center&gt;";
   $str.="&lt;CENTER&gt;Your additions may not show up immediately."
     . " If you want to show unapproved nodes, change the setting"
     . " on your [User Settings] page&lt;/CENTER&gt;"
           if(!$$VARS{unapprovedcontent} and $allowunmoderated);
}
$HTMLVARS{unapproved}=\@unapproved;
$str.="&lt;/TD&gt;&lt;/TR&gt;&lt;/TABLE&gt;\n";
}
return $str if($numshown);
return;</patch_code>
<applied>2006-08-07 18:19:05</applied>
<htmlcode_id>28871</htmlcode_id>
<live_code>die "handlesConsiders is not used!"</live_code>
<reason>[id://565967]</reason>
<field>code</field>
</record>
<record><htmlcode_id>661194</htmlcode_id>
<patch_code>use Everything::Experience;


my ( $title, $nodesperpage, @options ) = @_;

#*********************************************************************
# set options based on @_

$HTMLVARS{listapproved}{title} = $title;
$nodesperpage ||= 10;

my ( $showall, $navbaron, $showunapproved ) = ( 0, 0, 0 );
my $innercontainer = 'consider container';
my $innerhtmlcode = 'considertextgenerator';
my $outercontainer;

{
    # Not sure why $type is used.  It doesn't appear to get set to
    # anything besides ' ', and the listapproved settings doesn't
    # contain 'outerContainerForType_ ' (with a space on the end) so
    # I think 'defaultOuterContainer' will always be used.
    # $type is used only in $outercontainer
    my $type = ' ';

    my $LAS = getVars( getNode( 'listapproved settings', 'setting' ) );
    $outercontainer = $LAS-&gt;{ 'outerContainerForType_' . $type } ||
                      $LAS-&gt;{defaultOuterContainer};

    foreach my $opt ( @options ){
        if( lc($opt) eq 'navbaron' ){
            $navbaron = 1;
        }
        elsif(lc($opt) eq 'showunapproved'){
            $showunapproved = 1;
        }
        elsif(lc($opt) eq 'showall'){
            $showall = 1;
        }
        elsif( $opt =~ m/linkto\|(.*)\|(.*)/ ){
            $HTMLVARS{listapproved}{linkto_node_id} =
                getId( getNode( $1,$2 ) );
        }
        elsif( $opt =~ m/outerContainerOverride:(.*)/ ){
            $outercontainer = $LAS-&gt;{ $1 };
        }
        elsif( $opt =~ m/innerContainerOverride:(.*)/ ){
            $innercontainer = $LAS-&gt;{ $1 };
        }
        elsif( $opt =~ m/innerHtmlcodeOverride:(.*)/ ){
            $innerhtmlcode = $-&gt;LAS{ $1 };
        }
    }
}

#*********************************************************************
# query for considered nodes, return if none

my @considered_nodes;

{
    my $csr = $DB-&gt;sqlSelectMany( 'considernodes_id', 
                                  'considernodes', '', 
                                  'order by considertime desc');

    while( my $Q = $csr-&gt;fetchrow_hashref ){
        push( @considered_nodes, $Q-&gt;{considernodes_id} );
    }

    return containHtml( $outercontainer, 
                        "&lt;p&gt;&lt;i&gt;There are no nodes to consider at this time.&lt;/i&gt;&lt;/p&gt;" ) 
           unless @considered_nodes;
}

my $tot_considered_nodes = scalar @considered_nodes;

#*********************************************************************
# Grab up to the next $nodesperpage nodes from @considered_nodes

# $startnode and the 'next' parameter are 0-based (to index @considered_nodes)
my $startnode = $query-&gt;param( 'next' ) || 0;

my $canconsider = Everything::isApproved( $USER, 'CanConsider' );
my ( %approved, @unapproved );
my $innerstr = '';

for( my $i = $startnode, my $numshown = 0;
     $i &lt; $tot_considered_nodes and $numshown &lt; $nodesperpage; $i++ ){

    $HTMLVARS{embed_node} = selectNode( $considered_nodes[$i] );

    my $reason = $DB-&gt;sqlSelect( 'description', 'considernodes',
                                 'considernodes_id=' . $considered_nodes[$i] );
    $reason = htmlcode( 'parselinksinchatter', '', $reason );

    my $embed_node_id = getId( $HTMLVARS{embed_node} );

    # Where is $approved{$embed_node_id} set? Delete if superfluous
    if( $approved{$embed_node_id} or $showall or
        ($VARS-&gt;{unapprovedcontent} and $showunapproved) ){

        my $csr = $DB-&gt;getDatabaseHandle
                     -&gt;prepare_cached( 'select * from repliesinfo where parent=?' );
        $csr-&gt;execute( $embed_node_id );
        my $Q = $csr-&gt;fetchrow_hashref;
        $csr-&gt;finish;

        my $typeofreplies = $VARS-&gt;{repliesdisplay} || 'directreplies';
        $HTMLVARS{embed_node}{numreplies} = $Q-&gt;{$typeofreplies} || 0;

        my $html = containHtml( $innercontainer, 
                                "Reason: $reason &lt;BR&gt;" . htmlcode($innerhtmlcode) );
        $innerstr = join( '', $innerstr, $html );

        $numshown++;
    } 

    if( $canconsider and !$approved{$embed_node_id} ){
        push( @unapproved, $HTMLVARS{embed_node} );
    }
}

$HTMLVARS{unapproved} = \@unapproved;

#*********************************************************************
# Create and return the HTML
# Note: $startnode and $prev_page_startnode are 0-based, but
# $max_node_this_page and $tot_considered_nodes are 1-based.

my $navbarhtml = '';

if( $navbaron ){
    $navbarhtml = join( '', $navbarhtml,
                     '&lt;table width="100%" class="highlight"',
                     ' border=0 cellpadding=2 cellspacing=0&gt;&lt;tr&gt;' );

    {
        my $prev_page_startnode = $startnode - $nodesperpage;     
        $prev_page_startnode = $prev_page_startnode &lt; 0 
                             ? 0 
                             : $prev_page_startnode;
        my $prev_url = $startnode &gt; 0 
                     ? urlGen( { node_id =&gt; getId( $NODE ), 
                                 next =&gt; $prev_page_startnode } ) 
                     : '';
        my $td = $startnode &gt; 0 
               ? "&lt;a href=$prev_url&gt;&lt;--Previous entries&lt;/a&gt;" 
               : '';

        # Is the &amp;nbsp; necessary?
        $navbarhtml = join( '', $navbarhtml, 
                                "&lt;td align=left width=100&gt;$td&amp;nbsp;&lt;/td&gt;" );
    }

    my $max_node_this_page = $startnode + $nodesperpage;

    {
        my $top_range = $max_node_this_page &lt; $tot_considered_nodes ?
                        $max_node_this_page : $tot_considered_nodes;
        my $bottom_range = $startnode + 1;
        my $td = "($bottom_range-$top_range) of $tot_considered_nodes considered nodes shown";

        $navbarhtml = join( '', $navbarhtml, "&lt;td align=center&gt;$td&lt;/td&gt;" );
    }

    {
        my $next_url = $max_node_this_page &lt; $tot_considered_nodes ?
                       urlGen( { node_id =&gt; getId( $NODE ), 
                                 next =&gt; $max_node_this_page } ) : '';
        my $td = $max_node_this_page &lt; $tot_considered_nodes 
               ? "&lt;a href=$next_url&gt;Next entries--&gt;&lt;/a&gt;" 
               : '';

        # Is the &amp;nbsp; necessary?
        $navbarhtml = join( '', $navbarhtml, 
                            "&lt;td align=right width=100&gt;$td&amp;nbsp;&lt;/td&gt;" );
    }

    $navbarhtml = join( '', $navbarhtml, '&lt;/tr&gt;&lt;/table&gt;&lt;/center&gt;' );
}

return join( '', containHtml( $outercontainer, $innerstr ), $navbarhtml );
</patch_code>
<applied>2008-01-11 22:44:26</applied>
<htmlcode_id>28881</htmlcode_id>
<live_code>use Everything::Experience;


my ( $title, $nodesperpage, @options ) = @_;

#*********************************************************************
# set options based on @_

$HTMLVARS{listapproved}{title} = $title;
$nodesperpage ||= 10;

my ( $showall, $navbaron, $showunapproved ) = ( 0, 0, 0 );
my $innercontainer = 'consider container';
my $innerhtmlcode = 'considertextgenerator';
my $outercontainer;

{
    # Not sure why $type is used.  It doesn't appear to get set to
    # anything besides ' ', and the listapproved settings doesn't
    # contain 'outerContainerForType_ ' (with a space on the end) so
    # I think 'defaultOuterContainer' will always be used.
    # $type is used only in $outercontainer
    my $type = ' ';

    my $LAS = getVars( getNode( 'listapproved settings', 'setting' ) );
    $outercontainer = $LAS-&gt;{ 'outerContainerForType_' . $type } ||
                      $LAS-&gt;{defaultOuterContainer};

    foreach my $opt ( @options ){
        if( lc($opt) eq 'navbaron' ){
            $navbaron = 1;
        }
        elsif(lc($opt) eq 'showunapproved'){
            $showunapproved = 1;
        }
        elsif(lc($opt) eq 'showall'){
            $showall = 1;
        }
        elsif( $opt =~ m/linkto\|(.*)\|(.*)/ ){
            $HTMLVARS{listapproved}{linkto_node_id} =
                getId( getNode( $1,$2 ) );
        }
        elsif( $opt =~ m/outerContainerOverride:(.*)/ ){
            $outercontainer = $LAS-&gt;{ $1 };
        }
        elsif( $opt =~ m/innerContainerOverride:(.*)/ ){
            $innercontainer = $LAS-&gt;{ $1 };
        }
        elsif( $opt =~ m/innerHtmlcodeOverride:(.*)/ ){
            $innerhtmlcode = $-&gt;LAS{ $1 };
        }
    }
}

#*********************************************************************
# query for considered nodes, return if none

my @considered_nodes;

{
    my $csr = $DB-&gt;sqlSelectMany( 'considernodes_id', 
                                  'considernodes', '', 
                                  'order by considertime desc');

    while( my $Q = $csr-&gt;fetchrow_hashref ){
        push( @considered_nodes, $Q-&gt;{considernodes_id} );
    }

    return containHtml( $outercontainer, 
                        "&lt;p&gt;&lt;i&gt;There are no nodes to consider at this time.&lt;/i&gt;&lt;/p&gt;" ) 
           unless @considered_nodes;
}

my $tot_considered_nodes = scalar @considered_nodes;

#*********************************************************************
# Grab up to the next $nodesperpage nodes from @considered_nodes

# $startnode and the 'next' parameter are 0-based (to index @considered_nodes)
my $startnode = $query-&gt;param( 'next' ) || 0;

my $canconsider = Everything::isApproved( $USER, 'CanConsider' );
my ( %approved, @unapproved );
my $innerstr = '';

for( my $i = $startnode, my $numshown = 0;
     $i &lt; $tot_considered_nodes and $numshown &lt; $nodesperpage; $i++ ){

    $HTMLVARS{embed_node} = selectNode( $considered_nodes[$i] );

    my $reason = $DB-&gt;sqlSelect( 'description', 'considernodes',
                                 'considernodes_id=' . $considered_nodes[$i] );
    $reason = htmlcode( 'parselinksinchatter', '', $reason );

    my $embed_node_id = getId( $HTMLVARS{embed_node} );

    # Where is $approved{$embed_node_id} set? Delete if superfluous
    if( $approved{$embed_node_id} or $showall or
        ($VARS-&gt;{unapprovedcontent} and $showunapproved) ){

        my $csr = $DB-&gt;getDatabaseHandle
                     -&gt;prepare_cached( 'select * from repliesinfo where parent=?' );
        $csr-&gt;execute( $embed_node_id );
        my $Q = $csr-&gt;fetchrow_hashref;
        $csr-&gt;finish;

        my $typeofreplies = $VARS-&gt;{repliesdisplay} || 'directreplies';
        $HTMLVARS{embed_node}{numreplies} = $Q-&gt;{$typeofreplies} || 0;
        $HTMLVARS{embed_node}{reason} = $reason;

        my $html = containHtml( $innercontainer, 
                                htmlcode($innerhtmlcode) );
        $innerstr = join( '', $innerstr, $html );

        $numshown++;
    } 

    if( $canconsider and !$approved{$embed_node_id} ){
        push( @unapproved, $HTMLVARS{embed_node} );
    }
}

$HTMLVARS{unapproved} = \@unapproved;

#*********************************************************************
# Create and return the HTML
# Note: $startnode and $prev_page_startnode are 0-based, but
# $max_node_this_page and $tot_considered_nodes are 1-based.

my $navbarhtml = '';

if( $navbaron ){
    $navbarhtml .= '&lt;table width="100%" class="highlight"'
                 . ' border=0 cellpadding=2 cellspacing=0&gt;&lt;tr&gt;';

    {
        my $prev_page_startnode = $startnode - $nodesperpage;     
        $prev_page_startnode = $prev_page_startnode &lt; 0 
                             ? 0 
                             : $prev_page_startnode;
        my $prev_url = $startnode &gt; 0 
                     ? urlGen( { node_id =&gt; getId( $NODE ), 
                                 next =&gt; $prev_page_startnode } ) 
                     : '';
        my $td = $startnode &gt; 0 
               ? "&lt;a href=$prev_url&gt;&lt;--Previous&amp;nbsp;entries&lt;/a&gt;" 
               : '&amp;nbsp;';

        $navbarhtml .= "&lt;td align=left width=100&gt;$td&lt;/td&gt;";
    }

    my $max_node_this_page = $startnode + $nodesperpage;

    {
        my $top_range = $max_node_this_page &lt; $tot_considered_nodes ?
                        $max_node_this_page : $tot_considered_nodes;
        my $bottom_range = $startnode + 1;
        my $td = "($bottom_range-$top_range) of $tot_considered_nodes considered nodes shown";

        $navbarhtml .= "&lt;td align=center&gt;$td&lt;/td&gt;";
    }

    {
        my $next_url = $max_node_this_page &lt; $tot_considered_nodes ?
                       urlGen( { node_id =&gt; getId( $NODE ), 
                                 next =&gt; $max_node_this_page } ) : '';
        my $td = $max_node_this_page &lt; $tot_considered_nodes 
               ? "&lt;a href=$next_url&gt;Next&amp;nbsp;entries--&gt;&lt;/a&gt;" 
               : '&amp;nbsp;';

        $navbarhtml .= "&lt;td align=right width=100&gt;$td&lt;/td&gt;";
    }

    $navbarhtml .= '&lt;/tr&gt;&lt;/table&gt;&lt;/center&gt;';
}

return join( '', containHtml( $outercontainer, $innerstr ), $navbarhtml );
</live_code>
<reason>replace clr_highlight with css</reason>
<field>code</field>
</record>
<record><htmlcode_id>579183</htmlcode_id>
<patch_code>use strict;
use warnings;


return ''   if  $HTMLVARS{guest_user} == getId($USER);
my %opts=@_;

if (my $field = $q-&gt;param('addtoscratchpad')){
  # this used to be an opcode. no point anymore.
  my $str = "\n&lt;br /&gt;[id://" . $q-&gt;param('node_id') . ']';

  $field  = 'privatetext'
       unless $field=~/^(private|doc)text$/;

  if ( my $pad_id = htmlcode( 'scratchpad_link','',getId($USER),'',{},1,1 ) )
  {
    my $pad=getNodeById($pad_id);
    $pad-&gt;{$field} .= $str
       unless  $pad-&gt;{$field}=~ s/(&lt;INSERTHERE&gt;)/$str$1/i;
    updateNode($pad, -1);
  }
}


my $Delim='*';
my $Delim_qm=quotemeta($Delim);
my $Esc='^';
my $Esc_qm=quotemeta($Esc);
my $Enc_Ver='DMQ2';

my $PN='personal_nodelet';
my $HV  ='hide_personal_nodelets';
my $MNV ='show_in_personal_nodelet';
my $AD  ='allow_dupe_personal_nodelet_entries';
my $append_param='append_to_personal_nodelet';
my $delete_param='delete_from_personal_nodelet';

my $max_to_show=$VARS-&gt;{$MNV} || $HTMLVARS{personalNodeletLimit} || 100;
my $debug=$q-&gt;param('debug_pnh');

my @html;
my @pns;
my $must_update=0;


my $pn=$VARS-&gt;{$PN}||'';
push @html,qq|&lt;!--\$pn="$pn"--&gt;|
    if $debug;

my $delLink = 0; # set to id if $NODE is linked in nodelet
if ($pn=~s/^\Q$Enc_Ver:\E//) {
   @pns=map {
              s/$Esc_qm(.)/($Esc,$Delim)[$1]/ge;
              s/^\[\s*(&lt;.*&gt;)\s*\]$/$1/g;
              $delLink = $1 if m|//(\d+)]| and $1 == getId ($NODE);
              $_
            } split /$Delim_qm/,$pn;
} elsif ($pn=~/^DMQ\d:/) {
  $must_update=1;
  @pns=();
} else {
   push @html,"&lt;!--Old style--&gt;";
   @pns=map   {
                my $result =
                    /^(\d+)$/
                    ? "[id://$1]"
                    : !$_
                      ? ()
                      : /^\s*&lt;/
                        ? $_
                        : "[$_]";
                $delLink = $1 if m|//(\d+)]| and $1 == getId ($NODE);
                $result;
              }
        split /&lt;br&gt;/,$pn;
   $must_update=1;
};

if ($opts{show_form} &amp;&amp; $q-&gt;param('modifypn')) {
    push @html,"&lt;!--modifypn--&gt;" if $debug;
    my %new;
    my @order;
    my $index=0;
    foreach my $param (sort $q-&gt;param) {
        my $val=$q-&gt;param($param);
        if ($param=~/prc0_pn_lnk_((new)?\d+)_val/ and $val) {
            $new{$1}=$val;
        }
        if ($param=~/prc1_pn_lnk_((new)?\d+)_pos/) {
            my $item=$1;
            my $is_new=$2;
            next if $is_new and !$new{$item};
            if ($val=~/^\s*\+\s*$/) {
                $val=9999998; # big number to sort to the end.
            } elsif ($val=~/^\s*\-\s*$/) {
                $val=-9999998; # small number to sort to the start.
            }
            if (!$val or $val!~/^-?\d{1,10}(?:\.\d{1,10})?$/) {
                $val=0;
            }
            push @order,[$item,0+$val,$index++]
                if $val and $new{$item} || $item&lt;=@pns;
        }
    }
    @pns=map  { $new{$_-&gt;[0]} ? $new{$_-&gt;[0]} : $pns[$_-&gt;[0]] }
         sort { $a-&gt;[1] &lt;=&gt; $b-&gt;[1] || $a-&gt;[2] &lt;=&gt; $b-&gt;[2] }
         @order;

    $must_update=1;
    ($VARS-&gt;{$MNV})=$1 if $q-&gt;param("param_$MNV")=~m/^(-?\d+)$/;
    ($VARS-&gt;{$HV})=($q-&gt;param("param_$HV")||'') eq 'hide';
    ($VARS-&gt;{$AD})=($q-&gt;param("param_$AD")||'') eq 'allow';
}

if (my $link=$q-&gt;param($append_param)) {
    push @html,"&lt;!--append:$link--&gt;" if $debug;
    $link=~s/^\s*|\s*$//g;
    push @pns,$link if $link=~/\S/;
    $must_update=1;
    ($delLink) = $link=~ m|//(\d+)]|;
    $q-&gt;param($append_param,''); # clear the option once we are done
}

if (my $nodeId=$q-&gt;param($delete_param)) {
    push @html,"&lt;!--delete:$nodeId--&gt;" if $debug;
    $nodeId=~s/(\d+)/$1/;
    for (0..(@pns-1)) {
        next if $pns[$_] !~ m|//$nodeId\]|;
        splice @pns, $_, 1;
        $must_update=1;
        last;
    }
    $q-&gt;param($delete_param,'0'); # clear the option once we are done
    $delLink = 0;
}

if ($must_update) {
    push @html,"&lt;!--must_update--&gt;" if $debug;
    unless ($VARS-&gt;{$AD}) {
       my %seen;
       @pns=grep { !$seen{$_}++ } @pns;
    }

    $VARS-&gt;{$PN}="$Enc_Ver:" .
                 join $Delim,
                 map {
                      (my $s=$_)=~s{([$Esc_qm$Delim_qm])}
                                   {$Esc.index($Esc.$Delim,$1)}eg;
                      $s
                    } @pns;
    push @html,qq|&lt;!--new \$pn="$pn"--&gt;|
        if $debug;
}


my $node_id    = getId($NODE);        # used when linking
my @pns_html=map {
        my $copy=$_;
        if( $node_id == 142755  ) { # [tye&amp;nbsp;] for testing
            $copy=~s{\[([^\]]+)\]}
                    {
                      my $x=$1;
                      htmlcode( 'linkHandler','', $x, $node_id );
                    }ges;
        } else {
            $copy=~s{\[([^\]]+)\]}

                    {
                      my $x=$1;
                      handleLinks($x,$node_id)
                    }ges;
        }
        $copy
   } @pns;

if ($opts{show_form}) {
    push @html,'&lt;!--showform--&gt;' if $debug;
    push @html,htmlcode('openform') if $opts{formwrap};
    push @html,$q-&gt;start_table({border=&gt;0,width=&gt;'100%'}),
               '&lt;col width="10%" span=1 align="center" /&gt;',
               '&lt;col width="30%" span=1 align="center" /&gt;',
               '&lt;col width="60%" span=1 align="center" /&gt;',
    ;


    push @html,
        $q-&gt;Tr([
           (map { $q-&gt;td({colspan=&gt;3,align=&gt;'left'},$_) }
               join("\n",'&lt;p&gt;&lt;font size="smaller"&gt;',
                     'You can provide a maximum number of items to show ',
                     'in your personal nodelet by providing a value in',
                     'the textbox below.  Positive numbers mean to show',
                     'the &lt;i&gt;last&lt;/i&gt; N items, negative to show the &lt;i&gt;first&lt;/i&gt;',
                     'abs(N) items, and 0 means to display them all.',
                     '&lt;/font&gt;&lt;/p&gt;',
                ),
                '&lt;b&gt;Number of items to show:&lt;/b&gt;'.
                $q-&gt;textfield(
                             -name =&gt;"param_$MNV",
                             -value=&gt;$VARS-&gt;{$MNV}||0,
                             -force    =&gt; 1,
                             -size     =&gt;4,
                             -maxlength=&gt;4
                            ),

                $q-&gt;checkbox(
                             -name =&gt;"param_$HV",
                             -checked=&gt;$VARS-&gt;{$HV},
                             -force    =&gt; 1,
                             -value=&gt;'hide',
                             -label=&gt;'&lt;b&gt;Hide Items In Nodelet Viewer&lt;/b&gt;'.
                                     ' (Only use it to capture node bookmarks)'
                             ),
                $q-&gt;checkbox(
                              -name =&gt;"param_$AD",
                              -checked=&gt;$VARS-&gt;{$AD},
                              -force    =&gt; 1,
                              -value=&gt;'allow',
                              -label=&gt;'&lt;b&gt;Allow Duplicates&lt;/b&gt;'.
                                         ' (By default dupes are ignored)'
                            ),
                join("\n",
                '&lt;p&gt;&lt;font size="smaller"&gt;',
                'Use numeric values in the "Position" column to control ordering.',
                'When set to 0 the item will will be deleted. When set to "+" the',
                'item will be appended, and when set to "-" the item will be prepended.',
                'New items may be added by putting',
                '&lt;a href="/?node_id=29281"&gt;PerlMonks-style HTML&lt;/a&gt;',
                '(including &lt;a href="/?node_id=43037"&gt;shortcuts&lt;/a&gt;)',
                'in the textboxes provided.',
                '&lt;/font&gt;&lt;/p&gt;'),
          ),
          $q-&gt;th([qw(Position Rendered Source)])
    ]);

    foreach my $idx (0..$#pns+5){
        my $name=$idx&lt;@pns ? $idx : "new".$idx;
        my $pos=$q-&gt;textfield(-name     =&gt;"prc1_pn_lnk_${name}_pos",
                              -value    =&gt;($idx&lt;@pns ? $idx+.1 : '+'),
                              -force    =&gt;1,
                              -size     =&gt;6,
                              -maxlength=&gt;10
                             );
        my $lnk=$idx&lt;@pns ? $pns_html[$idx] : '(new)';
        my $txt=$q-&gt;textfield(
                                -name     =&gt;"prc0_pn_lnk_${name}_val",
                                -value    =&gt;$idx&lt;@pns ? $pns[$idx] : '',
                                -force    =&gt; 1,
                                -size     =&gt;"64",
                                -maxlength=&gt;1024
                                );
        push @html, $q-&gt;Tr($q-&gt;td([$pos,$lnk,$txt]));
    }

    push @html,$q-&gt;end_table;
    push @html,$q-&gt;hidden(-name=&gt;'modifypn',-value=&gt;'modifypn');
    push @html,htmlcode('closeform') if $opts{formwrap};
} else {
    push @html,'&lt;!--default(nodelet)--&gt;' if $debug;
      my $br = "\n&lt;br /&gt;\n";

      my @show=$max_to_show&lt;0 ? @pns_html[0..(-1-$max_to_show)]
                              : @pns_html[-$max_to_show..-1];

      push @html,"&lt;!--max:$max_to_show--&gt;" if $debug;
      push @html,'&lt;div class="pn_links"&gt;',
                 join($br,
                      $VARS-&gt;{$HV} ? () : grep {/\S/} @show
                 ),
                 '&lt;/div&gt;',
                 $br,
                 '&lt;div class="pn_addlnks"&gt;',
                 linkNode( 366609, "Edit"),
                 '|',
                 ($delLink == 0
                    ? linkNode( $NODE,'Add', {$append_param =&gt; "[id://".getId($NODE).']'})
                    : linkNode( $NODE,'Remove', {$delete_param =&gt; "$delLink"}) )
                 . ' current node',
                 "$br Add to ",
                 linkNode( $NODE, 'public', {addtoscratchpad=&gt;'doctext'}),
                 '&amp;nbsp;/&amp;nbsp;',
                 linkNode( $NODE, 'private', {addtoscratchpad=&gt;'privatetext'}),
                 ' pad',
                 "&lt;/div&gt;",
                 ;

}
return join "\n","&lt;!--begin:personalnodelethandler--&gt;",
                 (map { if (/^&lt;!--/) { s/\[/&amp;#91;/g; s/\]/&amp;#93;/g; $_ } else {$_}}
                  @html),
                 "&lt;!--end:personalnodelethandler--&gt;";
</patch_code>
<applied>2006-10-18 15:28:24</applied>
<htmlcode_id>29452</htmlcode_id>
<live_code>use strict;
use warnings;


return ''   if  $HTMLVARS{guest_user} == getId($USER);
my %opts=@_;

if (my $field = $q-&gt;param('addtoscratchpad')){
  # this used to be an opcode. no point anymore.
  my $str = "\n&lt;br /&gt;[id://" . $q-&gt;param('node_id') . ']';

  $field  = 'privatetext'
    unless $field =~ /^(private|doc)text$/;

  if ( my $pad_id = htmlcode( 'scratchpad_link','',getId($USER),'',{},1,1 ) )
  {
    my $pad=getNodeById($pad_id);
    $pad-&gt;{$field} .= $str
       unless  $pad-&gt;{$field} =~ s/(&lt;!--INSERTHERE--&gt;|&lt;INSERTHERE&gt;)/$str$1/i;
    updateNode($pad,$USER);
  }
}


my $Delim='*';
my $Delim_qm=quotemeta($Delim);
my $Esc='^';
my $Esc_qm=quotemeta($Esc);
my $Enc_Ver='DMQ2';

my $PN='personal_nodelet';
my $HV  ='hide_personal_nodelets';
my $MNV ='show_in_personal_nodelet';
my $AD  ='allow_dupe_personal_nodelet_entries';
my $append_param='append_to_personal_nodelet';
my $delete_param='delete_from_personal_nodelet';

my $max_to_show=$VARS-&gt;{$MNV} || $HTMLVARS{personalNodeletLimit} || 100;
my $debug=$q-&gt;param('debug_pnh');

my @html;
my @pns;
my $must_update=0;


my $pn=$VARS-&gt;{$PN}||'';
push @html,qq|&lt;!--\$pn="$pn"--&gt;|
  if $debug;

my $delLink = 0; # set to id if $NODE is linked in nodelet
if ( $pn =~ s/^\Q$Enc_Ver:\E// ) {
  @pns=map {
    s/$Esc_qm(.)/($Esc,$Delim)[$1]/ge;
    s/^\[\s*(&lt;.*&gt;)\s*\]$/$1/g;
    $delLink = $1 if m|//(\d+)]| and $1 == getId ($NODE);
    $_
  } split /$Delim_qm/,$pn;
}
elsif ( $pn =~ /^DMQ\d:/ ) {
  $must_update=1;
  @pns=();
}
else {
  push @html, "&lt;!--Old style--&gt;";
  @pns=map {
    my $result =
      /^(\d+)$/
      ? "[id://$1]"
      : !$_
        ? ()
        : /^\s*&lt;/
          ? $_
          : "[$_]";
    $delLink = $1 if m|//(\d+)]| and $1 == getId ($NODE);
    $result;
  }
  split /&lt;br&gt;/,$pn;
  $must_update=1;
}

if ( $opts{show_form} &amp;&amp; $q-&gt;param('modifypn') ) {
  push @html,"&lt;!--modifypn--&gt;" if $debug;
  my %new;
  my @order;
  my $index=0;
  foreach my $param ( sort $q-&gt;param ) {
    my $val=$q-&gt;param($param);
    if ( $param =~ /prc0_pn_lnk_((new)?\d+)_val/ and $val ) {
      $new{$1}=$val;
    }
    if ( $param =~ /prc1_pn_lnk_((new)?\d+)_pos/ ) {
      my $item=$1;
      my $is_new=$2;
      next if $is_new and !$new{$item};
      if ( $val =~ /^\s*\+\s*$/ ) {
        $val=9999998; # big number to sort to the end.
      }
      elsif ( $val =~ /^\s*\-\s*$/ ) {
        $val=-9999998; # small number to sort to the start.
      }
      if ( !$val or $val !~ /^-?\d{1,10}(?:\.\d{1,10})?$/ ) {
        $val=0;
      }
      push @order, [$item,0+$val,$index++]
        if $val and $new{$item} || $item&lt;=@pns;
    }
  }
  @pns=map  { $new{$_-&gt;[0]} ? $new{$_-&gt;[0]} : $pns[$_-&gt;[0]] }
    sort { $a-&gt;[1] &lt;=&gt; $b-&gt;[1] || $a-&gt;[2] &lt;=&gt; $b-&gt;[2] }
    @order;

  $must_update=1;
  ($VARS-&gt;{$MNV})=$1 if $q-&gt;param("param_$MNV") =~ m/^(-?\d+)$/;
  ($VARS-&gt;{$HV})=($q-&gt;param("param_$HV")||'') eq 'hide';
  ($VARS-&gt;{$AD})=($q-&gt;param("param_$AD")||'') eq 'allow';
}

if ( my $link=$q-&gt;param($append_param) ) {
  push @html,"&lt;!--append:$link--&gt;" if $debug;
  $link =~ s/^\s*|\s*$//g;
  push @pns,$link if $link =~ /\S/;
  $must_update=1;
  ($delLink) = $link =~ m|//(\d+)]|;
  $q-&gt;param($append_param,''); # clear the option once we are done
}

if ( my $nodeId=$q-&gt;param($delete_param) ) {
  push @html,"&lt;!--delete:$nodeId--&gt;" if $debug;
  $nodeId =~ s/(\d+)/$1/;
  for ( 0 .. $#pns ) {
    next if $pns[$_] !~ m|//$nodeId\]|;
    splice @pns, $_, 1;
    $must_update=1;
    last;
  }
  $q-&gt;param($delete_param,'0'); # clear the option once we are done
  $delLink = 0;
}

if ( $must_update ) {
  push @html,"&lt;!--must_update--&gt;" if $debug;
  unless ( $VARS-&gt;{$AD} ) {
    my %seen;
    @pns=grep { !$seen{$_}++ } @pns;
  }

  $VARS-&gt;{$PN} = "$Enc_Ver:" .
    join $Delim,
    map {
      ( my $s = $_ ) =~ 
        s/([$Esc_qm$Delim_qm])/$Esc.index($Esc.$Delim,$1)/eg;
      $s
    } @pns;
  push @html,qq|&lt;!--new \$pn="$pn"--&gt;|
    if $debug;
}


my $node_id = getId($NODE); # used when linking
my @pns_html=map {
  my $copy=$_;
  if ( $node_id == 142755  ) { # [tye&amp;nbsp;] for testing
    $copy =~ s{\[([^\]]+)\]}
      {
        my $x=$1;
        htmlcode( 'linkHandler','', $x, $node_id );
      }ges;
  }
  else {
    $copy =~ s{\[([^\]]+)\]}
      {
        my $x=$1;
        handleLinks($x,$node_id)
      }ges;
  }
  $copy
} @pns;

if ($opts{show_form}) {
  push @html, '&lt;!--showform--&gt;' if $debug;
  push @html, htmlcode('openform') if $opts{formwrap};

  push @html, (
    '&lt;div id="options"&gt;',

    htmlcode( 'get_sitedoclet','',
      'Personal Nodelet Settings sitedoclet', 'MAX_USAGE' ),

    '&lt;b&gt;Number of items to show:&lt;/b&gt;'.
    $q-&gt;textfield(
      -name =&gt; "param_$MNV",
      -value =&gt; $VARS-&gt;{$MNV}||0,
      -force =&gt; 1,
      -size =&gt; 4,
      -maxlength =&gt; 4
    ),
    '&lt;br /&gt;',

    $q-&gt;checkbox(
      -name =&gt; "param_$HV",
      -checked =&gt; $VARS-&gt;{$HV},
      -force =&gt; 1,
      -value =&gt; 'hide',
      -label =&gt; '&lt;b&gt;Hide Items In Nodelet Viewer&lt;/b&gt;'
        . ' (Only use it to capture node bookmarks)'
    ),
    '&lt;br /&gt;',

    $q-&gt;checkbox(
      -name =&gt; "param_$AD",
      -checked =&gt; $VARS-&gt;{$AD},
      -force =&gt; 1,
      -value =&gt; 'allow',
      -label =&gt; '&lt;b&gt;Allow Duplicates&lt;/b&gt;'
        . ' (By default, duplicates are ignored)'
    ),

    htmlcode( 'get_sitedoclet','',
      'Personal Nodelet Settings sitedoclet', 'TABLE_USAGE' ),

    '&lt;/div&gt;',
  );

  push @html, (
    $q-&gt;start_table({border=&gt;0,width=&gt;'100%'}),
    '&lt;col width="10%" span=1 align="center" /&gt;',
    '&lt;col width="30%" span=1 align="center" /&gt;',
    '&lt;col width="60%" span=1 align="center" /&gt;',
    $q-&gt;Tr( $q-&gt;th([qw(Position Rendered Source)]) ),
  );

  foreach my $idx ( 0..$#pns+5 ) {
    my $name=$idx&lt;@pns ? $idx : "new".$idx;
    my $pos=$q-&gt;textfield(
        -name =&gt; "prc1_pn_lnk_${name}_pos",
        -value =&gt; ($idx&lt;@pns ? $idx+.1 : '+'),
        -force =&gt; 1,
        -size =&gt; 6,
        -maxlength =&gt; 10,
      );
    my $lnk=$idx&lt;@pns ? $pns_html[$idx] : '(new)';
    my $txt=$q-&gt;textfield(
        -name =&gt; "prc0_pn_lnk_${name}_val",
        -value =&gt; $idx&lt;@pns ? $pns[$idx] : '',
        -force =&gt; 1,
        -size =&gt; 64,
        -maxlength =&gt; 1024,
      );
    push @html, $q-&gt;Tr( $q-&gt;td([$pos,$lnk,$txt]) );
  }

  push @html,$q-&gt;end_table;
  push @html,$q-&gt;hidden(-name=&gt;'modifypn',-value=&gt;'modifypn');
  push @html,htmlcode('closeform') if $opts{formwrap};
}
else {
  push @html,'&lt;!--default(nodelet)--&gt;' if $debug;
  my $br = "\n&lt;br /&gt;\n";

  my @show = $max_to_show&lt;0
    ? @pns_html[0..(-1-$max_to_show)]
    : @pns_html[-$max_to_show..-1];

  push @html,"&lt;!--max:$max_to_show--&gt;" if $debug;

  unless ( $VARS-&gt;{$HV} ) {
    push @html,
      '&lt;div class="pn_links"&gt;',
      join( $br, grep /\S/, @show ),
      '&lt;/div&gt;',
      $br;
  }

  push @html,
    '&lt;div class="pn_addlnks"&gt;',
      linkNode( 366609, 'Edit'),
      '|',
      ($delLink == 0
        ? linkNode( $NODE,'Add', {$append_param =&gt; '[id://'.getId($NODE).']'})
        : linkNode( $NODE,'Remove', {$delete_param =&gt; $delLink}) ),
      ' current node',
    $br,
                  'Add to ',
      linkNode( $NODE, 'public', {addtoscratchpad=&gt;'doctext'}),
      '&amp;nbsp;/&amp;nbsp;',
      linkNode( $NODE, 'private', {addtoscratchpad=&gt;'privatetext'}),
      ' pad',
    '&lt;/div&gt;';
}
return join "\n",
  "&lt;!--begin:personalnodelethandler--&gt;",
  ( map { if (/^&lt;!--/) { s/\[/&amp;#91;/g; s/\]/&amp;#93;/g; $_ } else {$_} } @html ),
  "&lt;!--end:personalnodelethandler--&gt;";
</live_code>
<reason>it isn't just about links anymore.</reason>
<field>code</field>
</record>
<record><htmlcode_id>403758</htmlcode_id>
<patch_code>my($type,$title,$texttag,$nodetitle,$parentparam)=@_;
my $str;
my $starttext;
my $preview;
my $PS=getVars(getNode('preview settings','setting'));
my %signatureTypes;

map{$signatureTypes{$_}=1} split(/,/,$$PS{signatureWithTypes});
$preview=1 if($query-&gt;param('op') eq 'preview');
$nodetitle||=$query-&gt;param('preview_node') if $preview;
$starttext=$$VARS{signature} if($signatureTypes{$type});
$starttext=$query-&gt;param("preview_".$type."_doctext") if $preview;
$starttext=~s/\&amp;/\&amp;amp;/g;
$texttag||="Your text";
$str.="&lt;BR&gt;&lt;TABLE width=100%&gt;&lt;TR BGCOLOR=";
if($$VARS{titlebgcolor}){
    $str.=$$THEME{titlebgcolor}; 
} else{
    $str.="000066";
}
$str.="&gt;&lt;TD&gt;";
$str.="&lt;FONT COLOR=ffffff&gt;&lt;B&gt;$title&lt;/B&gt;&lt;/FONT&gt;&lt;/TD&gt;&lt;/TR&gt;&lt;TR&gt;&lt;TD&gt;";
#$str.="\n".htmlcode('openform') unless (getId($USER)==$HTMLVARS{default_user});


$str.="\n".htmlcode('openform');
$str.=$query-&gt;hidden("type", $type);
$str.="&lt;INPUT TYPE=\"hidden\" NAME=\"lastnode_id\" VALUE=\"".getId($NODE)."\"&gt;" unless $preview;
$str.="&lt;INPUT TYPE=\"hidden\" NAME=\"lastnode_id\" VALUE=\"".$query-&gt;param('preview_parent_node')."\"&gt;" if $preview;
if($type=~/note/i){
   if($query-&gt;param('preview_parent_node')){
      $str.=$query-&gt;hidden("parent_node",$query-&gt;param('preview_parent_node'));
   } elsif($query-&gt;param('parent_node')){
      $str.=$query-&gt;hidden("parent_node",$query-&gt;param('parent_node'));
   } else {
      $str.=$query-&gt;hidden("parent_node",getId($NODE));
   }
   
   $nodetitle="Re: $nodetitle" unless $preview;
}

$str.="&lt;font size=2&gt;&lt;b&gt;Title:&lt;/b&gt;&lt;/font&gt;";
$str.="&lt;INPUT TYPE=\"text\" name=\"node\" value=\"$nodetitle\"&gt;&lt;BR&gt;";
$str.="&lt;font size=2&gt;&lt;b&gt;&lt;br&gt;$texttag&lt;br&gt;&lt;/b&gt;&lt;/font&gt;";
$str.="&lt;TEXTAREA name=$type\_doctext rows=10 cols=60)&gt;$starttext&lt;/textarea&gt;&lt;BR&gt;";
$str.=$query-&gt;submit("op","preview");
$str.=$query-&gt;submit("op","new");
$str.="&lt;INPUT TYPE=\"hidden\" name=\"$parentparam\" value=\"$$NODE{node_id}\"&gt;";
$str.=$query-&gt;endform;
$str.="&lt;/TD&gt;&lt;/TR&gt;&lt;/TABLE&gt;";
$str;</patch_code>
<applied>2004-10-29 14:12:35</applied>
<htmlcode_id>30600</htmlcode_id>
<live_code>die "parentedaddnewform is not used!"</live_code>
<reason>use openform</reason>
<field>code</field>
</record>
<record><htmlcode_id>732551</htmlcode_id>
<patch_code># Note: Patch tested on local perlmonks copy.
return   if  getId($USER) == $HTMLVARS{guest_user};

for(  $VARS-&gt;{cbmaxmsgs}  ) {
  $_ = 10   if  /\D/ || $_ &lt; 0 || 50 &lt; $_;
}
my $length= $_[0] || $VARS-&gt;{cbmaxmsgs} || 10;
my $split= $_[1];
my $order= '' || $VARS-&gt;{priv_msg_order};
$order= 'desc'   if  $VARS-&gt;{reverse_messages};
$order= ''   unless  $order eq ''
  or  $order eq 'desc'  or  $order eq 'asc';

if(  $length &lt; 0   ) {
  $order  = " desc";
  $length = -$length &lt; 51 ? -$length : 50;
}

my( $total )= $DB-&gt;sqlSelect( 'count(*)',
    'message', "for_user=" . getId($USER). " and archive &gt; -1" );
my( $live )= $DB-&gt;sqlSelect( 'count(*)',
    'message', "archive=0 and for_user=" . getId($USER) );

return '' if 0 == $total;

my @msgs;
{
  my $csr= $DB-&gt;sqlSelectMany( "*", "message",
     "for_user=" . getId($USER) . " and archive=0",
     "order by tstamp $order limit $length" );
  push @msgs, $_ while $_ = $csr-&gt;fetchrow_hashref;
  $csr-&gt;finish;
}

my $start=$query-&gt;param( 'privmessagebegin' );
my $numshown= @msgs;
my $AT= getVars( getNode('approved chatter tags','setting') );

my $str;

foreach my $MSG (  @msgs  ) {
     $str .= $query-&gt;checkbox(
        "deletemsg_$MSG-&gt;{message_id}", "", "yup", " " );

     my $title = htmlcode(
        'parseTimeInString', 
        $MSG-&gt;{tstamp}
     );
     local $AUTHOR=getNodeById($MSG-&gt;{author_user}); # pad:// needs this
     my $msgtext = htmlcode(
        'parselinksinchatter','',
        $MSG-&gt;{msgtext},
        $split
     );

     $msgtext = htmlScreen( $msgtext, $AT );

     $str .= sprintf qq[
&lt;span class="msg"&gt;
 &lt;span class="msgfrom_$MSG-&gt;{author_user}"&gt;
  &lt;i class="msgfrom" title="%s"&gt;%s says&lt;/i&gt;
  %s&lt;!-- --&gt;
 &lt;/span&gt;
&lt;/span&gt;&lt;br /&gt;
],
               $title,
               linkNode(
                 $MSG-&gt;{author_user}, 
                 undef, # look up title
                 {trusted =&gt; 'yes'}
               ),
               $msgtext;}

$str= "$str\n";

my $extra= $live - $numshown;
my $archived= $total - $live;
{
    my $pref= qq[&lt;a href="?node=Message+Inbox;srch_folder];
    $str .= qq[\n&lt;span class="cb_more_messages"&gt;]
        . qq[&lt;i&gt;&amp;nbsp;&amp;nbsp;&amp;#8226; And &lt;/i&gt;]
        . qq[$pref=0"&gt;&lt;b&gt;$extra&lt;/b&gt;&lt;i&gt; more&lt;/i&gt;&lt;/a&gt;, ]
        . qq[$pref=1"&gt;&lt;b&gt;$archived&lt;/b&gt;&lt;i&gt; archived&lt;/i&gt;&lt;/a&gt;]
        . qq[&lt;br /&gt;]
        . qq[&lt;/span&gt;\n];
}
return $str;</patch_code>
<applied>2008-12-25 02:31:42</applied>
<htmlcode_id>30752</htmlcode_id>
<live_code># Note: Patch tested on local perlmonks copy.
return   if  getId($USER) == $HTMLVARS{guest_user};

for(  $VARS-&gt;{cbmaxmsgs}  ) {
  $_ = 10   if  /\D/ || $_ &lt; 0 || 50 &lt; $_;
}
my $length= $_[0] || $VARS-&gt;{cbmaxmsgs} || 10;
my $split= $_[1];
my $order= '' || $VARS-&gt;{priv_msg_order};
$order= 'desc'   if  $VARS-&gt;{reverse_messages};
$order= ''   unless  $order eq ''
  or  $order eq 'desc'  or  $order eq 'asc';

if(  $length &lt; 0   ) {
  $order  = " desc";
  $length = -$length &lt; 51 ? -$length : 50;
}

my( $total )= $DB-&gt;sqlSelect( 'count(*)',
    'message', "for_user=" . getId($USER). " and archive &gt; -1" );
my( $live )= $DB-&gt;sqlSelect( 'count(*)',
    'message', "archive=0 and for_user=" . getId($USER) );

return '' if 0 == $total;

my @msgs;
{
  my $csr= $DB-&gt;sqlSelectMany( "*", "message",
     "for_user=" . getId($USER) . " and archive=0",
     "order by tstamp $order limit $length" );
  push @msgs, $_ while $_ = $csr-&gt;fetchrow_hashref;
  $csr-&gt;finish;
}

my $start=$query-&gt;param( 'privmessagebegin' );
my $numshown= @msgs;
my $AT= getVars( getNode('approved chatter tags','setting') );

my $str;

foreach my $MSG (  @msgs  ) {
     $str .= $query-&gt;checkbox(
        "deletemsg_$MSG-&gt;{message_id}", "", "yup", " " );

     my $title = htmlcode(
        'parseTimeInString', 
        $MSG-&gt;{tstamp}
     );
     local $AUTHOR=getNodeById($MSG-&gt;{author_user}); # pad:// needs this
     my $msgtext = htmlcode(
        'parselinksinchatter','',
        $MSG-&gt;{msgtext},
        $split
     );

     $msgtext = htmlScreen( $msgtext, $AT );

     $str .= sprintf qq[
&lt;span class="msg"&gt;
 &lt;span class="msgfrom_$MSG-&gt;{author_user}"&gt;
  &lt;i class="msgfrom" title="%s"&gt;%s says&lt;/i&gt;
  %s&lt;!-- --&gt;
 &lt;/span&gt;
&lt;/span&gt;&lt;br /&gt;
],
               $title,
               linkNode(
                 $MSG-&gt;{author_user}, 
                 undef, # look up title,
                 {},
                 {trusted =&gt; 'yes'},
               ),
               $msgtext;}

$str= "$str\n";

my $extra= $live - $numshown;
my $archived= $total - $live;
{
    my $pref= qq[&lt;a href="?node=Message+Inbox;srch_folder];
    $str .= qq[\n&lt;span class="cb_more_messages"&gt;]
        . qq[&lt;i&gt;&amp;nbsp;&amp;nbsp;&amp;#8226; And &lt;/i&gt;]
        . qq[$pref=0"&gt;&lt;b&gt;$extra&lt;/b&gt;&lt;i&gt; more&lt;/i&gt;&lt;/a&gt;, ]
        . qq[$pref=1"&gt;&lt;b&gt;$archived&lt;/b&gt;&lt;i&gt; archived&lt;/i&gt;&lt;/a&gt;]
        . qq[&lt;br /&gt;]
        . qq[&lt;/span&gt;\n];
}
return $str;</live_code>
<reason>remove bogus bonus title</reason>
<field>code</field>
</record>
<record><htmlcode_id>761568</htmlcode_id>
<patch_code>my( $timeout, $limit, $split, $reverse )= @_;
$timeout ||= 500;
$limit   ||= 10;

my $ignore_list = $VARS-&gt;{ignoredusers};
$ignore_list =~ s/\|//g;
$ignore_list =~ s/,$//;
my $not_ignored = $ignore_list
    ? " and updateinterval not in ($ignore_list) "
    : '';
my $skip;
if ( $VARS-&gt;{chatter_filter} ) {
   $skip=join "|", map { quotemeta($_) }
         split /\s*,\s*/, $VARS-&gt;{chatter_filter};
   $skip=qr/(?:$skip)/i;
}


my $current = "DATE_FORMAT(FROM_UNIXTIME(UNIX_TIMESTAMP(now())-$timeout), '%Y-%m-%d %H:%i:%s')  &lt; lastupdate";

my $code_id = $HTMLVARS{public_chatter_cache_code_id};

my $csr = $DB-&gt;sqlSelectMany(
    "*,".
    "UNIX_TIMESTAMP(now())-UNIX_TIMESTAMP(lastupdate) as secsago,".
    "DATE_FORMAT(lastupdate,'%Y-%m-%d %T') as date",
    'cachedinfo',
    "code_id = $code_id and $current $not_ignored",
    "order by cachekey desc limit $limit",
);


return "&lt;i&gt;and mysqld suddenly died...&lt;/i&gt;&lt;br /&gt;\n"
    unless  $csr;

my @msgs;
unshift @msgs, $_   while  $_ = $csr-&gt;fetchrow_hashref();

if(  ! @msgs  ) {
    # Get random 0&lt;=value&lt;1 from only "this 6-second time window":
    require Digest::MD5;
    require Everything::VoteSecret; # Prevent prediction
    # Multiplying by 107 changes more digits, which seems to help:
    my $rand= $Everything::VoteSecret::secret . 107*int(time()/6);
    $rand= Digest::MD5::md5_hex( $rand );
    my $x= 0xFFFFFFFF + 1;
    $rand= (
                hex( substr $rand, 4, 8 ) / $x
            +   hex( substr $rand, 13, 8 )
        ) / $x;

    # To get $x= rand(10), paste the following:
    $x= 10*$rand;  $rand= $x - int($x);

    return "&lt;i&gt;and all is quiet...&lt;/i&gt;&lt;br /&gt;\n"
        if  1 &lt;= $x;    # 90% of the time.
    $x= 10*$rand;  $rand= $x - int($x);
    if(  1 &lt;= $x  ) {   # 90% of the 10%
        my @quiet= (
            'and the monastery is silent',
            'and the rats come out to play',
            'and the monks are mute',
            'and the questions are moot',
            'and not a whisper to be heard',
            'and the grasshoppers chirp',
            'and the leaves swirl about',
            'and a soft breeze sighs',
            'and the voices are still',
            'and the sunlight beams',
            'and a moth chases the moon',
            'and the pool shimmers',
            'and the daffodils sway',
            'and nobody stirs',
            'and all is calm',
            'and snow settles gently',
            'and the fog begins to lift',
            'and John Coltrane plays',
            'Ook. Ook!',
            'and the fire pops',
            'and a log crumbles through the grate',
            'and dust plays in a shaft of sunlight',
            'and the radiator hisses contentedly',
            'and a kettle whistles',
            'and cookies bake in the oven',
            'and monks bake in the sun',
            'and one hand claps',
            'and the universe expands',
            'and the shadows deepen',
            '&lt;tt&gt;and !@monks&lt;/tt&gt;',
            'What\'s the matter? &lt;a href="?node=NodeReaper"&gt;Cat&lt;/a&gt; got your tongue?',
        );
        $x= @quiet*$rand;  $rand= $x - int($x);
        if (htmlcode('parseTimeInString', '', ('')x3, '%m-%d') eq '05-01' and not $VARS-&gt;{nosenseofhumor}) {
            return "&lt;i&gt;&lt;font color=\"red\"&gt;$quiet[ $x ]...&lt;/font&gt;&lt;/i&gt;&lt;br /&gt;\n"
        }
        else {
            return "&lt;i&gt;$quiet[ $x ]...&lt;/i&gt;&lt;br /&gt;\n"
        }
    }
    $x= 4*$rand;  $rand= $x - int($x);
    my @borgisms= (
        'sharpens his wit',
        'stumbles on his way to the attic',
        'patrols the perimeter',
        'preheats the oven before tossing in a TV dinner',
        'silently materializes above an unsuspecting visitor',
        'patches his monknet',
        'waits for the new pizza guy, again',
        'practices exenteration where nobody will notice',
        'lights some incense and reads Tool and Die',
        'gets another author to use Module::Build',
        'polishes bones to Britney',
        'serves almond tarts with the cider',
        'takes a ball from the brass monkey',
        'files his shovel',
        'writes the same droll phrase again',
        'adds to his collection',
        'duct tapes the vents to muffle the moaning',
        'power washes the cellar floor',
        'suddenly falls through the false ceiling',
        'tries to shade his eye-sockets with his hands',
        'gets the Vote Fairy drunk',
        'releases the hounds',
        'practices with his stiletto',
        'emits an eerie hum',
        'adjusts the cross hairs',
        'selects a flavor of Kool-Aid',
        q(says "Shhhh! Be vewy vewy quiet, I'm hunting wumpus"),
        'wonders through a maze of twisty little sayings, all different',
        'slips on a banana skin',
        "settles into the armchair by the fire."
          . " You weren't using it were you?",
        'stokes the furnace',
        '. o O ( Did I forget to leave the gas on? )',
        'shuffles a deck of punched cards',
        "edits tomorrow's obituaries",
        "hides the Vote Fairy's wand",
        'snacks on some Soylent Green',
        'does the &lt;a href="http://en.wikipedia.org/wiki/Danse_macabre"&gt;'
            . 'danse macabre&lt;/a&gt;',
        'recites &lt;a href="http://en.wikipedia.org/wiki/The_Raven"&gt;'
            . 'The Raven&lt;/a&gt; over the P.A. again',
        'updates his toe tag collection database',
        'cracks his knuckles - loudly',
        'drums his fingers on the chair arm',
        'sorts his collection of toe tags, '
            . ( 'alphabetically',
                'chronologically',
                'by blood type',
                'by difficulty' )[$x],
        'cleans and fillets',
        'eats a grue',
        'buffs his metatarsals',
        'listens to &lt;a href="http://en.wikipedia.org/wiki/Dies_Irae"&gt;'
            . 'Dies Irae&lt;/a&gt;',
        'reads the &lt;a href="http://en.wikipedia.org/wiki/Necronomicon"&gt;'
            . 'Necronomicon&lt;/a&gt;',
    );
    $x= @borgisms*$rand;  $rand= $x - int($x);
    if (htmlcode('parseTimeInString', '', ('')x3, '%m-%d') eq '05-01' and not $VARS-&gt;{nosenseofhumor}) {
        return sprintf qq(&lt;i class="borgism"&gt;&lt;font color="red"&gt;%s %s&lt;/font&gt;&lt;/i&gt;&lt;br /&gt;\n),
            linkNodeTitle('NodeReaper'),
            $borgisms[$x];
    }
    else {
        return sprintf qq(&lt;i class="borgism"&gt;%s %s&lt;/i&gt;&lt;br /&gt;\n),
            linkNodeTitle('NodeReaper'),
            $borgisms[$x];
    }
}

my $html= qq[&lt;table class="cb_table" border="0" width="100%"]
        . qq[ cellspacing="0" cellpadding="2"&gt;\n];
my $odd = 1;
my $secsago;
my @html;
my $offset = 1;
my $when = 'before next';
if( $reverse ){
    @msgs = reverse @msgs;
    $when = 'after prev';
    $offset = -1;
}

for my $i ( 0 .. $#msgs ) {
    my $msg=$msgs[$i];
    next if $skip &amp;&amp; $msg-&gt;{cachedata}=~/$skip/;

    my $ds = ($i+$offset &gt;=0 &amp;&amp; $i+$offset&lt;=$#msgs)
             ? $msg-&gt;{secsago} - $msgs[$i+$offset]{secsago}
             : $msg-&gt;{secsago};
    my ( $min, $sec )=  $msg-&gt;{date} =~ /(..):(..)$/;
    $ds += 60*60   if  $ds &lt; 0;
    my $dm= int( $ds / 60 );
    $ds %= 60;

    my $title = sprintf 'Posted :%02d:%02d (%d:%02d %s)',
        $min, $sec,
        $dm, $ds,
        $i == $#msgs ? 'ago' : $when
      if $dm||$ds;

   # Extra whitespace here causes some browsers to mis-wrap
   # when it happens at the end of a line.

   my ($msg_type,$text)=split /\t/,$msg-&gt;{cachedata},3;


   $text=~s/%%titletext%%/$title/;
   $text=htmlcode('convert_links_to_html','',$text);
   $text=htmlcode('split_html','',$text) if $split;
   push @html,sprintf '&lt;tr class="%s"&gt;&lt;td class="%s"&gt;%s&lt;/td&gt;&lt;/tr&gt;',
            $msg_type,( $odd ? "odd-row" : "even-row" ),$text;

   $odd= ! $odd;
}
#@html=reverse @html if $reverse;
return join "\n",$html,@html,"&lt;/table&gt;\n";

</patch_code>
<applied>2009-05-03 07:08:30</applied>
<htmlcode_id>30755</htmlcode_id>
<live_code>my( $timeout, $limit, $split, $reverse )= @_;
$timeout ||= 500;
$limit   ||= 10;

my $ignore_list = $VARS-&gt;{ignoredusers};
$ignore_list =~ s/\|//g;
$ignore_list =~ s/,$//;
my $not_ignored = $ignore_list
    ? " and updateinterval not in ($ignore_list) "
    : '';
my $skip;
if ( $VARS-&gt;{chatter_filter} ) {
   $skip=join "|", map { quotemeta($_) }
         split /\s*,\s*/, $VARS-&gt;{chatter_filter};
   $skip=qr/(?:$skip)/i;
}


my $current = "DATE_FORMAT(FROM_UNIXTIME(UNIX_TIMESTAMP(now())-$timeout), '%Y-%m-%d %H:%i:%s')  &lt; lastupdate";

my $code_id = $HTMLVARS{public_chatter_cache_code_id};

my $csr = $DB-&gt;sqlSelectMany(
    "*,".
    "UNIX_TIMESTAMP(now())-UNIX_TIMESTAMP(lastupdate) as secsago,".
    "DATE_FORMAT(lastupdate,'%Y-%m-%d %T') as date",
    'cachedinfo',
    "code_id = $code_id and $current $not_ignored",
    "order by cachekey desc limit $limit",
);


return qq(&lt;i class="cb_quiet"&gt;and mysqld suddenly died...&lt;/i&gt;&lt;br /&gt;\n)
    unless  $csr;

my @msgs;
unshift @msgs, $_   while  $_ = $csr-&gt;fetchrow_hashref();

if(  ! @msgs  ) {
    # Get random 0&lt;=value&lt;1 from only "this 6-second time window":
    require Digest::MD5;
    require Everything::VoteSecret; # Prevent prediction
    # Multiplying by 107 changes more digits, which seems to help:
    my $rand= $Everything::VoteSecret::secret . 107*int(time()/6);
    $rand= Digest::MD5::md5_hex( $rand );
    my $x= 0xFFFFFFFF + 1;
    $rand= (
                hex( substr $rand, 4, 8 ) / $x
            +   hex( substr $rand, 13, 8 )
        ) / $x;

    # To get $x= rand(10), paste the following:
    $x= 10*$rand;  $rand= $x - int($x);

    return qq(&lt;i class="cb_quiet"&gt;and all is quiet...&lt;/i&gt;&lt;br /&gt;\n)
        if  1 &lt;= $x;    # 90% of the time.
    $x= 10*$rand;  $rand= $x - int($x);
    if(  1 &lt;= $x  ) {   # 90% of the 10%
        my @quiet= (
            'and the monastery is silent',
            'and the rats come out to play',
            'and the monks are mute',
            'and the questions are moot',
            'and not a whisper to be heard',
            'and the grasshoppers chirp',
            'and the leaves swirl about',
            'and a soft breeze sighs',
            'and the voices are still',
            'and the sunlight beams',
            'and a moth chases the moon',
            'and the pool shimmers',
            'and the daffodils sway',
            'and nobody stirs',
            'and all is calm',
            'and snow settles gently',
            'and the fog begins to lift',
            'and John Coltrane plays',
            'Ook. Ook!',
            'and the fire pops',
            'and a log crumbles through the grate',
            'and dust plays in a shaft of sunlight',
            'and the radiator hisses contentedly',
            'and a kettle whistles',
            'and cookies bake in the oven',
            'and monks are getting baked in the sun',
            'and the monks are chillaxin\'',
            'and one hand claps',
            'and the universe expands',
            'and the shadows deepen',
            '&lt;tt&gt;and !@monks&lt;/tt&gt;',
            'What\'s the matter? &lt;a href="?node=NodeReaper"&gt;Cat&lt;/a&gt; got your tongue?',
        );
        $x= @quiet*$rand;  $rand= $x - int($x);
        if (htmlcode('parseTimeInString', '', ('')x3, '%m-%d') eq '05-01' and not $VARS-&gt;{nosenseofhumor}) {
            return qq(&lt;i class="cb_quiet"&gt;&lt;font color=\"red\"&gt;$quiet[ $x ]...&lt;/font&gt;&lt;/i&gt;&lt;br /&gt;\n)
        }
        else {
            return qq(&lt;i class="cb_quiet"&gt;$quiet[ $x ]...&lt;/i&gt;&lt;br /&gt;\n)
        }
    }
    $x= 4*$rand;  $rand= $x - int($x);
    my @borgisms= (
        'sharpens his wit',
        'stumbles on his way to the attic',
        'patrols the perimeter',
        'preheats the oven before tossing in a TV dinner',
        'silently materializes above an unsuspecting visitor',
        'patches his monknet',
        'waits for the new pizza guy, again',
        'practices exenteration where nobody will notice',
        'lights some incense and reads Tool and Die',
        'gets another author to use Module::Build',
        'polishes bones to Britney',
        'serves mincemeat tarts with the cider',
        'takes a ball from the brass monkey',
        'files his shovel',
        'writes the same droll phrase again',
        'adds to his collection',
        'duct tapes the vents to muffle the moaning',
        'power washes the cellar floor',
        'suddenly falls through the false ceiling',
        'tries to shade his eye-sockets with his hands',
        'gets the Vote Fairy drunk',
        'releases the hounds',
        'practices with his stiletto',
        'emits an eerie hum',
        'adjusts the cross hairs',
        'selects a flavor of Kool-Aid',
        q(says "Shhhh! Be vewy vewy quiet, I'm hunting wumpus"),
        'wonders through a maze of twisty little sayings, all different',
        'slips on a banana skin',
        "settles into the armchair by the fire."
          . " You weren't using it were you?",
        'stokes the furnace',
        '. o O ( Did I forget to leave the gas on? )',
        'shuffles a deck of punched cards',
        "edits tomorrow's obituaries",
        "hides the Vote Fairy's wand",
        'snacks on some Soylent Green',
        'does the &lt;a href="http://en.wikipedia.org/wiki/Danse_macabre"&gt;'
            . 'danse macabre&lt;/a&gt;',
        'recites &lt;a href="http://en.wikipedia.org/wiki/The_Raven"&gt;'
            . 'The Raven&lt;/a&gt; over the P.A. again',
        'updates his toe tag collection database',
        'cracks his knuckles - loudly',
        'drums his fingers on the chair arm',
        'sorts his collection of toe tags, '
            . ( 'alphabetically',
                'chronologically',
                'by blood type',
                'by difficulty' )[$x],
        'cleans and fillets',
        'eats a grue',
        'buffs his metatarsals',
        'listens to &lt;a href="http://en.wikipedia.org/wiki/Dies_Irae"&gt;'
            . 'Dies Irae&lt;/a&gt;',
        'reads the &lt;a href="http://en.wikipedia.org/wiki/Necronomicon"&gt;'
            . 'Necronomicon&lt;/a&gt;',
    );
    $x= @borgisms*$rand;  $rand= $x - int($x);
    if (htmlcode('parseTimeInString', '', ('')x3, '%m-%d') eq '05-01' and not $VARS-&gt;{nosenseofhumor}) {
        return sprintf qq(&lt;i class="cb_quiet borgism"&gt;&lt;font color="red"&gt;%s %s&lt;/font&gt;&lt;/i&gt;&lt;br /&gt;\n),
            linkNodeTitle('NodeReaper'),
            $borgisms[$x];
    }
    else {
        return sprintf qq(&lt;i class="cb_quiet borgism"&gt;%s %s&lt;/i&gt;&lt;br /&gt;\n),
            linkNodeTitle('NodeReaper'),
            $borgisms[$x];
    }
}

my $html= qq[&lt;table class="cb_table" border="0" width="100%"]
        . qq[ cellspacing="0" cellpadding="2"&gt;\n];
my $odd = 1;
my $secsago;
my @html;
my $offset = 1;
my $when = 'before next';
if( $reverse ){
    @msgs = reverse @msgs;
    $when = 'after prev';
    $offset = -1;
}

for my $i ( 0 .. $#msgs ) {
    my $msg=$msgs[$i];
    next if $skip &amp;&amp; $msg-&gt;{cachedata}=~/$skip/;

    my $ds = ($i+$offset &gt;=0 &amp;&amp; $i+$offset&lt;=$#msgs)
             ? $msg-&gt;{secsago} - $msgs[$i+$offset]{secsago}
             : $msg-&gt;{secsago};
    my ( $min, $sec )=  $msg-&gt;{date} =~ /(..):(..)$/;
    $ds += 60*60   if  $ds &lt; 0;
    my $dm= int( $ds / 60 );
    $ds %= 60;

    my $title = sprintf 'Posted :%02d:%02d (%d:%02d %s)',
        $min, $sec,
        $dm, $ds,
        $i == $#msgs ? 'ago' : $when
      if $dm||$ds;

   # Extra whitespace here causes some browsers to mis-wrap
   # when it happens at the end of a line.

   my ($msg_type,$text)=split /\t/,$msg-&gt;{cachedata},3;


   $text=~s/%%titletext%%/$title/;
   $text=htmlcode('convert_links_to_html','',$text);
   $text=htmlcode('split_html','',$text) if $split;
   push @html,sprintf '&lt;tr class="%s"&gt;&lt;td class="%s"&gt;%s&lt;/td&gt;&lt;/tr&gt;',
            $msg_type,( $odd ? "odd-row" : "even-row" ),$text;

   $odd= ! $odd;
}
#@html=reverse @html if $reverse;
return join "\n",$html,@html,"&lt;/table&gt;\n";

</live_code>
<reason>Excise MySQL specific date handling</reason>
<field>code</field>
</record>
<record><htmlcode_id>403760</htmlcode_id>
<patch_code>my($type,$title,$texttag,$nodetitle)=@_;
my $str;
my $starttext;
my $preview;
my $PS=getVars(getNode('preview settings','setting'));
my %signatureTypes;

map{$signatureTypes{$_}=1} split(/,/,$$PS{signatureWithTypes});
$preview=1 if($query-&gt;param('op') eq 'preview');
$nodetitle||=$query-&gt;param('preview_node') if $preview;
$starttext=$$VARS{signature} if($signatureTypes{$type});
$starttext=$query-&gt;param("preview_".$type."_doctext") if $preview;
$starttext=~s/\&amp;/\&amp;amp;/g;
$texttag||="Your text";
$str.="&lt;BR&gt;&lt;TABLE width=100%&gt;&lt;TR BGCOLOR=";
if($$VARS{titlebgcolor}){
    $str.=$$THEME{titlebgcolor}; 
} else{
    $str.="000066";
}
$str.="&gt;&lt;TD&gt;";
$str.="&lt;FONT COLOR=ffffff&gt;&lt;B&gt;$title&lt;/B&gt;&lt;/FONT&gt;&lt;/TD&gt;&lt;/TR&gt;&lt;TR&gt;&lt;TD&gt;";
#$str.="\n".htmlcode('openform') unless (getId($USER)==$HTMLVARS{default_user});


$str.="\n".htmlcode('openform');
$str.=$query-&gt;hidden("type", $type);
$str.="&lt;INPUT TYPE=\"hidden\" NAME=\"lastnode_id\" VALUE=\"".getId($NODE)."\"&gt;" unless $preview;
$str.="&lt;INPUT TYPE=\"hidden\" NAME=\"lastnode_id\" VALUE=\"".$query-&gt;param('preview_parent_node')."\"&gt;" if $preview;
if($type=~/note/i){
   if($query-&gt;param('preview_parent_node')){
      $str.=$query-&gt;hidden("parent_node",$query-&gt;param('preview_parent_node'));
   } elsif($query-&gt;param('parent_node')){
      $str.=$query-&gt;hidden("parent_node",$query-&gt;param('parent_node'));
   } else {
      $str.=$query-&gt;hidden("parent_node",getId($NODE));
   }
   
   $nodetitle="Re: $nodetitle" unless $preview;
}

$str.="&lt;font size=2&gt;&lt;b&gt;Title:&lt;/b&gt;&lt;/font&gt;";
$str.="&lt;INPUT TYPE=\"text\" name=\"node\" value=\"$nodetitle\"&gt;&lt;BR&gt;";
$str.="&lt;font size=2&gt;&lt;b&gt;&lt;br&gt;$texttag&lt;br&gt;&lt;/b&gt;&lt;/font&gt;";
$str.="&lt;TEXTAREA name=$type\_doctext rows=10 cols=60)&gt;$starttext&lt;/textarea&gt;&lt;BR&gt;";
$str.=$query-&gt;submit("op","preview");
$str.=$query-&gt;submit("op","new") if $query-&gt;param('op') eq 'preview' or $$VARS{previewfirstoff};
$str.=$query-&gt;endform;
$str.="&lt;/TD&gt;&lt;/TR&gt;&lt;/TABLE&gt;";
$str;</patch_code>
<applied>2004-10-29 10:33:53</applied>
<htmlcode_id>36625</htmlcode_id>
<live_code>die "testaddnewform is not used!";</live_code>
<reason>use openform</reason>
<field>code</field>
</record>
<record><htmlcode_id>720733</htmlcode_id>
<patch_code># If logging in from the gates, redirect to the "login" node
# since a non-anonymous 'gates' is not a light-weigt page
my @dest;
@dest= ( -node_id =&gt; $HTMLVARS{login_node} )
    if  $HTMLVARS{default_node} == $NODE-&gt;{node_id};

return join "\n",
    '&lt;div id="minilogin"&gt;',
    htmlcode( 'openform','', -name =&gt; "login", @dest ),
    qq[&lt;input type="hidden" name="op" value="login" /&gt;],
    qq[&lt;input type="hidden" name="lastnode_id" value="$NODE-&gt;{node_id}" /&gt;],
    qq[&lt;table border="0"&gt;&lt;tr&gt;&lt;td&gt;&lt;font size="2"&gt;],
    qq[Login:&lt;/font&gt;&lt;/td&gt;&lt;td&gt;],
    $q-&gt;textfield( -name=&gt;"user", -size=&gt;10, -maxlength=&gt;34 ),
    qq[&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;font size="2"&gt;],
    qq[Password&lt;/font&gt;&lt;/td&gt;&lt;td&gt;],
    $q-&gt;password_field( -name=&gt;"passwd", -size=&gt;10, -maxlength=&gt;8 ),
    !$q-&gt;param('passwd') ? "" : "&lt;br /&gt;Oops wrong login or password",
    qq[&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;font size="2"&gt;],
    $q-&gt;checkbox( "expires", "", "+10y", "remember me" ),
    $q-&gt;submit( "login", "Login" ),
    "&lt;/font&gt;&lt;br /&gt;",
    linkNodeTitle( "What's my password?|password reminder" ),
    qq[&lt;br /&gt;],
    linkNode( $HTMLVARS{createNewUser_node} ),
    qq[&lt;/form&gt;], '&lt;/div&gt;', '';
</patch_code>
<applied>2008-10-31 13:29:17</applied>
<htmlcode_id>38451</htmlcode_id>
<live_code># If logging in from the gates, redirect to the "login" node
# since a non-anonymous 'gates' is not a light-weigt page
my @dest;
@dest= ( -node_id =&gt; $HTMLVARS{login_node} )
    if  $HTMLVARS{default_node} == $NODE-&gt;{node_id};

return join "\n",
    '&lt;div id="minilogin"&gt;',
    htmlcode( 'openform','', -name =&gt; "login", @dest ),
    qq[&lt;input type="hidden" name="op" value="login" /&gt;],
    qq[&lt;input type="hidden" name="lastnode_id" value="$NODE-&gt;{node_id}" /&gt;],
    qq[&lt;table border="0"&gt;&lt;tr&gt;&lt;td&gt;&lt;font size="2"&gt;],
    qq[Login:&lt;/font&gt;&lt;/td&gt;&lt;td&gt;],
    $q-&gt;textfield( -name=&gt;"user", -size=&gt;10, -maxlength=&gt;34 ),
    qq[&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;font size="2"&gt;],
    qq[Password&lt;/font&gt;&lt;/td&gt;&lt;td&gt;],
    $q-&gt;password_field( -name=&gt;"passwd", -size=&gt;10, -maxlength=&gt;8 ),
    !$q-&gt;param('passwd') ? "" : "&lt;br /&gt;Oops wrong login or password",
    qq[&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;font size="2"&gt;],
    $q-&gt;checkbox( "expires", "", "+10y", "remember me" ),
    $q-&gt;submit( "login", "Login" ),
    "&lt;/font&gt;&lt;br /&gt;",
    linkNode( 2513, "What's my password?" ),
    qq[&lt;br /&gt;],
    linkNode( $HTMLVARS{createNewUser_node} ),
    qq[&lt;/form&gt;], '&lt;/div&gt;', '';
</live_code>
<reason>put it in a div</reason>
<field>code</field>
</record>
<record><htmlcode_id>711765</htmlcode_id>
<patch_code># [addnewnoteform]
# be careful, changes made here should be sync'ed to [addnewform]
# at least until that node and this one are refactored

# a large chunk of this code was refactored into [add_signature]
# demerphq

my( $type, $parent )= @_;

my $text="";
my $title="";

my $preview = $query-&gt;param('op') eq 'preview';

if(  $preview  ) {
   $type   ||= $query-&gt;param('preview_type');

   my $etype = $query-&gt;escapeHTML( $type );
   return "Invalid preview_type parameter ($etype)"
      if  $type ne $etype;

   $text   = $query-&gt;param('preview_'.$type.'_doctext');
   $title  = $query-&gt;param('preview_node');
   $parent ||= $query-&gt;param($type.'_parent_node');
}

$parent ||= getId($NODE);

if ($parent !~ /^\d+$/) {
    Everything::printLog(
        join ",",
        'Non-numerical parent id',
        $ENV{REMOTE_ADDR},
        "'".quotemeta(substr($parent,0,20))."'",
    );
    # Invalid parameter means you get no form at all:
    return '';
};

my $PARENT= $parent ? getNodeById($parent) : 0;

if  ( !$title and $PARENT ) {
    $title  = ( $type eq 'categorized answer' )
               ? "Answer: $PARENT-&gt;{title}"
               : htmlcode('add_re_to_title','',$PARENT-&gt;{title})
} elsif ( !$title ) {
    $title = "New Node";
}

my $warning=htmlcode('add_signature','',\$text);

my $single_word_title = !!$preview &amp;&amp; $title !~ /\S\s+\S/;

# Don't do this if you use $q-&gt;textfield() instead of "&lt;input ...&gt;":
$title = $query-&gt;escapeHTML( $title );

my $root;
$root = getNodeById($PARENT-&gt;{root_node}) if
$PARENT-&gt;{root_node} &amp;&amp; $PARENT-&gt;{root_node} ne $parent;

my $uplinks = $parent ? (
  "&lt;p&gt;&lt;i&gt;In reply to&lt;/i&gt; ".
  "&lt;b&gt;".linkNode($PARENT)."&lt;/b&gt; ".
  "&lt;i&gt;by&lt;/i&gt; ".
  "&lt;b&gt;".linkNode($PARENT-&gt;{author_user})."&lt;/b&gt;".
  ( $root ? 
      "&lt;br/&gt;&lt;i&gt;in thread&lt;/i&gt; ".
      "&lt;b&gt;".linkNode($root)."&lt;/b&gt; ".
      "&lt;i&gt;by&lt;/i&gt; ".
      "&lt;b&gt;".linkNode($root-&gt;{author_user})."&lt;/b&gt; "
    : ''
  )."&lt;/p&gt;"
) : '';

my $html= $uplinks . htmlcode('openform') . qq[
   Title: &lt;input type="text" name="node" value="$title"&gt;&lt;br /&gt;
   ]. $warning . qq{ Your "PerlMonks-approved HTML"-formatted text:&lt;br /&gt;
   } . $query-&gt;textarea(
         -name =&gt; $type."_doctext",
         -value =&gt; $text,
         -rows =&gt; 10,
         -cols =&gt; 60
   ) . ($single_word_title &amp;&amp; qq[\n&lt;br /&gt;&lt;strong&gt;Title must be more than one word.&lt;/strong&gt;])
   . qq[&lt;br /&gt;
   &lt;input type="hidden" name="type" value="$type"&gt;
   ] . $query-&gt;hidden( $type.'_parent_node', $parent ) . qq[
   ] . $query-&gt;submit( 'op', 'preview' );

if (($preview || $VARS-&gt;{previewfirstoff}) &amp;&amp; ! $single_word_title) {
    $html.= $query-&gt;submit( 'op', 'create' );
}

return $html . $query-&gt;end_form();
</patch_code>
<applied>2008-09-16 14:30:42</applied>
<htmlcode_id>41840</htmlcode_id>
<live_code># [addnewnoteform]
# Be careful, changes made here should be sync'ed to [addnewform]
# at least until that node and this one are refactored.
# A large chunk of this code was refactored into [add_signature].

my( $type, $parent )= @_;

my $title= '';
my $text= '';
my $preview= $q-&gt;param('op') eq 'preview';
if(  $preview  ) {
    $type ||= $q-&gt;param('preview_type');
    my $etype= $q-&gt;escapeHTML( $type );
    return "Invalid preview_type parameter ($etype)"
        if  $type ne $etype;

    $title= $q-&gt;param('preview_node');
    $text= $q-&gt;param( 'preview_' . $type . '_doctext' );
    $parent ||= $q-&gt;param($type.'_parent_node');
}

$parent ||= getId($NODE);
if(  $parent !~ /^\d+$/  ) {
    Everything::printLog( join ",",
        'Non-numerical parent id',
        $ENV{REMOTE_ADDR},
        "'".quotemeta(substr($parent,0,20))."'",
    );
    # Invalid parameter means you get no form at all:
    return '';
}

my $PARENT= $parent ? getNodeById($parent) : 0;

if(  ! $title  &amp;&amp;  $PARENT  ) {
    $title= $type eq 'categorized answer'
        ?   "Answer: $PARENT-&gt;{title}"
        :   htmlcode( 'add_re_to_title','', $PARENT-&gt;{title} );
} elsif(  ! $title  ) {
    $title= "New Node";
}

my $warning= htmlcode(
    'add_signature','',
    \$text,
);

my $root;
$root= getNodeById($PARENT-&gt;{root_node})
    if  $PARENT-&gt;{root_node}
    &amp;&amp;  $PARENT-&gt;{root_node} ne $parent;

my $html= '';
if(  $parent  ) {
    $html .= join '',
        "&lt;p&gt;&lt;i&gt;In reply to&lt;/i&gt; &lt;b&gt;",
        linkNode($PARENT),
        "&lt;/b&gt;\n&lt;i&gt;by&lt;/i&gt; &lt;b&gt;",
        linkNode( $PARENT-&gt;{author_user} ),
        "&lt;/b&gt;",
    "\n";
    $html .= join( '',
        "&lt;br/&gt;&lt;i&gt;in thread&lt;/i&gt; &lt;b&gt;",
        linkNode($root),
        "&lt;/b&gt;\n&lt;i&gt;by&lt;/i&gt; &lt;b&gt;",
        linkNode( $root-&gt;{author_user} ),
        "&lt;/b&gt;",
    "\n")
        if  $root;
    $html .= "&lt;/p&gt;\n";
}

my $single_word_title=  $preview  &amp;&amp;  $title !~ /\S\s+\S/;

$html .= join "\n",
    htmlcode('openform'),
    "&lt;span class='add-title'&gt;Title:&lt;/span&gt;",
    $q-&gt;textfield( -name =&gt; 'node', -value =&gt; $title, -force =&gt; 1 ),
    ! $single_word_title ? '' :
        "&lt;br /&gt;&lt;strong&gt;Title must be more than one word!&lt;/strong&gt;",
    $warning,
    "&lt;br /&gt;Use:&amp;nbsp; &lt;tt&gt;&amp;lt;p&amp;gt; text here (a &lt;b&gt;p&lt;/b&gt;aragraph) &amp;lt;/p&amp;gt;&lt;/tt&gt;",
    "&lt;br /&gt;and:&amp;nbsp; &lt;tt&gt;&amp;lt;code&amp;gt; code here &amp;lt;/code&amp;gt;&lt;/tt&gt;&lt;br /&gt;",
    "to format your post; it's \"PerlMonks-approved HTML\": &lt;br /&gt;",
    $q-&gt;textarea( $type."_doctext", $text, 10, 60 ),
    "&lt;br /&gt;&lt;input type='hidden' name='type' value='$type'&gt;",
    $q-&gt;hidden( $type.'_parent_node', $parent ),
    $q-&gt;submit( 'op', 'preview' ),
'';

if(     (   $preview
        ||  $VARS-&gt;{previewfirstoff}  )
    &amp;&amp;  ! $single_word_title
) {
    $html .= $q-&gt;submit( 'op', 'create' ) . "\n";
}

return join "\n",
    "&lt;div class='editnodetext'&gt;",
    $html,
    $q-&gt;end_form(),
    "&lt;/div&gt;",
'';
</live_code>
<reason>Link interfered with nav, rendered wrong but first time</reason>
<field>code</field>
</record>
<record><htmlcode_id>763832</htmlcode_id>
<patch_code>#!perl
# ok, this code is a little harsh, my apologies. its the old inbox somewhat
# refactored and and quite extended, IMO it could do with a complete rewrite
# but I dont have the time.
return "Anonymous Monk has no inbox. Sorry."
   if  getId($USER) == $HTMLVARS{guest_user};

my $DEBUG;
{
    last if ! Everything::isApproved($USER,'pmdev');
    my $var= $q-&gt;param('inboxdebug');
    if ( defined $var ) {
        $VARS-&gt;{inboxdebug}= $var;
        delete $VARS-&gt;{inboxdebug} if !$var;
    }
    $DEBUG= $VARS-&gt;{inboxdebug};
}

my ($length,$offset);
{
    for(  $VARS-&gt;{inboxmaxmsgs}  ) {
        $_ = 50  if  /\D/ || $_ &lt; 0 || 1000 &lt; $_;
    }
    $length =  $q-&gt;param('inboxmaxmsgs')
               || $VARS-&gt;{inboxmaxmsgs};
    $length = 50  unless  $length =~ /^\d+$/;

    $offset = $q-&gt;param('inboxskipmsgs');
    $offset = 0  unless  $offset =~ /^\d+$/;
    if(  defined $q-&gt;param("inboxskip0")  ) {
        $offset= 0;
    } elsif(  defined $q-&gt;param("inboxskip-1")  ) {
        $offset -= $length;
        $offset= 0  if  $offset &lt; 0;
    } else {
        for(  $q-&gt;param()  ) {
            if(  /^inboxskip(\d+)$/i  ) {
                $offset= $1;
                last;
            }
        }
    }
    if(  $q-&gt;param("set_inboxmaxmsgs")  ) {
        $VARS-&gt;{inboxmaxmsgs}= $length;
    }
}

my $recvId;
{
    $recvId= $q-&gt;param('recipient');
    if(  $recvId =~ /\D/  ) {
        $recvId= getNode( $recvId, 'usergroup' )
            || getNode( $recvId, 'user' );
    } elsif(  $recvId =~ /^\d+$/  ) {
        getRef( $recvId );
    }
    if(    $recvId
        &amp;&amp;  $recvId-&gt;{type}{title} =~ /^user(group)?$/
        &amp;&amp;  Everything::isApproved($USER,$recvId)
    ) {
        $recvId= getId($recvId);
    } else {
        $recvId= getId($USER);
    }
    if(  $recvId != getId($USER)  &amp;&amp;  0 == $offset
        &amp;&amp;  exists $VARS-&gt;{"inbox$recvId"}  ) {
        $VARS-&gt;{"inbox$recvId"}= $DB-&gt;sqlSelect(
            "max(message_id)", "message", "for_user=$recvId"
        ) || 0;
    }
}

my $box= getNodeById($recvId);
my $reverse= $VARS-&gt;{inboxrevmsgs};

my $vars_id= $box-&gt;{node_id} == $USER-&gt;{node_id}
           ? "" : $recvId;

my ( %folder_lbls, %folder_counts, @folder_order );
{
    htmlcode( 'inbox_folder_settings', '',
        $box,
        hash=&gt; \%folder_lbls,
        order=&gt;\@folder_order,
        counts=&gt;\%folder_counts,
    );
}
my %folder_lbls_with_counts = map {
    ( $_ =&gt; "$folder_lbls{$_} ($folder_counts{$_}{count})" )
} @folder_order;
my $simple=do {
    if ( $q-&gt;param('inboxstyle') ) {
       $VARS-&gt;{"simple_inbox$vars_id"}= 1;
       delete $VARS-&gt;{"simple_inbox$vars_id"}
         if $q-&gt;param('inboxstyle') ne 'simple';
    }
    $VARS-&gt;{"simple_inbox$vars_id"};
};

my $del_only= do {
    if ( defined( my $val= $q-&gt;param('inbox_del_only') ) ) {
        $VARS-&gt;{"inbox_del_only$vars_id"}=$val;
        delete $VARS-&gt;{"inbox_del_only$vars_id"} if ! $val;
    }
    $VARS-&gt;{"inbox_del_only$vars_id"} || $simple;
};


# Searching from or to
my %srch_type;
{
    my @t=$q-&gt;param('srch_recip_type');
    @t=($VARS-&gt;{"inbox_srch_type$vars_id"})
        if !@t &amp;&amp; !$q-&gt;param('set_inbox');
    %srch_type = map { /^(From|To)$/ ? ($_ =&gt; 1) : ()}
                 map { split /\s*,\s*/, $_ } @t;
    if ( !%srch_type ) {
        $srch_type{To}= 1;
    }
    $VARS-&gt;{"inbox_srch_type$vars_id"}=join ",",keys %srch_type;
}

# Folder To Search
my ($Not, @srch_folder, %srch_folder);
{
    $Not= $q-&gt;param('not_folders');
    @srch_folder= $q-&gt;param('srch_folder');
    @srch_folder=grep {
            /^(-?\d+)$/ &amp;&amp; $_ &gt; -2 &amp;&amp; !$srch_folder{$_}++
        } map { split /\s*,\s*/,$_ } @srch_folder;
    if (!$Not &amp;&amp; !@srch_folder &amp;&amp; !$q-&gt;param('set_inbox')) {
        $Not= $VARS-&gt;{"not_folders$vars_id"} || "";
        @srch_folder= @{ $VARS-&gt;{"srch_folder$vars_id"} || [] };
    }
    if ($srch_folder{-1}) {
        # -1 means -2 as well.
        push @srch_folder,-2;
        $srch_folder{-2}= 1;
    }
    if ( $Not ) {
        # since we are negating we need to include -3 so
        # that it is not included.
        push @srch_folder, -3;
        $Not= "not";
        $VARS-&gt;{"not_folders$vars_id"}= $Not;
    } else {
        delete $VARS-&gt;{"not_folders$vars_id"};
        $Not= ""; # make sure its an empty string
    }
    # if we aren't negated and no folder is chosen show the inbox
    # the -3 logic guarantees that if we are negating we will
    # have at least one member in @srch_folder
    if ( ! @srch_folder ) {
        for (0, $vars_id ? 1 : () ) {
            push @srch_folder, $_;
            $srch_folder{$_}++;
        }
    }
    $VARS-&gt;{"srch_folder$vars_id"}= \@srch_folder;
}

my @upd_clause;
my @and_clause; # anded together
{
    my @or_clause=(); # or'ed together
    my $ids;
                  #recip  srch-field       key-field     folder
    for my $type (['To', 'author_user',  'for_user',    'archive'   ],
                  ['From',   'for_user',     'author_user', 'folder']) {
        my ($recip,$srch,$key,$fldr)=@$type;
        my $str;
        if ($srch_type{$recip}) {
          # we only want messages by this user
          # if they are for us.
            $str= "$key = $recvId";

            $str.= " and $fldr $Not in ("
             . join(",",@srch_folder)
             . ")";
                            # set            # constraint
            push @upd_clause,[ $fldr, "$key = $recvId" ];
            if ( $q-&gt;param('srch_author_user') ) {
                $ids||=[map {
                        my $node= $_=~/\D/
                                  ? getNode($_,'user')
                                  : getNodeById($_);
                        $node ? $node-&gt;{node_id} : ()
                    } split /,/, $q-&gt;param('srch_author_user')];
                if (@$ids&gt;1) {
                    $str.= " and $srch in (". join( ",", @$ids). ")";
                } elsif ( @$ids ) {
                    $str.= " and $srch = $ids-&gt;[0]";
                }
            }
        }
        push @or_clause,"( $str )" if $str;
    }
    my $str=join " or ",@or_clause;
    push @and_clause, "( $str )" if $str;
}

if ($q-&gt;param('srch_msgtxt')) {
    my $v=$q-&gt;param('srch_msgtxt');
    $v="%$v%" if $v!~/%/;
    push @and_clause,"msgtext like ".$DB-&gt;quote($v);
}


my $and_clause=join " and ",grep $_,@and_clause;
# Everything::printLog("sandpit: $and_clause");

# output
my @html;

push @html, "&lt;code&gt;\n$and_clause\n&lt;/code&gt;"
          if $DEBUG;

my( $total )= $DB-&gt;sqlSelect(
    'count(*)',
    'message',
    $and_clause,
);
my ($bulk)=grep { /^bulk_update_\d+_\d+$/ } $q-&gt;param();
my @sel=grep { $q-&gt;param( "sel_$_" ) }
        map { /^sel_(\d+)$/ ? $1 : () } $q-&gt;param();

if ($bulk and $q-&gt;param($bulk)=~/^(-1|\d+)$/) {
    my $sel="";
    if (@sel) {
       if ($q-&gt;param('bulk_selected') eq 'except') {
         $sel=" and message_id not in ";
       } else {
         $sel=" and message_id in ";
       }
       $sel.="(" . join( ",", @sel) . ")"
    }
    my $moveto= 0+$1;
    my ($min,$max)= $bulk=~/_(\d+)_(\d+)$/;
    foreach my $upd (@upd_clause) {
        my ($field,$constraint)=@$upd;
        my $where= "($and_clause) and $constraint"
            . " and message_id &gt;= $min"
            . " and message_id &lt;= $max"
            . $sel;
        my $res= $DB-&gt;sqlUpdate(
            'message',
            {
                $field  =&gt; $moveto,
                -tstamp =&gt; 'tstamp',
            },
            $where,
        );
        push @html, "&lt;code&gt;\n$field=$moveto\n$where\n'$res'&lt;/code&gt;"
          if $DEBUG;
    }
}

# Run Query
my ($minid,$maxid);
my @msgs;
{
    my $order = $VARS-&gt;{reverse_messages} ? 'desc' : '';
    my $csr= $DB-&gt;sqlSelectMany(
        '*',
        'message',
        $and_clause,
        "order by message_id $order limit $offset, $length"
    );

    while  ($_ = $csr-&gt;fetchrow_hashref()) {
        push @msgs, $_;
    }
    if (@msgs) {
        $maxid= $msgs[ 0]{message_id};
        $minid= $msgs[-1]{message_id};
        ($minid, $maxid) = ($maxid, $minid) if $minid &gt; $maxid;
    }
    $csr-&gt;finish();

    if( $reverse ) {
        @msgs= reverse @msgs;
    }
}
my $count= @msgs;
# Build Html

=for uedit
sub self_link{}

=cut

my $self_link=sub {
    my ($text,%opts)=@_;
    my @clean=grep { $_&gt;-2 } @srch_folder;
    linkNode( $NODE, $text,
                {
                    @clean ? (srch_folder =&gt; join(",",@clean)) : (),
                    srch_recip_type =&gt; join( ",",keys %srch_type),
                    not_folders =&gt; $Not||0,
                    $vars_id ? ( recipient =&gt; $vars_id ) : (),
                    %opts
                });
};

=for uedit
sub do_recipient{}

=cut

my $do_recipient= sub {
    my $hidden= shift;
    if( !$hidden &amp;&amp; isGod($USER)  ) {
        push @html, qq[&lt;br /&gt; Show Inbox: ]
              .  $q-&gt;textfield( "recipient" )
              .  "\n";
    } elsif(  $vars_id  ) {
        push @html, $q-&gt;hidden(
                    -name =&gt; "recipient",
                    -value =&gt; $recvId,
                    -override =&gt; 1 );
    }
};

=for uedit

sub do_search{}

=cut
my $do_search= sub {
    my $switch;
    if ($simple) {
        $switch=$self_link-&gt;("Search Mode",inboxstyle=&gt;'searchable');
    } else {
        $switch=$self_link-&gt;("Simple Mode",inboxstyle=&gt;'simple');
    }
    push @html,
          htmlcode('state_link', '', 512013,
              in_form =&gt; 1, other =&gt; $switch );

    my $who= qq[Showing messages ]
           .$q-&gt;checkbox_group(
                 -name=&gt;'srch_recip_type',
                 -values=&gt;['From','To'],
                 -default=&gt;'To',
            )
           ." ".linkNode( $recvId );
    if  ($recvId != getId($USER)) {
       $who = qq[&lt;b&gt;$who&lt;/b&gt;]
    }

    push @html,
        htmlcode('openform'),
        $q-&gt;hidden('set_inbox',1),
        "&lt;p align='left'&gt;$who&lt;br/&gt;(",
        $q-&gt;checkbox(
                -name =&gt; "not_folders",
                -checked =&gt; $Not,
                -override =&gt; 1,
                -value =&gt; "yes",
                -label =&gt; "not"
        ),
        ") in &lt;b&gt;folders&lt;/b&gt; ",
        $q-&gt;checkbox_group(
             -name=&gt;'srch_folder',
             -values=&gt;\@folder_order,
             -default=&gt;\@srch_folder,
             -labels=&gt;\%folder_lbls_with_counts,
             -override =&gt; 1,
        ),
    ;


    if ( !$simple ) {
        push @html, "&lt;br/&gt;constrain by &lt;b&gt;content&lt;/b&gt;: "
              .  $q-&gt;textfield(
                        -name =&gt; "srch_msgtxt",
                        -size =&gt; 30 )
              .  "&lt;br /&gt;and/or by &lt;b&gt;user&lt;/b&gt; "
              .  $q-&gt;textfield(
                        -name =&gt; "srch_author_user",
                        -size =&gt; 10 )
              .  $q-&gt;submit( "sexisgood", "constrain" )
        ;
    } elsif ($q-&gt;param('srch_msgtxt') || $q-&gt;param('srch_author_user')) {

        push @html, "&lt;br/&gt;Constrained by ";

        push @html, "&lt;b&gt;content&lt;/b&gt;: "
              . "&lt;i&gt;".$q-&gt;param('srch_msgtxt')."&lt;/i&gt;"
              . $q-&gt;hidden('srch_msgtxt',$q-&gt;param('srch_msgtxt'))
            if $q-&gt;param('srch_msgtxt');

        push @html, "&lt;br&gt;and by"
            if $q-&gt;param('srch_msgtxt')
            &amp;&amp; $q-&gt;param('srch_author_user');

        push @html, "&lt;b&gt;user&lt;/b&gt; "
              . "&lt;i&gt;".$q-&gt;param('srch_author_user')."&lt;/i&gt;"
              . $q-&gt;hidden('srch_author_user',$q-&gt;param('srch_author_user'))
            if $q-&gt;param('srch_author_user');
        #push @html, "&lt;br/&gt;"
        #    . $self_link-&gt;("Clear Constraint");
    }

    if ( $simple ) {
        push @html,"&lt;br /&gt;", $q-&gt;submit( "sexisgood", "change" );
    }
    $do_recipient-&gt;();
    push @html, "&lt;/form&gt;&lt;/p&gt;",htmlcode("openform"),
        @srch_folder ? $q-&gt;hidden('srch_folder',@srch_folder) : (),
        $q-&gt;hidden( 'srch_recip_type', grep { $srch_type{$_} }
                   keys %srch_type ),
        $Not ? $q-&gt;hidden('not_folders',1) : (),
        (map { $q-&gt;param($_) ? $q-&gt;hidden($_,$q-&gt;param($_)) : () }
        qw( srch_msgtxt srch_author_user  )),
        "&lt;hr /&gt;";
};

=for uedit
sub do_totals{}

=cut


my $do_totals=sub {
    if( $count &lt; $total ) {
        my $extra= $total - $count - $offset;
        $extra= 0  if  $extra &lt; 0;
        push @html, qq[&lt;tr&gt;&lt;td&gt;&lt;/td&gt;\n]
              .  qq[&lt;td&gt;&lt;center&gt;Plus $extra earlier]
              .  qq[ (of &lt;b&gt;$total&lt;/b&gt;) ]
              .  qq[messages not shown.]
              .  qq[&lt;/center&gt;&lt;/td&gt;\n]
              .  qq[&lt;td colspan='3'&gt;&lt;/td&gt;&lt;/tr&gt;\n];
    }
};

=for uedit
sub do_skip_and_max{}

=cut

my $fits= 1;   # does the entire inbox fit on the page
my $do_skip_and_max=sub {

    if( 0 &lt; $offset ||  $count &lt; $total ) {
        $fits= 0;
        push @html, qq[&lt;tr&gt;&lt;td&gt;&lt;/td&gt;\n]
              .  qq[&lt;td colspan='4'&gt;];
        push @html, $q-&gt;submit(
                    "inboxskip".($offset+$length),
                    "Earlier" )
            if  $offset+$count &lt; $total;
        push @html, " Show " . $q-&gt;textfield(
                    -name =&gt; "inboxmaxmsgs",
                    -default =&gt; $length,
                    -override =&gt; 1,
                    -size =&gt; 4 );
        push @html, $q-&gt;checkbox(
                    -name =&gt; "set_inboxmaxmsgs",
                    -checked =&gt; 0,
                    -override =&gt; 1,
                    -value =&gt; "yes",
                    -label =&gt; "always." )
            if  $recvId == getId($USER);
        push @html, " Skip " . $q-&gt;textfield(
                    -name =&gt; "inboxskipmsgs",
                    -default =&gt; $offset,
                    -override =&gt; 1,
                    -size =&gt; 4 );
        push @html, $q-&gt;submit( "inboxskip-1", "Later" )
              .  qq[&lt;/td&gt;\n&lt;td&gt;\n]
              .  $q-&gt;submit( "inboxskip0", "Latest" )
            if  0 &lt; $offset;
        push @html, qq[&lt;/td&gt;&lt;/tr&gt;\n];
    }
    if(  $fits  ) {
        push @html, qq[&lt;tr&gt;&lt;td&gt;&lt;/td&gt;]
              .  qq[&lt;td colspan='4'&gt;Max messages to show:\n]
              .  $q-&gt;textfield(
                    -name =&gt; "inboxmaxmsgs",
                    -default =&gt; $length,
                    -override =&gt; 1,
                    -size =&gt; 4 );
        push @html, $q-&gt;checkbox(
                    -name =&gt; "set_inboxmaxmsgs",
                    -checked =&gt; 0,
                    -override =&gt; 1,
                    -value =&gt; "yes",
                    -label =&gt; "Use this value in future sessions" )
            if  $recvId == getId($USER);
        push @html, "\n". $q-&gt;submit( "sexisgood", "Set" );
        push @html, qq[&lt;/td&gt;&lt;/tr&gt;\n];
    }
};

=for uedit
sub do_messages{}

=cut


my $do_messages=sub {
    push @html, "&lt;tr&gt;"
          .  join("\n",map { /^&lt;/ ? $_ : "&lt;th&gt;$_&lt;/th&gt;" }
               "Reply to",
               !$del_only ? "&lt;th colspan=2&gt;Message&lt;/th&gt;" : "Message",
               $del_only ? ("Folder","(Un)&lt;br/&gt;Del") : "Folder",
               "Sel", )
          .  "&lt;/tr&gt;";

    my $approvedtags = getVars(
        getNode( 'approved chatter tags', 'setting' ) );
    for my $MSG (  @msgs  ) {
        my $we_sent= $MSG-&gt;{for_user} != $recvId;

        my $title = htmlcode(
            'parseTimeInString',
            $MSG-&gt;{tstamp}
        );
        my $msgtext= do {
            local $AUTHOR= getNodeById( $MSG-&gt;{author_user}, 'light' );
            # as in [add_public_chatter]
            # double screen?
            htmlScreen(
                htmlcode( 'parselinksinchatter','', $MSG-&gt;{msgtext}, 0 ),
                $approvedtags
            );
        };

        my ($fld_name,$fld_id,$msg_uid);
        if ( $we_sent ) {
            $msg_uid=$MSG-&gt;{for_user};
            $fld_id= $MSG-&gt;{folder};
            $fld_name= "move";
        } else {
            $msg_uid=$MSG-&gt;{author_user};
            $fld_id= $MSG-&gt;{archive};
            $fld_name= "archive";
        }
        $fld_id= -1 if $fld_id == -2;
        my $msg_id= $MSG-&gt;{message_id};
        my $opmsgcmd=join("_",$fld_name,$msg_id,$fld_id);

        push @html, qq[&lt;tr class="inbox_message"&gt;&lt;td valign="top"&gt;&lt;center&gt;]
          . qq[&lt;input type="radio" name="replyto" value="]
          . $q-&gt;escapeHTML( $msg_id ) . qq["&gt;]
          . qq[&lt;/center&gt;&lt;/td&gt;\n]
          . qq[&lt;td valign="top"]
          . (!$del_only ? ' colspan="2"' : "")
          . qq[&gt;&lt;span title="]
          . $q-&gt;escapeHTML( $title )
          . qq["&gt;&lt;i&gt;]
          . ( $we_sent ? "told " : "" )
          . linkNode(
                $msg_uid,
                undef, # look up title
                # some browsers ignore span title (?)
                # so put another here:
                { -title =&gt; $title },
                { trusted =&gt; 'yes' },
            )
          . ( $we_sent ? "" : " says" )
          . qq[&lt;/i&gt;&lt;/span&gt;\n]
          . $msgtext
          . qq[&lt;!-- --&gt;&lt;/td&gt;\n]
          . ( $del_only ?
                qq[&lt;td valign="top" align='center'&gt;&lt;small&gt;]
              . qq[$folder_lbls{$fld_id}&lt;/small&gt;&lt;/td&gt;]
            :   ""
            )
          . qq[&lt;td valign="top"&gt;&lt;center&gt;]
          . (!$del_only
              ? $q-&gt;popup_menu(
                    -name=&gt; $opmsgcmd,
                    -values =&gt; \@folder_order,
                    -default =&gt; $fld_id ,
                    -labels =&gt; \%folder_lbls,
                )
              : $q-&gt;checkbox(
                    -name =&gt; $opmsgcmd,
                    -checked =&gt; 0,
                    -override =&gt; 1,
                    -value =&gt; $fld_id==-1 ? 0 : -1 ,
                    -label =&gt; $fld_id==-1
                        ? "&lt;br /&gt;&lt;sup&gt;&lt;b&gt;un&lt;/b&gt;&lt;/sup&gt;"
                        : "",
                )
            )
          . qq[&lt;/center&gt;&lt;/td&gt;&lt;td  valign="top"&gt;&lt;center&gt;]
          . $q-&gt;checkbox(
                -name =&gt; "sel_$msg_id",
                -checked =&gt; 0,
                -override =&gt; 1,
                -value =&gt; "yes",
                -label =&gt; "",
            )
          . qq[&lt;/center&gt;&lt;/td&gt;&lt;/tr&gt;\n];
    }

};

=for uedit
sub do_reply_fields{}

=cut


my $do_reply_fields=sub {
    #push @html, qq[&lt;tr&gt;&lt;td colspan='5'&gt;&lt;table&gt;];
    push @html, qq[&lt;tr&gt;&lt;td&gt;&lt;/td&gt;&lt;td colspan='3'&gt;]
          .  $q-&gt;param("sentmessage")
          .  qq[&lt;/td&gt;\n]
          .  qq[&lt;td&gt;&lt;/td&gt;&lt;/tr&gt;\n]
        if  $q-&gt;param("sentmessage");
    push @html, qq[&lt;tr&gt;]
          .  qq[&lt;td valign="center"&gt;]
          .  $q-&gt;submit( "sexisgood", "Send" )
          .  qq[&lt;/td&gt;]
          .  qq[&lt;td colspan='4'&gt;]
          .  $q-&gt;textfield(
                -name=&gt;'replytotext',
                -size=&gt;60,
                -maxlength=&gt;255 )
          .  qq[&lt;/td&gt;]
          .  qq[&lt;/tr&gt;\n]
          .  qq[&lt;tr&gt;&lt;td&gt;&lt;center&gt;&lt;b&gt;To&amp;nbsp;User:&lt;/b&gt;]
          .  qq[&lt;input type="radio" name="replyto" value="user"&gt;&lt;/center&gt;&lt;/td&gt;]
          .  qq[&lt;td  valign='center' colspan='4'&gt;]
          .  $q-&gt;textfield(
                -name=&gt;'sendto',
                -size=&gt;20,
                -maxlength=&gt;255 )
          .  qq[ or &lt;input type="radio" name="replyto" value="0" checked="checked"&gt;]
          .  qq[ &lt;b&gt;Don't&amp;nbsp;Send&amp;nbsp;At&amp;nbsp;All&lt;/b&gt;&lt;/td&gt;\n]
          .  qq[&lt;/tr&gt;]
          .  (!$total ? '' : "&lt;tr&gt;&lt;td colspan='5' align='right' valign='bottom'&gt;"
          .  $q-&gt;submit('sexisgood','Move')
          .  " ("
          .  $q-&gt;checkbox(
               -name=&gt;"bulk_selected",
               -value=&gt;'except',
               -checked=&gt;0,
               -force=&gt;1,
               -label=&gt;'all but')
          .  ") selected to "
          .  $q-&gt;popup_menu(
               -name=&gt;"bulk_update_${minid}_${maxid}",
               -values=&gt;[ @folder_order,-2 ],
               -default =&gt; -2,
               -force=&gt;1,
               -labels=&gt; {
                           -2 =&gt; '(nowhere)',
                           %folder_lbls,
                         },)
             )
          .  qq[&lt;/td&gt;]
          .  qq(&lt;/tr&gt;\n)
    ;
    push @html, qq(&lt;tr&gt;&lt;td&gt;&lt;/td&gt;)
          . qq(&lt;td colspan=3&gt;)
          . qq(To help someone by giving Writeup Formatting Tips, )
          . qq(link to it by including &lt;tt&gt;[id://17558]&lt;/tt&gt; in your message.)
          . qq(&lt;/td&gt;)
          . qq(&lt;td&gt;&lt;/td&gt;&lt;/tr&gt;)
        if $q-&gt;param('replytotext') =~ m|^Re \[id://|;

    if(  0 &lt; $offset  ) {
        push @html, qq[&lt;tr&gt;&lt;td&gt;&lt;/td&gt;\n]
              .  qq[&lt;td colspan='3'&gt;&lt;center&gt;Most recent $offset]
              .  qq[ messages not displayed]
              .  qq[&lt;/center&gt;&lt;/td&gt;]
              .  qq[&lt;td&gt;&lt;/td&gt;&lt;/tr&gt;\n];
    }
};



push @html,
  qq{&lt;p align="right"&gt;&lt;a href="/?node_id=419625"&gt;Help for this page&lt;/a&gt;&lt;/p&gt;\n};

$do_search-&gt;();
my $border= $DEBUG ? 1 : 0;
push @html,
   '&lt;input type="hidden" name="op" value="message" /&gt;',
   "&lt;table border='$border' width='100%'&gt;\n";
$do_reply_fields-&gt;();
$do_messages-&gt;();
$do_totals-&gt;();
$do_skip_and_max-&gt;();
push @html, "&lt;/table&gt;\n";
$do_recipient-&gt;(1);

return join("",@html,'&lt;/form&gt;')
;
</patch_code>
<applied>2009-05-13 12:33:54</applied>
<htmlcode_id>51845</htmlcode_id>
<live_code>#!perl
# ok, this code is a little harsh, my apologies. its the old inbox somewhat
# refactored and and quite extended, IMO it could do with a complete rewrite
# but I dont have the time.
return "Anonymous Monk has no inbox. Sorry."
   if  getId($USER) == $HTMLVARS{guest_user};

my $DEBUG;
{
    last if ! Everything::isApproved($USER,'pmdev');
    my $var= $q-&gt;param('inboxdebug');
    if ( defined $var ) {
        $VARS-&gt;{inboxdebug}= $var;
        delete $VARS-&gt;{inboxdebug} if !$var;
    }
    $DEBUG= $VARS-&gt;{inboxdebug};
}

my ($length,$offset);
{
    for(  $VARS-&gt;{inboxmaxmsgs}  ) {
        $_ = 50  if  /\D/ || $_ &lt; 0 || 1000 &lt; $_;
    }
    $length =  $q-&gt;param('inboxmaxmsgs')
               || $VARS-&gt;{inboxmaxmsgs};
    $length = 50  unless  $length =~ /^\d+$/;

    $offset = $q-&gt;param('inboxskipmsgs');
    $offset = 0  unless  $offset =~ /^\d+$/;
    if(  defined $q-&gt;param("inboxskip0")  ) {
        $offset= 0;
    } elsif(  defined $q-&gt;param("inboxskip-1")  ) {
        $offset -= $length;
        $offset= 0  if  $offset &lt; 0;
    } else {
        for(  $q-&gt;param()  ) {
            if(  /^inboxskip(\d+)$/i  ) {
                $offset= $1;
                last;
            }
        }
    }
    if(  $q-&gt;param("set_inboxmaxmsgs")  ) {
        $VARS-&gt;{inboxmaxmsgs}= $length;
    }
}

my $recvId;
{
    $recvId= $q-&gt;param('recipient');
    if(  $recvId =~ /\D/  ) {
        $recvId= getNode( $recvId, 'usergroup' )
            || getNode( $recvId, 'user' );
    } elsif(  $recvId =~ /^\d+$/  ) {
        getRef( $recvId );
    }
    if(    $recvId
        &amp;&amp;  $recvId-&gt;{type}{title} =~ /^user(group)?$/
        &amp;&amp;  Everything::isApproved($USER,$recvId)
    ) {
        $recvId= getId($recvId);
    } else {
        $recvId= getId($USER);
    }
    if(  $recvId != getId($USER)  &amp;&amp;  0 == $offset
        &amp;&amp;  exists $VARS-&gt;{"inbox$recvId"}  ) {
        $VARS-&gt;{"inbox$recvId"}= $DB-&gt;sqlSelect(
            "max(message_id)", "message", "for_user=$recvId"
        ) || 0;
    }
}

my $box= getNodeById($recvId);
my $reverse= !$VARS-&gt;{reverse_messages};

my $vars_id= $box-&gt;{node_id} == $USER-&gt;{node_id}
           ? "" : $recvId;

my ( %folder_lbls, %folder_counts, @folder_order );
{
    htmlcode( 'inbox_folder_settings', '',
        $box,
        hash=&gt; \%folder_lbls,
        order=&gt;\@folder_order,
        counts=&gt;\%folder_counts,
    );
}
my %folder_lbls_with_counts = map {
    ( $_ =&gt; "$folder_lbls{$_} ($folder_counts{$_}{count})" )
} @folder_order;
my $simple=do {
    if ( $q-&gt;param('inboxstyle') ) {
       $VARS-&gt;{"simple_inbox$vars_id"}= 1;
       delete $VARS-&gt;{"simple_inbox$vars_id"}
         if $q-&gt;param('inboxstyle') ne 'simple';
    }
    $VARS-&gt;{"simple_inbox$vars_id"};
};

my $del_only= do {
    if ( defined( my $val= $q-&gt;param('inbox_del_only') ) ) {
        $VARS-&gt;{"inbox_del_only$vars_id"}=$val;
        delete $VARS-&gt;{"inbox_del_only$vars_id"} if ! $val;
    }
    $VARS-&gt;{"inbox_del_only$vars_id"} || $simple;
};


# Searching from or to
my %srch_type;
{
    my @t=$q-&gt;param('srch_recip_type');
    @t=($VARS-&gt;{"inbox_srch_type$vars_id"})
        if !@t &amp;&amp; !$q-&gt;param('set_inbox');
    %srch_type = map { /^(From|To)$/ ? ($_ =&gt; 1) : ()}
                 map { split /\s*,\s*/, $_ } @t;
    if ( !%srch_type ) {
        $srch_type{To}= 1;
    }
    $VARS-&gt;{"inbox_srch_type$vars_id"}=join ",",keys %srch_type;
}

# Folder To Search
my ($Not, @srch_folder, %srch_folder);
{
    $Not= $q-&gt;param('not_folders');
    @srch_folder= $q-&gt;param('srch_folder');
    @srch_folder=grep {
            /^(-?\d+)$/ &amp;&amp; $_ &gt; -2 &amp;&amp; !$srch_folder{$_}++
        } map { split /\s*,\s*/,$_ } @srch_folder;
    if (!$Not &amp;&amp; !@srch_folder &amp;&amp; !$q-&gt;param('set_inbox')) {
        $Not= $VARS-&gt;{"not_folders$vars_id"} || "";
        @srch_folder= @{ $VARS-&gt;{"srch_folder$vars_id"} || [] };
    }
    if ($srch_folder{-1}) {
        # -1 means -2 as well.
        push @srch_folder,-2;
        $srch_folder{-2}= 1;
    }
    if ( $Not ) {
        # since we are negating we need to include -3 so
        # that it is not included.
        push @srch_folder, -3;
        $Not= "not";
        $VARS-&gt;{"not_folders$vars_id"}= $Not;
    } else {
        delete $VARS-&gt;{"not_folders$vars_id"};
        $Not= ""; # make sure its an empty string
    }
    # if we aren't negated and no folder is chosen show the inbox
    # the -3 logic guarantees that if we are negating we will
    # have at least one member in @srch_folder
    if ( ! @srch_folder ) {
        for (0, $vars_id ? 1 : () ) {
            push @srch_folder, $_;
            $srch_folder{$_}++;
        }
    }
    $VARS-&gt;{"srch_folder$vars_id"}= \@srch_folder;
}

my @upd_clause;
my @and_clause; # anded together
{
    my @or_clause=(); # or'ed together
    my $ids;
                  #recip  srch-field       key-field     folder
    for my $type (['To', 'author_user',  'for_user',    'archive'   ],
                  ['From',   'for_user',     'author_user', 'folder']) {
        my ($recip,$srch,$key,$fldr)=@$type;
        my $str;
        if ($srch_type{$recip}) {
          # we only want messages by this user
          # if they are for us.
            $str= "$key = $recvId";

            $str.= " and $fldr $Not in ("
             . join(",",@srch_folder)
             . ")";
                            # set            # constraint
            push @upd_clause,[ $fldr, "$key = $recvId" ];
            if ( $q-&gt;param('srch_author_user') ) {
                $ids||=[map {
                        my $node= $_=~/\D/
                                  ? getNode($_,'user')
                                  : getNodeById($_);
                        $node ? $node-&gt;{node_id} : ()
                    } split /,/, $q-&gt;param('srch_author_user')];
                if (@$ids&gt;1) {
                    $str.= " and $srch in (". join( ",", @$ids). ")";
                } elsif ( @$ids ) {
                    $str.= " and $srch = $ids-&gt;[0]";
                }
            }
        }
        push @or_clause,"( $str )" if $str;
    }
    my $str=join " or ",@or_clause;
    push @and_clause, "( $str )" if $str;
}

if ($q-&gt;param('srch_msgtxt')) {
    my $v=$q-&gt;param('srch_msgtxt');
    $v="%$v%" if $v!~/%/;
    push @and_clause,"msgtext like ".$DB-&gt;quote($v);
}


my $and_clause=join " and ",grep $_,@and_clause;
# Everything::printLog("sandpit: $and_clause");

# output
my @html;

push @html, "&lt;code&gt;\n$and_clause\n&lt;/code&gt;"
          if $DEBUG;

my( $total )= $DB-&gt;sqlSelect(
    'count(*)',
    'message',
    $and_clause,
);
my ($bulk)=grep { /^bulk_update_\d+_\d+$/ } $q-&gt;param();
my @sel=grep { $q-&gt;param( "sel_$_" ) }
        map { /^sel_(\d+)$/ ? $1 : () } $q-&gt;param();

if ($bulk and $q-&gt;param($bulk)=~/^(-1|\d+)$/) {
    my $sel="";
    if (@sel) {
       if ($q-&gt;param('bulk_selected') eq 'except') {
         $sel=" and message_id not in ";
       } else {
         $sel=" and message_id in ";
       }
       $sel.="(" . join( ",", @sel) . ")"
    }
    my $moveto= 0+$1;
    my ($min,$max)= $bulk=~/_(\d+)_(\d+)$/;
    foreach my $upd (@upd_clause) {
        my ($field,$constraint)=@$upd;
        my $where= "($and_clause) and $constraint"
            . " and message_id &gt;= $min"
            . " and message_id &lt;= $max"
            . $sel;
        my $res= $DB-&gt;sqlUpdate(
            'message',
            {
                $field  =&gt; $moveto,
                -tstamp =&gt; 'tstamp',
            },
            $where,
        );
        push @html, "&lt;code&gt;\n$field=$moveto\n$where\n'$res'&lt;/code&gt;"
          if $DEBUG;
    }
}

# Run Query
my ($minid,$maxid);
my @msgs;
{
    my $csr= $DB-&gt;sqlSelectMany(
        '*',
        'message',
        $and_clause,
        "order by message_id desc limit $offset, $length"
    );

    while  ($_ = $csr-&gt;fetchrow_hashref()) {
        push @msgs, $_;
    }
    if (@msgs) {
        $maxid= $msgs[ 0]{message_id};
        $minid= $msgs[-1]{message_id};
        ($minid, $maxid) = ($maxid, $minid) if $minid &gt; $maxid;
    }
    $csr-&gt;finish();

    if( $reverse ) {
        @msgs= reverse @msgs;
    }
}
my $count= @msgs;
# Build Html

=for uedit
sub self_link{}

=cut

my $self_link=sub {
    my ($text,%opts)=@_;
    my @clean=grep { $_&gt;-2 } @srch_folder;
    linkNode( $NODE, $text,
                {
                    @clean ? (srch_folder =&gt; join(",",@clean)) : (),
                    srch_recip_type =&gt; join( ",",keys %srch_type),
                    not_folders =&gt; $Not||0,
                    $vars_id ? ( recipient =&gt; $vars_id ) : (),
                    %opts
                });
};

=for uedit
sub do_recipient{}

=cut

my $do_recipient= sub {
    my $hidden= shift;
    if( !$hidden &amp;&amp; isGod($USER)  ) {
        push @html, qq[&lt;br /&gt; Show Inbox: ]
              .  $q-&gt;textfield( "recipient" )
              .  "\n";
    } elsif(  $vars_id  ) {
        push @html, $q-&gt;hidden(
                    -name =&gt; "recipient",
                    -value =&gt; $recvId,
                    -override =&gt; 1 );
    }
};

=for uedit

sub do_search{}

=cut
my $do_search= sub {
    my $switch;
    if ($simple) {
        $switch=$self_link-&gt;("Search Mode",inboxstyle=&gt;'searchable');
    } else {
        $switch=$self_link-&gt;("Simple Mode",inboxstyle=&gt;'simple');
    }
    push @html,
          htmlcode('state_link', '', 512013,
              in_form =&gt; 1, other =&gt; $switch );

    my $who= qq[Showing messages ]
           .$q-&gt;checkbox_group(
                 -name=&gt;'srch_recip_type',
                 -values=&gt;['From','To'],
                 -default=&gt;'To',
            )
           ." ".linkNode( $recvId );
    if  ($recvId != getId($USER)) {
       $who = qq[&lt;b&gt;$who&lt;/b&gt;]
    }

    push @html,
        htmlcode('openform'),
        $q-&gt;hidden('set_inbox',1),
        "&lt;p align='left'&gt;$who&lt;br/&gt;(",
        $q-&gt;checkbox(
                -name =&gt; "not_folders",
                -checked =&gt; $Not,
                -override =&gt; 1,
                -value =&gt; "yes",
                -label =&gt; "not"
        ),
        ") in &lt;b&gt;folders&lt;/b&gt; ",
        $q-&gt;checkbox_group(
             -name=&gt;'srch_folder',
             -values=&gt;\@folder_order,
             -default=&gt;\@srch_folder,
             -labels=&gt;\%folder_lbls_with_counts,
             -override =&gt; 1,
        ),
    ;


    if ( !$simple ) {
        push @html, "&lt;br/&gt;constrain by &lt;b&gt;content&lt;/b&gt;: "
              .  $q-&gt;textfield(
                        -name =&gt; "srch_msgtxt",
                        -size =&gt; 30 )
              .  "&lt;br /&gt;and/or by &lt;b&gt;user&lt;/b&gt; "
              .  $q-&gt;textfield(
                        -name =&gt; "srch_author_user",
                        -size =&gt; 10 )
              .  $q-&gt;submit( "sexisgood", "constrain" )
        ;
    } elsif ($q-&gt;param('srch_msgtxt') || $q-&gt;param('srch_author_user')) {

        push @html, "&lt;br/&gt;Constrained by ";

        push @html, "&lt;b&gt;content&lt;/b&gt;: "
              . "&lt;i&gt;".$q-&gt;param('srch_msgtxt')."&lt;/i&gt;"
              . $q-&gt;hidden('srch_msgtxt',$q-&gt;param('srch_msgtxt'))
            if $q-&gt;param('srch_msgtxt');

        push @html, "&lt;br&gt;and by"
            if $q-&gt;param('srch_msgtxt')
            &amp;&amp; $q-&gt;param('srch_author_user');

        push @html, "&lt;b&gt;user&lt;/b&gt; "
              . "&lt;i&gt;".$q-&gt;param('srch_author_user')."&lt;/i&gt;"
              . $q-&gt;hidden('srch_author_user',$q-&gt;param('srch_author_user'))
            if $q-&gt;param('srch_author_user');
        #push @html, "&lt;br/&gt;"
        #    . $self_link-&gt;("Clear Constraint");
    }

    if ( $simple ) {
        push @html,"&lt;br /&gt;", $q-&gt;submit( "sexisgood", "change" );
    }
    $do_recipient-&gt;();
    push @html, "&lt;/form&gt;&lt;/p&gt;",htmlcode("openform"),
        @srch_folder ? $q-&gt;hidden('srch_folder',@srch_folder) : (),
        $q-&gt;hidden( 'srch_recip_type', grep { $srch_type{$_} }
                   keys %srch_type ),
        $Not ? $q-&gt;hidden('not_folders',1) : (),
        (map { $q-&gt;param($_) ? $q-&gt;hidden($_,$q-&gt;param($_)) : () }
        qw( srch_msgtxt srch_author_user  )),
        "&lt;hr /&gt;";
};

=for uedit
sub do_totals{}

=cut


my $do_totals=sub {
    if( $count &lt; $total ) {
        my $extra= $total - $count - $offset;
        $extra= 0  if  $extra &lt; 0;
        push @html, qq[&lt;tr&gt;&lt;td&gt;&lt;/td&gt;\n]
              .  qq[&lt;td&gt;&lt;center&gt;Plus $extra earlier]
              .  qq[ (of &lt;b&gt;$total&lt;/b&gt;) ]
              .  qq[messages not shown.]
              .  qq[&lt;/center&gt;&lt;/td&gt;\n]
              .  qq[&lt;td colspan='3'&gt;&lt;/td&gt;&lt;/tr&gt;\n];
    }
};

=for uedit
sub do_skip_and_max{}

=cut

my $fits= 1;   # does the entire inbox fit on the page
my $do_skip_and_max=sub {

    if( 0 &lt; $offset ||  $count &lt; $total ) {
        $fits= 0;
        push @html, qq[&lt;tr&gt;&lt;td&gt;&lt;/td&gt;\n]
              .  qq[&lt;td colspan='4'&gt;];
        push @html, $q-&gt;submit(
                    "inboxskip".($offset+$length),
                    "Earlier" )
            if  $offset+$count &lt; $total;
        push @html, " Show " . $q-&gt;textfield(
                    -name =&gt; "inboxmaxmsgs",
                    -default =&gt; $length,
                    -override =&gt; 1,
                    -size =&gt; 4 );
        push @html, $q-&gt;checkbox(
                    -name =&gt; "set_inboxmaxmsgs",
                    -checked =&gt; 0,
                    -override =&gt; 1,
                    -value =&gt; "yes",
                    -label =&gt; "always." )
            if  $recvId == getId($USER);
        push @html, " Skip " . $q-&gt;textfield(
                    -name =&gt; "inboxskipmsgs",
                    -default =&gt; $offset,
                    -override =&gt; 1,
                    -size =&gt; 4 );
        push @html, $q-&gt;submit( "inboxskip-1", "Later" )
              .  qq[&lt;/td&gt;\n&lt;td&gt;\n]
              .  $q-&gt;submit( "inboxskip0", "Latest" )
            if  0 &lt; $offset;
        push @html, qq[&lt;/td&gt;&lt;/tr&gt;\n];
    }
    if(  $fits  ) {
        push @html, qq[&lt;tr&gt;&lt;td&gt;&lt;/td&gt;]
              .  qq[&lt;td colspan='4'&gt;Max messages to show:\n]
              .  $q-&gt;textfield(
                    -name =&gt; "inboxmaxmsgs",
                    -default =&gt; $length,
                    -override =&gt; 1,
                    -size =&gt; 4 );
        push @html, $q-&gt;checkbox(
                    -name =&gt; "set_inboxmaxmsgs",
                    -checked =&gt; 0,
                    -override =&gt; 1,
                    -value =&gt; "yes",
                    -label =&gt; "Use this value in future sessions" )
            if  $recvId == getId($USER);
        push @html, "\n". $q-&gt;submit( "sexisgood", "Set" );
        push @html, qq[&lt;/td&gt;&lt;/tr&gt;\n];
    }
};

=for uedit
sub do_messages{}

=cut


my $do_messages=sub {
    push @html, "&lt;tr&gt;"
          .  join("\n",map { /^&lt;/ ? $_ : "&lt;th&gt;$_&lt;/th&gt;" }
               "Reply to",
               !$del_only ? "&lt;th colspan=2&gt;Message&lt;/th&gt;" : "Message",
               $del_only ? ("Folder","(Un)&lt;br/&gt;Del") : "Folder",
               "Sel", )
          .  "&lt;/tr&gt;";

    my $approvedtags = getVars(
        getNode( 'approved chatter tags', 'setting' ) );
    for my $MSG (  @msgs  ) {
        my $we_sent= $MSG-&gt;{for_user} != $recvId;

        my $title = htmlcode(
            'parseTimeInString',
            $MSG-&gt;{tstamp}
        );
        my $msgtext= do {
            local $AUTHOR= getNodeById( $MSG-&gt;{author_user}, 'light' );
            # as in [add_public_chatter]
            # double screen?
            htmlScreen(
                htmlcode( 'parselinksinchatter','', $MSG-&gt;{msgtext}, 0 ),
                $approvedtags
            );
        };

        my ($fld_name,$fld_id,$msg_uid);
        if ( $we_sent ) {
            $msg_uid=$MSG-&gt;{for_user};
            $fld_id= $MSG-&gt;{folder};
            $fld_name= "move";
        } else {
            $msg_uid=$MSG-&gt;{author_user};
            $fld_id= $MSG-&gt;{archive};
            $fld_name= "archive";
        }
        $fld_id= -1 if $fld_id == -2;
        my $msg_id= $MSG-&gt;{message_id};
        my $opmsgcmd=join("_",$fld_name,$msg_id,$fld_id);

        push @html, qq[&lt;tr class="inbox_message"&gt;&lt;td valign="top"&gt;&lt;center&gt;]
          . qq[&lt;input type="radio" name="replyto" value="]
          . $q-&gt;escapeHTML( $msg_id ) . qq["&gt;]
          . qq[&lt;/center&gt;&lt;/td&gt;\n]
          . qq[&lt;td valign="top"]
          . (!$del_only ? ' colspan="2"' : "")
          . qq[&gt;&lt;span title="]
          . $q-&gt;escapeHTML( $title )
          . qq["&gt;&lt;i&gt;]
          . ( $we_sent ? "told " : "" )
          . linkNode(
                $msg_uid,
                undef, # look up title
                # some browsers ignore span title (?)
                # so put another here:
                { -title =&gt; $title },
                { trusted =&gt; 'yes' },
            )
          . ( $we_sent ? "" : " says" )
          . qq[&lt;/i&gt;&lt;/span&gt;\n]
          . $msgtext
          . qq[&lt;!-- --&gt;&lt;/td&gt;\n]
          . ( $del_only ?
                qq[&lt;td valign="top" align='center'&gt;&lt;small&gt;]
              . qq[$folder_lbls{$fld_id}&lt;/small&gt;&lt;/td&gt;]
            :   ""
            )
          . qq[&lt;td valign="top"&gt;&lt;center&gt;]
          . (!$del_only
              ? $q-&gt;popup_menu(
                    -name=&gt; $opmsgcmd,
                    -values =&gt; \@folder_order,
                    -default =&gt; $fld_id ,
                    -labels =&gt; \%folder_lbls,
                )
              : $q-&gt;checkbox(
                    -name =&gt; $opmsgcmd,
                    -checked =&gt; 0,
                    -override =&gt; 1,
                    -value =&gt; $fld_id==-1 ? 0 : -1 ,
                    -label =&gt; $fld_id==-1
                        ? "&lt;br /&gt;&lt;sup&gt;&lt;b&gt;un&lt;/b&gt;&lt;/sup&gt;"
                        : "",
                )
            )
          . qq[&lt;/center&gt;&lt;/td&gt;&lt;td  valign="top"&gt;&lt;center&gt;]
          . $q-&gt;checkbox(
                -name =&gt; "sel_$msg_id",
                -checked =&gt; 0,
                -override =&gt; 1,
                -value =&gt; "yes",
                -label =&gt; "",
            )
          . qq[&lt;/center&gt;&lt;/td&gt;&lt;/tr&gt;\n];
    }

};

=for uedit
sub do_reply_fields{}

=cut


my $do_reply_fields=sub {
    #push @html, qq[&lt;tr&gt;&lt;td colspan='5'&gt;&lt;table&gt;];
    push @html, qq[&lt;tr&gt;&lt;td&gt;&lt;/td&gt;&lt;td colspan='3'&gt;]
          .  $q-&gt;param("sentmessage")
          .  qq[&lt;/td&gt;\n]
          .  qq[&lt;td&gt;&lt;/td&gt;&lt;/tr&gt;\n]
        if  $q-&gt;param("sentmessage");
    push @html, qq[&lt;tr&gt;]
          .  qq[&lt;td valign="center"&gt;]
          .  $q-&gt;submit( "sexisgood", "Send" )
          .  qq[&lt;/td&gt;]
          .  qq[&lt;td colspan='4'&gt;]
          .  $q-&gt;textfield(
                -name=&gt;'replytotext',
                -size=&gt;60,
                -maxlength=&gt;255 )
          .  qq[&lt;/td&gt;]
          .  qq[&lt;/tr&gt;\n]
          .  qq[&lt;tr&gt;&lt;td&gt;&lt;center&gt;&lt;b&gt;To&amp;nbsp;User:&lt;/b&gt;]
          .  qq[&lt;input type="radio" name="replyto" value="user"&gt;&lt;/center&gt;&lt;/td&gt;]
          .  qq[&lt;td  valign='center' colspan='4'&gt;]
          .  $q-&gt;textfield(
                -name=&gt;'sendto',
                -size=&gt;20,
                -maxlength=&gt;255 )
          .  qq[ or &lt;input type="radio" name="replyto" value="0" checked="checked"&gt;]
          .  qq[ &lt;b&gt;Don't&amp;nbsp;Send&amp;nbsp;At&amp;nbsp;All&lt;/b&gt;&lt;/td&gt;\n]
          .  qq[&lt;/tr&gt;]
          .  (!$total ? '' : "&lt;tr&gt;&lt;td colspan='5' align='right' valign='bottom'&gt;"
          .  $q-&gt;submit('sexisgood','Move')
          .  " ("
          .  $q-&gt;checkbox(
               -name=&gt;"bulk_selected",
               -value=&gt;'except',
               -checked=&gt;0,
               -force=&gt;1,
               -label=&gt;'all but')
          .  ") selected to "
          .  $q-&gt;popup_menu(
               -name=&gt;"bulk_update_${minid}_${maxid}",
               -values=&gt;[ @folder_order,-2 ],
               -default =&gt; -2,
               -force=&gt;1,
               -labels=&gt; {
                           -2 =&gt; '(nowhere)',
                           %folder_lbls,
                         },)
             )
          .  qq[&lt;/td&gt;]
          .  qq(&lt;/tr&gt;\n)
    ;
    push @html, qq(&lt;tr&gt;&lt;td&gt;&lt;/td&gt;)
          . qq(&lt;td colspan=3&gt;)
          . qq(To help someone by giving Writeup Formatting Tips, )
          . qq(link to it by including &lt;tt&gt;[id://17558]&lt;/tt&gt; in your message.)
          . qq(&lt;/td&gt;)
          . qq(&lt;td&gt;&lt;/td&gt;&lt;/tr&gt;)
        if $q-&gt;param('replytotext') =~ m|^Re \[id://|;

    if(  0 &lt; $offset  ) {
        push @html, qq[&lt;tr&gt;&lt;td&gt;&lt;/td&gt;\n]
              .  qq[&lt;td colspan='3'&gt;&lt;center&gt;Most recent $offset]
              .  qq[ messages not displayed]
              .  qq[&lt;/center&gt;&lt;/td&gt;]
              .  qq[&lt;td&gt;&lt;/td&gt;&lt;/tr&gt;\n];
    }
};



push @html,
  qq{&lt;p align="right"&gt;&lt;a href="/?node_id=419625"&gt;Help for this page&lt;/a&gt;&lt;/p&gt;\n};

$do_search-&gt;();
my $border= $DEBUG ? 1 : 0;
push @html,
   '&lt;input type="hidden" name="op" value="message" /&gt;',
   "&lt;table border='$border' width='100%'&gt;\n";
$do_reply_fields-&gt;();
$do_messages-&gt;();
$do_totals-&gt;();
$do_skip_and_max-&gt;();
push @html, "&lt;/table&gt;\n";
$do_recipient-&gt;(1);

return join("",@html,'&lt;/form&gt;')
;
</live_code>
<reason>Preserver msg timestamps</reason>
<field>code</field>
</record>
<record><htmlcode_id>450379</htmlcode_id>
<patch_code>   my( $node, $field, $readmore, $id )= @_;

   my $N= getNodeById($node);
   my $text= $N-&gt;{$field};

   return htmlcode ( 'ParseLinksInContent', '', $text, 
       id =&gt; $id,
       readmore_remove =&gt; !($readmore &amp;&amp;  $id =~ /\d/  &amp;&amp;  $id !~ /\D/
                           &amp;&amp;  ! $VARS-&gt;{readmoreoff}),
   ) unless $q-&gt;param('oldparselinks');



   $HTMLVARS{buybook} ||= $text =~ /(book)|(reference)/i;

   $text =~ s[(&lt;code&gt;(.*?)&lt;/code&gt;)]{
      my $whole= $1;
      my $code= $2;
      $HTMLVARS{code} .= $whole;
      htmlcode( 'wrapcode','', $code );
   }iges;

   $text=htmlcode('handle_readmore','',$id,$text,0,
             !($readmore  &amp;&amp;  $id =~ /\d/  &amp;&amp;  $id !~ /\D/)
   );


   htmlcode( "perlfuncadder" );

   $text =~ s/\[(.*?)\]/handleLinks($1,getId($NODE))/egs;

   my $APPROVED= getVars( getNode('approved html tags','setting') );
   $text= htmlScreen( $text, $APPROVED );

   return $text;
</patch_code>
<applied>2005-04-23 07:27:14</applied>
<htmlcode_id>53586</htmlcode_id>
<live_code>'parseLinksInNodeField has been deprecated'</live_code>
<reason>test parselinksincontent</reason>
<field>code</field>
</record>
<record><htmlcode_id>556073</htmlcode_id>
<patch_code>my ( $type, $node, $user )= @_;
$node ||= $NODE;
$user ||= $USER;
getRef( $node );
getRef( $user );

$type= substr( lc( $type || "-" ), 0, 1 );

return 0 unless $type eq "r" or $type eq "w";
$type= $type eq 'r' ? 'readers' : 'writers';

use Everything::Experience;

my $userlevel= getLevel( $user );    # can`t accessrule
my $uid= getId( $user );

return 1 if $uid == $node-&gt;{author_user};

my $field= $node-&gt;{$type};

return 0
  if $type eq "writers"
  &amp;&amp; $uid == $HTMLVARS{guest_user};

if ( $field =~ /^lvl_(\d+)/ ) {
    return 0 if $userlevel &lt; $1;
} elsif ( $field =~ /^ug_(\d+)/ ) {
    my $UG= getNodeById( $1 );
    return $DB-&gt;isApproved( $user, $UG );
}

return 1;</patch_code>
<applied>2006-06-18 07:17:56</applied>
<htmlcode_id>73992</htmlcode_id>
<live_code>my ( $type, $node, $user )= @_;
$node ||= $NODE;
$user ||= $USER;
getRef( $node );
getRef( $user );

$type= substr( lc( $type || "-" ), 0, 1 );

return 0 unless $type eq "r" or $type eq "w";
$type= $type eq 'r' ? 'readers' : 'writers';

my $uid= getId( $user );

return 1 if $uid == $node-&gt;{author_user};

my $field= $node-&gt;{$type};

return 0
  if $type eq "writers"
  &amp;&amp; $uid == $HTMLVARS{guest_user};

if ( $field =~ /^lvl_(\d+)/ ) {
  my $lvl = $1;
  require Everything::Experience;
  return 0 if Everything::Experience::getLevel( $user ) &lt; $lvl;
} elsif ( $field =~ /^ug_(\d+)/ ) {
  my $UG= getNodeById( $1 );
  return $DB-&gt;isApproved( $user, $UG );
}

return 1;</live_code>
<reason>parameterize NODE, make interface more flexible</reason>
<field>code</field>
</record>
<record><htmlcode_id>233040</htmlcode_id>
<patch_code>my $str = $q-&gt;span(
  join ' | ',
    linkNode(131, 'Front Page'),
    map { linkNodeTitle($_) }
      'Seekers of Perl Wisdom|Perl&amp;nbsp;Questions',
      'Meditations',
      'Perl Monks Discussion|Site&amp;nbsp;Discussion',
      'Tutorials',
      'Snippets Section|Snippets',
      'Cool Uses for Perl|Cool&amp;nbsp;Uses&amp;nbsp;For&amp;nbsp;Perl',
      'Code Catacombs|Code',
      'Obfuscated Code|Obfuscation',
      'Categorized Questions and Answers|Q&amp;nbsp;and&amp;nbsp;A',
      'Craft',
      'Perl News|News',
      'Reviews',
      'Super Search|Search',
);

return $str;</patch_code>
<applied>2003-05-02 16:26:12</applied>
<htmlcode_id>233038</htmlcode_id>
<live_code>$q-&gt;span(
  "\n        " .
  join " |\n        ",
    linkNode(131, 'Front Page'),
    map { linkNodeTitle($_) }
      'Seekers of Perl Wisdom|Perl&amp;nbsp;Questions',
      'Meditations',
      'Perl Monks Discussion|Site&amp;nbsp;Discussion',
      'Tutorials',
      'Snippets Section|Snippets',
      'Cool Uses for Perl|Cool&amp;nbsp;Uses&amp;nbsp;For&amp;nbsp;Perl',
      'Code Catacombs|Code',
      'Obfuscated Code|Obfuscation',
      'Categorized Questions and Answers|Q&amp;nbsp;and&amp;nbsp;A',
      'Craft',
      'Perl News|News',
      'Reviews',
      'Super Search|Search',
);</live_code>
<reason>Created</reason>
<field>code</field>
</record>
<record><htmlcode_id>245096</htmlcode_id>
<patch_code>my ( $nodelet, $nodelets ) = @_;
# need to remove a comma along with a nodelet
# in order to keep blank fields out of user settings
$nodelets =~ s/\b,$nodelet\b//g;
return $nodelets;</patch_code>
<applied>2003-03-21 22:41:06</applied>
<htmlcode_id>233767</htmlcode_id>
<live_code>my ( $nodelet, $nodelets ) = @_;
# need to remove a comma along with a nodelet
# in order to keep blank fields out of user settings
$nodelets =~ s/\b$nodelet\b//g;
$nodelets =~ s/,,/,/g;
return $nodelets;</live_code>
<reason>nodelets are a comma separated field.</reason>
<field>code</field>
</record>
<record><htmlcode_id>489165</htmlcode_id>
<patch_code>   my( $rowid )= @_;

   if ( $HTMLVARS{guest_user} == getId($USER) ) {
      return "No edit viewing for [Anonymous Monk], please login to view this";
   }

   my $N;
   {
      my $sth = $DB-&gt;sqlSelectMany(
         "*",
         "edithistory",
         "rowid = $rowid",
      );
      $N = $sth-&gt;fetchrow_hashref();
      $sth-&gt;finish();
   }

   if( $N-&gt;{private}  &amp;&amp;
       ! Everything::isApproved( $USER, getNode('editors','usergroup') ) ) {
      return 'This edit is marked private, sorry bud!';
   }

   my $html = '';

   $html .= qq[\n&lt;p&gt;On ]
      . htmlcode( 'parseTimeInString','', $N-&gt;{edittime} )
      . qq[, ]
      . linkNodeTitle( 'janitors|janitor' )
      . qq[ ]
      . linkNode( $N-&gt;{editor_user} )
      . qq[ swept up in the ]
      . $N-&gt;{fieldname}
      . qq[ of ]
      . linkNode( $N-&gt;{edithistory_id} )
      . qq[.  You can see the ]
      . linkNode( $N-&gt;{edithistory_id}, "list of other changes", {
            displaytype=&gt;'edithistory',
            ($q-&gt;param('limit') ? ( limit =&gt; 0+$q-&gt;param('limit')) : ()),
        } )
      . qq[ to that node.\n&lt;/p&gt;&lt;p&gt;Changes:&lt;/p&gt;];

   require Everything::Diff;
   Everything::Diff-&gt;import(qw( showDiff ));

   my $diff= showDiff( $N-&gt;{starttext}, $N-&gt;{endtext} );

   $diff =~ s#\n#&lt;br /&gt;\n#g;
   $diff =~ s#  # &amp;nbsp;#g;
   $html .= qq[&lt;p&gt;\n]
      . $diff
      . qq[\n&lt;/p&gt;\n];

   return $html;

</patch_code>
<applied>2005-09-05 04:19:22</applied>
<htmlcode_id>244651</htmlcode_id>
<live_code>   my( $rowid )= @_;

   if ( $HTMLVARS{guest_user} == getId($USER) ) {
      return "No edit viewing for [Anonymous Monk], please login to view this";
   }

   my $N;
   {
      my $sth = $DB-&gt;sqlSelectMany(
         "*",
         "edithistory",
         "rowid = $rowid",
      );
      $N = $sth-&gt;fetchrow_hashref();
      $sth-&gt;finish();
   }

   if( $N-&gt;{private}  &amp;&amp;
       ! Everything::isApproved( $USER, getNode('editors','usergroup') ) ) {
      return 'This edit is marked private, sorry bud!';
   }

   my $html = '';

   $html .= qq[\n&lt;p&gt;On ]
      . htmlcode( 'parseTimeInString','', $N-&gt;{edittime} )
      . qq[, ]
      . linkNode( $N-&gt;{editor_user} )
      . qq[ edited the ']
      . $N-&gt;{fieldname}
      . qq[' field of ]
      . linkNode( $N-&gt;{edithistory_id} )
      . qq[.  You can see the ]
      . linkNode( $N-&gt;{edithistory_id}, "history of (non-owner) edits", {
            displaytype=&gt;'edithistory',
            ($q-&gt;param('limit') ? ( limit =&gt; 0+$q-&gt;param('limit')) : ()),
        } )
      . qq[ to that node.\n&lt;/p&gt;&lt;p&gt;Changes:&lt;/p&gt;];

   require Everything::Diff;
   Everything::Diff-&gt;import(qw( showDiff ));

   my $diff= showDiff( $N-&gt;{starttext}, $N-&gt;{endtext} );

   $diff =~ s#\n#&lt;br /&gt;\n#g;
   $diff =~ s#  # &amp;nbsp;#g;
   $html .= qq[&lt;p&gt;\n]
      . $diff
      . qq[\n&lt;/p&gt;\n];

   return $html;

</live_code>
<reason>preserve limit param</reason>
<field>code</field>
</record>
<record><htmlcode_id>297757</htmlcode_id>
<patch_code>if($query-&gt;param('node')){
   my $dupe=0;
   my $type=$query-&gt;param('type');
   my $title=$query-&gt;param('node');
   my @N=getNodeWhere({author_user=&gt;getId($USER),title=&gt;$query-&gt;param('node')},$query-&gt;param('type'));
   foreach(@N){
      $dupe=1 and last if($$_{doctext} eq $query-&gt;param($type."_doctext"));
   }
   if($dupe){
       my $N=getNode('Duplicate Post Warning','superdoc');
       $query-&gt;param('node','');
       $query-&gt;param('node_id',getId($N));
   }  else{
      $query-&gt;param('op','new');
      Everything::HTML::execOpCode();
   }
} else{
   my $N=getNode('You need a title, sucka!','superdoc');
   $query-&gt;param('node_id',getId($N));
   $query-&gt;param('node','');
}</patch_code>
<applied>2003-10-08 18:15:29</applied>
<htmlcode_id>297756</htmlcode_id>
<live_code>my $goto= sub {
    my( $title, $type )= @_;
    my $N= getNode( $title, $type );
    $q-&gt;param( 'node', '' );
    $q-&gt;param( 'node_id', getId($N) );
};

my $type=    $q-&gt;param('type');
my $title=   $q-&gt;param('node');

return $goto-&gt;( 'You need a title, sucka!', 'superdoc' )
    if  ! $title;

my @N= getNodeWhere(
    {
        author_user =&gt; getId($USER),
        title       =&gt; $title,
    },
    $type,
);
for my $N (  @N  ) {
    if(  $N-&gt;{doctext} eq $q-&gt;param( $type."_doctext" )  ) {
        return $goto-&gt;( 'Duplicate Post Warning', 'superdoc' );
    }
}

$q-&gt;param( 'op', 'new' );
Everything::HTML::execOpCode();
</live_code>
<reason>create: copy of [submit]</reason>
<field>code</field>
</record>
<record><htmlcode_id>732609</htmlcode_id>
<patch_code># This returns the basics to put inside a head element for 
# a normal-looking page.  Code is taken from [basichead], 
# for use in [basichead], and the various pages that make up 
# [fullpage chat].
# This does not include a title tag, users should do that 
# themselves.
# No arguments.

my $absprefix = ( $ENV{SCRIPT_NAME} =~ m!^(/~\w+)! ? $1 : '' );
my $icon = qq(&lt;link rel="icon" href="$absprefix/favicon.ico" /&gt;);
$_ = qq(&lt;link rel="stylesheet" href="?node_id=%d" type="text/css" /&gt;);
my( $theme, $common ) = ('','');
my $theme_comment = "&lt;!-- Theme $$VARS{preferred_theme}: $THEME-&gt;{description} --&gt;";
if ( $THEME-&gt;{CSS} ) {
  $theme = sprintf $_, $THEME-&gt;{CSS};
  $common = qq(&lt;link rel="stylesheet" href="$absprefix/css/common.css" type="text/css" /&gt;);
}
my $css = $VARS-&gt;{css_link};
if ( $css ) {
  $css =~ s/\n//g;
  $css =~ s/&lt;/&amp;lt;/g;
  $css =~ s/&gt;/&amp;gt;/g;
  $css =~ s/'/&amp;quot;/g;
  $css = qq(&lt;link rel="stylesheet" href='$css' type="text/css" /&gt;);
}
$css ||= '&lt;!-- No CSS Link in User Settings --&gt;';

my $style = $VARS-&gt;{style};
if ( $style ) {
  chomp $style;
  my $ind = ' ' x 6;
  $style  =~ s/&lt;/&amp;lt;/g;
  $style  =~ s/\n/\n$ind/g;
  $style  = &lt;&lt;"END";
&lt;style type="text/css"&gt;
      $style
    &lt;/style&gt;
END
}
$style ||= '&lt;!-- No CSS Data in User Settings --&gt;';

return "
    $theme_comment
    $common
    $theme
    $css
    $style
    $icon
";</patch_code>
<applied>2008-12-25 15:22:32</applied>
<htmlcode_id>320275</htmlcode_id>
<live_code># This returns the basics to put inside a head element for 
# a normal-looking page.  Code is taken from [basichead], 
# for use in [basichead], and the various pages that make up 
# [fullpage chat].
# This does not include a title tag, users should do that 
# themselves.
# No arguments.

my $absprefix = ( $ENV{SCRIPT_NAME} =~ m!^(/~\w+)! ? $1 : '' );
my $icon = qq(&lt;link rel="icon" href="$absprefix/favicon.ico" /&gt;);
$_ = qq(&lt;link rel="stylesheet" href="?node_id=%d" type="text/css" /&gt;);
my( $theme, $common ) = ('','');
my $theme_comment = "&lt;!-- Theme $$VARS{preferred_theme}: $THEME-&gt;{description} --&gt;";
if ( $THEME-&gt;{CSS} ) {
  $theme = sprintf $_, $THEME-&gt;{CSS};
  $common = qq(&lt;link rel="stylesheet" href="$absprefix/css/common.css" type="text/css" /&gt;);
}
my $css = $VARS-&gt;{css_link};
if ( $css ) {
  $css =~ s/\n//g;
  $css =~ s/&lt;/&amp;lt;/g;
  $css =~ s/&gt;/&amp;gt;/g;
  $css =~ s/'/&amp;quot;/g;
  $css = qq(&lt;link rel="stylesheet" href='$css' type="text/css" /&gt;);
}
$css ||= '&lt;!-- No CSS Link in User Settings --&gt;';

my $style = $VARS-&gt;{style};
if ( $style ) {
  chomp $style;
  my $ind = ' ' x 6;
  $style  =~ s/&lt;/&amp;lt;/g;
  $style  =~ s/\n/\n$ind/g;
  $style  = &lt;&lt;"END";
&lt;style type="text/css"&gt;
$style
&lt;/style&gt;
END
}
$style ||= '&lt;!-- No CSS Data in User Settings --&gt;';

if ( 'print' eq ($q-&gt;param('displaytype') || '') ) {
  $theme = $style = '';
  $common = qq(&lt;link rel="stylesheet" type="text/css" href=").(
    $VARS-&gt;{printcss} || urlGen({ node =&gt; 'print displaytype stylesheet' }, -1)
  ).qq(" /&gt;\n);
}

my $noindex =
  'document' eq $NODE-&gt;{type}{title} 
    ? '&lt;meta name="robots" content="noindex"&gt;'
    : 'Super Search' eq $NODE-&gt;{title}
    ? '&lt;meta name="robots" content="noindex,nofollow"&gt;' : '';

return "
    $theme_comment
    $common
    $theme
    $css
    $style
    $icon
    $noindex
";</live_code>
<reason>modify absolute paths when testing</reason>
<field>code</field>
</record>
<record><htmlcode_id>781981</htmlcode_id>
<patch_code># get_picked_nodes htmlcode (tested with nodelets/other users)
# -- demerphq
use strict;
use warnings;
require XML::Fling;
require List::Util;
require POSIX;
require Everything::Experience;

my $start_time=time;
# my ($NODE,$USER,$THEME,$DB,$q);  # for testing under perl -c and without PM

my $DEBUG= isGod($USER);

#---------------------------------------------------------
# Table used by this code:
# CREATE TABLE picked_nodes (
#    pick_id  int(11)    NOT NULL,
#    pickname char(240)  NOT NULL,
#    auth_id  int(11)    NOT NULL,
#    authname char(240)  NOT NULL,
#    rep      int(11)    NOT NULL,
#    days     int(3)     NOT NULL,
#    picktype int(1)     NOT NULL,  /* x0 - Best x1 Selected | 0x - DESC 1x ASC */
#    seq      int(3)     NOT NULL,
#    ulastupdate int(11) NOT NULL,
#    UNIQUE INDEX idx_pick (days,picktype,pick_id),
#    UNIQUE INDEX uidx_main (days,picktype,seq)
# ) TYPE=MyISAM PACK_KEYS=1
#
# Picktype: 0 = Best Nodes
#           1 = Selected Best Nodes
#           2 = Worst Nodes
#          *3 = Selected Worst Nodes
#           4 = Users In descending order of XP
#          *5 = Selected Users In descending order of XP
#          *6 = Users in Ascending order of XP
#          *7 = Selected Users In Ascending order of XP
#
# Lines marked * are hypothetical as they arent used.
# NOTE that Picktype + 64  is for temporary creation
#      that Picktype + 128 is for locking Picktype updates.
#
# Picktypes are update by first obtaining a lock (Days/Picktype+128/Seq=0)
# then by creating the new result set with Days/Picktype+64
# then by deleting the old set (Days/Picktype)
# then by updating the (days/picktype+64) to (days/picktype)
# then by deleting the lock record (days/picktype+128)
# This SHOULD resolve the race condition in get picked nodes.
#
#---------------------------------------------------------
# Cache refresh occurs when there are no recs within the selected $args{days} or if the
# data is too old.  This means that if a particular $args{days} isn't currently stored
# then on first fetch it will be created. A random factor is added to the
# $cache_time to keep multiple $args{days} types from refreshing simultaneously.
#---------------------------------------------------------
# Note: Using XML::Fling for the html as well is just for convenience and for simplicity.
#     : I agree it does look a bit strange. :-)
#---------------------------------------------------------
# Initialization


my $dbh=$DB-&gt;getDatabaseHandle();
my %args=(
    #default
    type   =&gt; "Select", # Select | Best/Worst/NotSelect etc
    order  =&gt; "DESC",   # DESC | ASC only
    days   =&gt; 30,       # 0 = All time, selected only
    sample =&gt; 500,
    choose =&gt; 10,
    max_age=&gt; 24,
    style  =&gt; 'html',   # xml -&gt; xml, nodelet -&gt; simple html, else full html

    time_text=&gt;undef,
    title    =&gt;undef,
    show     =&gt;undef,

    past     =&gt;undef,   # only for when doing the user list.

    cols     =&gt;'NAR',   # html only, chooses columns.

    @_
);

my $IS_USERS = $args{type} eq 'Users';

my $cache_time;
my $where_time;

if ($IS_USERS) {
   $args{past}||=3;
   $args{sample}=$args{choose};
   $cache_time = $args{max_age} * 60;
   $where_time= $args{past} * 60;
   $args{days}=$args{past};
   $args{title}="Users present in the last $args{past} minutes";
   $args{cols}='AR';
} else {
    #Convert to seconds.
    $cache_time=($args{max_age}*=3600);
    $where_time=$args{days};
    my $order_text = $args{order} eq 'DESC'   ? "Best" : "Worst";

    return "&lt;h1&gt;error: We don't do $order_text Nodes of All Time anymore!&lt;/h1&gt;"
       if $args{type} ne 'Select' and !$args{days};

    $args{time_text}="The Past $args{days} days"
        unless defined $args{time_text};
    $args{title}=($args{type} eq 'Select' ? "Selected $order_text" : $order_text).
                 " Nodes of $args{time_text}"
                        unless defined $args{title};
}

my $force_refresh=isGod($USER) &amp;&amp; $q-&gt;param('force_refresh');

$args{show}=$args{choose} unless defined $args{show};
my $type_mod= ( $args{order} eq 'DESC'  ? 0 : 2 );
$type_mod+=4 if $IS_USERS;
my $picktype= ( $args{type} ne 'Select' ? 0 : 1 ) + $type_mod;

my $time=time;


# +- 15 minutes float to keep things staggered a bit.
if ($cache_time&gt;900) {
    $cache_time+=int(rand(1800)-900)
} elsif ($cache_time&gt;=60) {
    my $float=$cache_time/4;
    $cache_time+=int(rand($float*2)-$float);
}

my $end_of_the_world=0;
my $redo_count=0;

ALL: {

my $rows;         # the data we will ultimately print out
                  # and AoA ref structure which could be
                  # built in several ways.

my $update=0;      # must update?
my $last_update=0; # time


#---------------------------------------------------------
# FETCH

FETCH:{
    my $geth=$dbh-&gt;prepare_cached("
        SELECT   pick_id,
                 pickname,
                 auth_id,
                 authname,
                 rep,
                 seq,
                 ulastupdate
        FROM     picked_nodes
        WHERE    picktype = ?
        AND      days     = ?
        ORDER BY days   ASC,
                 seq    ASC
    ");
    $geth-&gt;execute($picktype,$args{days})
        or die "Can't execute statement: $DBI::errstr";

    $rows=$geth-&gt;fetchall_arrayref();

    $last_update=@$rows ? $rows-&gt;[0][-1] : $time;

    if ($force_refresh or !@$rows or $time-$last_update&gt;$cache_time) {
       # this insert acts a lock. if it succeeds then we are allowed to update
       # otherwise we should just use whatever we got.
       $DEBUG &amp;&amp; printLog("gpn: trying to get lock ($$) ".
                join (',',$force_refresh,!@$rows,$time-$last_update&gt;$cache_time,
                     $NODE-&gt;{node_id},$NODE-&gt;{title},$args{days},$picktype+128));

      local $dbh-&gt;{RaiseError};
      local $dbh-&gt;{PrintError};

       my $res=$dbh-&gt;do(qq[
           insert into picked_nodes
                   ( pick_id, pickname, auth_id,  authname,
                     rep,     days,     picktype, seq,       ulastupdate)
            values ( ?      , ?       , 113    , 'rootlock',
                     0,       ?       , ?      , 0         , unix_timestamp(now()))
       ],{},$NODE-&gt;{node_id},$NODE-&gt;{title},$args{days},$picktype+128);
       if ($res==1) {
          $update++;
          $DEBUG &amp;&amp; printLog("gpn: got lock! \$res=$res ($$)\n");
       } else {
           my $res=$dbh-&gt;do(qq[
               update picked_nodes set
                 ulastupdate=unix_timestamp(now()),
                 pick_id=?,
                 pickname=?
               where days=?
               and picktype=?
               and ulastupdate&lt;unix_timestamp(now())-600
           ],{},$NODE-&gt;{node_id},$NODE-&gt;{title},$args{days},$picktype+128);
           if ($res) {
              $DEBUG &amp;&amp; printLog("gpn: recovered bad lock! \$res=$res ($$)\n");
              $update++;
           } else {
              $DEBUG &amp;&amp; printLog("gpn: failed lock! \$res=$res ($$)\n");
           }
       }
    }
}

#---------------------------------------------------------
# Update
if ( $update ) {
    @$rows=(); # there might be stuff in here.

    my $seth=$dbh-&gt;prepare_cached(qq[
        INSERT INTO picked_nodes (
            pick_id,   pickname, auth_id,  authname,
            rep,       seq,      days,     picktype,
            ulastupdate
        ) VALUES (
            ?,         ?,        ?,        ?,
            ?,         ?,        ?,        ?,
            ?
        )
    ]);
    my $op=$args{order} eq 'DESC' ? '&lt;' : '&gt;=';

    my $delh=$dbh-&gt;prepare_cached(qq[
       DELETE FROM picked_nodes
             WHERE days     = ?
               AND picktype = ?
    ]);
    $delh-&gt;execute($args{days},$picktype+64);

    my $AND=$args{days} ? "AND ( ( n.ucreatetime + 86400 * ? ) &gt; unix_timestamp())"
                        : "";
    $AND.="AND (n.reputation &lt; 0)"
            if $args{order} eq 'ASC';

    my $limit = ($args{type} eq 'Select' ? $args{sample} : $args{choose});

    my $sel_query=qq[
       SELECT n.node_id     pick_id,
              n.title       pickname,
              a.node_id     auth_id,
              a.title       authname,
              n.reputation  rep
         FROM node a,
              node n
        WHERE a.node_id=n.author_user
         $AND
     ORDER BY n.reputation $args{order},
              n.node_id DESC
         LIMIT $limit
    ];
    if ($IS_USERS) {
        $sel_query=qq[
              SELECT node_id    pick_id,
                     title      pickname,
                     node_id    auth_id,
                     title      authname,
                     experience rep
                FROM node,
                     user
               WHERE node_id = user_id
                 AND (UNIX_TIMESTAMP(NOW()) - UNIX_TIMESTAMP(lasttime) &lt; ?)
            ORDER BY experience $args{order},
                     node_id ASC
              LIMIT  $limit
        ];
   }

    my $geth=$dbh-&gt;prepare($sel_query) or die "$sel_query\n $DBI::errstr";
    my @args=(
               ($where_time ? $where_time : ()),
    );
    $geth-&gt;execute(@args)
        or die "Can't execute statement [@args]: \n$sel_query\n$DBI::errstr";
    my ($best,$selected)=(0,0);
    my @pick;
    $last_update=$time;

    local $seth-&gt;{RaiseError};
    local $seth-&gt;{PrintError};

    while (my @row=$geth-&gt;fetchrow_array()) {

        # clean the names
        $row[$_]=$q-&gt;escapeHTML($row[$_])
            for 1,3;

        if ($args{type} ne 'Select') {
            unless ($seth-&gt;execute(@row, $best, $args{days},
                           $picktype+64, $time)) {
                 if ($end_of_the_world++ &lt;2) {
                    redo ALL;
                 } else {
                    return "&lt;p&gt;Internal problem occurred in get_picked_nodes"
                       ."&lt;br&gt;".$seth-&gt;errstr." &lt;/p&gt;\n" ;
                 }
            }
            push @$rows,\@row;
            push @row,$best++;
        } else {
            push @pick,\@row;
            push @row,$selected++;
        }

    }
    if ( $args{type} eq 'Select') {
        @pick=List::Util::shuffle(@pick);

        # throw away the rest of the deck
        splice @pick,$args{choose} if @pick&gt;$args{choose};

        # we can use the initial order returned by the db
        # because of the seq element
        @pick=sort { $a-&gt;[-1] &lt;=&gt; $b-&gt;[-1] } @pick;

        # and put it all back, renumbering it as we go
        foreach my $idx (0.. $#pick )
        {
          $pick[$idx][-1]=$idx;
          unless ($seth-&gt;execute(@{$pick[$idx]},$args{days},
                         $picktype+64, $time)) {
             if ($end_of_the_world++ &lt;2) {
                redo ALL;
             } else {
                return "&lt;p&gt;Internal problem occurred in get_picked_nodes"
                    ."&lt;br&gt;".$seth-&gt;errstr." &lt;/p&gt;\n" ;
             }
          }
        }
        @$rows=@pick
    }
    # first delete the old data set
    $delh-&gt;execute($args{days},$picktype);
    # then switch the new one over, this should be an atomic action
    $dbh-&gt;do(qq[update picked_nodes
                set picktype = ?
                where days = ?
                and picktype = ? ],
             {}, $picktype,$args{days},$picktype+64)
      or ($DEBUG &amp;&amp; printLog("gpn: Failed to restore nodes"));
    # then delete the lock record
    $delh-&gt;execute($args{days},$picktype+128);
}

#---------------------------------------------------------
# Render - from here on in, this is all non-db
#
# hypothetically this could be split here, and a pass through
# parameter in $args{} could direct to the correct rendering code.
#
# Do the start


# have nodereaper show up once in a while :-)
if ( $IS_USERS and rand(100)&lt;5) {
    my $nr=getNodeById($HTMLVARS{NodeReaperID});
    push @$rows,[$nr-&gt;{node_id},$nr-&gt;{title},
                $nr-&gt;{node_id},$nr-&gt;{title},
                $nr-&gt;{experience}
               ];
    @$rows=sort { $b-&gt;[4] &lt;=&gt; $a-&gt;[4] } @$rows;
    @$rows=reverse @$rows if $args{order} eq 'ASC'
}

splice @$rows,$args{show} if @$rows&gt;$args{show};
$args{title}=@$rows. " " . $args{title} if $IS_USERS;


return "&lt;error&gt;Error creatng fling object&lt;/error&gt;"
   unless htmlcode('new_xml_fling','',\my($xml,@data,%xmlstyle));

# we use 15 minute chunks to determine when the next refresh is
my $remains=int(($args{max_age} - ( $time - $last_update))/900)||1;
my $hours=int($remains/4);
my $mins=int($remains % 4)*15;

if ($args{style} eq 'xml') {

    unless ($IS_USERS) {
        $xml-&gt;start('picked',
              'type'  =&gt; $args{type},
              'order' =&gt; $args{order},
              'title' =&gt; $args{title},
              'days'  =&gt; $args{days},
              'ulastupdate'   =&gt; $last_update,
              'lastupdate_gm' =&gt; POSIX::strftime("%Y%m%d%H%M%S",
                                   gmtime($last_update)),
              'nextrefresh_min' =&gt; $hours * 60 + $mins
        )
    }

} elsif ($args{style} eq 'nodelet') {

    push @data,'('.(@$rows ? 0+@$rows : 'None').')&lt;br /&gt;'
        if $IS_USERS;

} else {

    $xml-&gt;element('hr')
        -&gt;element('h4',$args{title})
        -&gt;start('table',
                width=&gt;'100%',
                class =&gt; 'highlight' )
        -&gt;start('tr')
        -&gt;element('th','#');
        $xml-&gt;element('th','Node')   if $args{cols}=~/N/i;
        $xml-&gt;element('th','Author') if $args{cols}=~/A/i;
        $xml-&gt;element('th','Rep')    if $args{cols}=~/R/i;
        $xml-&gt;end('tr');

}



foreach my $row (@$rows) {
    my ($pick_id,$pickname,$auth_id,$authname,$rep,$seq)=@$row;
    $pickname="&lt;i&gt;*No Title*&lt;/i&gt;"
            unless length $pickname;
    if ($args{style} eq 'xml') {
        unless ($IS_USERS) {
            $xml-&gt;start('pick', seq =&gt; $seq)
                    -&gt;element('node', pick_id =&gt; $pick_id, rep=&gt;$rep, $pickname)
                    -&gt;element('user', user_id =&gt; $auth_id, $authname)
                -&gt;end('pick')
        } elsif ($args{xml_ver}) {
            # unused code branch... rethinking required before use.
            $xml-&gt;start('user')
                -&gt;element(user_id=&gt;$pick_id)
                -&gt;element(user_name=&gt;$pickname)
                -&gt;end
        } else {
            $xml-&gt;element( 'user',
                user_id     =&gt; $pick_id,
                username    =&gt; $pickname,
            );
        }
    } else {
        # we assume that these are all html like....
        # ie: html or nodelet
        my ($node_html,$node_title,$auth_html);
        $node_title=($IS_USERS)
                    ? $pickname . "'s home node"
                    : ($args{style} eq 'nodelet')
                      ? "by $authname"
                      : $pickname;
        $node_html=$q-&gt;a(
                        {
                            href  =&gt; "?node_id=$pick_id" ,
                            title =&gt; $node_title,
                        },
                        $pickname
        );
        my $groups = !$IS_USERS ? '' : Everything::isGod($pick_id) ? 'gods' :
          join ', ', grep 
            Everything::isApproved( $pick_id, getNode( $_, 'usergroup' ) ),
              'janitors', 'pedagogues', 'pollsters', 'power users',
               'pmdev', 'SiteDocClan', 'QandAEditors';
        $groups = ". Member of: $groups." if $groups;
        $auth_html=$q-&gt;a(
                        {
                            href  =&gt; "?node_id=$auth_id" ,
                            title =&gt; $authname . "'s home node" . $groups,
                        },
                        $authname
                );

        my $row_class=$seq % 2 ? 'odd-row' : 'even-row';
        my $item_class=sprintf 'item-%03d', $seq;

        if ($args{style} eq 'nodelet')  {
                my $html;
                if ($IS_USERS) {
                    my $level=Everything::Experience::getLevel($auth_id);
                    $html= "&lt;span class='user-$auth_id'&gt;$auth_html&lt;br /&gt;&lt;/span&gt;";
                    $html= "&lt;span class='user-level-$level'&gt;$html&lt;/span&gt;";                    
                } else {
                    $html= $node_html . '&lt;br /&gt;'
                }
                push @data, sprintf("&lt;span class='%s'&gt;&lt;span class='%s'&gt;%s&lt;/span&gt;&lt;/span&gt;\n",
                      $row_class, $item_class, $html)
                ;
        } else {
            $xml-&gt;start('tr', class=&gt;"$row_class $item_class auth-$auth_id")
                -&gt;element('td',$seq+1);
            if ($args{cols}=~/N/i) {
                $xml-&gt;start('td');
                push @data, $node_html;
                $xml-&gt;end('td');
            }
            if ($args{cols}=~/A/i) {
                $xml-&gt;start('td');
                push @data,$auth_html;
                $xml-&gt;end('td');
            }
            $xml-&gt;element('td',$rep) if $args{cols}=~/R/i;
            $xml-&gt;end('tr');
        }
    }
}

if ($args{style} eq 'xml') {

        $xml-&gt;end('picked')
            unless $IS_USERS;

} elsif ($args{style} eq 'nodelet') {

    $hours++ unless $hours;
    my $user_time=POSIX::strftime( (!$IS_USERS ? '' : '%Y-' ).
                      '%m-%d %H:%M GMT' ,  gmtime($last_update) );
    $hours="$hours hr".($hours&gt;1 ? 's' : '');
    my $time_str=!$hours &amp;&amp; !$mins ? "&lt;b&gt;Current.&lt;/b&gt;" : "Next in ~$hours";


    push @data,(!$IS_USERS)
               ? "&lt;span class='update-time'&gt;&lt;small&gt;From $user_time $time_str&lt;/small&gt;&lt;/span&gt;"
               : "&lt;span class='update-time'&gt;&lt;small&gt;As of $user_time&lt;/small&gt;&lt;/span&gt;"


} else { # HTML table

    $xml-&gt;end('table');
    my $user_time=htmlcode('parseTimeInString','',
                POSIX::strftime( "%Y%m%d%H%M%S", localtime($last_update) )
             );
    $hours="$hours hour".($hours&gt;1 ? 's' : '')
      if $hours;
    $mins="$mins min".($mins&gt; 1 ? 's' : '')
      if $mins;
    my @timestr=grep { $_ } ($hours, $mins);
    my $time_str;
    if (@timestr) {
        $time_str="Next refresh in " .
                   join(" and ",@timestr) .
                   " &amp;plusmn;15 min"
    } else {
        $time_str="&lt;b&gt;Just refreshed!&lt;/b&gt;";
    }
    push @data,"&lt;span class='update-time'&gt;&lt;small&gt;As of $user_time, $time_str&lt;/small&gt;&lt;/span&gt;";

}
if ($args{style} eq 'xml') {
  htmlcode('log_ticker','',"$args{type}/$args{order}/$args{days}",
           "Took ".(time-$start_time)." seconds",328453)
    or printLog("gpn: finished p:$picktype/d:$args{days} in "
         .(time-$start_time)
         ." seconds");
}
return join "",@data;
} # ALL
</patch_code>
<applied>2009-07-24 14:36:45</applied>
<htmlcode_id>328453</htmlcode_id>
<live_code># get_picked_nodes htmlcode (tested with nodelets/other users)
# -- demerphq
use strict;
use warnings;
require XML::Fling;
require List::Util;
require POSIX;
require Everything::Experience;

my $start_time=time;
# my ($NODE,$USER,$THEME,$DB,$q);  # for testing under perl -c and without PM

my $DEBUG= isGod($USER);

#---------------------------------------------------------
# Table used by this code:
# CREATE TABLE picked_nodes (
#    pick_id  int(11)    NOT NULL,
#    pickname char(240)  NOT NULL,
#    auth_id  int(11)    NOT NULL,
#    authname char(240)  NOT NULL,
#    rep      int(11)    NOT NULL,
#    days     int(3)     NOT NULL,
#    picktype int(1)     NOT NULL,  /* x0 - Best x1 Selected | 0x - DESC 1x ASC */
#    seq      int(3)     NOT NULL,
#    ulastupdate int(11) NOT NULL,
#    UNIQUE INDEX idx_pick (days,picktype,pick_id),
#    UNIQUE INDEX uidx_main (days,picktype,seq)
# ) TYPE=MyISAM PACK_KEYS=1
#
# Picktype: 0 = Best Nodes
#           1 = Selected Best Nodes
#           2 = Worst Nodes
#          *3 = Selected Worst Nodes
#           4 = Users In descending order of XP
#          *5 = Selected Users In descending order of XP
#          *6 = Users in Ascending order of XP
#          *7 = Selected Users In Ascending order of XP
#
# Lines marked * are hypothetical as they arent used.
# NOTE that Picktype + 64  is for temporary creation
#      that Picktype + 128 is for locking Picktype updates.
#
# Picktypes are update by first obtaining a lock (Days/Picktype+128/Seq=0)
# then by creating the new result set with Days/Picktype+64
# then by deleting the old set (Days/Picktype)
# then by updating the (days/picktype+64) to (days/picktype)
# then by deleting the lock record (days/picktype+128)
# This SHOULD resolve the race condition in get picked nodes.
#
#---------------------------------------------------------
# Cache refresh occurs when there are no recs within the selected $args{days} or if the
# data is too old.  This means that if a particular $args{days} isn't currently stored
# then on first fetch it will be created. A random factor is added to the
# $cache_time to keep multiple $args{days} types from refreshing simultaneously.
#---------------------------------------------------------
# Note: Using XML::Fling for the html as well is just for convenience and for simplicity.
#     : I agree it does look a bit strange. :-)
#---------------------------------------------------------
# Initialization


my $dbh=$DB-&gt;getDatabaseHandle();
my %args=(
    #default
    type   =&gt; "Select", # Select | Best/Worst/NotSelect etc
    order  =&gt; "DESC",   # DESC | ASC only
    days   =&gt; 30,       # 0 = All time, selected only
    sample =&gt; 500,
    choose =&gt; 10,
    max_age=&gt; 24,
    style  =&gt; 'html',   # xml -&gt; xml, nodelet -&gt; simple html, else full html

    time_text=&gt;undef,
    title    =&gt;undef,
    show     =&gt;undef,

    past     =&gt;undef,   # only for when doing the user list.

    cols     =&gt;'NAR',   # html only, chooses columns.

    @_
);

my $IS_USERS = $args{type} eq 'Users';

my $cache_time;
my $where_time;

if ($IS_USERS) {
   $args{past}||=3;
   $args{sample}=$args{choose};
   $cache_time = $args{max_age} * 60;
   $where_time= $args{past} * 60;
   $args{days}=$args{past};
   $args{title}="Users present in the last $args{past} minutes";
   $args{cols}='AR';
} else {
    #Convert to seconds.
    $cache_time=($args{max_age}*=3600);
    $where_time=$args{days};
    my $order_text = $args{order} eq 'DESC'   ? "Best" : "Worst";

    return "&lt;h1&gt;error: We don't do $order_text Nodes of All Time anymore!&lt;/h1&gt;"
       if $args{type} ne 'Select' and !$args{days};

    $args{time_text}="The Past $args{days} days"
        unless defined $args{time_text};
    $args{title}=($args{type} eq 'Select' ? "Selected $order_text" : $order_text).
                 " Nodes of $args{time_text}"
                        unless defined $args{title};
}

my $force_refresh=isGod($USER) &amp;&amp; $q-&gt;param('force_refresh');

$args{show}=$args{choose} unless defined $args{show};
my $type_mod= ( $args{order} eq 'DESC'  ? 0 : 2 );
$type_mod+=4 if $IS_USERS;
my $picktype= ( $args{type} ne 'Select' ? 0 : 1 ) + $type_mod;

my $time=time;


# +- 15 minutes float to keep things staggered a bit.
if ($cache_time&gt;900) {
    $cache_time+=int(rand(1800)-900)
} elsif ($cache_time&gt;=60) {
    my $float=$cache_time/4;
    $cache_time+=int(rand($float*2)-$float);
}

my $end_of_the_world=0;
my $redo_count=0;

ALL: {

my $rows;         # the data we will ultimately print out
                  # and AoA ref structure which could be
                  # built in several ways.

my $update=0;      # must update?
my $last_update=0; # time


#---------------------------------------------------------
# FETCH

FETCH:{
    my $geth=$dbh-&gt;prepare_cached("
        SELECT   pick_id,
                 pickname,
                 auth_id,
                 authname,
                 rep,
                 seq,
                 ulastupdate
        FROM     picked_nodes
        WHERE    picktype = ?
        AND      days     = ?
        ORDER BY days   ASC,
                 seq    ASC
    ");
    $geth-&gt;execute($picktype,$args{days})
        or die "Can't execute statement: $DBI::errstr";

    $rows=$geth-&gt;fetchall_arrayref();

    $last_update=@$rows ? $rows-&gt;[0][-1] : $time;

    if ($force_refresh or !@$rows or $time-$last_update&gt;$cache_time) {
       # this insert acts a lock. if it succeeds then we are allowed to update
       # otherwise we should just use whatever we got.
       $DEBUG &amp;&amp; printLog("gpn: trying to get lock ($$) ".
                join (',',$force_refresh,!@$rows,$time-$last_update&gt;$cache_time,
                     $NODE-&gt;{node_id},$NODE-&gt;{title},$args{days},$picktype+128));

      local $dbh-&gt;{RaiseError};
      local $dbh-&gt;{PrintError};

       my $res=$dbh-&gt;do(qq[
           insert into picked_nodes
                   ( pick_id, pickname, auth_id,  authname,
                     rep,     days,     picktype, seq,       ulastupdate)
            values ( ?      , ?       , 113    , 'rootlock',
                     0,       ?       , ?      , 0         , unix_timestamp(now()))
       ],{},$NODE-&gt;{node_id},$NODE-&gt;{title},$args{days},$picktype+128);
       if ($res==1) {
          $update++;
          $DEBUG &amp;&amp; printLog("gpn: got lock! \$res=$res ($$)\n");
       } else {
           my $res=$dbh-&gt;do(qq[
               update picked_nodes set
                 ulastupdate=unix_timestamp(now()),
                 pick_id=?,
                 pickname=?
               where days=?
               and picktype=?
               and ulastupdate&lt;unix_timestamp(now())-600
           ],{},$NODE-&gt;{node_id},$NODE-&gt;{title},$args{days},$picktype+128);
           if ($res) {
              $DEBUG &amp;&amp; printLog("gpn: recovered bad lock! \$res=$res ($$)\n");
              $update++;
           } else {
              $DEBUG &amp;&amp; printLog("gpn: failed lock! \$res=$res ($$)\n");
           }
       }
    }
}

#---------------------------------------------------------
# Update
if ( $update ) {
    @$rows=(); # there might be stuff in here.

    my $seth=$dbh-&gt;prepare_cached(qq[
        INSERT INTO picked_nodes (
            pick_id,   pickname, auth_id,  authname,
            rep,       seq,      days,     picktype,
            ulastupdate
        ) VALUES (
            ?,         ?,        ?,        ?,
            ?,         ?,        ?,        ?,
            ?
        )
    ]);
    my $op=$args{order} eq 'DESC' ? '&lt;' : '&gt;=';

    my $delh=$dbh-&gt;prepare_cached(qq[
       DELETE FROM picked_nodes
             WHERE days     = ?
               AND picktype = ?
    ]);
    $delh-&gt;execute($args{days},$picktype+64);

    my @WHERE;
    my $USE_INDEX = "";
    if ($args{days}) {
        push @WHERE, "n.createtime &gt; date_sub(now(), interval ? day)";
	# needed in mariadb and presumably mysql 5.1+ to avoid the reputation_node index
        $USE_INDEX = " use index (node_createtime)";
    }

    push @WHERE, "(n.reputation &lt; 0)"
            if $args{order} eq 'ASC';

    my $WHERE = "";
    if (@WHERE) { $WHERE = "WHERE " . join(" AND ", @WHERE) }

    my $limit = ($args{type} eq 'Select' ? $args{sample} : $args{choose});

    my $sel_query=qq[
       SELECT n.node_id     pick_id,
              n.title       pickname,
              a.node_id     auth_id,
              a.title       authname,
              n.reputation  rep
         FROM node n$USE_INDEX
         INNER JOIN node a on a.node_id=n.author_user
        $WHERE
     ORDER BY n.reputation $args{order},
              n.node_id DESC
         LIMIT $limit
    ];
    if ($IS_USERS) {
        $sel_query=qq[
              SELECT node_id    pick_id,
                     title      pickname,
                     node_id    auth_id,
                     title      authname,
                     experience rep
                FROM node,
                     user
               WHERE node_id = user_id
                  AND lasttime &gt; date_sub(NOW(), INTERVAL ? SECOND)
            ORDER BY experience $args{order},
                     node_id ASC
              LIMIT  $limit
        ];
   }

    my $geth=$dbh-&gt;prepare($sel_query) or die "$sel_query\n $DBI::errstr";
    my @args=(
               ($where_time ? $where_time : ()),
    );
    $geth-&gt;execute(@args)
        or die "Can't execute statement [@args]: \n$sel_query\n$DBI::errstr";
    my ($best,$selected)=(0,0);
    my @pick;
    $last_update=$time;

    local $seth-&gt;{RaiseError};
    local $seth-&gt;{PrintError};

    while (my @row=$geth-&gt;fetchrow_array()) {

        # clean the names
        $row[$_]=$q-&gt;escapeHTML($row[$_])
            for 1,3;

        if ($args{type} ne 'Select') {
            unless ($seth-&gt;execute(@row, $best, $args{days},
                           $picktype+64, $time)) {
                 if ($end_of_the_world++ &lt;2) {
                    redo ALL;
                 } else {
                    return "&lt;p&gt;Internal problem occurred in get_picked_nodes"
                       ."&lt;br&gt;".$seth-&gt;errstr." &lt;/p&gt;\n" ;
                 }
            }
            push @$rows,\@row;
            push @row,$best++;
        } else {
            push @pick,\@row;
            push @row,$selected++;
        }

    }
    if ( $args{type} eq 'Select') {
        @pick=List::Util::shuffle(@pick);

        # throw away the rest of the deck
        splice @pick,$args{choose} if @pick&gt;$args{choose};

        # we can use the initial order returned by the db
        # because of the seq element
        @pick=sort { $a-&gt;[-1] &lt;=&gt; $b-&gt;[-1] } @pick;

        # and put it all back, renumbering it as we go
        foreach my $idx (0.. $#pick )
        {
          $pick[$idx][-1]=$idx;
          unless ($seth-&gt;execute(@{$pick[$idx]},$args{days},
                         $picktype+64, $time)) {
             if ($end_of_the_world++ &lt;2) {
                redo ALL;
             } else {
                return "&lt;p&gt;Internal problem occurred in get_picked_nodes"
                    ."&lt;br&gt;".$seth-&gt;errstr." &lt;/p&gt;\n" ;
             }
          }
        }
        @$rows=@pick
    }
    # first delete the old data set
    $delh-&gt;execute($args{days},$picktype);
    # then switch the new one over, this should be an atomic action
    $dbh-&gt;do(qq[update picked_nodes
                set picktype = ?
                where days = ?
                and picktype = ? ],
             {}, $picktype,$args{days},$picktype+64)
      or ($DEBUG &amp;&amp; printLog("gpn: Failed to restore nodes"));
    # then delete the lock record
    $delh-&gt;execute($args{days},$picktype+128);
}

#---------------------------------------------------------
# Render - from here on in, this is all non-db
#
# hypothetically this could be split here, and a pass through
# parameter in $args{} could direct to the correct rendering code.
#
# Do the start


# have nodereaper show up once in a while :-)
if ( $IS_USERS and rand(100)&lt;5) {
    my $nr=getNodeById($HTMLVARS{NodeReaperID});
    push @$rows,[$nr-&gt;{node_id},$nr-&gt;{title},
                $nr-&gt;{node_id},$nr-&gt;{title},
                $nr-&gt;{experience}
               ];
    @$rows=sort { $b-&gt;[4] &lt;=&gt; $a-&gt;[4] } @$rows;
    @$rows=reverse @$rows if $args{order} eq 'ASC'
}

splice @$rows,$args{show} if @$rows&gt;$args{show};
$args{title}=@$rows. " " . $args{title} if $IS_USERS;


return "&lt;error&gt;Error creatng fling object&lt;/error&gt;"
   unless htmlcode('new_xml_fling','',\my($xml,@data,%xmlstyle));

# we use 15 minute chunks to determine when the next refresh is
my $remains=int(($args{max_age} - ( $time - $last_update))/900)||1;
my $hours=int($remains/4);
my $mins=int($remains % 4)*15;

if ($args{style} eq 'xml') {

    unless ($IS_USERS) {
        $xml-&gt;start('picked',
              'type'  =&gt; $args{type},
              'order' =&gt; $args{order},
              'title' =&gt; $args{title},
              'days'  =&gt; $args{days},
              'ulastupdate'   =&gt; $last_update,
              'lastupdate_gm' =&gt; POSIX::strftime("%Y%m%d%H%M%S",
                                   gmtime($last_update)),
              'nextrefresh_min' =&gt; $hours * 60 + $mins
        )
    }

} elsif ($args{style} eq 'nodelet') {

    push @data,'('.(@$rows ? 0+@$rows : 'None').')&lt;br /&gt;'
        if $IS_USERS;
    push @data,'&lt;ul class="spacey-list"&gt;';

} else {

    $xml-&gt;element('hr')
        -&gt;element('h4',$args{title})
        -&gt;start('table',
                width=&gt;'100%',
                class =&gt; 'highlight' )
        -&gt;start('tr')
        -&gt;element('th','#');
        $xml-&gt;element('th','Node')   if $args{cols}=~/N/i;
        $xml-&gt;element('th','Author') if $args{cols}=~/A/i;
        $xml-&gt;element('th','Rep')    if $args{cols}=~/R/i;
        $xml-&gt;end('tr');

}



foreach my $row (@$rows) {
    my ($pick_id,$pickname,$auth_id,$authname,$rep,$seq)=@$row;
    $pickname="&lt;i&gt;*No Title*&lt;/i&gt;"
            unless length $pickname;
    if ($args{style} eq 'xml') {
        unless ($IS_USERS) {
            $xml-&gt;start('pick', seq =&gt; $seq)
                    -&gt;element('node', pick_id =&gt; $pick_id, rep=&gt;$rep, $pickname)
                    -&gt;element('user', user_id =&gt; $auth_id, $authname)
                -&gt;end('pick')
        } elsif ($args{xml_ver}) {
            # unused code branch... rethinking required before use.
            $xml-&gt;start('user')
                -&gt;element(user_id=&gt;$pick_id)
                -&gt;element(user_name=&gt;$pickname)
                -&gt;end
        } else {
            $xml-&gt;element( 'user',
                user_id     =&gt; $pick_id,
                username    =&gt; $pickname,
            );
        }
    } else {
        # we assume that these are all html like....
        # ie: html or nodelet
        my ($node_html,$node_title,$auth_html);
        $node_title=($IS_USERS)
                    ? $pickname . "'s home node"
                    : ($args{style} eq 'nodelet')
                      ? "by $authname"
                      : $pickname;
        $node_html=$q-&gt;a(
                        {
                            href  =&gt; "?node_id=$pick_id" ,
                            title =&gt; $node_title,
                        },
                        $pickname
        );
        my @titles = ( $authname."'s home node" );
        my $level = $IS_USERS ? Everything::Experience::getLevel($auth_id) : '';
        push @titles, "Level $level" if $level;
        my $groups = !$IS_USERS ? '' : Everything::isGod($pick_id) ? 'gods' :
          join ', ', grep 
            Everything::isApproved( $pick_id, getNode( $_, 'usergroup' ) ),
              'janitors', 'pedagogues', 'pollsters', 'power users',
               'pmdev', 'SiteDocClan', 'QandAEditors';
        push @titles, "Member of: $groups" if $groups;
        $auth_html=$q-&gt;a(
                        {
                            href  =&gt; "?node_id=$auth_id" ,
                            title =&gt; join( '. ', @titles ),
                        },
                        $authname
                );

        my $row_class=$seq % 2 ? 'odd-row' : 'even-row';
        my $item_class=sprintf 'item-%03d', $seq;

        if ($args{style} eq 'nodelet')  {
                my $html;
                if ($IS_USERS) {
                    $html= "&lt;span class='user-$auth_id'&gt;$auth_html&lt;/span&gt;";
                    $html= "&lt;span class='user-level-$level'&gt;$html&lt;/span&gt;";                    
                } else {
                    $html= $node_html
                }
                push @data, sprintf("&lt;li&gt;&lt;span class='%s'&gt;&lt;span class='%s'&gt;%s&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;\n",
                      $row_class, $item_class, $html)
                ;
        } else {
            $xml-&gt;start('tr', class=&gt;"$row_class $item_class auth-$auth_id")
                -&gt;element('td',$seq+1);
            if ($args{cols}=~/N/i) {
                $xml-&gt;start('td');
                push @data, $node_html;
                $xml-&gt;end('td');
            }
            if ($args{cols}=~/A/i) {
                $xml-&gt;start('td');
                push @data,$auth_html;
                $xml-&gt;end('td');
            }
            $xml-&gt;element('td',$rep) if $args{cols}=~/R/i;
            $xml-&gt;end('tr');
        }
    }
}

if ($args{style} eq 'xml') {

        $xml-&gt;end('picked')
            unless $IS_USERS;

} elsif ($args{style} eq 'nodelet') {

    $hours++ unless $hours;
    my $user_time=POSIX::strftime( (!$IS_USERS ? '' : '%Y-' ).
                      '%m-%d %H:%M GMT' ,  gmtime($last_update) );
    $hours="$hours hr".($hours&gt;1 ? 's' : '');
    my $time_str=!$hours &amp;&amp; !$mins ? "&lt;b&gt;Current.&lt;/b&gt;" : "Next in ~$hours";


    push @data,'&lt;/ul&gt;';
    push @data,(!$IS_USERS)
               ? "&lt;span class='update-time'&gt;&lt;small&gt;From $user_time $time_str&lt;/small&gt;&lt;/span&gt;"
               : "&lt;span class='update-time'&gt;&lt;small&gt;As of $user_time&lt;/small&gt;&lt;/span&gt;"


} else { # HTML table

    $xml-&gt;end('table');
    my $user_time=htmlcode('parseTimeInString','',
                POSIX::strftime( "%Y%m%d%H%M%S", localtime($last_update) )
             );
    $hours="$hours hour".($hours&gt;1 ? 's' : '')
      if $hours;
    $mins="$mins min".($mins&gt; 1 ? 's' : '')
      if $mins;
    my @timestr=grep { $_ } ($hours, $mins);
    my $time_str;
    if (@timestr) {
        $time_str="Next refresh in " .
                   join(" and ",@timestr) .
                   " &amp;plusmn;15 min"
    } else {
        $time_str="&lt;b&gt;Just refreshed!&lt;/b&gt;";
    }
    push @data,"&lt;span class='update-time'&gt;&lt;small&gt;As of $user_time, $time_str&lt;/small&gt;&lt;/span&gt;";

}
if ($args{style} eq 'xml') {
  htmlcode('log_ticker','',"$args{type}/$args{order}/$args{days}",
           "Took ".(time-$start_time)." seconds",328453)
    or printLog("gpn: finished p:$picktype/d:$args{days} in "
         .(time-$start_time)
         ." seconds");
}
return join "",@data;
} # ALL
</live_code>
<reason>add group membership info to hover on usernames in Other Users</reason>
<field>code</field>
</record>
<record><htmlcode_id>493255</htmlcode_id>
<patch_code>use lib $HTMLVARS{uselib};
use Everything::Experience;
my ($type,$linktype,$title,$length) = @_;
my ($showall, $showunapproved, $tempkey);


$linktype = 'frontpage linktype';
my $lt_id = getId( getNode( $linktype, 'linktype' ) );

my $updateinterval   = 180;
my $daysBeforeExpire = 7;
my $expireTime = $DB-&gt;sqlSelect("from_unixtime(unix_timestamp(now())-86400*$daysBeforeExpire)");
my $SETTING = getNode('listapproved settings','setting');
my $LAS = getVars $SETTING;

my $outercontainer = $LAS-&gt;{defaultOuterContainer};
my $innercontainer = $LAS-&gt;{defaultInnerContainer};
my $innerhtmlcode  = $LAS-&gt;{defaultInnerHtmlcode};

$innercontainer = 'css embed node with vote container';
$outercontainer = 'css listapproved default outer container';

my $start = my $count = $q-&gt;param('next') || 0;
my $maxlength = $length ||= 10;
my $max = $count + $length;
my $numshown = 0;

my( %approved, @unapproved, @approved, @list );

my $htmlcode_id = getId(getNode('simple_cachedlistapproved','htmlcode'));

my $cachekey = join ':', getId($NODE), $type, $linktype, $length, $showunapproved,
                         $VARS-&gt;{unapprovedcontent}, $showall;
my $csr = $DB-&gt;getDatabaseHandle-&gt;prepare_cached(&lt;&lt;END);
  SELECT updateinterval,
         unix_timestamp(lastupdate),
         cachedata
  FROM   cachedinfo
  WHERE  code_id  = ?
  AND    cachekey = ?
END

$csr-&gt;execute($htmlcode_id,$cachekey);
my $RESULT = $csr-&gt;fetchrow_hashref;
$csr-&gt;finish;
if(! $RESULT or ( time - $RESULT-&gt;{'unix_timestamp(lastupdate)'} ) &gt; $RESULT-&gt;{updateinterval} ){
  my $links = selectLinks $NODE;
  $approved{$_-&gt;{to_node}} = 1 for grep $_-&gt;{linktype} == $lt_id, @$links;
  my $ref = selectNodeWhere( {type_nodetype =&gt; getType($type) }, '', 'createtime desc limit 100');
  my @ref = @$ref[$count..$#$ref];
  for(@ref){
    if($approved{$_}){
      push @approved,   $_;
      push @list,       $_;
      last if ++$numshown &gt;= $maxlength;
    }
    else{
      push @unapproved, $_;
      push @list,      -$_;
    }
  }

  my $cachedata = join ',', @list;

  my $sql = $RESULT ? &lt;&lt;END : &lt;&lt;END;

  UPDATE cachedinfo
  SET    lastupdate = now(),
         cachedata  = "$cachedata" 
  WHERE  cachekey = "$cachekey"
  AND    code_id  = $htmlcode_id
END

  INSERT INTO cachedinfo (code_id, cachedata, updateinterval, lastupdate, cachekey)
  VALUES ($htmlcode_id, "$cachedata", $updateinterval, now(), "$cachekey")
END

  $DB-&gt;getDatabaseHandle-&gt;do($sql);
}
else{
  @list = split /,/, $RESULT-&gt;{cachedata};
}

$HTMLVARS{listapproved}{title} = $title;
my $innerstr;
$numshown = 0;
for (@list){
  $HTMLVARS{embed_node} = selectNode $_;
  next if $expireTime gt $HTMLVARS{embed_node}{createtime};
  if($_ &gt; 0 or ($VARS-&gt;{unapprovedcontent}) and $showunapproved or $showall){
    $numshown++;
    my $csr = $DB-&gt;getDatabaseHandle-&gt;prepare_cached('select * from repliesinfo where parent = ?');
    $csr-&gt;execute(getId($HTMLVARS{embed_node}));
    my $Q = $csr-&gt;fetchrow_hashref;
    $csr-&gt;finish;
    my $typeofreplies = $VARS-&gt;{repliesdisplay} || 'directreplies';
    $HTMLVARS{embed_node}{numreplies} = $Q-&gt;{$typeofreplies} || '0';
    $innerstr .= containHtml($innercontainer, htmlcode($innerhtmlcode));
    last if $numshown == $length;
  }
  next if $approved{ getId( $HTMLVARS{embed_node} ) };
  push @unapproved, -$_ if Everything::isApproved($USER,'CanConsider');
}

$HTMLVARS{unapproved} = \@unapproved;

$numshown ? containHtml($outercontainer,$innerstr) : '';</patch_code>
<applied>2005-09-19 15:06:43</applied>
<htmlcode_id>355217</htmlcode_id>
<live_code>use lib $HTMLVARS{uselib};
use Everything::Experience;

my( $type, $linktype, $title, $length )= @_;
my( $showall, $showunapproved, $tempkey );

$linktype = 'frontpage linktype';
my $lt_id = getId( getNode( $linktype, 'linktype' ) );

my $updateinterval   = 180;
my $daysBeforeExpire = 7;
my $expireTime = $DB-&gt;sqlSelect("from_unixtime(unix_timestamp(now())-86400*$daysBeforeExpire)");
my $SETTING = getNode('listapproved settings','setting');
my $LAS = getVars $SETTING;

my $outercontainer = $LAS-&gt;{defaultOuterContainer};
my $innercontainer = $LAS-&gt;{defaultInnerContainer};
my $innerhtmlcode  = $LAS-&gt;{defaultInnerHtmlcode};

$innercontainer = 'css embed node with vote container';
$outercontainer = 'css listapproved default outer container';

my $start = my $count = $q-&gt;param('next') || 0;
my $maxlength = $length ||= 10;
my $max = $count + $length;
my $numshown = 0;

my( %approved, @unapproved, @approved, @list );
my $htmlcode_id = getId(getNode('simple_cachedlistapproved','htmlcode'));

my $cachekey = join ':',
    getId($NODE), $type, $linktype, $length, $showunapproved,
    $VARS-&gt;{unapprovedcontent}, $showall;
my $csr = $DB-&gt;getDatabaseHandle()-&gt;prepare_cached( join ' ',
    "select updateinterval,",
    "unix_timestamp(lastupdate),",
    "cachedata",
    "from   cachedinfo",
    "where  code_id  = ?",
    "and    cachekey = ?",
    "order by lastupdate desc limit 1",
);

$csr-&gt;execute($htmlcode_id,$cachekey);
my $RESULT = $csr-&gt;fetchrow_hashref;
$csr-&gt;finish;
if(! $RESULT or ( time - $RESULT-&gt;{'unix_timestamp(lastupdate)'} ) &gt; $RESULT-&gt;{updateinterval} ) {
    my $links = selectLinks $NODE;
    $approved{$_-&gt;{to_node}} = 1
        for grep $_-&gt;{linktype} == $lt_id, @$links;
    my $ref = selectNodeWhere( {type_nodetype =&gt; getType($type) }, '', 'createtime desc limit 100');
    for( @$ref[$count..$#$ref] ) {
        if($approved{$_}){
            push @approved,   $_;
            push @list,       $_;
            last if ++$numshown &gt;= $maxlength;
        } else {
            push @unapproved, $_;
            push @list,      -$_;
        }
    }
    my $cachedata = join ',', @list;

    my $sql = $RESULT
        ?   join( ' ',
                "update cachedinfo set",
                "lastupdate = now(),",
                "cachedata  = '$cachedata'",
                "where cachekey = '$cachekey'",
                "and code_id = $htmlcode_id",
            )
        :   join( ' ',
                "insert into cachedinfo",
                "( code_id, cachedata, updateinterval, lastupdate, cachekey )",
                "values( $htmlcode_id, '$cachedata', $updateinterval, now(),",
                "'$cachekey' )",
            )
    ;
    $DB-&gt;getDatabaseHandle()-&gt;do( $sql );
} else {
    @list = split /,/, $RESULT-&gt;{cachedata};
}

$HTMLVARS{listapproved}{title} = $title;
my $innerstr;
$numshown = 0;
my $canconsider= Everything::isApproved($USER,'CanConsider');
for( @list ) {
    $HTMLVARS{embed_node} = selectNode $_;
    next if $expireTime gt $HTMLVARS{embed_node}{createtime};
    if($_ &gt; 0 or ($VARS-&gt;{unapprovedcontent}) and $showunapproved or $showall){
        $numshown++;

        my $node= $HTMLVARS{embed_node};
        $node-&gt;{replies}= htmlcode( 'formatRepliesInfo','', $node );
        $node-&gt;{numreplies} = 0 + $node-&gt;{replies}; # temp backward compat

        $innerstr .= containHtml($innercontainer, htmlcode($innerhtmlcode));
        last if $numshown == $length;
    }
    next if $approved{ getId( $HTMLVARS{embed_node} ) };
    push @unapproved, -$_ if $canconsider;
}

$HTMLVARS{unapproved} = \@unapproved;
return '' if ! $numshown;
return containHtml($outercontainer,$innerstr);
</live_code>
<reason>lose getLevel (CanConsider)</reason>
<field>code</field>
</record>
<record><htmlcode_id>752228</htmlcode_id>
<patch_code># [handle_xml_view]
my ( $node, $user ) = @_;
$node ||= $NODE;
$user ||= $USER;

use XML::Fling;
use Everything::Experience;

my $pmdev=$DB-&gt;isApproved( $user, getNode( 'pmdev', 'usergroup' ) );
my $isGod=$pmdev ? isGod($user) : 0;

=begin comment

This code is responsible for rendering a given $NODE as XML.

The XML comes in essentially three parts.

The first part is the default information that is available for all
nodes. Such as title, node_id, author etc. This is hardcoded here
and cannot be changed via a setting.

The second is a set of key/value pairs which we will call 'fields'.
These are normally the contents of a corresponding key/value in the
$NODE hash itself. However additional arbitrary fields can be added by
specifying a code snippet in the appropriate 'allowed fields' setting
with '_eval' suffixed to the type name as the key.  The code may
return one or more strings or array refs. If the return is a string
it is taken as a $NODE key, and if it is an array is is assumed to
contain a key/value pair to be embedded.

The third is via a type specific and or a node specific setting. This
is where an htmlcode node is specified for either a given node_id or a
given type. This code is executed and then the results are added to
the end of the returned XML packet. A special property of this type of
dispatch is that at user request it can be used to _totally_ replace
the normal node XML content. Thus a node can pretend to be another
from the XML point of view. One node that exploits this behaviour is
the [Scratch Pad Viewer], which when the 'passthrough=1' parameter is
provided in the query will display the XML of the requested scratchpad
and not its own. The setting has to specifically enable this by
providing a TRUE second value (comma seperated) in the passthrough
setting.

=cut


# *** Useful Vars ***
my $author  = getNodeById( $node-&gt;{author_user} );
my $type    = $node-&gt;{type};
my $t_title = $type-&gt;{title};
$t_title =~ s/\s+//g;

# *** Passthrough ***
# Passthrough settings are handled first as they pre-empt everything else.
# If its inline text (most likely) then its appended to the end.
#
# xml passthrough setting contains
# id   =&gt; htmlcode
# id   =&gt; htmlcode,passthrough
# type =&gt; htmlcode
# type =&gt; htmlcode,passthrough

my @inline_xml;
my $passthrough=$q-&gt;param('passthrough');

my %passthrough = %{ getVars( getNode( 'xml passthrough setting', 'setting' ) ) };
my %done_htmlcode;
for my $key ( "id_".getId($NODE), "type_".$t_title ) 
{
  foreach my $pfx (($isGod ? 'gods_' : ()),($pmdev ? 'pmdev_' : ()),'') {
    my $opt=$passthrough{"$pfx$key"};
    next unless $opt;

    my ( $htmlcode, $is_passthrough, @args ) = split /,/, $opt || '';
    next if $htmlcode &amp;&amp; $done_htmlcode{$htmlcode}++;
    unshift @args,"" if @args;

    if ( $htmlcode and $is_passthrough and $passthrough) {
      $q-&gt;param( 'passthrough', 0 );
      if ($htmlcode) {
          my $return;
          $return = htmlcode($htmlcode,@args) if $htmlcode;
          return $return if $return;
      }
    } elsif ( $htmlcode and !$is_passthrough ) {
      push @inline_xml, htmlcode($htmlcode,@args);
    }
  }
}

# *** Type Specific Behaviour ***
#
# Build a HoA of type/fields. Skip any 'type' ending with _eval
# which are ${type}_eval =&gt; code for more complex behaviour
#
# allowed xml fields contain the following:
# typename      =&gt; list,of,fields
# typename_eval =&gt; code to eval
# special       =&gt; list,of,fields
#
# we build the full HoA because some of our rules (user for instance)
# depend on the 'special' feature.
#

my %types;

# how much to tell...
foreach my $setting (
                   # [use the setting, node ]
                   # we use getNode() and not a string because its
                   # self documenting with pm's display mechanism
                   [ 1, getNode( 'allowed xml fields', 'setting' ) ],
                   [ $pmdev, getNode('pmdev allowed xml fields', 'setting' ) ],
                   [ $isGod, getNode('gods allowed xml fields', 'setting' ) ] 
)
{
    my ($ok,$setting_node)=@$setting;
    last unless $ok;
    # they are in group so fetch any extra info they get to see
    my %extra_types=%{ getVars( $setting_node ) };
    # and merge it in.
    foreach (keys %extra_types) {
        push @{$types{$_}},/_eval$/ ? $extra_types{$_}
                                    : split /,/,$extra_types{$_}||'';
    }
}

if ($user-&gt;{title} eq 'de-merphq') {
  use Data::Dumper;
  printLog(Dumper(\%types));
}


# now we get the list of fields to add
my @fields = @{ $types{$t_title} || [] };

# Fields are either a non-ref, in which case they are the key for the $NODE hash
# being dumped, or they are an anonymous array of two elements, the first which
# represents the field name, and the second the value.

# Example Special Code

#*user
# my $user_vars = getVars($node);
#   map { [ $user_vars, $_ ] } @{ $types{'user_settings'} };


# and eval any special stuff into existance
if (my $eval_array=$types{$t_title."_eval"}) {
    foreach my $eval (@$eval_array) {
        my @add=eval $eval;
        if ($@) {
            printLog("In xml type eval '$eval':$@");
        } else {
            #printLog("for $t_title got: @add\n");
            push @fields,@add;
        }
    }
}
push @fields, 'reputation'
    if (($node-&gt;{original_author}  ||  $node-&gt;{author_user}) == $USER-&gt;{node_id})
       || canUpdateNode($user,$node) 
       || hasVoted($node,$user);

# Now we start XML production

return "Error creatng fling object"
  unless htmlcode('new_xml_fling','',\my($xml,@data,%xmlstyle));

$xml-&gt;header("windows-1252");

my %nosend;
if ($q-&gt;param('nosend')) {
  my @nosend = map { split /,/,$_ } $q-&gt;param('nosend');
  @nosend{@nosend} = @nosend;
}

# first the stuff every node gets
my $update = $node-&gt;{lastupdate} || $node-&gt;{nodeupdated};
$update =~ s!(\d{4})(\d\d)(\d\d)(\d\d)(\d\d)(\d\d)!$1-$2-$3 $4:$5:$6!;
$xml-&gt;start(
    'node',
    id      =&gt; getId($node),
    title   =&gt; $node-&gt;{title},
    created =&gt; $node-&gt;{createtime},
    updated =&gt; $update,
);
$xml-&gt;element( 'type',   id =&gt; getId($type),   $type-&gt;{title} )
  unless $nosend{'type'};
$xml-&gt;element( 'author', id =&gt; getId($author), $author-&gt;{title} )
  unless $nosend{'author'};

# now any fields
if (!$q-&gt;param('nofields') &amp;&amp; @fields) {
    $xml-&gt;start('data') unless $xmlstyle{flat};
    
    my $csr= $DB-&gt;sqlSelectMany(
        "word",
        "keywords",
        "node_id=$NODE-&gt;{node_id}",
        "order by rating desc",
    );
    if(  $csr  ) {
        my $started=0;
        while(  my $kwd= $csr-&gt;fetchrow_hashref()  ) {
            $xml-&gt;start('keywords')
              unless $started++;
            $xml-&gt;element('keyword',
              rating=&gt; $kwd-&gt;{rating},
              $kwd-&gt;{word});
        }
        $xml-&gt;end('keywords')
          if $started;
    }
    my %dupe;
    foreach my $field (@fields) {
        my ( $name, $data, $parse );
        if ( ref $field ) {
            ( $name, $data ) = @$field;

            #$parse=$name=~s/^\*//g;
        } else {
            $name = $field;
            next unless $name;
            #$parse=$name=~s/^\*//g;
            $data = $node-&gt;{$field};
            #next if $name eq 'reputation'
            #    and !(canUpdateNode( $user, $node ) || hasVoted( $node, $user ));
        }
        next if $nosend{$name} || $dupe{$name}++;
        if ( $q-&gt;param('links') eq 'on' ) # and $parse
        {
            $HTMLVARS{linkstagparse} = $data;
            $data = htmlcode('parselinkstotags');
        }
        unless ($xmlstyle{flat}) {
            $xml-&gt;element( 'field', name =&gt; $name, $data );
        }
        else {
            ( my $tagname = $name ) =~ s/ /_/g;
            $tagname =~ s/\W//g;
            $xml-&gt;element( $tagname, field_name =&gt; $name, $data );
        }
    }
    $xml-&gt;end('data') unless $xmlstyle{flat};
}


# add any inline XML as the last
push @data, @inline_xml
  if @inline_xml;

$xml-&gt;end('node');

# and we are done
return join '', @data;</patch_code>
<applied>2009-03-21 09:36:05</applied>
<htmlcode_id>366346</htmlcode_id>
<live_code># [handle_xml_view]
my ( $node, $user ) = @_;
$node ||= $NODE;
$user ||= $USER;

use XML::Fling;
use Everything::Experience;

my $pmdev=$DB-&gt;isApproved( $user, getNode( 'pmdev', 'usergroup' ) );
my $isGod=$pmdev ? isGod($user) : 0;

=begin comment

This code is responsible for rendering a given $NODE as XML.

The XML comes in essentially three parts.

The first part is the default information that is available for all
nodes. Such as title, node_id, author etc. This is hardcoded here
and cannot be changed via a setting.

The second is a set of key/value pairs which we will call 'fields'.
These are normally the contents of a corresponding key/value in the
$NODE hash itself. However additional arbitrary fields can be added by
specifying a code snippet in the appropriate 'allowed fields' setting
with '_eval' suffixed to the type name as the key.  The code may
return one or more strings or array refs. If the return is a string
it is taken as a $NODE key, and if it is an array is is assumed to
contain a key/value pair to be embedded.

The third is via a type specific and or a node specific setting. This
is where an htmlcode node is specified for either a given node_id or a
given type. This code is executed and then the results are added to
the end of the returned XML packet. A special property of this type of
dispatch is that at user request it can be used to _totally_ replace
the normal node XML content. Thus a node can pretend to be another
from the XML point of view. One node that exploits this behaviour is
the [Scratch Pad Viewer], which when the 'passthrough=1' parameter is
provided in the query will display the XML of the requested scratchpad
and not its own. The setting has to specifically enable this by
providing a TRUE second value (comma seperated) in the passthrough
setting.

=cut


# *** Useful Vars ***
my $author  = getNodeById( $node-&gt;{author_user} );
my $type    = $node-&gt;{type};
my $t_title = $type-&gt;{title};
$t_title =~ s/\s+//g;

# *** Passthrough ***
# Passthrough settings are handled first as they pre-empt everything else.
# If its inline text (most likely) then its appended to the end.
#
# xml passthrough setting contains
# id   =&gt; htmlcode
# id   =&gt; htmlcode,passthrough
# type =&gt; htmlcode
# type =&gt; htmlcode,passthrough

my @inline_xml;
my $passthrough=$q-&gt;param('passthrough');

my %passthrough = %{ getVars( getNode( 'xml passthrough setting', 'setting' ) ) };
my %done_htmlcode;
for my $key ( "id_".getId($NODE), "type_".$t_title ) 
{
  foreach my $pfx (($isGod ? 'gods_' : ()),($pmdev ? 'pmdev_' : ()),'') {
    my $opt=$passthrough{"$pfx$key"};
    next unless $opt;

    my ( $htmlcode, $is_passthrough, @args ) = split /,/, $opt || '';
    next if $htmlcode &amp;&amp; $done_htmlcode{$htmlcode}++;
    unshift @args,"" if @args;

    if ( $htmlcode and $is_passthrough and $passthrough) {
      $q-&gt;param( 'passthrough', 0 );
      if ($htmlcode) {
          my $return;
          $return = htmlcode($htmlcode,@args) if $htmlcode;
          return $return if $return;
      }
    } elsif ( $htmlcode and !$is_passthrough ) {
      push @inline_xml, htmlcode($htmlcode,@args);
    }
  }
}

# *** Type Specific Behaviour ***
#
# Build a HoA of type/fields. Skip any 'type' ending with _eval
# which are ${type}_eval =&gt; code for more complex behaviour
#
# allowed xml fields contain the following:
# typename      =&gt; list,of,fields
# typename_eval =&gt; code to eval
# special       =&gt; list,of,fields
#
# we build the full HoA because some of our rules (user for instance)
# depend on the 'special' feature.
#

my %types;

# how much to tell...
foreach my $setting (
                   # [use the setting, node ]
                   # we use getNode() and not a string because its
                   # self documenting with pm's display mechanism
                   [ 1, getNode( 'allowed xml fields', 'setting' ) ],
                   [ $pmdev, getNode('pmdev allowed xml fields', 'setting' ) ],
                   [ $isGod, getNode('gods allowed xml fields', 'setting' ) ] 
)
{
    my ($ok,$setting_node)=@$setting;
    last unless $ok;
    # they are in group so fetch any extra info they get to see
    my %extra_types=%{ getVars( $setting_node ) };
    # and merge it in.
    foreach (keys %extra_types) {
        push @{$types{$_}},/_eval$/ ? $extra_types{$_}
                                    : split /,/,$extra_types{$_}||'';
    }
}

if ($user-&gt;{title} eq 'de-merphq') {
  use Data::Dumper;
  printLog(Dumper(\%types));
}


# now we get the list of fields to add
my @fields = @{ $types{$t_title} || [] };

# Fields are either a non-ref, in which case they are the key for the $NODE hash
# being dumped, or they are an anonymous array of two elements, the first which
# represents the field name, and the second the value.

# Example Special Code

#*user
# my $user_vars = getVars($node);
#   map { [ $user_vars, $_ ] } @{ $types{'user_settings'} };


# and eval any special stuff into existance
if (my $eval_array=$types{$t_title."_eval"}) {
    foreach my $eval (@$eval_array) {
        my @add=eval $eval;
        if ($@) {
            printLog("In xml type eval '$eval':$@");
        } else {
            #printLog("for $t_title got: @add\n");
            push @fields,@add;
        }
    }
}
push @fields, 'reputation'
    if (($node-&gt;{original_author}  ||  $node-&gt;{author_user}) == $USER-&gt;{node_id})
       || canUpdateNode($user,$node) 
       || hasVoted($node,$user);

# Now we start XML production

return "Error creatng fling object"
  unless htmlcode('new_xml_fling','',\my($xml,@data,%xmlstyle));

$xml-&gt;header("windows-1252");

my %nosend;
if ($q-&gt;param('nosend')) {
  my @nosend = map { split /,/,$_ } $q-&gt;param('nosend');
  @nosend{@nosend} = @nosend;
}

# first the stuff every node gets
my $update = $node-&gt;{lastupdate} || $node-&gt;{nodeupdated};
$update =~ s!(\d{4})(\d\d)(\d\d)(\d\d)(\d\d)(\d\d)!$1-$2-$3 $4:$5:$6!;
$xml-&gt;start(
    'node',
    id      =&gt; getId($node),
    title   =&gt; $node-&gt;{title},
    created =&gt; $node-&gt;{createtime},
    updated =&gt; $update,
);
$xml-&gt;element( 'type',   id =&gt; getId($type),   $type-&gt;{title} )
  unless $nosend{'type'};
$xml-&gt;element( 'author', id =&gt; getId($author), $author-&gt;{title} )
  unless $nosend{'author'};

# now any fields
if (!$q-&gt;param('nofields') &amp;&amp; @fields) {
    $xml-&gt;start('data') unless $xmlstyle{flat};
    
    my $csr= $DB-&gt;sqlSelectMany(
        "word",
        "keywords",
        "node_id=$NODE-&gt;{node_id}",
        "order by rating desc",
    );
    if(  $csr  ) {
        my $started=0;
        while(  my $kwd= $csr-&gt;fetchrow_hashref()  ) {
            $xml-&gt;start('keywords')
              unless $started++;
            $xml-&gt;element('keyword',
              rating=&gt; $kwd-&gt;{rating},
              $kwd-&gt;{word});
        }
        $xml-&gt;end('keywords')
          if $started;
    }
    my %dupe;
    foreach my $field (@fields) {
        my ( $name, $data, $parse );
        if ( ref $field ) {
            ( $name, $data ) = @$field;

            #$parse=$name=~s/^\*//g;
        } else {
            $name = $field;
            next unless $name;
            #$parse=$name=~s/^\*//g;
            $data = $node-&gt;{$field};
            #next if $name eq 'reputation'
            #    and !(canUpdateNode( $user, $node ) || hasVoted( $node, $user ));
        }
        next if $nosend{$name} || $dupe{$name}++;
        if ( $q-&gt;param('links') eq 'on' ) # and $parse
        {
            $HTMLVARS{linkstagparse} = $data;
            $data = htmlcode('parselinkstotags');
        }
        unless ($xmlstyle{flat}) {
            $xml-&gt;element( 'field', name =&gt; $name, $data );
        }
        else {
            ( my $tagname = $name ) =~ s/ /_/g;
            $tagname =~ s/\W//g;
            $xml-&gt;element( $tagname, field_name =&gt; $name, $data );
        }
    }
    $xml-&gt;end('data') unless $xmlstyle{flat};
}


# add any inline XML as the last
push @data, @inline_xml
  if @inline_xml;

$xml-&gt;end('node');

my $data = join '', @data;

htmlcode('postProcessXML', '', \$data); 

# and we are done
return $data;
</live_code>
<reason>encoding in xml header</reason>
<field>code</field>
</record>
<record><htmlcode_id>379842</htmlcode_id>
<patch_code>my ($NODE) = @_;

getRef $NODE;

my $user_id=$NODE-&gt;{author_user};
#printLog("Scratchpad Delete:$NODE-&gt;{node_id} : $user_id");
my $U=getNodeById($user_id);

if ($U-&gt;{user_scratchpad} eq $NODE-&gt;{scratchpad_id}) {
  $U-&gt;{user_scratchpad}=0;
  updateNode($U,$U);
  $USER-&gt;{user_scratchpad}=0
     if $USER-&gt;{user_id}==$U-&gt;{user_id};
}

</patch_code>
<applied>2004-08-03 18:28:31</applied>
<htmlcode_id>366349</htmlcode_id>
<live_code>my ($NODE) = @_;

getRef $NODE;

my $user_id=$NODE-&gt;{author_user};
#printLog("Scratchpad Delete:$NODE-&gt;{node_id} : $user_id");
my $U=getNodeById($user_id);

if ($U-&gt;{user_scratchpad} eq $NODE-&gt;{scratchpad_id}) {
  $U-&gt;{user_scratchpad}=0;
  updateNode($U,$U);
}

</live_code>
<reason>robustness?</reason>
<field>code</field>
</record>
<record><htmlcode_id>781062</htmlcode_id>
<patch_code># get_sitedoclet: $NODE_OR_NAME, @OPT_SECTIONS, %OPT_TAGS, $OPT_HASHREF
#
# Extracts a [sitedoclet] node from the DB, then extracts the requested
# sections from it as specified by the array @OPT_SECTIONS.
# Special tags are subtituted into the text if provided.
# If using the list interface, then tagnames must be preceded by a '-'.
# After the first such tagname is encountered everything following (except
# a lone ref at the end) are treated as -KEY=&gt;Value pairs.
#
# Sections are denoted in the text as &lt;!--&amp;NAME&amp;--&gt;
# Tags are denoted in the text as &lt;!--$NAME$--&gt;
#
# Tags are substituted into the text first, and this process can be recursive.
# If no specific section is requested then the whole sitedoclet is returned
# If $OPT_HASHREF is proved then any @OPT_SECTIONS or %OPT_TAGS settings
# are merged into the "fields" and "tags" slots in the $OPT_HASHREF
# Additionally various after extraction data is loaded into %OPT_TAGS for
# return. Thus providing this parameter can be used as an alternate return
# vector.
#eg: [{get_sitedoclet:foobar}] returns the foobar sitedoclet
#    [{get_sitedoclet:foobar,baz}] the baz section of the foobar sitedoclet
#    [{get_sitedoclet:foobar,-bop,Bop}] returns the foobar sitedoclet,
#         with 'bop' tags replaced with 'Bop';
#    [{get_sitedoclet:foobar,baz,-bop,Bop}] returns the baz section
#         with any 'bop' tags replaced with 'Bop'

my( $name, @args )= @_;
my $rss_link= '';
if(  $name  ) {
    ;
} elsif(  'sitedoclet' eq $NODE-&gt;{type}{title}  ) {
    $name= $NODE-&gt;{title};
} else {
    $name= "$NODE-&gt;{title} sitedoclet";
    # Only a superdoc can be a Section
    if(  'superdoc' eq $NODE-&gt;{type}{title}  ) {
        # So don't do all this work for non-superdocs
        # If this is a Section, add an rss link for the section's nodetype
        my $sections= getVars(
            getNode( 'section list', 'setting' ) );
        my $nodetypes= join ',',
            grep {
                s/_/ /g; 1;
            } grep {
                $sections-&gt;{$_} eq $NODE-&gt;{title};
            } keys %$sections;
        $rss_link= join( '',
            '&lt;link rel="alternate" type="application/rss+xml"',
            ' href="?node_id=30175;xmlstyle=rss;types=',
            $nodetypes,
            '"&gt;',
        )
            if  $nodetypes;
    }
}

my $N;
if(  ref $name  ) {
    $N= $name;
}
$N ||= getNode( $name, 'sitedoclet' );
$N ||= getNode( "$name sitedoclet", 'sitedoclet' );
return ""
    if  ! $N;
$name= $N-&gt;{title};

my $opts;
$opts= pop @args
    if  ref $args[-1];
$opts-&gt;{fields} ||= [];

while(  @args  &amp;&amp;  $args[0] !~ /^-/  ) {
    push @{ $opts-&gt;{fields} }, shift @args;
}
while(  @args  ) {
    my( $tag, $value )= splice @args, 0, 2;
    $tag =~ s/^-//;
    $opts-&gt;{tags}{$tag}= $value;
}

# Parse any links and do simple substitution
my $doctext= $N-&gt;{doctext};
$doctext= htmlcode(
    'parseLinksInContent','',
    $doctext,
    overridefilter =&gt; {
        img =&gt; 'alt,border,height,src,width,/',
    },
);

for(  1 .. 10  ) {  # Only support tags nesting 10 levels deep
    last
        if  $doctext !~ s{ &lt;!-- \$ (\w+) \$ --&gt; }{
                exists $opts-&gt;{tags}{$1}
                    ?   $opts-&gt;{tags}{$1}
                    :   '&amp;lt;!--$' . $1 . '$--&amp;gt;'
            }gex;
}

# each section is preceded by a marker like this
my $sep_qr= qr/&lt;!--&amp;(\w+)&amp;--&gt;/;

my @contains= $doctext =~ /$sep_qr/g;
my( $single, @parts )= split /$sep_qr/, $doctext;
if(  $single =~ /\S/  ) {
    unshift @parts, $name, $single;
    unshift @contains, $name;
}

# turn the sections into hashes
my %sections= @parts;

# prep for more sophisticated post processing
$opts-&gt;{sections}=  \%sections;
$opts-&gt;{parts}=     \@parts;
$opts-&gt;{contains}=  \@contains;

# we return the full parsed doctext if no specific fields were requested
return $rss_link . $doctext
    if  ! @{ $opts-&gt;{fields} };

# we return the sections requested
return join( '',
    $rss_link,
    "&lt;!--\nbegin get_sitedoclet($name)\n--&gt;",
    map( "&lt;!--\nSection:$_\n--&gt;$sections{$_}", @{ $opts-&gt;{fields} } ),
    "&lt;!--\nend get_sitedoclet()\n--&gt;",
);
</patch_code>
<applied>2009-07-17 09:55:10</applied>
<htmlcode_id>370014</htmlcode_id>
<live_code># get_sitedoclet: $NODE_OR_NAME, @OPT_SECTIONS, %OPT_TAGS, $OPT_HASHREF
#
# Extracts a [sitedoclet] node from the DB, then extracts the requested
# sections from it as specified by the array @OPT_SECTIONS.
# Special tags are subtituted into the text if provided.
# If using the list interface, then tagnames must be preceded by a '-'.
# After the first such tagname is encountered everything following (except
# a lone ref at the end) are treated as -KEY=&gt;Value pairs.
#
# Sections are denoted in the text as &lt;!--&amp;NAME&amp;--&gt;
# Tags are denoted in the text as &lt;!--$NAME$--&gt;
#
# Tags are substituted into the text first, and this process can be recursive.
# If no specific section is requested then the whole sitedoclet is returned
# If $OPT_HASHREF is proved then any @OPT_SECTIONS or %OPT_TAGS settings
# are merged into the "fields" and "tags" slots in the $OPT_HASHREF
# Additionally various after extraction data is loaded into %OPT_TAGS for
# return. Thus providing this parameter can be used as an alternate return
# vector.
#eg: [{get_sitedoclet:foobar}] returns the foobar sitedoclet
#    [{get_sitedoclet:foobar,baz}] the baz section of the foobar sitedoclet
#    [{get_sitedoclet:foobar,-bop,Bop}] returns the foobar sitedoclet,
#         with 'bop' tags replaced with 'Bop';
#    [{get_sitedoclet:foobar,baz,-bop,Bop}] returns the baz section
#         with any 'bop' tags replaced with 'Bop'

my( $name, @args )= @_;
my $rss_link= '';
if(  $name  ) {
    ;
} elsif(  'sitedoclet' eq $NODE-&gt;{type}{title}  ) {
    $name= $NODE-&gt;{title};
} else {
    $name= "$NODE-&gt;{title} sitedoclet";
    # Only a superdoc can be a Section
    if(  'superdoc' eq $NODE-&gt;{type}{title}  ) {
        # So don't do all this work for non-superdocs
        # If this is a Section, add an rss link for the section's nodetype
        my $sections= getVars(
            getNode( 'section list', 'setting' ) );
        my $nodetypes= join ',',
            grep {
                s/_/ /g; 1;
            } grep {
                $sections-&gt;{$_} eq $NODE-&gt;{title};
            } keys %$sections;
        $rss_link= join( '',
            '&lt;link rel="alternate" type="application/rss+xml"',
            ' href="?node_id=30175;xmlstyle=rss;types=',
            $nodetypes,
            '"&gt;',
        )
            if  $nodetypes;
    }
}

my $N;
if(  ref $name  ) {
    $N= $name;
}
$N ||= getNode( "$name sitedoclet", 'sitedoclet' )
    if  $name !~ / sitedoclet$/;
$N ||= getNode( $name, 'sitedoclet' );
return ""
    if  ! $N;
$name= $N-&gt;{title};

my $opts;
$opts= pop @args
    if  ref $args[-1];
$opts-&gt;{fields} ||= [];

while(  @args  &amp;&amp;  $args[0] !~ /^-/  ) {
    push @{ $opts-&gt;{fields} }, shift @args;
}
while(  @args  ) {
    my( $tag, $value )= splice @args, 0, 2;
    $tag =~ s/^-//;
    $opts-&gt;{tags}{$tag}= $value;
}

my $doctext= $N-&gt;{doctext};

# do tag substitution
for(  1 .. 10  ) {  # Only support tags nesting 10 levels deep
    last
        if  $doctext !~ s{ (&lt;!-- \$ (\w+) \$ --&gt;) }{
                exists $opts-&gt;{tags}{$2}
                    ?   $opts-&gt;{tags}{$2}
                    :   $1
            }gex;
}

# Parse any links and do simple substitution
$doctext= htmlcode(
    'parseLinksInContent','',
    $doctext,
    overridefilter =&gt; {
        img =&gt; 'alt,border,height,src,width,/',
        ul =&gt; 'class,id',
        ol =&gt; 'class,id',
        dl =&gt; 'class,id',
        div =&gt; 'class,id',
        span =&gt; 'class,id',
    },
);

# each section is preceded by a marker like this
my $sep_qr= qr/&lt;!--&amp;(\w+)&amp;--&gt;/;

my @contains= $doctext =~ /$sep_qr/g;
my( $single, @parts )= split /$sep_qr/, $doctext;
if(  $single =~ /\S/  ) {
    unshift @parts, $name, $single;
    unshift @contains, $name;
}

# turn the sections into hashes
my %sections= @parts;

# prep for more sophisticated post processing
$opts-&gt;{sections}=  \%sections;
$opts-&gt;{parts}=     \@parts;
$opts-&gt;{contains}=  \@contains;

# we return the full parsed doctext if no specific fields were requested
return $rss_link . $doctext
    if  ! @{ $opts-&gt;{fields} };

# we return the sections requested
return join( '',
    $rss_link,
    "&lt;!--\nbegin get_sitedoclet($name)\n--&gt;",
    map( "&lt;!--\nSection:$_\n--&gt;$sections{$_}", @{ $opts-&gt;{fields} } ),
    "&lt;!--\nend get_sitedoclet()\n--&gt;",
);
</live_code>
<reason>img tags are always "empty"</reason>
<field>code</field>
</record>
<record><htmlcode_id>605959</htmlcode_id>
<patch_code>return ''   if  ! $q-&gt;param("searchterms");
my $edit= 'viewcode';
# $edit= 'edit'   if  isGod($USER);
my @terms= split /;/, $q-&gt;param("searchterms");

my $grep= $q-&gt;param('dogrep');
$grep= $VARS-&gt;{sic_dogrep}   if  ! defined $grep;

my $or_terms= $q-&gt;param('or_terms');
$or_terms= $VARS-&gt;{sic_or_terms}   if  ! defined $or_terms;

my @match;
{
    my %fieldOfTable= (
        htmlpage =&gt; 'page',
        htmlcode =&gt; 'code',
        document =&gt; 'doctext',
        container =&gt; 'context',
        nodelet =&gt; 'nlcode',
        setting =&gt; 'vars',
    );
    my %restrictForTable= (
        document =&gt;
            " and type_nodetype in ( "
            . join(
                ",", map {
                    $DB-&gt;sqlSelect( "node_id", "node",
                        qq[type_nodetype=1 and title="$_"] )
                } 'fullpage', 'superdoc', 'rawpage', 'strangedoc', 'script'
            ) . " ) ",
        htmlcode =&gt;
            " and type_nodetype not in ( "
            . join(
                ",", map {
                    $DB-&gt;sqlSelect( "node_id", "node",
                      qq[type_nodetype=1 and title="$_"] )
                } 'patch'
            ) . " ) ",
        setting =&gt;
            " and type_nodetype not in ( "
            . join( ",", map getId( getType( $_ ) ),
               qw/user zombie_user doclist faqlist tutlist/
            ) . " ) ",
    );

    my $title= '';
    if(  1 == @terms  ) {
        my $like= $terms[0];
        $like =~ s#([%_\\\[\]])#\\$1#g;
        $like =~ s#(['\\])#\\$1#g;
        $title= " or title like '%$like%'"
    }
    for my $table (  keys %fieldOfTable  ) {
        my $sth= $DB-&gt;sqlSelectMany(
            "node_id,title,type_nodetype,$fieldOfTable{$table}",
            "node,$table",
            #my $where=
            "node_id=${table}_id and ( " . join( ($or_terms ? " or " : " and "), map {
                my $quoted= $_;
                $quoted =~ s#([%_\\\[\]])#\\$1#g;
                $quoted =~ s#(['\\])#\\$1#g;
                "$fieldOfTable{$table} like '%$quoted%'"
            } @terms )
            . "$title )" . $restrictForTable{$table},
        );
        #$str .= qq[
        #  where=] . $q-&gt;escapeHTML($where) . qq[
        #  &lt;br /&gt;];
        my $rec;
        while(  $rec= $sth-&gt;fetchrow_hashref()  ) {
            my @lines;
            my $index= 0;
            if(  $grep  &amp;&amp;  $table ne 'setting'  ) {
                LINE:
                foreach my $line (
                    split /\n/, $rec-&gt;{$fieldOfTable{$table}}
                ) {
                    $index++;
                    for my $term (  @terms  ) {
                        if(  0 &lt;= index( lc($line), lc($term) )  ) {
                            push @lines, sprintf "% 4d:%s", $index, $line;
                            next LINE;
                        }
                    }
                }
            }
            push @match, [$rec,\@lines];
        }
        $sth-&gt;finish();
    }
}
{
    my $pmmod= getId( getType('pmmodule') );
    my $sth= $DB-&gt;sqlSelectMany(
        "node_id,title,type_nodetype",
        "node",
        "type_nodetype=$pmmod",
    );
    my $mod;
    $_= lc $_   for  @terms;

MODULE:
    while(  $mod= $sth-&gt;fetchrow_hashref()  ) {
        my $name= $mod-&gt;{title};
        my @mod;
        htmlcode( 'readPmModule','', $name, {}, \@mod );
        my @lines;
        my $lineNo= 0;
        my %matched;
        LINE:
        for my $line (  @mod  ) {
            $lineNo++;
            chomp $line;
            local $_= lc $line;
            my $pushed;
            for my $term (  @terms  ) {
                if(  0 &lt;= index( $_, $term )  ) {
                    $matched{$term}++;
                    if(  $grep  &amp;&amp;  !$pushed  ) {
                        push @lines, sprintf "%4d:%s", $lineNo, $line;
                        $pushed= 1;
                    }
                }
            }
        }
        push @match, [$mod,\@lines]
            if  $or_terms &amp;&amp; @lines  or  keys %matched == @terms;
    }
    $sth-&gt;finish();
}
if(  $q-&gt;param('displaytype') eq 'xml'  ) {
    my @data;
    my $xml_nl= $/;
    $xml_nl= ""   if  grep $_ eq "clean", $q-&gt;param("xmlstyle");
    my $xml= XML::Fling-&gt;new( \@data, "&lt;","&gt;\n","&lt;","&gt;$xml_nl","&lt;","&gt;\n" );
    $xml-&gt;start('searchresult');
    for my $term (  @terms  ) {
        $xml-&gt;element( term =&gt; $term );
    }
    for my $item (  sort {
            $a-&gt;[0]{type_nodetype} &lt;=&gt; $b-&gt;[0]{type_nodetype}
        ||  uc($a-&gt;[0]{title}) cmp uc($b-&gt;[0]{title})
        } @match
    ) {
        my( $match, $lines )= @$item;
        $xml-&gt;start(
            'match',
            node_id =&gt; $match-&gt;{node_id},
            type_nodetype =&gt; $match-&gt;{type_nodetype},
            title =&gt; $match-&gt;{title},
        );
        $xml-&gt;element( line =&gt; $_ )
            for  @$lines;
        $xml-&gt;end('match');
    }
    $xml-&gt;end();
    return join '', @data;
}

my $str .=
    $/ . 0+@match . qq[ match(es) found&lt;br /&gt;$/]
  . qq[&lt;table&gt;$/];
for my $item (  sort {
        $a-&gt;[0]{type_nodetype} &lt;=&gt; $b-&gt;[0]{type_nodetype}
    ||  uc($a-&gt;[0]{title}) cmp uc($b-&gt;[0]{title})
    } @match
) {
    my( $match, $lines )= @$item;
    $str .= qq[&lt;tr&gt;&lt;td&gt;]
      . linkNode( $match-&gt;{node_id}, $match-&gt;{title} )
      . qq[&lt;/td&gt;$/&lt;td&gt;]
      . linkNode(
            $match-&gt;{node_id}, $edit,
            { displaytype =&gt; $edit },
            { trusted =&gt; 'yes' } )
      . qq[&lt;/td&gt;$/&lt;td&gt;]
      . linkNode( $match-&gt;{type_nodetype} )
      . qq[&lt;/td&gt;&lt;/tr&gt;$/];
    $str .= qq[&lt;tr class='grep'&gt;&lt;td colspan='3'&gt;$/]
      . htmlcode( 'wrapcode','', join("\n",@$lines) )
      . qq[&lt;/td&gt;&lt;/tr&gt;$/]
        if  $grep;
}
$str .= qq[&lt;/table&gt;$/];
return linkNode(
    $NODE,
    "This Query As Link",
    {   searchterms =&gt; join(";",@terms),
        dogrep =&gt; $grep||0,
        or_terms =&gt; $or_terms||0,
    },
) . "&lt;br/&gt;$/" . $str;
</patch_code>
<applied>2007-03-22 01:56:20</applied>
<htmlcode_id>382266</htmlcode_id>
<live_code>return ''   if  ! $q-&gt;param("searchterms");
my $edit= 'viewcode';
# $edit= 'edit'   if  isGod($USER);
my @terms= split /;/, $q-&gt;param("searchterms");

my $grep= $q-&gt;param('dogrep');
$grep= $VARS-&gt;{sic_dogrep}   if  ! defined $grep;

my $or_terms= $q-&gt;param('or_terms');
$or_terms= $VARS-&gt;{sic_or_terms}   if  ! defined $or_terms;

my @match;
{
    my %fieldOfTable= (
        htmlpage =&gt; 'page',
        htmlcode =&gt; 'code',
        document =&gt; 'doctext',
        container =&gt; 'context',
        nodelet =&gt; 'nlcode',
        setting =&gt; 'vars',
    );
    my %restrictForTable= (
        document =&gt;
            " and type_nodetype in ( "
            . join(
                ",", map {
                    $DB-&gt;sqlSelect( "node_id", "node",
                        qq[type_nodetype=1 and title="$_"] )
                } 'fullpage', 'superdoc', 'rawpage', 'strangedoc', 'script', 'css',
            ) . " ) ",
        htmlcode =&gt;
            " and type_nodetype not in ( "
            . join(
                ",", map {
                    $DB-&gt;sqlSelect( "node_id", "node",
                      qq[type_nodetype=1 and title="$_"] )
                } 'patch'
            ) . " ) ",
        setting =&gt;
            " and type_nodetype not in ( "
            . join( ",", map getId( getType( $_ ) ),
               qw/user zombie_user doclist faqlist tutlist/
            ) . " ) ",
    );

    my $title= '';
    if(  1 == @terms  ) {
        my $like= $terms[0];
        $like =~ s#([%_\\\[\]])#\\$1#g;
        $like =~ s#(['\\])#\\$1#g;
        $title= " or title like '%$like%'"
    }
    for my $table (  keys %fieldOfTable  ) {
        my $sth= $DB-&gt;sqlSelectMany(
            "node_id,title,type_nodetype,$fieldOfTable{$table}",
            "node,$table",
            #my $where=
            "node_id=${table}_id and ( " . join( ($or_terms ? " or " : " and "), map {
                my $quoted= $_;
                $quoted =~ s#([%_\\\[\]])#\\$1#g;
                $quoted =~ s#(['\\])#\\$1#g;
                "$fieldOfTable{$table} like '%$quoted%'"
            } @terms )
            . "$title )" . $restrictForTable{$table},
        );
        #$str .= qq[
        #  where=] . $q-&gt;escapeHTML($where) . qq[
        #  &lt;br /&gt;];
        my $rec;
        while(  $rec= $sth-&gt;fetchrow_hashref()  ) {
            my @lines;
            my $index= 0;
            if(  $grep  &amp;&amp;  $table ne 'setting'  ) {
                LINE:
                foreach my $line (
                    split /\n/, $rec-&gt;{$fieldOfTable{$table}}
                ) {
                    $index++;
                    for my $term (  @terms  ) {
                        if(  0 &lt;= index( lc($line), lc($term) )  ) {
                            push @lines, sprintf "% 4d:%s", $index, $line;
                            next LINE;
                        }
                    }
                }
            }
            push @match, [$rec,\@lines];
        }
        $sth-&gt;finish();
    }
}
{
    my $pmmod= getId( getType('pmmodule') );
    my $sth= $DB-&gt;sqlSelectMany(
        "node_id,title,type_nodetype",
        "node",
        "type_nodetype=$pmmod",
    );
    my $mod;
    $_= lc $_   for  @terms;

MODULE:
    while(  $mod= $sth-&gt;fetchrow_hashref()  ) {
        my $name= $mod-&gt;{title};
        my @mod;
        htmlcode( 'readPmModule','', $name, {}, \@mod );
        my @lines;
        my $lineNo= 0;
        my %matched;
        LINE:
        for my $line (  @mod  ) {
            $lineNo++;
            chomp $line;
            local $_= lc $line;
            my $pushed;
            for my $term (  @terms  ) {
                if(  0 &lt;= index( $_, $term )  ) {
                    $matched{$term}++;
                    if(  $grep  &amp;&amp;  !$pushed  ) {
                        push @lines, sprintf "%4d:%s", $lineNo, $line;
                        $pushed= 1;
                    }
                }
            }
        }
        push @match, [$mod,\@lines]
            if  $or_terms &amp;&amp; @lines  or  keys %matched == @terms;
    }
    $sth-&gt;finish();
}
if(  $q-&gt;param('displaytype') eq 'xml'  ) {
    my @data;
    my $xml_nl= $/;
    $xml_nl= ""   if  grep $_ eq "clean", $q-&gt;param("xmlstyle");
    my $xml= XML::Fling-&gt;new( \@data, "&lt;","&gt;\n","&lt;","&gt;$xml_nl","&lt;","&gt;\n" );
    $xml-&gt;start('searchresult');
    for my $term (  @terms  ) {
        $xml-&gt;element( term =&gt; $term );
    }
    for my $item (  sort {
            $a-&gt;[0]{type_nodetype} &lt;=&gt; $b-&gt;[0]{type_nodetype}
        ||  uc($a-&gt;[0]{title}) cmp uc($b-&gt;[0]{title})
        } @match
    ) {
        my( $match, $lines )= @$item;
        $xml-&gt;start(
            'match',
            node_id =&gt; $match-&gt;{node_id},
            type_nodetype =&gt; $match-&gt;{type_nodetype},
            title =&gt; $match-&gt;{title},
        );
        $xml-&gt;element( line =&gt; $_ )
            for  @$lines;
        $xml-&gt;end('match');
    }
    $xml-&gt;end();
    return join '', @data;
}

my $str .=
    $/ . 0+@match . qq[ match(es) found&lt;br /&gt;$/]
  . qq[&lt;table&gt;$/];
for my $item (  sort {
        $a-&gt;[0]{type_nodetype} &lt;=&gt; $b-&gt;[0]{type_nodetype}
    ||  uc($a-&gt;[0]{title}) cmp uc($b-&gt;[0]{title})
    } @match
) {
    my( $match, $lines )= @$item;
    $str .= qq[&lt;tr&gt;&lt;td&gt;]
      . linkNode( $match-&gt;{node_id}, $match-&gt;{title} )
      . qq[&lt;/td&gt;$/&lt;td&gt;]
      . linkNode(
            $match-&gt;{node_id}, $edit,
            { displaytype =&gt; $edit },
            { trusted =&gt; 'yes' } )
      . qq[&lt;/td&gt;$/&lt;td&gt;]
      . linkNode( $match-&gt;{type_nodetype} )
      . qq[&lt;/td&gt;&lt;/tr&gt;$/];
    $str .= qq[&lt;tr class='grep'&gt;&lt;td colspan='3'&gt;$/]
      . htmlcode( 'wrapcode','', join("\n",@$lines) )
      . qq[&lt;/td&gt;&lt;/tr&gt;$/]
        if  $grep;
}
$str .= qq[&lt;/table&gt;$/];
return linkNode(
    $NODE,
    "This Query As Link",
    {   searchterms =&gt; join(";",@terms),
        dogrep =&gt; $grep||0,
        or_terms =&gt; $or_terms||0,
    },
) . "&lt;br/&gt;$/" . $str;
</live_code>
<reason>Don't show module lines forced to lower case!</reason>
<field>code</field>
</record>
<record><htmlcode_id>390032</htmlcode_id>
<patch_code># Nate sez:  If for some reason the ad server is down, 
# please feel free to comment out the ad IFRAME tag
# BUT, when you do please email me at
#     &lt;nate@oostendorp.net&gt;

# Perlmonks does have some advertising obligations for
# PAIR, and YAS makes a few bucks from some other ads
# but I do need to know when ads are yanked.  Thanks.

q'&lt;a href="http://pair.com"&gt;
 &lt;img src="http://promote.pair.com/i/pair-banner-current.gif"
  height = "60"
  width  = "468"
  alt    = "Beefy Boxes and Bandwidth Generously Provided by pair Networks"
 /&gt;
&lt;/a&gt;';</patch_code>
<applied>2004-09-10 07:35:27</applied>
<htmlcode_id>390030</htmlcode_id>
<live_code># Kurt sez: Here's the new ad code. 
# Pair ads should show up 75% of the time
# ORA ads should show up 25% of the time
# ORA should be yanked after Jan 25, 2006


#my $random = rand;
my $ad_code = "";

#if ($random &gt; .25)
#{  
  $ad_code = '&lt;a href="http://pair.com"&gt;
 &lt;img src="http://promote.pair.com/i/pair-banner-current.gif"
  height = "60"
  width  = "468"
  alt    = "Beefy Boxes and Bandwidth Generously Provided by pair Networks"
 /&gt;
&lt;/a&gt;';
#}
#else
#{
#    $ad_code = '&lt;a #href="http://oreilly.com/promos/perlbooks/?CMP=OTC-FN34
#12256845"&gt;
# &lt;img #src="http://donate.perlfoundation.org/images/perl_style.gif"
#  height = "60"
#  width  = "468"
#  alt    = "OReilly Ad"
# /&gt;
#&lt;/a&gt;';
#}

$ad_code;</live_code>
<reason>Move comment from monkbar2001</reason>
<field>code</field>
</record>
<record><htmlcode_id>394381</htmlcode_id>
<patch_code>my ($NODE, $varsref, $field) = @_;

$field||='vars';

# MAKE SURE THIS NODE IS CHANGED OR REMOVED IF setVar()'s changes!!!!


getRef($NODE);

unless (exists $NODE-&gt;{$field}) {
    warn ("setVars:\t'$field' field does not exist for node $NODE-&gt;{node_id}\n");
}

# Clean out the keys that have do not have a value.
# this code is probably buggy even though it does the same thing as setVars()...

my $str = join("&amp;", map{ 
   $varsref-&gt;{$_} = " " unless $varsref-&gt;{$_};
   "$_=".escape( $varsref-&gt;{$_} )
} sort keys %$varsref );

return unless ($str ne $NODE-&gt;{$field}); #we don't need to update...
# heh, this mostly didnt work in the real setVars()

# The new vars are different from what this user node contains, force
# an update on the user info.
$NODE-&gt;{$field} = $str;
my $superuser = -1;
$DB-&gt;updateNode($NODE, $superuser);
</patch_code>
<applied>2004-09-27 18:49:26</applied>
<htmlcode_id>394379</htmlcode_id>
<live_code>return;
# I code surely wasn't used recently</live_code>
<reason>create, make sorted</reason>
<field>code</field>
</record>
<record><htmlcode_id>764336</htmlcode_id>
<patch_code>###########################################################################
###########################################################################

use Everything::Experience;
use Time::Local;
use Time::Local qw(timegm timelocal);
use POSIX qw(strftime);

return '' if $HTMLVARS{__NOP};

my $basetime=time;

=for myeditor
sub MarkTime {}

=cut

# this is a routine for handling debugging.
my $Do_MarkTime=isGod($USER) &amp;&amp; $q-&gt;param('debug_sandpit');
my @mark_time_html;

local *MarkTime=do {
    my $stime=$basetime;
    my $rtime=$basetime;
    sub {
        return unless $Do_MarkTime;
        my $t=time;
        my $total=$t-$stime;
        my $running=$t-$rtime;
        $rtime=$t;
        push @mark_time_html,"&lt;li&gt;(r/t secs:$running/$total) @_&lt;/li&gt;"
    }
};
$Do_MarkTime &amp;&amp; MarkTime('start');

#===================================================================
# Configuration happens here. Its currently a mess that needs to be
# cleaned up. :-( demerphq
#===================================================================

my $ReaperId = $VARS-&gt;{showreaped} ? -1 : $HTMLVARS{NodeReaperID};


my $as_of=$q-&gt;param('nnt-as-of');
my $as_of_unix;
my $as_of_string;
if ($as_of=~/^(\d{4})-?(\d{2})-?(\d{2})(?: ?(\d{2})(?::?(\d{2})(?::?(\d{2}))?)?)?$/) {
    my ($year,$mon,$mday,$hour,$min,$sec)=($1,$2,$3,$4||0,$5||0,$5||0);
    $as_of_unix=timelocal($sec,$min,$hour,$mday,$mon-1,$year);
} elsif ($as_of=~/^-(\d+)\s*D(ays)?$/i) {
    $as_of_unix=$basetime-($1 * 86400);
    $as_of_string="$1 Days Ago";
} else {     
    $as_of_unix=$basetime;
    $as_of_string="Now!";
}

# fudge as_of_unix so if they go back then return they see the same thing even
# though the time will be very slightly off.
my $fudge=12*3600;
$as_of_unix=$basetime
    if $as_of_unix+$fudge&gt;=$basetime;
$as_of=strftime("'%Y-%m-%d %H:%M:%S'",localtime($as_of_unix));

my @ages=([15*60,         'Steaming' ],
          [30*60,         'Hot'      ],
          [60*60,         'Fresh'    ],
          [2*60*60,       'twohour'  ],
          [4*60*60,       'fourhour' ],
          [8*60*60,       'eighthour'],
          [12*3600,       'Recent'   ],
          [24*3600,       'oneday'   ],
          [2*24*3600,     'twodays'  ],
          [3*24*3600,     'threedays'],
          [4*24*3600,     'fourdays' ],
          [5*24*3600,     'fivedays' ],
          [6*24*3600,     'sixdays'  ],
          [7*24*3600,     'week'     ],

          [30*24*3600,    'month'    ],
          [60*24*3600,    'twomonths'],
          [90*24*3600,    'quarteryear'  ],
          [180*24*3600,   'halfyear' ],
          [365*24*3600,   '-Year'     ],
          [2*365*24*3600, '-TwoYear'],
          [$basetime,     '-Old'],
         );
my (@age_time,@age_desc,@color_classes);

for (@ages) {
    push @age_time,$_-&gt;[0];
    push @age_desc,$_-&gt;[1];
    (my $nnt=$_-&gt;[1])=~s/^-//;
    push @color_classes,"nnt-$nnt";
}

my $Color_Style=htmlcode('colorblend','',0+@ages,\my @colors,$THEME,\@color_classes,
q[
  .nnt-line-incidental .nnt-link { font-style: italic; }
  a.nnt-Steaming,
  a.nnt-Hot,
  a.nnt-Fresh  { font-weight: bold; }
]);
$VARS-&gt;{__nnt_color_style}=$Color_Style;
$Color_Style=$VARS-&gt;{nnt_color_style} if $VARS-&gt;{nnt_color_style};
$Color_Style=qq[
 &lt;style type="text/css"&gt;
 $Color_Style
 &lt;/style&gt;
] unless $Color_Style=~m[&lt;style type="text/css"&gt;];
$Color_Style.=qq[
 &lt;style type="text/css"&gt;
 p.nnt-p { display: inline; }
 p.nnt-p-title { /* width: 70%; */   }
 p.nnt-author  { /* width: 28%; */ }
 .nnt-line-incidental .nnt-link { font-style: italic; }
 tr.this-patch td { font-weight: bold; }
 tr.other-patch td { font-style: italic; }
 a.nnt-Steaming, a.nnt-Hot, a.nnt-Fresh { font-weight: bold; }
 .nnt-noderep,.nnt-nodeattribs,.time-text { font-size: smaller; }
 #nodethreads {  padding-right: 1em;  white-space:normal;}
 #nodethreads ul {  list-style: none;  margin-left: 0;  padding-left: 
 1em;  text-indent: 0em;  white-space:normal;}
 #nodethreads li {width: 100%;}
 #nodethreads ul.expanded {display: block;}
 #nodethreads ul.collapsed {  display: none;}
 &lt;/style&gt;
] if $q-&gt;param('style') eq 'bare';

my $toggle_fmt=qq[&lt;span class='nnt-toggle'&gt;&lt;a href="#ul%s" ]
               .qq[onclick="toggleMenu('ul%s'); return false;"]
               .qq[ class="toggle"&gt;&lt;small&gt;+/-&lt;/small&gt;&lt;/a&gt; &lt;/span&gt;];


# Handle user and param configuration options

my $blk=(getId($USER)!=$HTMLVARS{default_user}
          &amp;&amp; $q-&gt;param('nnt-blk'));
if ($q-&gt;param('Set') eq 'Set') {
  $VARS-&gt;{nnt_blk}=!!$blk;
  $VARS-&gt;{nnt_toggle_left}=!!$q-&gt;param('nnt-toggle-left');
  $VARS-&gt;{nnt_showage}=!!$q-&gt;param('showage');
  $VARS-&gt;{nnt_showtime}=!!$q-&gt;param('showtime');
}

my $cfg=getId($USER)!=$HTMLVARS{default_user}
     &amp;&amp; $q-&gt;param('nnt-cfg');

my %blocked;
if ($blk) {
    my $do_update=$q-&gt;param('Update') eq 'Update Blocking';
    if ($do_update and $q-&gt;param('nnt-clear-oldblocking') eq 'clear') {
        $VARS-&gt;{nnt_blocknodes}="";
    }
    %blocked=unpack "N*",$VARS-&gt;{nnt_blocknodes}||'';
    $blocked{$_}&lt;$basetime-48*3600 and delete $blocked{$_}
      for keys %blocked;
    $blocked{$_}=$basetime foreach grep {
         s/nnt-hide-// &amp;&amp; $q-&gt;param("nnt-hide-$_") eq "hide"
    } $q-&gt;param();
    my @keys=sort { $blocked{$b}&lt;=&gt;$blocked{$a} || $b &lt;=&gt; $b } keys %blocked;
    delete $blocked{pop @keys} while @keys&gt;128;
    if ($do_update) {
        $VARS-&gt;{nnt_blocknodes}=pack "N*",%blocked
    }
    $Do_MarkTime and MarkTime("blocknodes:@{[keys %blocked]}");
}

my $NICK=$USER-&gt;{nick} ? getNode($USER-&gt;{nick},'user') : undef;
my $USER_ID=$NICK ? $NICK-&gt;{user_id} : $USER-&gt;{user_id};

my $isGod= isGod($USER);
my $can_consider=Everything::isApproved($USER,'CanConsider');

my $APPROVAL_SETTING = getVars(
    getNode('approval nodelet settings','setting')
  );
my %approval_types = map { $_ =&gt; 1 } split /,/, $APPROVAL_SETTING-&gt;{types};
$can_consider=0
    if 0 &lt;= index( $APPROVAL_SETTING-&gt;{inconsiderate}, "[$USER-&gt;{title}]" )
    || 0 &lt;= index( $APPROVAL_SETTING-&gt;{inconsiderate}, "[$USER-&gt;{node_id}]" )
    || 0 &lt;= index( $APPROVAL_SETTING-&gt;{inconsiderate}, "[$USER_ID]" )
    || ($NICK and 0 &lt;= index( $APPROVAL_SETTING-&gt;{inconsiderate}, "[$NICK-&gt;{title}]" ))
;

my $mode = $q-&gt;param('mode');
$mode=undef unless $mode=~/(?:fullthread|root-and-node|minimal|ancestors)/;
$mode = $VARS-&gt;{nnt_mode} unless defined $mode; # setting this is handled above
$mode = 'ancestors' unless $mode;
$VARS-&gt;{nnt_mode}=$mode;
$mode='ancestors' if $q-&gt;param('style') eq 'bare'; # dontoveride user $VARS with this.

if ( getId($USER) != $HTMLVARS{default_user} ) {
  if ( $q-&gt;param('viewedNewNodes') ) {
    $VARS-&gt;{lastviewednewestnodes} = $q-&gt;param('pageloadtime');
  }

  if ( $q-&gt;param('clearNewNodesFlag') ) {
    $VARS-&gt;{lastviewednewestnodes} = '';
  }
}
my $when = $as_of_unix!=$basetime ? 0 : $VARS-&gt;{lastviewednewestnodes}||0;
if ($when) {
    my $oldest=time-3*24*60*60;
    $when=$oldest if $when&lt;$oldest;
}

my $days = $q-&gt;param('numdays')||0;
$days = 1 if !$days or $days !~ /^\d+(\.\d+)?$/;
$days = 3 if $days &gt; 3;

my @for_nodes;
if (my $csv=$q-&gt;param('for_nodes')) {
  $mode="fullthread";
  @for_nodes=map /^\s*(\d+)\s*$/?$1:(),split /\s*[,:;]\s*/,$csv;
  splice @for_nodes,10 if @for_nodes&gt;10;
}


my $maxdepth = $q-&gt;param('maxdepth');
$maxdepth = $VARS-&gt;{nnt_maxdepth} unless defined $maxdepth;
# $maxdepth = $VARS-&gt;{notedepth} unless defined $maxdepth; # just confuses issues
$maxdepth=2 unless defined $maxdepth;
$VARS-&gt;{nnt_maxdepth} = $maxdepth if defined $maxdepth;
$maxdepth=1 if $cfg;

my $showtime=$q-&gt;param('showtime');
$VARS-&gt;{nnt_showtime}=$showtime if $q-&gt;param('Set')
                                or $q-&gt;param('clearNewNodesFlag');
my $showage=$q-&gt;param('showage');
$VARS-&gt;{nnt_showage}=$showage if $q-&gt;param('Set')
                                or $q-&gt;param('clearNewNodesFlag');

my $cutoffdate = $mode eq 'fullthread'
               ? 0
               : $when
                 ? $when
                 : time - $days * 24 * 3600;



my %order=split /,/,$VARS-&gt;{nnt_order};
if ($cfg &amp;&amp; $q-&gt;param('Change') eq 'Change Order') {
    my @fields=map { s/^nnt_pos_// ? $_ : ()  } $q-&gt;param;
    my %hide;
    for (@fields) {
        $order{$_}=$q-&gt;param("nnt_pos_$_");
        if (!$order{$_}) {
            $hide{$_}=1;
        }
    }
    $VARS-&gt;{nn_hide_nodetypes}=join ",", keys %hide;
    $VARS-&gt;{nnt_order}=join",",map { $_,$order{$_} } keys %order;
}


my $nn = {};
htmlcode( 'handle_nn_settings', '', $nn );
my %types;
my @types = map {
    my $type = getType( $_ );
    $types{ $type-&gt;{node_id} } = $type;
    $types{$_} = $type;
    $type-&gt;{node_id};
} @{ $nn-&gt;{legal} };
return "No types?" unless @types;
my %want=map { $_=&gt;$types{$_},$types{$_}{node_id}=&gt;$types{$_} }
         @{$nn-&gt;{types}};

# @html will ultimately hold the returned HTML, we start off with a
# header of the params
my @html = (qq(
&lt;!--
NNT: \$mode=$mode|\$maxdepth=$maxdepth
     \$days=$days|\$when=$when|\$cutoffdate=$cutoffdate|time=@{[time]}
     \@types=(@types)
--&gt;
));

#===========================================================================
# Tree and DB Code. We handle constructing the tree and the main queries here
#===========================================================================

my %node;
my %authors;
my $notes;
my @roots;

=for myeditor
sub add_node_to_tree {}

=cut

#
# This sub integrates the node into the tree. Since we have a parent pointer
# system where we can't be guaranteed the parent exists and to minimize queries
# we build it from the bottom up.
# This process can generate a final set of objects which werent picked up in the
# original two queries which are for node which have sane note tables.
# These are then added in at the end as a series of adhoc queries. In most
# situations these are no adhoc performed.
#

local *add_node_to_tree=sub{
    my ($n,$notree)=@_;
    my $node_id =$n-&gt;{node_id};
    return unless $node_id;
    $node{$node_id}||={};
    @{ $node{$node_id} }{ keys %$n } = values %$n;

    $n=$node{$node_id};
    my $author = $n-&gt;{author_user};
    $n-&gt;{author_user} = $author = $n-&gt;{original_author} if $n-&gt;{original_author};
    $authors{$author}||=getNodeById($author,'light');

    return if $notree || $n-&gt;{_intree}++;



    if ($n-&gt;{type_nodetype}==1888) {
        $n-&gt;{root_node}||=$n-&gt;{parent_node}
            if $n-&gt;{parent_node};
    }
    push @roots, $n-&gt;{root_node} if $n-&gt;{root_node};

    for (qw(root_node parent_node)) {
        next unless $n-&gt;{$_};
        $node{ $n-&gt;{$_} } ||= { node_id =&gt; $n-&gt;{$_} };
        $n-&gt;{"_$_"} = $node{ $n-&gt;{$_} }
    }
    $n-&gt;{_root_node}{_descendents}{$node_id} = $n
      if $n-&gt;{root_node};
    $n-&gt;{_parent_node}{_children}{$node_id} = $n
      if $n-&gt;{parent_node};
    $n-&gt;{_root_node}{__newest}=$n
        if !$n-&gt;{_root_node}{__newest}
        or $n-&gt;{_root_node}{__newest}{node_id} &lt; $n-&gt;{node_id};
    return $n;
};


##### DB STUFF

my $dbh = $DB-&gt;getDatabaseHandle();


# we build up a generic where clause here. Depending on the args
# it can look fairly different.

my $in_nodetype = qq/type_nodetype in (@{[join ",",@types]})/;
my $where_time;
if (@for_nodes==1) {
  $where_time="node_id=@for_nodes";
} elsif (@for_nodes) {
  $where_time="node_id in ( ".join(",",@for_nodes)." )";
} else {
  $where_time ="createtime &gt;= ".(
    $when
      ? "FROM_UNIXTIME($when)"
      : "DATE_ADD($as_of,INTERVAL -$days DAY)"
  ). " and createtime &lt;= $as_of ";
}


$Do_MarkTime &amp;&amp; printLog("demerphq's sandpit query 1 start ($$)");
$Do_MarkTime &amp;&amp; MarkTime("demerphq's sandpit query 1 start ($$)");


my ($tquery,$rquery,$nquery); # query text for the different queries.

#get the most recent nodes
my $recent = $dbh-&gt;selectall_hashref($tquery=qq[
    select distinct
           node.*,
           note.*,
           original_author,
           weight,votetime,
           considernodes.considernodes_id,
           considernodes.description as considertext
    from node
    left join note on note_id=node_id
    left join vote on (vote_id=node_id and voter_user=$USER_ID)
    left join considernodes on considernodes_id=node_id
    left join contributor on contributor_id=node_id
    where $in_nodetype
    and $where_time
    limit 2000
], 'node_id' ) or return "Error in initial fetch.";

$Do_MarkTime &amp;&amp; MarkTime("demerphq's sandpit query 1 end ($$)&lt;br&gt;&lt;b/&gt;$tquery&lt;/b&gt;");
$Do_MarkTime &amp;&amp; printLog("demerphq's sandpit query 1 end ($$)");

# add them in
foreach my $n ( sort { $a-&gt;{node_id} &lt;=&gt; $b-&gt;{node_id} } values %$recent ) {
    my $node=add_node_to_tree($n);
    $node-&gt;{_recent}=1;
}

push @roots,@for_nodes; # add in the for_nodes to the first batch
my %dupe_root;
my $fetches=0;

$Do_MarkTime &amp;&amp; MarkTime("while roots=(@roots)");

# we actually only do this twice.
# the first query grabs any parents we didnt already have.
# the second query grabs any siblings we didnt already have.
while (@roots)
{
    if ($blk) {
        @roots=grep !$blocked{$_},@roots;
    }
    @roots=sort {$a &lt;=&gt; $b} grep $_ &amp;&amp; !$dupe_root{$_}++,@roots;
    $Do_MarkTime &amp;&amp; MarkTime("after roots=(@roots)");
    last if $fetches++&gt;1;
    last unless @roots;

    local $" = ', ';    #"
    $Do_MarkTime &amp;&amp; printLog("demerphq's sandpit query 2 start pass $fetches($$)");
    my @fetchroots=grep{ !$node{$_}{_recent} } @roots;
    my $roots;
    if (@fetchroots) {
      $roots = $dbh-&gt;selectall_hashref($rquery=qq[
          select node.*,
                 note.*,
                 original_author,
                 weight,votetime,
                 considernodes.considernodes_id,
                 considernodes.description as considertext
          from node
          left join note on node_id=note_id
          left join considernodes on considernodes_id=node_id
          left join contributor on contributor_id=node_id
          left join vote on (vote_id=node_id and voter_user=$USER_ID)
          where node_id in ( @fetchroots )
          and $in_nodetype
      ], 'node_id' ) or return "Error in Note Nodes Fetch.";
    } else {
      $roots={};

    }
    foreach my $n ( sort { $a-&gt;{node_id} &lt;=&gt; $b-&gt;{node_id} } values %$roots ) {
        add_node_to_tree($n);
    }

    @roots=grep { ($node{$_}{_recent} || $roots-&gt;{$_} )
                  &amp;&amp; $node{$_}{type_nodetype}!=1823
                  &amp;&amp; $want{$node{$_}{type_nodetype}} } @roots;
    if ($blk) {
        @roots=grep !$blocked{$_},@roots;
    }
    $Do_MarkTime &amp;&amp; MarkTime("demerphq's sandpit query 2 end (got "
      .scalar(@roots).") pass $fetches ($$)&lt;br/&gt;&lt;b&gt;$rquery&lt;/b&gt;&lt;br /&gt;roots=(@roots)");
    $Do_MarkTime &amp;&amp; printLog("demerphq's sandpit query 2 end (got "
      .scalar(@roots).") pass $fetches ($$)");
    if (@roots) {
      $notes = $dbh-&gt;selectall_arrayref($nquery=qq[
          select node.*,
                 note.*,
                 original_author,
                 weight,votetime,
                 considernodes.considernodes_id,
                 considernodes.description as considertext
          from node
          join note          on node.node_id = note.note_id
     left join considernodes on considernodes_id=node_id
     left join contributor   on contributor_id=node_id
     left join vote          on (vote_id=node_id and voter_user=$USER_ID)
          where (
              root_node in ( @roots )
          )
          and not ( $where_time )
          limit 2000
      ], { Slice =&gt; {} } ) or return "Error in Note Nodes Fetch.";

    } else {
      $notes=[];
    }

    $Do_MarkTime &amp;&amp; MarkTime("demerphq's sandpit query 3 end (got "
       .scalar(@$notes).") pass $fetches ($$)&lt;br/&gt;&lt;b&gt;$nquery&lt;/b&gt;");
    $Do_MarkTime &amp;&amp; printLog("demerphq's sandpit query 3 end (got "
       .scalar(@$notes).") pass $fetches ($$)");

    @roots=();
    foreach my $n ( sort { $a-&gt;{node_id} &lt;=&gt; $b-&gt;{node_id} } @$notes ) {
        add_node_to_tree($n);
    }
}

#
# This does an explain on the queries used, and writes them into a scratchpad
# it could probably be removed, but for now we will leave it as it is useful.
#

if ($Do_MarkTime and $USER-&gt;{title}=~/merphq/) {
    my @out;
    foreach my $str ($tquery,$rquery,$nquery)
    {
      next unless $str;
      my $r=$DB-&gt;getDatabaseHandle()-&gt;selectall_arrayref("explain $str");
      $str=~s/(\S)([,=])(\S)/$1 $2 $3/g;
      push @out,"&lt;dt&gt;$str&lt;/dt&gt;","&lt;dd&gt;&lt;table border='1'&gt;&lt;tr&gt;&lt;td&gt;".
               join("&lt;/td&gt;&lt;/tr&gt;\n&lt;tr&gt;&lt;td&gt;",map { join "&lt;/td&gt;\n&lt;td&gt;",
               map { length $_ ? $_ : '&amp;nbsp;' } @$_ } @$r)

               ."&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/dd&gt;";

    }
    my $sp=getNodeById(379341);

    my $out=join "\n","&lt;dl&gt;@out&lt;/dl&gt;";
    my ($exp,$lain)=("&lt;!--explain-$NODE-&gt;{node_id}--&gt;",
                     "&lt;!--\/explain-$NODE-&gt;{node_id}--&gt;");
    unless ($sp-&gt;{doctext}=~s/($exp).*($lain)/$1\n$out\n$2/s) {
        $sp-&gt;{doctext}="&lt;!--explain--&gt;\n$exp\n$out\n$lain\n&lt;!--/explain--&gt;\n";
    }
    updateNode($sp,-1);
}

$Do_MarkTime &amp;&amp; printLog("demerphq's sandpit ad-hoc fetch start ($$)");
$Do_MarkTime &amp;&amp; MarkTime("demerphq's sandpit ad-hoc fetch start ($$)");

#
# AdHoc queries. We add them in but dont update any parents. These nodes are
# usually problematic anyway, and their parents likely dont exist.
#
foreach my $id (keys %node) {
    my $node=$node{$id};

    if (!$node-&gt;{type_nodetype} and !$node-&gt;{author_user} and !$node-&gt;{_adhoc}) {
        my @keys=keys %$node;
        my $n=getNodeById($node-&gt;{node_id});
        $node-&gt;{_adhoc}=1;
        if ($n) {
            add_node_to_tree($n,'notree');
            $Do_MarkTime &amp;&amp; MarkTime("Added:".linkNode($node)
              ."&lt;br/&gt; nid:$node-&gt;{node_id} pid:$node-&gt;{parent_node} "
              ."rid:$node-&gt;{root_node} type:$node-&gt;{type_nodetype}".'&lt;br /&gt;'
              ."_desc:".join(',',keys %{$node-&gt;{_descendents}||{}}).'&lt;br /&gt;'
              ."_child:".join(',',map { "($_=&gt;$node-&gt;{_children}{$_}{type_nodetype}".
                                        ":$node-&gt;{_children}{$_}{root_node}:".
                                        "$node-&gt;{_children}{$_}{title})"}
                                        keys %{$node-&gt;{_children}||{}}).'&lt;br /&gt;'
              ."_keysa:".join(',',keys %$node).'&lt;br /&gt;'
              ."_keysb:".join(',',@keys).'&lt;br /&gt;');
        } else {
            $Do_MarkTime &amp;&amp; MarkTime("Bad node $id");
            $node-&gt;{_orphan}=1;
            next;
        }
    }
    my $tnode =( $types{$node-&gt;{type_nodetype}} ||=
                 getNodeById($node-&gt;{type_nodetype}) );
    my $typetitle=$tnode-&gt;{title};
    $node-&gt;{_type_title}=$typetitle;
}
$Do_MarkTime &amp;&amp; printLog("demerphq's sandpit ad-hoc end ($$)");

#===================================================================
# Now we define some subs to be used to build the tree.
# make_li() is the main routine
#===================================================================

=for myeditor
sub get_approval {}

=cut

#
# Handles approval queries.
#
local *get_approval=sub {

    my ($node)=@_;
    my $typetitle=$node-&gt;{_type_title};
    return $node-&gt;{_haslinks} if defined $node-&gt;{_haslinks};
    if ($approval_types{$typetitle}
         || grep $_ eq $typetitle,
         qw/modulereview bookreview
            note sourcecode snippet
            perltutorial perlnews/
    ) {
        my $nid = $node-&gt;{node_id};

        my $ok=0;
        $ok = $dbh-&gt;selectrow_hashref(qq[
              select *
              from links
              where from_node = $APPROVAL_SETTING-&gt;{$typetitle.'_node'}
              and to_node = $nid
              and linktype = $APPROVAL_SETTING-&gt;{$typetitle.'_linktype'}
              limit 1
        ]) if $approval_types{$typetitle};

        my $fp=0;
        $fp = $dbh-&gt;selectrow_hashref(qq[
              select *
              from links
              where from_node= $APPROVAL_SETTING-&gt;{front_page}
              and to_node = $nid
              and linktype = $APPROVAL_SETTING-&gt;{frontpage_linktype}
              limit 1
        ]);

        $node-&gt;{_ok_user} = $DB-&gt;sqlSelect(
            'user_id',
            'approved',
            qq[node_id = $nid and action = "ok"],
            "order by tstamp desc limit 1"
        ) if $ok;

        my $fpid = 0;
        $node-&gt;{_fp_user} = $DB-&gt;sqlSelect(
            'user_id',
            'approved',
            qq[node_id = $nid and action = "fp"],
            "order by tstamp desc limit 1"
        ) if $fp;

        $node-&gt;{_approval_type}=$approval_types{$typetitle};
        $node-&gt;{_haslinks}=1;
        $node-&gt;{_fp}=$node-&gt;{_fp_user} ? $fp : undef;
        $node-&gt;{_ok}=$node-&gt;{_ok_user} ? $ok : undef;
        return 1
    } else {
        $node-&gt;{_haslinks}=0;
        return 0;
    }
};

=for myeditor
sub node_details {}

=cut

#
# Handles building the node specific content of the li.
#

local *node_details=sub {
    my ($node,$showauthor,$showkids)=@_;

    my $localized=htmlcode('parseTimeInString','',$node-&gt;{createtime},'','','short');
    my ( $year, $mon, $day, $hour, $min, $sec ) =
      $node-&gt;{createtime} =~ /^(\d{4})-(\d{2})-(\d{2})\s+(\d{2}):(\d{2}):(\d{2})$/;
    my $time = $year ? timelocal( $sec, $min, $hour, $day, $mon - 1, $year ) : 0;
    my $timesince=htmlcode('timesince','',$node-&gt;{createtime});

    my $elapsed=$basetime-abs($time);
    my $index=0;
    $index++ while ($elapsed&gt;$age_time[$index]);
    #my $color=$colors[$index];
    my $class=$color_classes[$index];

    my @p_class=($class);

    my $nodetext='';

    my $title= length($node-&gt;{title}) 
               ? $q-&gt;escapeHTML($node-&gt;{title}) 
               : "&amp;#91;untitled node, ID $node-&gt;{node_id}&amp;#93;";

    $title =    qq[&lt;a class="nnt-link $class" href="?node_id=$node-&gt;{node_id}" ]
              . qq[title="Created at $localized ($timesince)"  &gt;]
              . $title
              . qq[&lt;/a&gt;\n];

    if ($USER_ID == $node-&gt;{author_user}
        || $USER-&gt;{user_id} == $node-&gt;{author_user}
        || $node-&gt;{votetime} || $node-&gt;{weight})
    {
        my ($cl,$v)=!$node-&gt;{weight}
                     ? ("","")
                     :  $node-&gt;{weight}&gt;0
                        ? ("nnt-plusplus","^")
                        : ("nnt-minusminus","v");
        push @p_class,$cl if $cl;
        $title.="&lt;span class='nnt-noderep'&gt;&amp;#91;"
              .($cl ? "&lt;span class='$cl'&gt;$v&lt;/span&gt;" : "")
              . "&lt;span class='nnt-reputation'&gt;"
              . ($node-&gt;{reputation}&gt;=0 ?  $node-&gt;{reputation} : '-X')
              . "&lt;/span&gt;&amp;#93;&lt;/span&gt;";
    }
    unless ($node-&gt;{_recent}) {
        $title="&lt;span class='nnt-incidental'&gt;$title&lt;/span&gt;";
        push @p_class,"nnt-line-incidental";
    }


    my $kidstuff;
    if ($node-&gt;{__kids}) {
        my @list=($node-&gt;{__kids});
        $list[-1]!=$_ and push @list,$_
            for $node-&gt;{__desc},$node-&gt;{__recent};
        if ($list[-1]==0) {
            pop @list;
        } else {
            $list[-1]="&lt;b&gt;$list[-1]&lt;/b&gt;";
        }
        $kidstuff="&lt;span class='nnt-kidstuff'&gt;".join("/",@list)."&lt;/span&gt;";
        push @p_class,'nnt-line-haskids';
    }
    my $plinks="";
    my $shown=0;
    my $root=$node-&gt;{_root_node};
    my $parent=$node-&gt;{_parent_node};
    if ($parent-&gt;{node_id} and !$parent-&gt;{_show}
        and $parent-&gt;{node_id}!=$shown)
    {
        my $str="Parent: '$parent-&gt;{title}' by ".
               "'$authors{$parent-&gt;{author_user}}-&gt;{title}'";
        $str=$q-&gt;escapeHTML($str);
        $str=~s/[""]/&amp;quot;/g;
        $plinks.="&lt;span class='nnt-parentlink'&gt;".linkNode($parent,'P',{-title=&gt;$str})."&lt;/span&gt;";
        $shown=$parent-&gt;{node_id};
    }
    if ($root-&gt;{node_id} and !$root-&gt;{_show}
        and $root-&gt;{node_id}!=$shown)
    {
        my $str="Root: '$root-&gt;{title}' by '$authors{$root-&gt;{author_user}}-&gt;{title}'";
        $str=$q-&gt;escapeHTML($str);
        $str=~s/[""]/&amp;quot;/g;
        $plinks.="&lt;span class='nnt-rootlink'&gt;".linkNode($root,'R',{-title=&gt;$str})."&lt;/span&gt;";
        $shown=$root-&gt;{node_id};
    }
    if ($can_consider &amp;&amp; $node-&gt;{considernodes_id}) {
        my $txt = htmlcode( 'parselinksinchatter','', $node-&gt;{considertext} );
        for ($txt) {
	    s/&lt;a href=.+?&gt;/Considered by /;
	    s|&lt;/a&gt;|:|;
	    s{&lt;a href=.+?&gt;|&lt;/a&gt;|[""]}{&amp;quot;}g;
        }                      
        $plinks.="&lt;span class='nnt-considerlink'&gt;"
               .qq[&lt;a href='?node=Nodes%20To%20Consider;]
               .qq[#consider-row-id$node-&gt;{node_id}' ]
               .qq[title="$txt" target="_blank"&gt;C&lt;/a&gt;&lt;/span&gt;];
        push @p_class,"nnt-line-considered";
    }
    if (get_approval($node)) {
        if ($node-&gt;{_fp} &amp;&amp; !$node-&gt;{considernodes_id}) {
            my $user=$authors{$node-&gt;{_fp_user}}
                     ||=getNodeById($node-&gt;{_fp_user},'light');
            $plinks.="&lt;span class='nnt-fplink'&gt;"
                   .qq[&lt;a href='?node_id=131#post-head-id$node-&gt;{node_id}' ]
                   .qq[title="Frontpaged by '$user-&gt;{title}'" target="_blank"&gt;F&lt;/a&gt;&lt;/span&gt;];
            push @p_class,"nnt-line-fp";
        }
        if ($node-&gt;{_approval_type}) {
            my $t;
            if (my $ok_id=$node-&gt;{_ok_user}) {
                my $user=$authors{$ok_id}||=getNodeById($ok_id,'light');
                $t=linkNode($user,'A',{-title=&gt;"Approved by '$user-&gt;{title}'"});
                push @p_class,"nnt-line-approved";
            } elsif (!($node-&gt;{_fp} &amp;&amp; !$node-&gt;{considernodes_id})) {
                $t="&lt;span class='nnt-unapproved'&gt;U&lt;/span&gt;";
                push @p_class,"nnt-line-unapproved";
            }
            $plinks.="&lt;span class='nnt-approval'&gt;$t&lt;/span&gt;";

        }
    }
    $plinks="&lt;span class='nnt-speciallinks'&gt;$plinks&lt;/span&gt;" if $plinks;
    if ($plinks or $kidstuff) {
        $kidstuff=":".$kidstuff
            if $plinks &amp;&amp; $kidstuff;
        $title.="&lt;span class='nnt-nodeattribs'&gt;($plinks$kidstuff)&lt;/span&gt;";
    }
    if ($showkids) {
        my $toggle=sprintf $toggle_fmt,$node-&gt;{node_id},$node-&gt;{node_id};
        if ($VARS-&gt;{nnt_toggle_left}) {
            $title=$toggle.$title;
        } else {
            $title.=$toggle;
        }
    }
    $title .= $q-&gt;checkbox(-name=&gt;'nnt-hide-'.$node-&gt;{node_id},
                           -checked=&gt;0,
                           -value=&gt;'hide',
                           -label=&gt;'',
                           -class=&gt;'nnt-hide',
                           -title=&gt;'Hide node and children for 24 hours?',
                           -force=&gt;0,)
        if $blk;
    $nodetext .="&lt;span class='nnt-title'&gt;$title&lt;/span&gt;";


    if ($VARS-&gt;{nnt_showtime} || $VARS-&gt;{nnt_showage}) {
      my $time_text="&lt;span class='time-text'&gt;";
      $time_text.="&lt;span class='nnt-time'&gt; $localized&lt;/span&gt;"
        if $VARS-&gt;{nnt_showtime};
      $time_text.="&lt;span class='nnt-timesince'&gt; $timesince&lt;/span&gt;"
        if $VARS-&gt;{nnt_showage};
      $nodetext.=$time_text."&lt;/span&gt;";
    }
    if ($node-&gt;{type_nodetype} ==112733) { #patch
       my $N=getNodeById($node-&gt;{node_id});
       $nodetext.="&lt;span class='nnt-patch-reason'&gt;&lt;br /&gt;("
                .htmlcode( 'parselinksinchatter','', $N-&gt;{reason} )
                .")&lt;/span&gt;";
    }
    push @p_class,'nnt-line-span',"nnt-line-author-$node-&gt;{author_user}";

    $nodetext ="&lt;p class='nnt-p-title nnt-p' align='left'&gt;$nodetext&lt;/p&gt;\n"
              ."&lt;p align='right' class='nnt-p nnt-author "
              ."nnt-author-$node-&gt;{author_user}'&gt; &amp;#91;"
              . linkNode( $node-&gt;{author_user} )
                # ,undef,{-target=&gt;'_blank'} )
              . "&amp;#93;&lt;/p&gt;"
      if $showauthor;
    @p_class=map {
               map { s/^nnt-(?!line)(.*)$/nnt-line-$1/g; $_} split / /,$_
             } "nnt-line",@p_class;
    return "&lt;!--\n\$NODE-&gt;{node_id}=$NODE-&gt;{node_id}--&gt;&lt;div class='"
           .join(" ",@p_class)."'&gt;"
           .$nodetext."&lt;/div&gt;&lt;!--\n--&gt;";
};

=for myeditor
sub make_li {}

=cut

#
# make_li is the main routine, it traverses the tree and builds the html
# based on the various config settings, and the tree and depth information
# previously aquired. The actual node text is handled by node_details
#

local *make_li = sub {
    my ( $node, $showauthor, $html, $depth ) = @_;
    $depth ||= 1;
    return if $blocked{$node-&gt;{node_id}};
    # dupecheck
    if (!$node or $node-&gt;{_make_li}++) {
      push @$html,
        "&lt;li&gt;Error: id://$node-&gt;{node_id} : parent://$node-&gt;{parent_node} "
       .": root://$node-&gt;{root_node}&lt;br/&gt;$node-&gt;{title}&lt;/li&gt;";
      return
    }

    my ($show,$showkids)=(1,$node-&gt;{__kids});
    if ($mode eq 'root-and-node' or $mode eq 'minimal') {
        $show=($node-&gt;{_recent} || ($mode ne 'minimal' and $depth==1));
        $showkids&amp;&amp;=$show &amp;&amp; $node-&gt;{__recent};
    } elsif ($mode eq 'ancestors') {
        return unless $node-&gt;{__recent}||$node-&gt;{_recent};
        $showkids&amp;&amp;=$node-&gt;{__recent};
    }
    if ($node-&gt;{author_user}==$ReaperId and !$node-&gt;{__kids}) {
        return;
    }
    $node-&gt;{_show}=$show;
    if ($show) {
        my $nodetext=node_details($node,$showauthor,$showkids);
        push @$html,"&lt;li id='li$node-&gt;{node_id}' "
                   ."class='nnt-depth-$depth nnt-auth-$node-&gt;{author_user}'&gt;"
                   .$nodetext;
    }

    if ( my $kids=$node-&gt;{_children} ) {
        my $state='expanded';
        $state='collapsed' if $maxdepth &amp;&amp;  (($depth==$maxdepth) or
          ($node-&gt;{_parent_node} and !$node-&gt;{_parent_node}{_show} and $depth&gt;$maxdepth));
        push @$html, "&lt;ul class='$state' id='ul$node-&gt;{node_id}'&gt;" if $showkids;
        if ($q-&gt;param('style') eq 'bare') {
            make_li( $node-&gt;{__newest}, $showauthor, $html, $depth + 1 );
        } else {
            foreach my $node_id ( sort { $a &lt;=&gt; $b } keys %{$kids} ) {
                make_li( $kids-&gt;{$node_id}, $showauthor, $html, $depth + 1 );
            }
        }
        push @$html, '&lt;/ul&gt;'
          if $showkids;
    }
    push @$html, '&lt;br class="nnt-br" /&gt;' if $mode ne 'minimal' and $show and $depth==1;
    push @$html, '&lt;/li&gt;'  if $show;
};

=for myeditor
sub count_kids {}

=cut

### count_kids() is an initial traversal that doesn't involve
### actually building the tree. This is where depths children
### counts are determined.


local *count_kids=sub {
    my ($node,$depth)=@_;

    return if $blocked{$node-&gt;{node_id}};
    $depth||=1;
    if ($node-&gt;{__depth}) {
        $Do_MarkTime &amp;&amp; MarkTime(
           "bad recursion: $node-&gt;{node_id} | $node-&gt;{__depth} | $depth!"
        );
        return;
    }
    $node-&gt;{__depth}=$depth;
    my $desc=0;
    my $recent=0;
    if ( my $kids = $node-&gt;{_children} ) {
        foreach my $node_id ( sort { $a &lt;=&gt; $b } keys %{$kids} ) {
            my ($count,$krecent)=count_kids($kids-&gt;{$node_id},$depth+1);
            $desc+=$count;
            $recent+=$krecent;
            $node-&gt;{__kids}++ unless $kids-&gt;{$node_id}{author_user}==$ReaperId;
        }
    } else {
        $node-&gt;{__kids}=0;
    }
    $node-&gt;{__desc}=$desc;
    $node-&gt;{__recent}=$recent;
    return ($desc+1,$recent+($node-&gt;{author_user}!=$ReaperId ? $node-&gt;{_recent}||0 : 0));
};

# Now we get the root nodes that arent blocked.
my @nodes = sort { $b-&gt;{node_id} &lt;=&gt; $a-&gt;{node_id} }
            grep { $_-&gt;{node_id} &amp;&amp; !$_-&gt;{root_node} &amp;&amp; !$blocked{$_-&gt;{node_id}} }
            values %node;


$Do_MarkTime &amp;&amp; MarkTime("Main loop start. ".scalar(@nodes)
                         ."nodes. Want types:".join(",",%want));
my (%sect,@toc);
# Loop over the root nodes and split them into their types.
foreach my $node (@nodes) {
    next unless $node-&gt;{type_nodetype};
    next if $node-&gt;{_orphan};
    my $typetitle=$node-&gt;{_type_title};
    next unless $typetitle &amp;&amp; $want{$typetitle};

    my ( $title, $link,
         $showauthor, $linkoff ) = @{ $nn-&gt;{typedata}{ $typetitle } };
    ( my $anchor    = $title ) =~ s/\s/-/g;


    unless ($sect{$typetitle}) {
        $sect{$typetitle}{html}=[];
    }
    my ($kids,$recent)=count_kids($node);
    if ($recent) { #sanity check
        $sect{$typetitle}{html}||=[];
        make_li( $node, $showauthor, $sect{$typetitle}{html} );
    }
    $Do_MarkTime &amp;&amp; MarkTime("*$typetitle $node-&gt;{node_id} $node-&gt;{title}");
}



#===============================================================
# Now we sort the groups and filter out ones we arent interested in
# to put together the sections.

my @fixed = #grep $types{$_}-&gt;{title} ne 'perlquestion',
            @{($cfg ? $nn-&gt;{legal} : $nn-&gt;{types})||[]};

my $count=@html;

my $blocking_submit=qq[&lt;input type="submit" name="Update" value="Update Blocking" /&gt;];

my $pos=0;
foreach my $typerec (sort {!!$b-&gt;[2] &lt;=&gt; !!$a-&gt;[2]
                           || $a-&gt;[2] &lt;=&gt; $b-&gt;[2]
                             || $a-&gt;[0] &lt;=&gt; $b-&gt;[0] }
                       map { [$_,$fixed[$_],$order{$fixed[$_]},] }
                       0..$#fixed)
{
    my ($old_pos,$typetitle)=@$typerec;
    next unless $cfg or $sect{$typetitle};
    next unless $cfg or @{$sect{$typetitle}{html}};
    @{$sect{$typetitle}{html}}=grep $_=~/\S/,@{$sect{$typetitle}{html}};
    next unless $cfg or @{$sect{$typetitle}{html}};

    my ( $title, $link,
         $showauthor, $linkoff ) = @{ $nn-&gt;{typedata}{ $typetitle } };
    ( my $anchor    = $title ) =~ s/\s/-/g;
    ( my $toc_title = $title ) =~ s/ /&amp;nbsp;/g;
    $sect{$typetitle}{toc}=$q-&gt;a( { href =&gt; "#toc-$anchor" }, $toc_title );

    my $top = '&amp;nbsp;&lt;font size="2"&gt;'
            . $q-&gt;a( { href =&gt; "#toc-top" }, "(Top)" )
            . '&lt;/font&gt;';

    my $sect_title;
    if ( !$linkoff ) {
        if ($link) {
            $sect_title.=
              $q-&gt;a( { href =&gt; "$ENV{SCRIPT_NAME}?node=$link",
                       name =&gt; "toc-$anchor" }, $title )
              . $top;
        } else {
            $sect_title.=
              $q-&gt;a( { href =&gt; "$ENV{SCRIPT_NAME}?node=$title",
                       name =&gt; "toc-$anchor" }, $title )
              . $top;
        }
    } else {
        $sect_title.=$q-&gt;a( { name =&gt; "toc-$anchor" }, "$title" ) . $top;

    }

    my $toc=$sect{$typetitle}{toc};
    if ($nn-&gt;{hide}{$typetitle}) {
        $toc="&lt;i&gt;$toc&lt;/i&gt;";
        $sect_title="&lt;i&gt;$sect_title&lt;/i&gt;";
    } elsif ($cfg &amp;&amp; @{$sect{$typetitle}{html}}) {
        $sect_title="&lt;b&gt;$sect_title&lt;/b&gt;";
        $toc="&lt;b&gt;$toc&lt;/b&gt;";
    }

    $sect_title=sprintf($toggle_fmt,"-$anchor","-$anchor").$sect_title;

    push @toc,$toc;

    my $textbox=$cfg
                ? "Enter a new position:"
                  .$q-&gt;textfield(
                    -name=&gt;"nnt_pos_$typetitle",
                    -default=&gt;$nn-&gt;{hide}{$typetitle} ? 0 : .5+$pos++,
                    -force=&gt;1,
                    -size=&gt;10,
                    -maxlength=&gt;10)
                  .qq[&lt;input type="submit" name="Change" value="Change Order" /&gt;]
                : "";
    push @{$sect{$typetitle}{html}},
         $nn-&gt;{hide}{$typetitle}
           ? '&lt;li&gt;&lt;i&gt;you currently have this secton hidden...&lt;/i&gt;&lt;/li&gt;'
           : '&lt;li&gt;nothing to see here right now, but you have the '
             . 'section enabled so if there were content of this '
             . 'type you would see it...&lt;/li&gt;'
        unless @{$sect{$typetitle}{html}};
    push @html, "&lt;div id='nnt-section-$anchor' class='nnt-section'&gt;";
    push @html, "&lt;h3&gt;",$sect_title,"&lt;/h3&gt;",$textbox,
                "&lt;ul id='ul-$anchor' class='expanded'&gt;",
                @{$sect{$typetitle}{html}},
                "&lt;/ul&gt;",
                $blk ? $blocking_submit : (),
                "&lt;hr class='nnt-section-break' /&gt;",
                "&lt;/div&gt;";
}
#-------------------------------
# legend stuff.

if (  my( $place )= $q-&gt;param('showlegend')  ) {
  $VARS-&gt;{'nnt-legend-bottom'}= ($place eq 'bottom');
}

my $legend=join "",
    "&lt;div id='nnt-legend' class='nnt-section'&gt;",
    "&lt;h3&gt;",
    sprintf($toggle_fmt,"-legend","-legend"),
    'Legend&amp;nbsp;&lt;font size="2"&gt;&lt;a href="#toc-top"&gt;(Top)&lt;/a&gt;&lt;/font&gt;&lt;/h3&gt;',
    "&lt;ul id='ul-legend'&gt;",
    q[&lt;blockquote&gt;&lt;u&gt;Title&lt;/u&gt; &amp;#91;&lt;b&gt;^1&lt;/b&gt;&amp;#93;].
    q[(&lt;b&gt;&lt;u&gt;AC&lt;/u&gt;&lt;/b&gt;:&lt;b&gt;3&lt;/b&gt;/&lt;b&gt;9&lt;/b&gt;/&lt;b&gt;7&lt;/b&gt;)].
    q[&lt;u&gt;&lt;b&gt;+/-&lt;/b&gt;&lt;/u&gt; &amp;#91;&lt;u&gt;author&lt;/u&gt;&amp;#93;&lt;/blockquote&gt;].
    q[&lt;p&gt;Means: You "&lt;b&gt;^&lt;/b&gt;"=up- or "&lt;b&gt;v&lt;/b&gt;"=down-voted,].
    q[ "&lt;b&gt;1&lt;/b&gt;"=reputation; "&lt;u&gt;&lt;b&gt;AC&lt;/b&gt;&lt;/u&gt;" from ].
    q[( &lt;b&gt;F&lt;/b&gt;ront-paged, &lt;b&gt;A&lt;/b&gt;pproved, ].
    q[&lt;b&gt;U&lt;/b&gt;napproved, &lt;b&gt;C&lt;/b&gt;onsidered, ].
    q[or link to &lt;b&gt;P&lt;/b&gt;arent or &lt;b&gt;R&lt;/b&gt;oot ); ].
    q[Replies: "&lt;b&gt;3&lt;/b&gt;" direct, "&lt;b&gt;9&lt;/b&gt;" ].
    q[descendents, "&lt;b&gt;7&lt;/b&gt;" recent, "&lt;b&gt;+/-&lt;/b&gt;" ].
    q[shows/hides(uses javascript)],
    "&lt;/p&gt;&lt;p align='right'&gt;",
    linkNode(396325,'View Full Documentation'),
    ", ",
    $VARS-&gt;{'nnt-legend-bottom'}  
      ? linkNode($NODE,'Show Legend at Top',
           {-title=&gt;"Move legend section to top",showlegend=&gt;'top'})
      : linkNode($NODE,'Show Legend at Bottom',
           {-title=&gt;"Move legend section to bottom",showlegend=&gt;'bottom'}),
    '&lt;/p&gt;&lt;/ul&gt;',
    "&lt;hr class='nnt-section-break' /&gt;",
    "&lt;/div&gt;";

if ($VARS-&gt;{'nnt-legend-bottom'}) {
    push @html,$legend;
} else {
    unshift @html,$legend;
}

#-------------------------------

$Do_MarkTime &amp;&amp; MarkTime("Done");
my $viewed_message = @toc ? "I've checked all of these" : "Check for newer nodes";
my $form;
  
#
# ===========================================================================
# We now handle forms and stuff. All of the sections are taken care of.
# ===========================================================================

#
# Time stuff
my %linkhash=(-1=&gt;'&lt;&lt;&lt;&lt;',0=&gt;"",1=&gt;'&gt;');
my @len_strs=('','Day','Week','Month','Year');
my $shown_basetime=0;
my $as_of_links="&lt;table align='center' id='nnt-as-of-links'&gt;".
                "&lt;tr&gt;&lt;th&gt;".$q-&gt;a( { name =&gt; "toc-top" },"Viewing Nodes As of:")."&lt;/th&gt;".
  (join "",
    map {
      my $c="".($_ &lt;=&gt; $as_of_unix);
      my $str=$linkhash{$c};
      if ($c&lt;0) {
        chop($linkhash{$c});
      } elsif ($c) {
        $linkhash{$c}.=substr($linkhash{$c},0,1);
      }
      my $date=strftime("%Y-%m-%d",localtime($_));
      my $ret= ($_+$fudge &gt;= $basetime )
                ? !$shown_basetime++
                  ? $c ? linkNode($NODE,'Return to Present',{-title=&gt;'Return to present!'})
                       : '&lt;b&gt;'.linkNode($NODE,'Now',{-title=&gt;'Current view!'})."&lt;/b&gt;"
                  : '&amp;nbsp;'
                : linkNode($NODE,$str||$date,
                           { 'nnt-as-of'=&gt; $date,
                            -title=&gt; !$str ? "Current!" : "View as of "
                                    .htmlcode('timesince','',0,$basetime-$_)
                                    ." ("
                                    .($len_strs[length($str)]
                                     ?($c&gt;0?'Forward':'Back')
                                      ." One "
                                      .$len_strs[length($str)]
                                     : "This page")
                                    .": $date)"
                    });

     "&lt;td&gt;$ret&lt;/td&gt;"
    } (
        $as_of_unix - 365*24*3600,
        $as_of_unix - 30*24*3600,
        $as_of_unix - 7*24*3600,
        $as_of_unix - 24*3600,
        $as_of_unix,
        $as_of_unix + 24*3600,
        $as_of_unix + 7*24*3600,
        $as_of_unix + 30*24*3600,
        $as_of_unix + 365*24*3600
        )
)."&lt;/tr&gt;&lt;/table&gt;";
my $color_key="&lt;table width='80%' align='center'&gt;&lt;tr&gt;"
             .join("",
               map {  my $text=$age_desc[$_];
                      my $no_time=$text=~s/^-//;
                      my $timetext=htmlcode('timesince','','',$age_time[$_]);
                      my ($color)=$color_classes[$_];
                      if ($text!~/[A-Z]/) {
                         $text=$timetext;
                      } elsif (!$no_time) {
                         $text.=":".$timetext;
                      }
                      # "&lt;td bgcolor='$color' title='$text'&gt;&amp;nbsp&lt;/td&gt;"
                       "&lt;td align='center' title='$text'&gt;"
                       ."&lt;a class='$color'&gt;&amp;#x2588;&lt;/a&gt;"
                       ."&lt;/td&gt;"

                   } 0..$#ages)."&lt;/tr&gt;&lt;/table&gt;";

# Build the form

if ( getId($USER) != $HTMLVARS{default_user} ) {
    $form = qq[&lt;p&gt;
      &lt;form method="post" action="?" enctype="application/x-www-form-urlencoded"&gt;
      &lt;input type="hidden" name="node_id" value="] . getId($NODE) . qq[" /&gt;
      &lt;input type="hidden" name="displaytype" value="display" /&gt;
      &lt;input type="hidden" name="pageloadtime" value="] . time() . qq[" /&gt;
      &lt;input type="submit" name="viewedNewNodes" value="$viewed_message" /&gt;
      &lt;/form&gt;&lt;/p&gt;];
}

$q-&gt;param('node_id',$NODE-&gt;{node_id});
if ($Do_MarkTime) {
    MarkTime('--final--');
    #printLog("demerphq's sandpit done mode: $VARS-&gt;{nnt_mode} ($$)");
}
my $notbare=$q-&gt;param('style') ne 'bare';
# and the rest of the links and cfg bodge.
return join "\n",
  qq[
    &lt;!--
    
    &lt;script&gt;&lt;/script&gt;

    --&gt;
    &lt;script type="text/javascript"&gt;
    function toggleMenu(id){
      element = document.getElementById(id);
      element.className = (element.className.toLowerCase() ==
                            'expanded' ? 'collapsed' : 'expanded');
    }
    &lt;/script&gt;
  ],
  $Color_Style,
  qq[&lt;div id="nodethreads-head"&gt;],
  (@mark_time_html ? ('&lt;ul class="nnt-marktime"&gt;',@mark_time_html,'&lt;/ul&gt;') : ()),
  '&lt;p&gt;',
  $notbare &amp;&amp; qq[&lt;span class="nnt-colorkey"&gt;$color_key&lt;/span&gt;],
  $notbare &amp;&amp; qq[&lt;span class="nnt-asof"&gt;$as_of_links&lt;/span&gt;],
  $notbare &amp;&amp; do{
    my $view_link;
    my $mode_ans=$q-&gt;a({href=&gt;"?node_id=$NODE-&gt;{node_id};mode=ancestors",
                        title=&gt;'nodes and their direct ancestors'},'Node Ancestors');
    my $mode_ful=$q-&gt;a({href=&gt;"?node_id=$NODE-&gt;{node_id};mode=fullthread",
                        title=&gt;'everything... the whole tree'} ,'Full Thread',);
    my $mode_rtn=$q-&gt;a({href=&gt;"?node_id=$NODE-&gt;{node_id};mode=root-and-node",
                        title=&gt;'nodes and their roots'},'Root and Node');
    my $mode_min=$q-&gt;a({href=&gt;"?node_id=$NODE-&gt;{node_id};mode=minimal",
                        title=&gt;'just nodes but threaded if possible'},'Minimal Nodes');

    if ($mode eq 'fullthread') {
      $view_link="&lt;b&gt;Full Thread&lt;/b&gt;, switch to $mode_rtn, $mode_min or $mode_ans";
    } elsif ($mode eq 'ancestors') {
      $view_link="&lt;b&gt;Node Ancestors&lt;/b&gt;, switch to $mode_rtn, $mode_min or $mode_ful";
    } elsif ($mode eq 'root-and-node')  {
      $view_link="&lt;b&gt;Root and Node&lt;/b&gt;, switch to $mode_min, $mode_ans or $mode_ful";

    } elsif ($mode eq 'minimal') {
      $view_link="&lt;b&gt;Minimal Nodes&lt;/b&gt;, switch to $mode_rtn, $mode_ans or $mode_ful";
    }
    qq[&lt;span class='nnt-viewlinks'&gt;].
    "Current View Mode is ".
    qq[ $view_link&lt;br /&gt;Jump to &lt;a href="?node_id=396325"&gt;Help&lt;/a&gt; |].
    qq[ &lt;a href="#nnt-legend"&gt;Legend&lt;/a&gt; |].
    qq[ &lt;a href="#nnt-config"&gt;Page Settings&lt;/a&gt;&lt;/span&gt;]
  },
  qq[&lt;span class="nnSummary"&gt;],
  (@html!=$count)
  ?
    ' | '
    . join( '&lt;span class="link-sep"&gt;&lt;span class="NN-link-sep"&gt;'
    . ' | &lt;/span&gt;&lt;/span&gt;', @toc )
    . ($cfg
       ?"&lt;br /&gt;&lt;b&gt;Config Mode&lt;/b&gt;: Sections in &lt;i&gt;italics&lt;/i&gt; are hidden,"
       ." &lt;b&gt;bold&lt;/b&gt; have content and would be shown and normal sections"
       ." are ones that would display but now have no content."
       :"")
  : ('. There are no nodes to view at this time.'),
  '&lt;/span&gt;',
  "&lt;/p&gt;&lt;hr /&gt;",
  "&lt;/div&gt;",
  "&lt;div id='nodethreads'&gt;",
  $cfg||$blk
  ? qq[
       &lt;form method="post" action="?" enctype="application/x-www-form-urlencoded"&gt;
       &lt;input type="hidden" name="node_id" value="] . getId($NODE) . qq[" /&gt;
       &lt;input type="hidden" name="displaytype" value="display" /&gt;]
  :(),
  $cfg?qq[&lt;input type="hidden" name="nnt-cfg" value="1" /&gt;] : (),
  $blk?qq[&lt;input type="hidden" name="nnt-blk" value="1" /&gt;] : (),
  @html,
  $blk ? "&lt;p&gt;You have ".scalar(keys %blocked)." nodes blocked.&lt;br /&gt;"
         .$q-&gt;checkbox(-name=&gt;'nnt-clear-oldblocking',
                       -checked=&gt;0,
                       -value=&gt;'clear',
                       -label=&gt;'Clear Old Filters',
                       -title=&gt;'Remove any old filters that are currently in effect',
                       -force=&gt;1,)
        ."&lt;/p&gt;"
         : (),
  $cfg ? qq[&lt;input type="submit" name="Change" value="Change Order" /&gt;] : (),
  $blk||$cfg ? qq[&lt;/form&gt;] : (),
  "&lt;/div&gt;",
  qq[&lt;div id="nodethreads-foot"&gt;],
  $form,
  do {
    my @array = (  map $_/2,1..6 );
    my $str= htmlcode('openform')
           . $q-&gt;hidden(  pageloadtime =&gt; time() );

    my $choosedepth = qq[to a maximum depth of ].$q-&gt;popup_menu('maxdepth',[0..10],
                      $VARS-&gt;{nnt_maxdepth}||0);
    my $checkboxes =
         $q-&gt;checkbox(-name=&gt;'showage',
                      -checked=&gt;$VARS-&gt;{nnt_showage}||0,
                      -value=&gt;'1',
                      -label=&gt;'Show node age',
                      -force=&gt;1,)." ".
         $q-&gt;checkbox(-name=&gt;'showtime',
                      -checked=&gt;$VARS-&gt;{nnt_showtime}||0,
                      -value=&gt;'1',
                      -label=&gt;'Show node time',
                      -force=&gt;1,)." ".
         $q-&gt;checkbox(-name=&gt;'nnt-toggle-left',
                      -checked=&gt;$VARS-&gt;{nnt_toggle_left}||0,
                      -value=&gt;'1',
                      -label=&gt;'Show toggle on the left',
                      -force=&gt;1,)." ".
         "&lt;br /&gt;\n".
         (getId($USER)!=$HTMLVARS{default_user}
         ?$q-&gt;checkbox(-name=&gt;'nnt-cfg',
                      -checked=&gt;0,
                      -value=&gt;'1',
                      -label=&gt;'Config Mode',
                      -force=&gt;0,
                      )." ".
          $q-&gt;checkbox(-name=&gt;'nnt-blk',
                      -checked=&gt;$VARS-&gt;{nnt_blk},
                      -value=&gt;'1',
                      -label=&gt;'Filtered Nodes?',
                      -force=&gt;0,
                      )." ".
          "&lt;br /&gt;\n"
         : "");
    $checkboxes="" unless $notbare;
    if(  ! $VARS-&gt;{lastviewednewestnodes}  ) {
      $str .= qq[Showing nodes created within the past ]
           . $q-&gt;popup_menu('numdays',\@array,$days)
           . qq[ days&lt;br /&gt;$choosedepth&lt;br /&gt;]
           . $checkboxes
           . $q-&gt;submit("Set")
           . qq[&lt;br /&gt;];
    } else{
      $str .= qq[Showing nodes created since ]
           . htmlcode('convertEpochSecs',$VARS-&gt;{lastviewednewestnodes})
           . qq[&lt;br /&gt;$choosedepth]
           . $checkboxes
           . $q-&gt;submit("Set")
           . qq[&lt;br /&gt;];
      $str.=qq[&lt;input type="submit" name="clearNewNodesFlag"
                 value="Clear my 'last checked' time" /&gt;&lt;br /&gt;]
            if  getId($USER) != $HTMLVARS{default_user};
    }
    qq[&lt;h3&gt;&lt;a name="nnt-config"&gt;Page Settings&lt;/a&gt;&lt;/h3&gt;$str&lt;/form&gt;];

  },
  "&lt;/div&gt;"
;

###########################################################################
###########################################################################
</patch_code>
<applied>2009-05-15 18:20:20</applied>
<htmlcode_id>395907</htmlcode_id>
<live_code>###########################################################################
###########################################################################

use Everything::Experience;
use Time::Local;
use Time::Local qw(timegm timelocal);
use POSIX ();

return '' if $HTMLVARS{__NOP};

my $basetime=time;

=for myeditor
sub MarkTime {}

=cut

# this is a routine for handling debugging.
my $Do_MarkTime=isGod($USER) &amp;&amp; $q-&gt;param('debug_sandpit');
my @mark_time_html;

local *MarkTime=do {
    my $stime=$basetime;
    my $rtime=$basetime;
    sub {
        return unless $Do_MarkTime;
        my $t=time;
        my $total=$t-$stime;
        my $running=$t-$rtime;
        $rtime=$t;
        push @mark_time_html,"&lt;li&gt;(r/t secs:$running/$total) @_&lt;/li&gt;"
    }
};
$Do_MarkTime &amp;&amp; MarkTime('start');

#===================================================================
# Configuration happens here. Its currently a mess that needs to be
# cleaned up. :-( demerphq
#===================================================================

my $ReaperId = $VARS-&gt;{showreaped} ? -1 : $HTMLVARS{NodeReaperID};


my $as_of=$q-&gt;param('nnt-as-of');
my $as_of_unix;
my $as_of_string;
if ($as_of=~/^(\d{4})-?(\d{2})-?(\d{2})(?: ?(\d{2})(?::?(\d{2})(?::?(\d{2}))?)?)?$/) {
    my ($year,$mon,$mday,$hour,$min,$sec)=($1,$2,$3,$4||0,$5||0,$5||0);
    $as_of_unix=timelocal($sec,$min,$hour,$mday,$mon-1,$year);
} elsif ($as_of=~/^-(\d+)\s*D(ays)?$/i) {
    $as_of_unix=$basetime-($1 * 86400);
    $as_of_string="$1 Days Ago";
} else {     
    $as_of_unix=$basetime;
    $as_of_string="Now!";
}

# fudge as_of_unix so if they go back then return they see the same thing even
# though the time will be very slightly off.
my $fudge=12*3600;
$as_of_unix=$basetime
    if $as_of_unix+$fudge&gt;=$basetime;
$as_of=POSIX::strftime("'%Y-%m-%d %H:%M:%S'",localtime($as_of_unix));

my @ages=([15*60,         'Steaming' ],
          [30*60,         'Hot'      ],
          [60*60,         'Fresh'    ],
          [2*60*60,       'twohour'  ],
          [4*60*60,       'fourhour' ],
          [8*60*60,       'eighthour'],
          [12*3600,       'Recent'   ],
          [24*3600,       'oneday'   ],
          [2*24*3600,     'twodays'  ],
          [3*24*3600,     'threedays'],
          [4*24*3600,     'fourdays' ],
          [5*24*3600,     'fivedays' ],
          [6*24*3600,     'sixdays'  ],
          [7*24*3600,     'week'     ],

          [30*24*3600,    'month'    ],
          [60*24*3600,    'twomonths'],
          [90*24*3600,    'quarteryear'  ],
          [180*24*3600,   'halfyear' ],
          [365*24*3600,   '-Year'     ],
          [2*365*24*3600, '-TwoYear'],
          [$basetime,     '-Old'],
         );
my (@age_time,@age_desc,@color_classes);

for (@ages) {
    push @age_time,$_-&gt;[0];
    push @age_desc,$_-&gt;[1];
    (my $nnt=$_-&gt;[1])=~s/^-//;
    push @color_classes,"nnt-$nnt";
}

my $Color_Style=htmlcode('colorblend','',0+@ages,\my @colors,$THEME,\@color_classes,
q[
  .nnt-line-incidental .nnt-link { font-style: italic; }
  a.nnt-Steaming,
  a.nnt-Hot,
  a.nnt-Fresh  { font-weight: bold; }
]);
$VARS-&gt;{__nnt_color_style}=$Color_Style;
$Color_Style=$VARS-&gt;{nnt_color_style} if $VARS-&gt;{nnt_color_style};
$Color_Style=qq[
 &lt;style type="text/css"&gt;
 $Color_Style
 &lt;/style&gt;
] unless $Color_Style=~m[&lt;style type="text/css"&gt;];
$Color_Style.=qq[
 &lt;style type="text/css"&gt;
 p.nnt-p { display: inline; }
 p.nnt-p-title { /* width: 70%; */   }
 p.nnt-author  { /* width: 28%; */ }
 .nnt-line-incidental .nnt-link { font-style: italic; }
 tr.this-patch td { font-weight: bold; }
 tr.other-patch td { font-style: italic; }
 a.nnt-Steaming, a.nnt-Hot, a.nnt-Fresh { font-weight: bold; }
 .nnt-noderep,.nnt-nodeattribs,.time-text { font-size: smaller; }
 #nodethreads {  padding-right: 1em;  white-space:normal;}
 #nodethreads ul {  list-style: none;  margin-left: 0;  padding-left: 
 1em;  text-indent: 0em;  white-space:normal;}
 #nodethreads li {width: 100%;}
 #nodethreads ul.expanded {display: block;}
 #nodethreads ul.collapsed {  display: none;}
 &lt;/style&gt;
] if $q-&gt;param('style') eq 'bare';

my $toggle_fmt=qq[&lt;span class='nnt-toggle'&gt;&lt;a href="#ul%s" ]
               .qq[onclick="toggleMenu('ul%s'); return false;"]
               .qq[ class="toggle"&gt;&lt;small&gt;+/-&lt;/small&gt;&lt;/a&gt; &lt;/span&gt;];


# Handle user and param configuration options

my $blk=(getId($USER)!=$HTMLVARS{default_user}
          &amp;&amp; $q-&gt;param('nnt-blk'));
if ($q-&gt;param('Set') eq 'Set') {
  $VARS-&gt;{nnt_blk}=!!$blk;
  $VARS-&gt;{nnt_toggle_left}=!!$q-&gt;param('nnt-toggle-left');
  $VARS-&gt;{nnt_showage}=!!$q-&gt;param('showage');
  $VARS-&gt;{nnt_showtime}=!!$q-&gt;param('showtime');
}

my $cfg=getId($USER)!=$HTMLVARS{default_user}
     &amp;&amp; $q-&gt;param('nnt-cfg');

my %blocked;
if ($blk) {
    my $do_update=$q-&gt;param('Update') eq 'Update Blocking';
    if ($do_update and $q-&gt;param('nnt-clear-oldblocking') eq 'clear') {
        $VARS-&gt;{nnt_blocknodes}="";
    }
    %blocked=unpack "N*",$VARS-&gt;{nnt_blocknodes}||'';
    $blocked{$_}&lt;$basetime-48*3600 and delete $blocked{$_}
      for keys %blocked;
    $blocked{$_}=$basetime foreach grep {
         s/nnt-hide-// &amp;&amp; $q-&gt;param("nnt-hide-$_") eq "hide"
    } $q-&gt;param();
    my @keys=sort { $blocked{$b}&lt;=&gt;$blocked{$a} || $b &lt;=&gt; $b } keys %blocked;
    delete $blocked{pop @keys} while @keys&gt;128;
    if ($do_update) {
        $VARS-&gt;{nnt_blocknodes}=pack "N*",%blocked
    }
    $Do_MarkTime and MarkTime("blocknodes:@{[keys %blocked]}");
}

my $NICK=$USER-&gt;{nick} ? getNode($USER-&gt;{nick},'user') : undef;
my $USER_ID=$NICK ? $NICK-&gt;{user_id} : $USER-&gt;{user_id};

my $isGod= isGod($USER);
my $can_consider=Everything::isApproved($USER,'CanConsider');

my $APPROVAL_SETTING = getVars(
    getNode('approval nodelet settings','setting')
  );
my %approval_types = map { $_ =&gt; 1 } split /,/, $APPROVAL_SETTING-&gt;{types};
$can_consider=0
    if 0 &lt;= index( $APPROVAL_SETTING-&gt;{inconsiderate}, "[$USER-&gt;{title}]" )
    || 0 &lt;= index( $APPROVAL_SETTING-&gt;{inconsiderate}, "[$USER-&gt;{node_id}]" )
    || 0 &lt;= index( $APPROVAL_SETTING-&gt;{inconsiderate}, "[$USER_ID]" )
    || ($NICK and 0 &lt;= index( $APPROVAL_SETTING-&gt;{inconsiderate}, "[$NICK-&gt;{title}]" ))
;

my $mode = $q-&gt;param('mode');
$mode=undef unless $mode=~/(?:fullthread|root-and-node|minimal|ancestors)/;
$mode = $VARS-&gt;{nnt_mode} unless defined $mode; # setting this is handled above
$mode = 'ancestors' unless $mode;
$VARS-&gt;{nnt_mode}=$mode;
$mode='ancestors' if $q-&gt;param('style') eq 'bare'; # dontoveride user $VARS with this.

if ( getId($USER) != $HTMLVARS{default_user} ) {
  if ( $q-&gt;param('viewedNewNodes') ) {
    $VARS-&gt;{lastviewednewestnodes} = $q-&gt;param('pageloadtime');
  }

  if ( $q-&gt;param('clearNewNodesFlag') ) {
    $VARS-&gt;{lastviewednewestnodes} = '';
  }
}
my $when = $as_of_unix!=$basetime ? 0 : $VARS-&gt;{lastviewednewestnodes}||0;
if ($when) {
    my $oldest=time-3*24*60*60;
    $when=$oldest if $when&lt;$oldest;
}

my $days = $q-&gt;param('numdays')||0;
$days = 1 if !$days or $days !~ /^\d+(\.\d+)?$/;
$days = 3 if $days &gt; 3;

my @for_nodes;
if (my $csv=$q-&gt;param('for_nodes')) {
  $mode="fullthread";
  @for_nodes=map /^\s*(\d+)\s*$/?$1:(),split /\s*[,:;]\s*/,$csv;
  splice @for_nodes,10 if @for_nodes&gt;10;
}


my $maxdepth = $q-&gt;param('maxdepth');
$maxdepth = $VARS-&gt;{nnt_maxdepth} unless defined $maxdepth;
# $maxdepth = $VARS-&gt;{notedepth} unless defined $maxdepth; # just confuses issues
$maxdepth=2 unless defined $maxdepth;
$VARS-&gt;{nnt_maxdepth} = $maxdepth if defined $maxdepth;
$maxdepth=1 if $cfg;

my $showtime=$q-&gt;param('showtime');
$VARS-&gt;{nnt_showtime}=$showtime if $q-&gt;param('Set')
                                or $q-&gt;param('clearNewNodesFlag');
my $showage=$q-&gt;param('showage');
$VARS-&gt;{nnt_showage}=$showage if $q-&gt;param('Set')
                                or $q-&gt;param('clearNewNodesFlag');

my $cutoffdate = $mode eq 'fullthread'
               ? 0
               : $when
                 ? $when
                 : time - $days * 24 * 3600;



my %order=split /,/,$VARS-&gt;{nnt_order};
if ($cfg &amp;&amp; $q-&gt;param('Change') eq 'Change Order') {
    my @fields=map { s/^nnt_pos_// ? $_ : ()  } $q-&gt;param;
    my %hide;
    for (@fields) {
        $order{$_}=$q-&gt;param("nnt_pos_$_");
        if (!$order{$_}) {
            $hide{$_}=1;
        }
    }
    $VARS-&gt;{nn_hide_nodetypes}=join ",", keys %hide;
    $VARS-&gt;{nnt_order}=join",",map { $_,$order{$_} } keys %order;
}


my $nn = {};
htmlcode( 'handle_nn_settings', '', $nn );
my %types;
my @types = map {
    my $type = getType( $_ );
    $types{ $type-&gt;{node_id} } = $type;
    $types{$_} = $type;
    $type-&gt;{node_id};
} @{ $nn-&gt;{legal} };
return "No types?" unless @types;
my %want=map { $_=&gt;$types{$_},$types{$_}{node_id}=&gt;$types{$_} }
         @{$nn-&gt;{types}};

# @html will ultimately hold the returned HTML, we start off with a
# header of the params
my @html = (qq(
&lt;!--
NNT: \$mode=$mode|\$maxdepth=$maxdepth
     \$days=$days|\$when=$when|\$cutoffdate=$cutoffdate|time=@{[time]}
     \@types=(@types)
--&gt;
));

#===========================================================================
# Tree and DB Code. We handle constructing the tree and the main queries here
#===========================================================================

my %node;
my %authors;
my $notes;
my @roots;

=for myeditor
sub add_node_to_tree {}

=cut

#
# This sub integrates the node into the tree. Since we have a parent pointer
# system where we can't be guaranteed the parent exists and to minimize queries
# we build it from the bottom up.
# This process can generate a final set of objects which werent picked up in the
# original two queries which are for node which have sane note tables.
# These are then added in at the end as a series of adhoc queries. In most
# situations these are no adhoc performed.
#

local *add_node_to_tree=sub{
    my ($n,$notree)=@_;
    my $node_id =$n-&gt;{node_id};
    return unless $node_id;
    $node{$node_id}||={};
    @{ $node{$node_id} }{ keys %$n } = values %$n;

    $n=$node{$node_id};
    my $author = $n-&gt;{author_user};
    $n-&gt;{author_user} = $author = $n-&gt;{original_author} if $n-&gt;{original_author};
    $authors{$author}||=getNodeById($author,'light');

    return if $notree || $n-&gt;{_intree}++;



    if ($n-&gt;{type_nodetype}==1888) {
        $n-&gt;{root_node}||=$n-&gt;{parent_node}
            if $n-&gt;{parent_node};
    }
    push @roots, $n-&gt;{root_node} if $n-&gt;{root_node};

    for (qw(root_node parent_node)) {
        next unless $n-&gt;{$_};
        $node{ $n-&gt;{$_} } ||= { node_id =&gt; $n-&gt;{$_} };
        $n-&gt;{"_$_"} = $node{ $n-&gt;{$_} }
    }
    $n-&gt;{_root_node}{_descendents}{$node_id} = $n
      if $n-&gt;{root_node};
    $n-&gt;{_parent_node}{_children}{$node_id} = $n
      if $n-&gt;{parent_node};
    $n-&gt;{_root_node}{__newest}=$n
        if !$n-&gt;{_root_node}{__newest}
        or $n-&gt;{_root_node}{__newest}{node_id} &lt; $n-&gt;{node_id};
    return $n;
};


##### DB STUFF

my $dbh = $DB-&gt;getDatabaseHandle();


# we build up a generic where clause here. Depending on the args
# it can look fairly different.

my $in_nodetype = qq/type_nodetype in (@{[join ",",@types]})/;
my $where_time;
if (@for_nodes==1) {
  $where_time="node_id=@for_nodes";
} elsif (@for_nodes) {
  $where_time="node_id in ( ".join(",",@for_nodes)." )";
} else {
  $where_time ="createtime &gt;= ".(
    $when
      ? "FROM_UNIXTIME($when)"
      : "DATE_ADD($as_of,INTERVAL -$days DAY)"
  ). " and createtime &lt;= $as_of ";
}


$Do_MarkTime &amp;&amp; printLog("demerphq's sandpit query 1 start ($$)");
$Do_MarkTime &amp;&amp; MarkTime("demerphq's sandpit query 1 start ($$)");


my ($tquery,$rquery,$nquery); # query text for the different queries.

#get the most recent nodes
my $recent = $dbh-&gt;selectall_hashref($tquery=qq[
    select distinct
           node.*,
           note.*,
           original_author,
           weight,votetime,
           considernodes.considernodes_id,
           considernodes.description as considertext
    from node
    left join note on note_id=node_id
    left join vote on (vote_id=node_id and voter_user=$USER_ID)
    left join considernodes on considernodes_id=node_id
    left join contributor on contributor_id=node_id
    where $in_nodetype
    and $where_time
    limit 2000
], 'node_id' ) or return "Error in initial fetch.";

$Do_MarkTime &amp;&amp; MarkTime("demerphq's sandpit query 1 end ($$)&lt;br&gt;&lt;b/&gt;$tquery&lt;/b&gt;");
$Do_MarkTime &amp;&amp; printLog("demerphq's sandpit query 1 end ($$)");

# add them in
foreach my $n ( sort { $a-&gt;{node_id} &lt;=&gt; $b-&gt;{node_id} } values %$recent ) {
    my $node=add_node_to_tree($n);
    $node-&gt;{_recent}=1;
}

push @roots,@for_nodes; # add in the for_nodes to the first batch
my %dupe_root;
my $fetches=0;

$Do_MarkTime &amp;&amp; MarkTime("while roots=(@roots)");

# we actually only do this twice.
# the first query grabs any parents we didnt already have.
# the second query grabs any siblings we didnt already have.
while (@roots)
{
    if ($blk) {
        @roots=grep !$blocked{$_},@roots;
    }
    @roots=sort {$a &lt;=&gt; $b} grep $_ &amp;&amp; !$dupe_root{$_}++,@roots;
    $Do_MarkTime &amp;&amp; MarkTime("after roots=(@roots)");
    last if $fetches++&gt;1;
    last unless @roots;

    local $" = ', ';    #"
    $Do_MarkTime &amp;&amp; printLog("demerphq's sandpit query 2 start pass $fetches($$)");
    my @fetchroots=grep{ !$node{$_}{_recent} } @roots;
    my $roots;
    if (@fetchroots) {
      $roots = $dbh-&gt;selectall_hashref($rquery=qq[
          select node.*,
                 note.*,
                 original_author,
                 weight,votetime,
                 considernodes.considernodes_id,
                 considernodes.description as considertext
          from node
          left join note on node_id=note_id
          left join considernodes on considernodes_id=node_id
          left join contributor on contributor_id=node_id
          left join vote on (vote_id=node_id and voter_user=$USER_ID)
          where node_id in ( @fetchroots )
          and $in_nodetype
      ], 'node_id' ) or return "Error in Note Nodes Fetch.";
    } else {
      $roots={};

    }
    foreach my $n ( sort { $a-&gt;{node_id} &lt;=&gt; $b-&gt;{node_id} } values %$roots ) {
        add_node_to_tree($n);
    }

    @roots=grep { ($node{$_}{_recent} || $roots-&gt;{$_} )
                  &amp;&amp; $node{$_}{type_nodetype}!=1823
                  &amp;&amp; $want{$node{$_}{type_nodetype}} } @roots;
    if ($blk) {
        @roots=grep !$blocked{$_},@roots;
    }
    $Do_MarkTime &amp;&amp; MarkTime("demerphq's sandpit query 2 end (got "
      .scalar(@roots).") pass $fetches ($$)&lt;br/&gt;&lt;b&gt;$rquery&lt;/b&gt;&lt;br /&gt;roots=(@roots)");
    $Do_MarkTime &amp;&amp; printLog("demerphq's sandpit query 2 end (got "
      .scalar(@roots).") pass $fetches ($$)");
    if (@roots) {
      $notes = $dbh-&gt;selectall_arrayref($nquery=qq[
          select node.*,
                 note.*,
                 original_author,
                 weight,votetime,
                 considernodes.considernodes_id,
                 considernodes.description as considertext
          from node
          join note          on node.node_id = note.note_id
     left join considernodes on considernodes_id=node_id
     left join contributor   on contributor_id=node_id
     left join vote          on (vote_id=node_id and voter_user=$USER_ID)
          where (
              root_node in ( @roots )
          )
          and not ( $where_time )
          limit 2000
      ], { Slice =&gt; {} } ) or return "Error in Note Nodes Fetch.";

    } else {
      $notes=[];
    }

    $Do_MarkTime &amp;&amp; MarkTime("demerphq's sandpit query 3 end (got "
       .scalar(@$notes).") pass $fetches ($$)&lt;br/&gt;&lt;b&gt;$nquery&lt;/b&gt;");
    $Do_MarkTime &amp;&amp; printLog("demerphq's sandpit query 3 end (got "
       .scalar(@$notes).") pass $fetches ($$)");

    @roots=();
    foreach my $n ( sort { $a-&gt;{node_id} &lt;=&gt; $b-&gt;{node_id} } @$notes ) {
        add_node_to_tree($n);
    }
}

#
# This does an explain on the queries used, and writes them into a scratchpad
# it could probably be removed, but for now we will leave it as it is useful.
#

if ($Do_MarkTime and $USER-&gt;{title}=~/merphq/) {
    my @out;
    foreach my $str ($tquery,$rquery,$nquery)
    {
      next unless $str;
      my $r=$DB-&gt;getDatabaseHandle()-&gt;selectall_arrayref("explain $str");
      $str=~s/(\S)([,=])(\S)/$1 $2 $3/g;
      push @out,"&lt;dt&gt;$str&lt;/dt&gt;","&lt;dd&gt;&lt;table border='1'&gt;&lt;tr&gt;&lt;td&gt;".
               join("&lt;/td&gt;&lt;/tr&gt;\n&lt;tr&gt;&lt;td&gt;",map { join "&lt;/td&gt;\n&lt;td&gt;",
               map { length $_ ? $_ : '&amp;nbsp;' } @$_ } @$r)

               ."&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/dd&gt;";

    }
    my $sp=getNodeById(379341);

    my $out=join "\n","&lt;dl&gt;@out&lt;/dl&gt;";
    my ($exp,$lain)=("&lt;!--explain-$NODE-&gt;{node_id}--&gt;",
                     "&lt;!--\/explain-$NODE-&gt;{node_id}--&gt;");
    unless ($sp-&gt;{doctext}=~s/($exp).*($lain)/$1\n$out\n$2/s) {
        $sp-&gt;{doctext}="&lt;!--explain--&gt;\n$exp\n$out\n$lain\n&lt;!--/explain--&gt;\n";
    }
    updateNode($sp,-1);
}

$Do_MarkTime &amp;&amp; printLog("demerphq's sandpit ad-hoc fetch start ($$)");
$Do_MarkTime &amp;&amp; MarkTime("demerphq's sandpit ad-hoc fetch start ($$)");

#
# AdHoc queries. We add them in but dont update any parents. These nodes are
# usually problematic anyway, and their parents likely dont exist.
#
foreach my $id (keys %node) {
    my $node=$node{$id};

    if (!$node-&gt;{type_nodetype} and !$node-&gt;{author_user} and !$node-&gt;{_adhoc}) {
        my @keys=keys %$node;
        my $n=getNodeById($node-&gt;{node_id});
        $node-&gt;{_adhoc}=1;
        if ($n) {
            add_node_to_tree($n,'notree');
            $Do_MarkTime &amp;&amp; MarkTime("Added:".linkNode($node)
              ."&lt;br/&gt; nid:$node-&gt;{node_id} pid:$node-&gt;{parent_node} "
              ."rid:$node-&gt;{root_node} type:$node-&gt;{type_nodetype}".'&lt;br /&gt;'
              ."_desc:".join(',',keys %{$node-&gt;{_descendents}||{}}).'&lt;br /&gt;'
              ."_child:".join(',',map { "($_=&gt;$node-&gt;{_children}{$_}{type_nodetype}".
                                        ":$node-&gt;{_children}{$_}{root_node}:".
                                        "$node-&gt;{_children}{$_}{title})"}
                                        keys %{$node-&gt;{_children}||{}}).'&lt;br /&gt;'
              ."_keysa:".join(',',keys %$node).'&lt;br /&gt;'
              ."_keysb:".join(',',@keys).'&lt;br /&gt;');
        } else {
            $Do_MarkTime &amp;&amp; MarkTime("Bad node $id");
            $node-&gt;{_orphan}=1;
            next;
        }
    }
    my $tnode =( $types{$node-&gt;{type_nodetype}} ||=
                 getNodeById($node-&gt;{type_nodetype}) );
    my $typetitle=$tnode-&gt;{title};
    $node-&gt;{_type_title}=$typetitle;
}
$Do_MarkTime &amp;&amp; printLog("demerphq's sandpit ad-hoc end ($$)");

#===================================================================
# Now we define some subs to be used to build the tree.
# make_li() is the main routine
#===================================================================

=for myeditor
sub get_approval {}

=cut

#
# Handles approval queries.
#
local *get_approval=sub {

    my ($node)=@_;
    my $typetitle=$node-&gt;{_type_title};
    return $node-&gt;{_haslinks} if defined $node-&gt;{_haslinks};
    if ($approval_types{$typetitle}
         || grep $_ eq $typetitle,
         qw/modulereview bookreview
            note sourcecode snippet
            perltutorial perlnews/
    ) {
        my $nid = $node-&gt;{node_id};

        my $ok=0;
        $ok = $dbh-&gt;selectrow_hashref(qq[
              select *
              from links
              where from_node = $APPROVAL_SETTING-&gt;{$typetitle.'_node'}
              and to_node = $nid
              and linktype = $APPROVAL_SETTING-&gt;{$typetitle.'_linktype'}
              limit 1
        ]) if $approval_types{$typetitle};

        my $fp=0;
        $fp = $dbh-&gt;selectrow_hashref(qq[
              select *
              from links
              where from_node= $APPROVAL_SETTING-&gt;{front_page}
              and to_node = $nid
              and linktype = $APPROVAL_SETTING-&gt;{frontpage_linktype}
              limit 1
        ]);

        $node-&gt;{_ok_user} = $DB-&gt;sqlSelect(
            'user_id',
            'approved',
            qq[node_id = $nid and action = "ok"],
            "order by tstamp desc limit 1"
        ) if $ok;

        my $fpid = 0;
        $node-&gt;{_fp_user} = $DB-&gt;sqlSelect(
            'user_id',
            'approved',
            qq[node_id = $nid and action = "fp"],
            "order by tstamp desc limit 1"
        ) if $fp;

        $node-&gt;{_approval_type}=$approval_types{$typetitle};
        $node-&gt;{_haslinks}=1;
        $node-&gt;{_fp}=$node-&gt;{_fp_user} ? $fp : undef;
        $node-&gt;{_ok}=$node-&gt;{_ok_user} ? $ok : undef;
        return 1
    } else {
        $node-&gt;{_haslinks}=0;
        return 0;
    }
};

=for myeditor
sub node_details {}

=cut

#
# Handles building the node specific content of the li.
#

local *node_details=sub {
    my ($node,$showauthor,$showkids)=@_;

    my $localized=htmlcode('parseTimeInString','',$node-&gt;{createtime},'','','short');
    my ( $year, $mon, $day, $hour, $min, $sec ) =
      $node-&gt;{createtime} =~ /^(\d{4})-(\d{2})-(\d{2})\s+(\d{2}):(\d{2}):(\d{2})$/;
    my $time = $year ? timelocal( $sec, $min, $hour, $day, $mon - 1, $year ) : 0;
    my $timesince=htmlcode('timesince','',$node-&gt;{createtime});

    my $elapsed=$basetime-abs($time);
    my $index=0;
    $index++ while ($elapsed&gt;$age_time[$index]);
    #my $color=$colors[$index];
    my $class=$color_classes[$index];

    my @p_class=($class);

    my $nodetext='';

    my $title= length($node-&gt;{title}) 
               ? $q-&gt;escapeHTML($node-&gt;{title}) 
               : "&amp;#91;untitled node, ID $node-&gt;{node_id}&amp;#93;";

    $title =    qq[&lt;a class="nnt-link $class" href="?node_id=$node-&gt;{node_id}" ]
              . qq[title="Created at $localized ($timesince)"  &gt;]
              . $title
              . qq[&lt;/a&gt;\n];

    if ($USER_ID == $node-&gt;{author_user}
        || $USER-&gt;{user_id} == $node-&gt;{author_user}
        || $node-&gt;{votetime} || $node-&gt;{weight})
    {
        my ($cl,$v)=!$node-&gt;{weight}
                     ? ("","")
                     :  $node-&gt;{weight}&gt;0
                        ? ("nnt-plusplus","^")
                        : ("nnt-minusminus","v");
        push @p_class,$cl if $cl;
        $title.="&lt;span class='nnt-noderep'&gt;&amp;#91;"
              .($cl ? "&lt;span class='$cl'&gt;$v&lt;/span&gt;" : "")
              . "&lt;span class='nnt-reputation'&gt;"
              . ($node-&gt;{reputation}&gt;=0 ?  $node-&gt;{reputation} : '-X')
              . "&lt;/span&gt;&amp;#93;&lt;/span&gt;";
    }
    unless ($node-&gt;{_recent}) {
        $title="&lt;span class='nnt-incidental'&gt;$title&lt;/span&gt;";
        push @p_class,"nnt-line-incidental";
    }


    my $kidstuff;
    if ($node-&gt;{__kids}) {
        my @list=($node-&gt;{__kids});
        $list[-1]!=$_ and push @list,$_
            for $node-&gt;{__desc},$node-&gt;{__recent};
        if ($list[-1]==0) {
            pop @list;
        } else {
            $list[-1]="&lt;b&gt;$list[-1]&lt;/b&gt;";
        }
        $kidstuff="&lt;span class='nnt-kidstuff'&gt;".join("/",@list)."&lt;/span&gt;";
        push @p_class,'nnt-line-haskids';
    }
    my $plinks="";
    my $shown=0;
    my $root=$node-&gt;{_root_node};
    my $parent=$node-&gt;{_parent_node};
    if ($parent-&gt;{node_id} and !$parent-&gt;{_show}
        and $parent-&gt;{node_id}!=$shown)
    {
        my $str="Parent: '$parent-&gt;{title}' by ".
               "'$authors{$parent-&gt;{author_user}}-&gt;{title}'";
        $str=$q-&gt;escapeHTML($str);
        $str=~s/[""]/&amp;quot;/g;
        $plinks.="&lt;span class='nnt-parentlink'&gt;".linkNode($parent,'P',{-title=&gt;$str})."&lt;/span&gt;";
        $shown=$parent-&gt;{node_id};
    }
    if ($root-&gt;{node_id} and !$root-&gt;{_show}
        and $root-&gt;{node_id}!=$shown)
    {
        my $str="Root: '$root-&gt;{title}' by '$authors{$root-&gt;{author_user}}-&gt;{title}'";
        $str=$q-&gt;escapeHTML($str);
        $str=~s/[""]/&amp;quot;/g;
        $plinks.="&lt;span class='nnt-rootlink'&gt;".linkNode($root,'R',{-title=&gt;$str})."&lt;/span&gt;";
        $shown=$root-&gt;{node_id};
    }
    if ($can_consider &amp;&amp; $node-&gt;{considernodes_id}) {
        my $txt = htmlcode( 'parselinksinchatter','', $node-&gt;{considertext} );
        for ($txt) {
	    s/&lt;a href=.+?&gt;/Considered by /;
	    s|&lt;/a&gt;|:|;
	    s{&lt;a href=.+?&gt;|&lt;/a&gt;|[""]}{&amp;quot;}g;
        }                      
        $plinks.="&lt;span class='nnt-considerlink'&gt;"
               .qq[&lt;a href='?node=Nodes%20To%20Consider;]
               .qq[#consider-row-id$node-&gt;{node_id}' ]
               .qq[title="$txt" target="_blank"&gt;C&lt;/a&gt;&lt;/span&gt;];
        push @p_class,"nnt-line-considered";
    }
    if (get_approval($node)) {
        if ($node-&gt;{_fp} &amp;&amp; !$node-&gt;{considernodes_id}) {
            my $user=$authors{$node-&gt;{_fp_user}}
                     ||=getNodeById($node-&gt;{_fp_user},'light');
            $plinks.="&lt;span class='nnt-fplink'&gt;"
                   .qq[&lt;a href='?node_id=131#post-head-id$node-&gt;{node_id}' ]
                   .qq[title="Frontpaged by '$user-&gt;{title}'" target="_blank"&gt;F&lt;/a&gt;&lt;/span&gt;];
            push @p_class,"nnt-line-fp";
        }
        if ($node-&gt;{_approval_type}) {
            my $t;
            if (my $ok_id=$node-&gt;{_ok_user}) {
                my $user=$authors{$ok_id}||=getNodeById($ok_id,'light');
                $t=linkNode($user,'A',{-title=&gt;"Approved by '$user-&gt;{title}'"});
                push @p_class,"nnt-line-approved";
            } elsif (!($node-&gt;{_fp} &amp;&amp; !$node-&gt;{considernodes_id})) {
                $t="&lt;span class='nnt-unapproved'&gt;U&lt;/span&gt;";
                push @p_class,"nnt-line-unapproved";
            }
            $plinks.="&lt;span class='nnt-approval'&gt;$t&lt;/span&gt;";

        }
    }
    $plinks="&lt;span class='nnt-speciallinks'&gt;$plinks&lt;/span&gt;" if $plinks;
    if ($plinks or $kidstuff) {
        $kidstuff=":".$kidstuff
            if $plinks &amp;&amp; $kidstuff;
        $title.="&lt;span class='nnt-nodeattribs'&gt;($plinks$kidstuff)&lt;/span&gt;";
    }
    if ($showkids) {
        my $toggle=sprintf $toggle_fmt,$node-&gt;{node_id},$node-&gt;{node_id};
        if ($VARS-&gt;{nnt_toggle_left}) {
            $title=$toggle.$title;
        } else {
            $title.=$toggle;
        }
    }
    $title .= $q-&gt;checkbox(-name=&gt;'nnt-hide-'.$node-&gt;{node_id},
                           -checked=&gt;0,
                           -value=&gt;'hide',
                           -label=&gt;'',
                           -class=&gt;'nnt-hide',
                           -title=&gt;'Hide node and children for 24 hours?',
                           -force=&gt;0,)
        if $blk;
    $nodetext .="&lt;span class='nnt-title'&gt;$title&lt;/span&gt;";


    if ($VARS-&gt;{nnt_showtime} || $VARS-&gt;{nnt_showage}) {
      my $time_text="&lt;span class='time-text'&gt;";
      $time_text.="&lt;span class='nnt-time'&gt; $localized&lt;/span&gt;"
        if $VARS-&gt;{nnt_showtime};
      $time_text.="&lt;span class='nnt-timesince'&gt; $timesince&lt;/span&gt;"
        if $VARS-&gt;{nnt_showage};
      $nodetext.=$time_text."&lt;/span&gt;";
    }
    if ($node-&gt;{type_nodetype} ==112733) { #patch
       my $N=getNodeById($node-&gt;{node_id});
       $nodetext.="&lt;span class='nnt-patch-reason'&gt;&lt;br /&gt;("
                .htmlcode( 'parselinksinchatter','', $N-&gt;{reason} )
                .")&lt;/span&gt;";
    }
    push @p_class,'nnt-line-span',"nnt-line-author-$node-&gt;{author_user}";

    $nodetext ="&lt;p class='nnt-p-title nnt-p' align='left'&gt;$nodetext&lt;/p&gt;\n"
              ."&lt;p align='right' class='nnt-p nnt-author "
              ."nnt-author-$node-&gt;{author_user}'&gt; &amp;#91;"
              . linkNode( $node-&gt;{author_user} )
                # ,undef,{-target=&gt;'_blank'} )
              . "&amp;#93;&lt;/p&gt;"
      if $showauthor;
    @p_class=map {
               map { s/^nnt-(?!line)(.*)$/nnt-line-$1/g; $_} split / /,$_
             } "nnt-line",@p_class;
    return "&lt;!--\n\$NODE-&gt;{node_id}=$NODE-&gt;{node_id}--&gt;&lt;div class='"
           .join(" ",@p_class)."'&gt;"
           .$nodetext."&lt;/div&gt;&lt;!--\n--&gt;";
};

=for myeditor
sub make_li {}

=cut

#
# make_li is the main routine, it traverses the tree and builds the html
# based on the various config settings, and the tree and depth information
# previously aquired. The actual node text is handled by node_details
#

local *make_li = sub {
    my ( $node, $showauthor, $html, $depth ) = @_;
    $depth ||= 1;
    return if $blocked{$node-&gt;{node_id}};
    # dupecheck
    if (!$node or $node-&gt;{_make_li}++) {
      push @$html,
        "&lt;li&gt;Error: id://$node-&gt;{node_id} : parent://$node-&gt;{parent_node} "
       .": root://$node-&gt;{root_node}&lt;br/&gt;$node-&gt;{title}&lt;/li&gt;";
      return
    }

    my ($show,$showkids)=(1,$node-&gt;{__kids});
    if ($mode eq 'root-and-node' or $mode eq 'minimal') {
        $show=($node-&gt;{_recent} || ($mode ne 'minimal' and $depth==1));
        $showkids&amp;&amp;=$show &amp;&amp; $node-&gt;{__recent};
    } elsif ($mode eq 'ancestors') {
        return unless $node-&gt;{__recent}||$node-&gt;{_recent};
        $showkids&amp;&amp;=$node-&gt;{__recent};
    }
    if ($node-&gt;{author_user}==$ReaperId and !$node-&gt;{__kids}) {
        return;
    }
    $node-&gt;{_show}=$show;
    if ($show) {
        my $nodetext=node_details($node,$showauthor,$showkids);
        push @$html,"&lt;li id='li$node-&gt;{node_id}' "
                   ."class='nnt-depth-$depth nnt-auth-$node-&gt;{author_user}'&gt;"
                   .$nodetext;
    }

    if ( my $kids=$node-&gt;{_children} ) {
        my $state='expanded';
        $state='collapsed' if $maxdepth &amp;&amp;  (($depth==$maxdepth) or
          ($node-&gt;{_parent_node} and !$node-&gt;{_parent_node}{_show} and $depth&gt;$maxdepth));
        push @$html, "&lt;ul class='$state' id='ul$node-&gt;{node_id}'&gt;" if $showkids;
        if ($q-&gt;param('style') eq 'bare') {
            make_li( $node-&gt;{__newest}, $showauthor, $html, $depth + 1 );
        } else {
            foreach my $node_id ( sort { $a &lt;=&gt; $b } keys %{$kids} ) {
                make_li( $kids-&gt;{$node_id}, $showauthor, $html, $depth + 1 );
            }
        }
        push @$html, '&lt;/ul&gt;'
          if $showkids;
    }
    push @$html, '&lt;br class="nnt-br" /&gt;' if $mode ne 'minimal' and $show and $depth==1;
    push @$html, '&lt;/li&gt;'  if $show;
};

=for myeditor
sub count_kids {}

=cut

### count_kids() is an initial traversal that doesn't involve
### actually building the tree. This is where depths children
### counts are determined.


local *count_kids=sub {
    my ($node,$depth)=@_;

    return if $blocked{$node-&gt;{node_id}};
    $depth||=1;
    if ($node-&gt;{__depth}) {
        $Do_MarkTime &amp;&amp; MarkTime(
           "bad recursion: $node-&gt;{node_id} | $node-&gt;{__depth} | $depth!"
        );
        return;
    }
    $node-&gt;{__depth}=$depth;
    my $desc=0;
    my $recent=0;
    if ( my $kids = $node-&gt;{_children} ) {
        foreach my $node_id ( sort { $a &lt;=&gt; $b } keys %{$kids} ) {
            my ($count,$krecent)=count_kids($kids-&gt;{$node_id},$depth+1);
            $desc+=$count;
            $recent+=$krecent;
            $node-&gt;{__kids}++ unless $kids-&gt;{$node_id}{author_user}==$ReaperId;
        }
    } else {
        $node-&gt;{__kids}=0;
    }
    $node-&gt;{__desc}=$desc;
    $node-&gt;{__recent}=$recent;
    return ($desc+1,$recent+($node-&gt;{author_user}!=$ReaperId ? $node-&gt;{_recent}||0 : 0));
};

# Now we get the root nodes that arent blocked.
my @nodes = sort { $b-&gt;{node_id} &lt;=&gt; $a-&gt;{node_id} }
            grep { $_-&gt;{node_id} &amp;&amp; !$_-&gt;{root_node} &amp;&amp; !$blocked{$_-&gt;{node_id}} }
            values %node;


$Do_MarkTime &amp;&amp; MarkTime("Main loop start. ".scalar(@nodes)
                         ."nodes. Want types:".join(",",%want));
my (%sect,@toc);
# Loop over the root nodes and split them into their types.
foreach my $node (@nodes) {
    next unless $node-&gt;{type_nodetype};
    next if $node-&gt;{_orphan};
    my $typetitle=$node-&gt;{_type_title};
    next unless $typetitle &amp;&amp; $want{$typetitle};

    my ( $title, $link,
         $showauthor, $linkoff ) = @{ $nn-&gt;{typedata}{ $typetitle } };
    ( my $anchor    = $title ) =~ s/\s/-/g;


    unless ($sect{$typetitle}) {
        $sect{$typetitle}{html}=[];
    }
    my ($kids,$recent)=count_kids($node);
    if ($recent) { #sanity check
        $sect{$typetitle}{html}||=[];
        make_li( $node, $showauthor, $sect{$typetitle}{html} );
    }
    $Do_MarkTime &amp;&amp; MarkTime("*$typetitle $node-&gt;{node_id} $node-&gt;{title}");
}



#===============================================================
# Now we sort the groups and filter out ones we arent interested in
# to put together the sections.

my @fixed = #grep $types{$_}-&gt;{title} ne 'perlquestion',
            @{($cfg ? $nn-&gt;{legal} : $nn-&gt;{types})||[]};

my $count=@html;

my $blocking_submit=qq[&lt;input type="submit" name="Update" value="Update Blocking" /&gt;];

my $pos=0;
foreach my $typerec (sort {!!$b-&gt;[2] &lt;=&gt; !!$a-&gt;[2]
                           || $a-&gt;[2] &lt;=&gt; $b-&gt;[2]
                             || $a-&gt;[0] &lt;=&gt; $b-&gt;[0] }
                       map { [$_,$fixed[$_],$order{$fixed[$_]},] }
                       0..$#fixed)
{
    my ($old_pos,$typetitle)=@$typerec;
    next unless $cfg or $sect{$typetitle};
    next unless $cfg or @{$sect{$typetitle}{html}};
    @{$sect{$typetitle}{html}}=grep $_=~/\S/,@{$sect{$typetitle}{html}};
    next unless $cfg or @{$sect{$typetitle}{html}};

    my ( $title, $link,
         $showauthor, $linkoff ) = @{ $nn-&gt;{typedata}{ $typetitle } };
    ( my $anchor    = $title ) =~ s/\s/-/g;
    ( my $toc_title = $title ) =~ s/ /&amp;nbsp;/g;
    $sect{$typetitle}{toc}=$q-&gt;a( { href =&gt; "#toc-$anchor" }, $toc_title );

    my $top = '&amp;nbsp;&lt;font size="2"&gt;'
            . $q-&gt;a( { href =&gt; "#toc-top" }, "(Top)" )
            . '&lt;/font&gt;';

    my $sect_title;
    if ( !$linkoff ) {
        if ($link) {
            $sect_title.=
              $q-&gt;a( { href =&gt; "$ENV{SCRIPT_NAME}?node=$link",
                       name =&gt; "toc-$anchor" }, $title )
              . $top;
        } else {
            $sect_title.=
              $q-&gt;a( { href =&gt; "$ENV{SCRIPT_NAME}?node=$title",
                       name =&gt; "toc-$anchor" }, $title )
              . $top;
        }
    } else {
        $sect_title.=$q-&gt;a( { name =&gt; "toc-$anchor" }, "$title" ) . $top;

    }

    my $toc=$sect{$typetitle}{toc};
    if ($nn-&gt;{hide}{$typetitle}) {
        $toc="&lt;i&gt;$toc&lt;/i&gt;";
        $sect_title="&lt;i&gt;$sect_title&lt;/i&gt;";
    } elsif ($cfg &amp;&amp; @{$sect{$typetitle}{html}}) {
        $sect_title="&lt;b&gt;$sect_title&lt;/b&gt;";
        $toc="&lt;b&gt;$toc&lt;/b&gt;";
    }

    $sect_title=sprintf($toggle_fmt,"-$anchor","-$anchor").$sect_title;

    push @toc,$toc;

    my $textbox=$cfg
                ? "Enter a new position:"
                  .$q-&gt;textfield(
                    -name=&gt;"nnt_pos_$typetitle",
                    -default=&gt;$nn-&gt;{hide}{$typetitle} ? 0 : .5+$pos++,
                    -force=&gt;1,
                    -size=&gt;10,
                    -maxlength=&gt;10)
                  .qq[&lt;input type="submit" name="Change" value="Change Order" /&gt;]
                : "";
    push @{$sect{$typetitle}{html}},
         $nn-&gt;{hide}{$typetitle}
           ? '&lt;li&gt;&lt;i&gt;you currently have this secton hidden...&lt;/i&gt;&lt;/li&gt;'
           : '&lt;li&gt;nothing to see here right now, but you have the '
             . 'section enabled so if there were content of this '
             . 'type you would see it...&lt;/li&gt;'
        unless @{$sect{$typetitle}{html}};
    push @html, "&lt;div id='nnt-section-$anchor' class='nnt-section'&gt;";
    push @html, "&lt;h3&gt;",$sect_title,"&lt;/h3&gt;",$textbox,
                "&lt;ul id='ul-$anchor' class='expanded'&gt;",
                @{$sect{$typetitle}{html}},
                "&lt;/ul&gt;",
                $blk ? $blocking_submit : (),
                "&lt;hr class='nnt-section-break' /&gt;",
                "&lt;/div&gt;";
}
#-------------------------------
# legend stuff.

if (  my( $place )= $q-&gt;param('showlegend')  ) {
  $VARS-&gt;{'nnt-legend-bottom'}= ($place eq 'bottom');
}

my $legend=join "",
    "&lt;div id='nnt-legend' class='nnt-section'&gt;",
    "&lt;h3&gt;",
    sprintf($toggle_fmt,"-legend","-legend"),
    'Legend&amp;nbsp;&lt;font size="2"&gt;&lt;a href="#toc-top"&gt;(Top)&lt;/a&gt;&lt;/font&gt;&lt;/h3&gt;',
    "&lt;ul id='ul-legend'&gt;",
    q[&lt;blockquote&gt;&lt;u&gt;Title&lt;/u&gt; &amp;#91;&lt;b&gt;^1&lt;/b&gt;&amp;#93;].
    q[(&lt;b&gt;&lt;u&gt;AC&lt;/u&gt;&lt;/b&gt;:&lt;b&gt;3&lt;/b&gt;/&lt;b&gt;9&lt;/b&gt;/&lt;b&gt;7&lt;/b&gt;)].
    q[&lt;u&gt;&lt;b&gt;+/-&lt;/b&gt;&lt;/u&gt; &amp;#91;&lt;u&gt;author&lt;/u&gt;&amp;#93;&lt;/blockquote&gt;].
    q[&lt;p&gt;Means: You "&lt;b&gt;^&lt;/b&gt;"=up- or "&lt;b&gt;v&lt;/b&gt;"=down-voted,].
    q[ "&lt;b&gt;1&lt;/b&gt;"=reputation; "&lt;u&gt;&lt;b&gt;AC&lt;/b&gt;&lt;/u&gt;" from ].
    q[( &lt;b&gt;F&lt;/b&gt;ront-paged, &lt;b&gt;A&lt;/b&gt;pproved, ].
    q[&lt;b&gt;U&lt;/b&gt;napproved, &lt;b&gt;C&lt;/b&gt;onsidered, ].
    q[or link to &lt;b&gt;P&lt;/b&gt;arent or &lt;b&gt;R&lt;/b&gt;oot ); ].
    q[Replies: "&lt;b&gt;3&lt;/b&gt;" direct, "&lt;b&gt;9&lt;/b&gt;" ].
    q[descendents, "&lt;b&gt;7&lt;/b&gt;" recent, "&lt;b&gt;+/-&lt;/b&gt;" ].
    q[shows/hides(uses javascript)],
    "&lt;/p&gt;&lt;p align='right'&gt;",
    linkNode(396325,'View Full Documentation'),
    ", ",
    $VARS-&gt;{'nnt-legend-bottom'}  
      ? linkNode($NODE,'Show Legend at Top',
           {-title=&gt;"Move legend section to top",showlegend=&gt;'top'})
      : linkNode($NODE,'Show Legend at Bottom',
           {-title=&gt;"Move legend section to bottom",showlegend=&gt;'bottom'}),
    '&lt;/p&gt;&lt;/ul&gt;',
    "&lt;hr class='nnt-section-break' /&gt;",
    "&lt;/div&gt;";

if ($VARS-&gt;{'nnt-legend-bottom'}) {
    push @html,$legend;
} else {
    unshift @html,$legend;
}

#-------------------------------

$Do_MarkTime &amp;&amp; MarkTime("Done");
my $viewed_message = @toc ? "I've checked all of these" : "Check for newer nodes";
my $form;
  
#
# ===========================================================================
# We now handle forms and stuff. All of the sections are taken care of.
# ===========================================================================

#
# Time stuff
my %linkhash=(-1=&gt;'&lt;&lt;&lt;&lt;',0=&gt;"",1=&gt;'&gt;');
my @len_strs=('','Day','Week','Month','Year');
my $shown_basetime=0;
my $as_of_links="&lt;table align='center' id='nnt-as-of-links'&gt;".
                "&lt;tr&gt;&lt;th&gt;".$q-&gt;a( { name =&gt; "toc-top" },"Viewing Nodes As of:")."&lt;/th&gt;".
  (join "",
    map {
      my $c="".($_ &lt;=&gt; $as_of_unix);
      my $str=$linkhash{$c};
      if ($c&lt;0) {
        chop($linkhash{$c});
      } elsif ($c) {
        $linkhash{$c}.=substr($linkhash{$c},0,1);
      }
      my $date=POSIX::strftime("%Y-%m-%d",localtime($_));
      my $ret= ($_+$fudge &gt;= $basetime )
                ? !$shown_basetime++
                  ? $c ? linkNode($NODE,'Return to Present',{-title=&gt;'Return to present!'})
                       : '&lt;b&gt;'.linkNode($NODE,'Now',{-title=&gt;'Current view!'})."&lt;/b&gt;"
                  : '&amp;nbsp;'
                : linkNode($NODE,$str||$date,
                           { 'nnt-as-of'=&gt; $date,
                            -title=&gt; !$str ? "Current!" : "View as of "
                                    .htmlcode('timesince','',0,$basetime-$_)
                                    ." ("
                                    .($len_strs[length($str)]
                                     ?($c&gt;0?'Forward':'Back')
                                      ." One "
                                      .$len_strs[length($str)]
                                     : "This page")
                                    .": $date)"
                    });

     "&lt;td&gt;$ret&lt;/td&gt;"
    } (
        $as_of_unix - 365*24*3600,
        $as_of_unix - 30*24*3600,
        $as_of_unix - 7*24*3600,
        $as_of_unix - 24*3600,
        $as_of_unix,
        $as_of_unix + 24*3600,
        $as_of_unix + 7*24*3600,
        $as_of_unix + 30*24*3600,
        $as_of_unix + 365*24*3600
        )
)."&lt;/tr&gt;&lt;/table&gt;";
my $color_key="&lt;table width='80%' align='center'&gt;&lt;tr&gt;"
             .join("",
               map {  my $text=$age_desc[$_];
                      my $no_time=$text=~s/^-//;
                      my $timetext=htmlcode('timesince','','',$age_time[$_]);
                      my ($color)=$color_classes[$_];
                      if ($text!~/[A-Z]/) {
                         $text=$timetext;
                      } elsif (!$no_time) {
                         $text.=":".$timetext;
                      }
                      # "&lt;td bgcolor='$color' title='$text'&gt;&amp;nbsp&lt;/td&gt;"
                       "&lt;td align='center' title='$text'&gt;"
                       ."&lt;a class='$color'&gt;&amp;#x2588;&lt;/a&gt;"
                       ."&lt;/td&gt;"

                   } 0..$#ages)."&lt;/tr&gt;&lt;/table&gt;";

# Build the form

if ( getId($USER) != $HTMLVARS{default_user} ) {
    $form = qq[&lt;p&gt;
      &lt;form method="post" action="?" enctype="application/x-www-form-urlencoded"&gt;
      &lt;input type="hidden" name="node_id" value="] . getId($NODE) . qq[" /&gt;
      &lt;input type="hidden" name="displaytype" value="display" /&gt;
      &lt;input type="hidden" name="pageloadtime" value="] . time() . qq[" /&gt;
      &lt;input type="submit" name="viewedNewNodes" value="$viewed_message" /&gt;
      &lt;/form&gt;&lt;/p&gt;];
}

$q-&gt;param('node_id',$NODE-&gt;{node_id});
if ($Do_MarkTime) {
    MarkTime('--final--');
    #printLog("demerphq's sandpit done mode: $VARS-&gt;{nnt_mode} ($$)");
}
my $notbare=$q-&gt;param('style') ne 'bare';
# and the rest of the links and cfg bodge.
return join "\n",
  qq[
    &lt;!--
    
    &lt;script&gt;&lt;/script&gt;

    --&gt;
    &lt;script type="text/javascript"&gt;
    function toggleMenu(id){
      element = document.getElementById(id);
      element.className = (element.className.toLowerCase() ==
                            'expanded' ? 'collapsed' : 'expanded');
    }
    &lt;/script&gt;
  ],
  $Color_Style,
  qq[&lt;div id="nodethreads-head"&gt;],
  (@mark_time_html ? ('&lt;ul class="nnt-marktime"&gt;',@mark_time_html,'&lt;/ul&gt;') : ()),
  '&lt;p&gt;',
  $notbare &amp;&amp; qq[&lt;span class="nnt-colorkey"&gt;$color_key&lt;/span&gt;],
  $notbare &amp;&amp; qq[&lt;span class="nnt-asof"&gt;$as_of_links&lt;/span&gt;],
  $notbare &amp;&amp; do{
    my $view_link;
    my $mode_ans=$q-&gt;a({href=&gt;"?node_id=$NODE-&gt;{node_id};mode=ancestors",
                        title=&gt;'nodes and their direct ancestors'},'Node Ancestors');
    my $mode_ful=$q-&gt;a({href=&gt;"?node_id=$NODE-&gt;{node_id};mode=fullthread",
                        title=&gt;'everything... the whole tree'} ,'Full Thread',);
    my $mode_rtn=$q-&gt;a({href=&gt;"?node_id=$NODE-&gt;{node_id};mode=root-and-node",
                        title=&gt;'nodes and their roots'},'Root and Node');
    my $mode_min=$q-&gt;a({href=&gt;"?node_id=$NODE-&gt;{node_id};mode=minimal",
                        title=&gt;'just nodes but threaded if possible'},'Minimal Nodes');

    if ($mode eq 'fullthread') {
      $view_link="&lt;b&gt;Full Thread&lt;/b&gt;, switch to $mode_rtn, $mode_min or $mode_ans";
    } elsif ($mode eq 'ancestors') {
      $view_link="&lt;b&gt;Node Ancestors&lt;/b&gt;, switch to $mode_rtn, $mode_min or $mode_ful";
    } elsif ($mode eq 'root-and-node')  {
      $view_link="&lt;b&gt;Root and Node&lt;/b&gt;, switch to $mode_min, $mode_ans or $mode_ful";

    } elsif ($mode eq 'minimal') {
      $view_link="&lt;b&gt;Minimal Nodes&lt;/b&gt;, switch to $mode_rtn, $mode_ans or $mode_ful";
    }
    qq[&lt;span class='nnt-viewlinks'&gt;].
    "Current View Mode is ".
    qq[ $view_link&lt;br /&gt;Jump to &lt;a href="?node_id=396325"&gt;Help&lt;/a&gt; |].
    qq[ &lt;a href="#nnt-legend"&gt;Legend&lt;/a&gt; |].
    qq[ &lt;a href="#nnt-config"&gt;Page Settings&lt;/a&gt;&lt;/span&gt;]
  },
  qq[&lt;span class="nnSummary"&gt;],
  (@html!=$count)
  ?
    ' | '
    . join( '&lt;span class="link-sep"&gt;&lt;span class="NN-link-sep"&gt;'
    . ' | &lt;/span&gt;&lt;/span&gt;', @toc )
    . ($cfg
       ?"&lt;br /&gt;&lt;b&gt;Config Mode&lt;/b&gt;: Sections in &lt;i&gt;italics&lt;/i&gt; are hidden,"
       ." &lt;b&gt;bold&lt;/b&gt; have content and would be shown and normal sections"
       ." are ones that would display but now have no content."
       :"")
  : ('. There are no nodes to view at this time.'),
  '&lt;/span&gt;',
  "&lt;/p&gt;&lt;hr /&gt;",
  "&lt;/div&gt;",
  "&lt;div id='nodethreads'&gt;",
  $cfg||$blk
  ? qq[
       &lt;form method="post" action="?" enctype="application/x-www-form-urlencoded"&gt;
       &lt;input type="hidden" name="node_id" value="] . getId($NODE) . qq[" /&gt;
       &lt;input type="hidden" name="displaytype" value="display" /&gt;]
  :(),
  $cfg?qq[&lt;input type="hidden" name="nnt-cfg" value="1" /&gt;] : (),
  $blk?qq[&lt;input type="hidden" name="nnt-blk" value="1" /&gt;] : (),
  @html,
  $blk ? "&lt;p&gt;You have ".scalar(keys %blocked)." nodes blocked.&lt;br /&gt;"
         .$q-&gt;checkbox(-name=&gt;'nnt-clear-oldblocking',
                       -checked=&gt;0,
                       -value=&gt;'clear',
                       -label=&gt;'Clear Old Filters',
                       -title=&gt;'Remove any old filters that are currently in effect',
                       -force=&gt;1,)
        ."&lt;/p&gt;"
         : (),
  $cfg ? qq[&lt;input type="submit" name="Change" value="Change Order" /&gt;] : (),
  $blk||$cfg ? qq[&lt;/form&gt;] : (),
  "&lt;/div&gt;",
  qq[&lt;div id="nodethreads-foot"&gt;],
  $form,
  do {
    my @array = (  map $_/2,1..6 );
    my $str= htmlcode('openform')
           . $q-&gt;hidden(  pageloadtime =&gt; time() );

    my $choosedepth = qq[to a maximum depth of ].$q-&gt;popup_menu('maxdepth',[0..10],
                      $VARS-&gt;{nnt_maxdepth}||0);
    my $checkboxes =
         $q-&gt;checkbox(-name=&gt;'showage',
                      -checked=&gt;$VARS-&gt;{nnt_showage}||0,
                      -value=&gt;'1',
                      -label=&gt;'Show node age',
                      -force=&gt;1,)." ".
         $q-&gt;checkbox(-name=&gt;'showtime',
                      -checked=&gt;$VARS-&gt;{nnt_showtime}||0,
                      -value=&gt;'1',
                      -label=&gt;'Show node time',
                      -force=&gt;1,)." ".
         $q-&gt;checkbox(-name=&gt;'nnt-toggle-left',
                      -checked=&gt;$VARS-&gt;{nnt_toggle_left}||0,
                      -value=&gt;'1',
                      -label=&gt;'Show toggle on the left',
                      -force=&gt;1,)." ".
         "&lt;br /&gt;\n".
         (getId($USER)!=$HTMLVARS{default_user}
         ?$q-&gt;checkbox(-name=&gt;'nnt-cfg',
                      -checked=&gt;0,
                      -value=&gt;'1',
                      -label=&gt;'Config Mode',
                      -force=&gt;0,
                      )." ".
          $q-&gt;checkbox(-name=&gt;'nnt-blk',
                      -checked=&gt;$VARS-&gt;{nnt_blk},
                      -value=&gt;'1',
                      -label=&gt;'Filtered Nodes?',
                      -force=&gt;0,
                      )." ".
          "&lt;br /&gt;\n"
         : "");
    $checkboxes="" unless $notbare;
    if(  ! $VARS-&gt;{lastviewednewestnodes}  ) {
      $str .= qq[Showing nodes created within the past ]
           . $q-&gt;popup_menu('numdays',\@array,$days)
           . qq[ days&lt;br /&gt;$choosedepth&lt;br /&gt;]
           . $checkboxes
           . $q-&gt;submit("Set")
           . qq[&lt;br /&gt;];
    } else{
      $str .= qq[Showing nodes created since ]
           . htmlcode('convertEpochSecs',$VARS-&gt;{lastviewednewestnodes})
           . qq[&lt;br /&gt;$choosedepth]
           . $checkboxes
           . $q-&gt;submit("Set")
           . qq[&lt;br /&gt;];
      $str.=qq[&lt;input type="submit" name="clearNewNodesFlag"
                 value="Clear my 'last checked' time" /&gt;&lt;br /&gt;]
            if  getId($USER) != $HTMLVARS{default_user};
    }
    qq[&lt;h3&gt;&lt;a name="nnt-config"&gt;Page Settings&lt;/a&gt;&lt;/h3&gt;$str&lt;/form&gt;];

  },
  "&lt;/div&gt;"
;

###########################################################################
###########################################################################
</live_code>
<reason>be consistent about putting squotes on usernames in 'title' attributes</reason>
<field>code</field>
</record>
<record><htmlcode_id>524788</htmlcode_id>
<patch_code>my ($opts)=@_;

unless ($opts-&gt;{no_query}) {
    $opts-&gt;{$_}||=$query-&gt;param($_)
       for qw( sql exec copytopad ascode );
}


my $is_xml = $opts-&gt;{is_xml} || $q-&gt;param('displaytype') eq 'xml';

my($xml,@data,%xmlstyle);
if ($is_xml) {
  $xmlstyle{clean}=1;
  return "&lt;error&gt;Error creating fling object&lt;/error&gt;"
     unless htmlcode('new_xml_fling','',\($xml,@data,%xmlstyle));
  $xml-&gt;start('sqlqueryresult') if $is_xml;
}

local *_error=sub {
  my ($type,$msg,$data)=@_;
  if ($is_xml) {
    $xml-&gt;start('error',type=&gt;$type);
    $xml-&gt;element('error_message',$msg);
    $xml-&gt;element('data',$data) if $data;
    $xml-&gt;end('error');
  } else {
    my $line=0;
    $data||="";
    $data=~s/^/sprintf "% 2d: ",++$line/mge;
    push @data, "&lt;p&gt;&lt;strong&gt;Error: $type&lt;/strong&gt;".
           htmlcode('wrapcode','',"\n$msg\n$data").
           "&lt;hr /&gt;"
  }
};

my $execstr = $opts-&gt;{sql};
my $doexec  = $opts-&gt;{exec};
my $ascode  = $opts-&gt;{ascode};


unless ($is_xml || $opts-&gt;{no_form}) {
    push @data, join "\n",
        htmlcode('openform'),
        "SQL Query:&lt;br /&gt;",
        $query-&gt;textarea( "sql", $execstr, 8, 60 ),
        "&lt;br /&gt;",
        $query-&gt;submit('exec', 'Execute'),
        $query-&gt;checkbox(-name=&gt;'fulldoctext',
                         -checked=&gt;0,
                         -value=&gt;'1',
                         -label=&gt;'Show all field content?'),

        "&lt;br /&gt;",
        $query-&gt;checkbox(-name=&gt;'ascode',
                         -checked=&gt;0,
                         -value=&gt;'1',
                         -label=&gt;'Output as code'),
        "&lt;br /&gt;",
        $query-&gt;checkbox(-name=&gt;'copytopad',
                         -checked=&gt;0,
                         -value=&gt;'1',
                         -label=&gt;'Copy to your private scratchpad on success?'),
        $query-&gt;end_form(),
    ;
} elsif (!$is_xml) {
   push @data, "&lt;h4&gt;SQL being executed:&lt;/h4&gt;"
           . htmlcode('wrapcode','',$execstr);
}

push @data,"&lt;hr /&gt;" unless $is_xml;
my $pretable=$#data;

my $error; # anything that means we cant make an sqlquery node from it.
my $has_recs=0;

my $dbh=$DB-&gt;getDatabaseHandle();
local $dbh-&gt;{PrintError}=0;
local $dbh-&gt;{RaiseError}=1;

while ($doexec and $execstr)
{
  $doexec=0; #prevent infinity!
  my @table;
  my $cursor;
  my $start_time = time();
  {
    local $SIG{__DIE__} = sub {};
    local *Everything::HTML::htmlErrorGods=sub {''};
    $cursor=eval { $dbh-&gt;prepare($execstr) };
  }
  if ($@) {
     $error++;
     _error("Prepare","$@",$execstr);
     last;
  }
  $cursor-&gt;{RaiseError} = 0;
  my $count;
  {
    local $SIG{__DIE__} = sub {};
    local *Everything::HTML::htmlErrorGods=sub {''};
    $count=eval { $cursor-&gt;execute() };
  }

  if ($@) {
     $error++;
     _error("Execute","$@",$execstr);
     last;
  }
  if(  ! $count  )
  {
    $error++;
    my $errstr=$DBI::errstr;
    _error("Execute","\n$errstr\n",$execstr);
    last;


  } elsif(  ! $cursor-&gt;{NUM_OF_FIELDS}  ) # not a select statement
  {
    $error++;
    if ($is_xml) {
      $xml-&gt;element(rows_affected=&gt;$count);
    } elsif (!$ascode) {
      push @data,"&lt;b&gt;$count&lt;/b&gt; rows affected.\n";
    }
  } else
  {
    if ($is_xml) {
      $xml-&gt;element(rows_affected=&gt;$count);
    } elsif (!$ascode) {

      push @data, qq[($count rows)\n&lt;br /&gt;]
                . qq[&lt;table border="1" cellpadding="2" cellspacing="2"&gt;];
    }

    my @hdr=@{$cursor-&gt;{NAME}};
    if (!$is_xml || $is_xml &amp;&amp; $xmlstyle{array}) {
      if ($ascode) {
        push @data, "&lt;code&gt;\n";
      } elsif (!$is_xml) {
        push @data, " &lt;tr&gt;\n";
      } else {
        $xml-&gt;start('fields');
      }
      if ($ascode) {
         push @data,join("\t",@hdr),"\n";
      } else {
        foreach (  0..$#hdr  )
        {
          my $v=$hdr[$_];
          if ($is_xml) {
            $xml-&gt;element('field',
                          (defined $v ? () : ('undef'=&gt;1)),
                          (defined $v ? $v : ())
                         );
          } else {
            if(  ! defined $v  ) {
              $v= "";
            } elsif(  "" eq $v  ) {
              $v= "&amp;nbsp;";
            } else {
              $v= $q-&gt;escapeHTML($v);
            }
            push @data, qq[  &lt;td align="center" bgcolor="#CC99CC"&gt;]
                      . qq[&lt;font color="#000000"&gt;$v&lt;/font&gt;&lt;/td&gt;\n];
          }
        } 
        unless ($is_xml) {
          push @data, "&lt;/tr&gt;\n";
        } else {
          $xml-&gt;end('fields');
        }
      }
    } elsif ($is_xml) {
      my %dupe;
      @hdr=map { 
        if ( $dupe{$_} ) {
          my $counter = 1;
          $counter++ while $dupe{ $_ . "_$counter" };
          $_ . "_$counter";
        } else {
          $_
        }
      } @hdr;
    }
    while(my @row = $cursor-&gt;fetchrow_array)
    {

      $has_recs++;

      
      if ($is_xml) {
        $xml-&gt;start('record');        
      } elsif ($ascode) {
        push @data,join("\t",@row)."\n";  
        next;
      } else {
        push @data, " &lt;tr&gt;\n";        
      }
      foreach my $idx ( 0..$#row )
      {
        my $k=$hdr[$idx];
        my $v=$row[$idx];
        unless ($is_xml) {
          if(  ! defined $v  ) {
            $v= "";
          } elsif(  "" eq $v  ) {
            $v= "&amp;nbsp;";
          } elsif ($k =~/passwd/i) {
            $v= "&lt;i&gt;restricted&lt;/i&gt;";
          } elsif(  $k =~ /_/  &amp;&amp;  $v !~ /\D/  ) {
            my $n= getNodeById($v,"light");
            $v = linkNode($v,$v);
            if(  $n  ) {
              my $t= $q-&gt;escapeHTML( $n-&gt;{title} );
              $v =~ s/href=/title="$t" href=/i;
            }
          } else {
            my $maxlen= $VARS-&gt;{sqlmaxlen} || 1024;
            if(  $maxlen &lt; length($v)  and  ! $q-&gt;param('fulldoctext')  ) {
              $v= $q-&gt;escapeHTML( substr($v,0,$maxlen) )
                . " &lt;b&gt;(Only $maxlen of " . length($v) . " bytes)&lt;/b&gt;";
            } else {

              $v= $q-&gt;escapeHTML($v);
            }
            $v =~ s#  # &amp;nbsp;#g;
            $v =~ s#\n#&lt;br /&gt;\n#g;
          }
          push @data, "  &lt;td&gt;$v&lt;/td&gt;\n";
        } elsif ($xmlstyle{array}) {
          $xml-&gt;element('v',
                      (defined $v ? () : ('undef'=&gt;1)),
                      (defined $v ? $v : ())
                     );
        } else {
          $xml-&gt;element($k,
                      (defined $v ? () : ('undef'=&gt;1)),
                      (defined $v ? $v : ())
                     );
        } 
      }
      unless ($is_xml) {
        push @data, "&lt;/tr&gt;\n";
      } else {
        $xml-&gt;end('record');
      }
      #if (!$is_xml and $has_recs&gt;5000 and !$q-&gt;param('no_limit')) {
      #  push @data,qq[&lt;tr&gt;&lt;td colspan="].scalar(@{$cursor-&gt;{NAME}})
      #            .qq["&gt;&lt;b&gt;Terminated fetch at 1000 records.&lt;/b&gt;&lt;/td&gt;&lt;/tr&gt;];
      #  last

      #}
    }
    $cursor-&gt;finish();
    if (!$is_xml &amp;&amp; !$ascode) {
      push @data, "&lt;/table&gt;\n";
    }
    if(!$has_recs &amp;&amp; !$ascode)
    {
      push @data, "&lt;b&gt;Zero rows returned.&lt;/b&gt;\n";
    } elsif ($ascode) {
      push @data,"&lt;/code&gt;\n";
    }
  }
  my $elapsed = time() - $start_time;
  push @data, "&lt;br /&gt;Elapsed time $elapsed s."
     if !$is_xml &amp;&amp; !$ascode;
 
  unless ($is_xml or $error or $opts-&gt;{no_form}) {
    if ( $opts-&gt;{copytopad} &amp;&amp; 
         ( my $pad_id = htmlcode( 'scratchpad_link','',
             getId($USER),'',{},1,1 ) ) )
    {
       my $str= join("","&lt;hr /&gt;",htmlcode('wrapcode','',$execstr),"\n",
                @data[$pretable+1 .. $#data]);
       my $pad= getNodeById($pad_id);
       
       $pad-&gt;{privatetext} .= $str."&lt;!--SQLQUERY--&gt;"
          unless  $pad-&gt;{privatetext}=~ s/(&lt;!--SQLQUERY--&gt;)/$str\n$1/i;
       updateNode($pad, -1) &amp;&amp;
          push @data,"&lt;p&gt;Pad updated.&lt;/p&gt;";
    }
    $data[$pretable].=join "\n",
        'Query successful. If you wish to create a node to execute this',
        'query enter the name for the query and hit the "Create" button.',
        '&lt;/br&gt;',
        "Query Name:\n",
        htmlcode('openform'),
        $q-&gt;hidden( -name=&gt;"op",      -force=&gt;1, -value=&gt; "new", -force=&gt;1 ),
        $q-&gt;hidden( -name=&gt;"type",    -force=&gt;1, -value=&gt; "sqlquery",  ),
        $q-&gt;hidden( -name=&gt;"sqlquery_doctext", -force=&gt;1,
                    -value=&gt; "&lt;p&gt;&lt;!-- Your description goes here--&gt;&lt;/p&gt;" ),
        $q-&gt;hidden( -name=&gt;"sqlquery_code", -force=&gt;1, -value=&gt; $execstr ),
        $q-&gt;hidden( -name=&gt;"displaytype", -force=&gt;1, -value=&gt; 'edit' ),
        $q-&gt;textfield( -name=&gt;'node', -force=&gt;1, -default=&gt;'', -maxlength=&gt;200 ),
        $q-&gt;submit("Create"),
        $q-&gt;end_form(),
        '&lt;hr /&gt;'
  }
}
if ($is_xml) {
  $xml-&gt;done;
}
return join "",@data;</patch_code>
<applied>2006-01-22 10:06:40</applied>
<htmlcode_id>397471</htmlcode_id>
<live_code>my ($opts)=@_;

unless ($opts-&gt;{no_query}) {
    $opts-&gt;{$_}||=$query-&gt;param($_)
       for qw( sql exec copytopad ascode );
}


my $is_xml = $opts-&gt;{is_xml} || $q-&gt;param('displaytype') eq 'xml';

my($xml,@data,%xmlstyle);
if ($is_xml) {
  $xmlstyle{clean}=1;
  return "&lt;error&gt;Error creating fling object&lt;/error&gt;"
     unless htmlcode('new_xml_fling','',\($xml,@data,%xmlstyle));
  $xml-&gt;start('sqlqueryresult') if $is_xml;
}

local *_error=sub {
  my ($type,$msg,$data)=@_;
  if ($is_xml) {
    $xml-&gt;start('error',type=&gt;$type);
    $xml-&gt;element('error_message',$msg);
    $xml-&gt;element('data',$data) if $data;
    $xml-&gt;end('error');
  } else {
    my $line=0;
    $data||="";
    $data=~s/^/sprintf "% 2d: ",++$line/mge;
    push @data, "&lt;p&gt;&lt;strong&gt;Error: $type&lt;/strong&gt;".
           htmlcode('wrapcode','',"\n$msg\n$data").
           "&lt;hr /&gt;"
  }
};

my $execstr = $opts-&gt;{sql};
my $doexec  = $opts-&gt;{exec};
my $ascode  = $opts-&gt;{ascode};


unless ($is_xml || $opts-&gt;{no_form}) {
    push @data, join "\n",
        htmlcode('openform'),
        "SQL Query:&lt;br /&gt;",
        $query-&gt;textarea( "sql", $execstr, 8, 60 ),
        "&lt;br /&gt;",
        $query-&gt;submit('exec', 'Execute'),
        $query-&gt;checkbox(-name=&gt;'fulldoctext',
                         -checked=&gt;0,
                         -value=&gt;'1',
                         -label=&gt;'Show all field content?'),

        "&lt;br /&gt;",
        $query-&gt;checkbox(-name=&gt;'ascode',
                         -checked=&gt;0,
                         -value=&gt;'1',
                         -label=&gt;'Output as code'),
        "&lt;br /&gt;",
        $query-&gt;checkbox(-name=&gt;'copytopad',
                         -checked=&gt;0,
                         -value=&gt;'1',
                         -label=&gt;'Copy to your private scratchpad on success?'),
        $query-&gt;end_form(),
    ;
} elsif (!$is_xml) {
   push @data, "&lt;h4&gt;SQL being executed:&lt;/h4&gt;"
           . htmlcode('wrapcode','',$execstr);
}

push @data,"&lt;hr /&gt;" unless $is_xml;
my $pretable=$#data;

my $error; # anything that means we cant make an sqlquery node from it.
my $has_recs=0;

my $dbh=$DB-&gt;getDatabaseHandle();
local $dbh-&gt;{PrintError}=0;
local $dbh-&gt;{RaiseError}=1;

while ($doexec and $execstr)
{
  $doexec=0; #prevent infinity!
  my @table;
  my $cursor;
  my $start_time = time();
  {
    local $SIG{__DIE__} = sub {};
    local *Everything::HTML::htmlErrorGods=sub {''};
    $cursor=eval { $dbh-&gt;prepare($execstr) };
  }
  if ($@) {
     $error++;
     _error("Prepare","$@",$execstr);
     last;
  }
  $cursor-&gt;{RaiseError} = 0;
  my $count;
  {
    local $SIG{__DIE__} = sub {};
    local *Everything::HTML::htmlErrorGods=sub {''};
    $count=eval { $cursor-&gt;execute() };
  }

  if ($@) {
     $error++;
     _error("Execute","$@",$execstr);
     last;
  }
  if(  ! $count  )
  {
    $error++;
    my $errstr=$DBI::errstr;
    _error("Execute","\n$errstr\n",$execstr);
    last;


  } elsif(  ! $cursor-&gt;{NUM_OF_FIELDS}  ) # not a select statement
  {
    $error++;
    if ($is_xml) {
      $xml-&gt;element(rows_affected=&gt;$count);
    } elsif (!$ascode) {
      push @data,"&lt;b&gt;$count&lt;/b&gt; rows affected.\n";
    }
  } else
  {
    if ($is_xml) {
      $xml-&gt;element(rows_affected=&gt;$count);
    } elsif (!$ascode) {

      push @data, qq[($count rows)\n&lt;br /&gt;]
                . qq[&lt;table border="1" cellpadding="2" cellspacing="2"&gt;];
    }

    my @hdr=@{$cursor-&gt;{NAME}};
    if (!$is_xml || $is_xml &amp;&amp; $xmlstyle{array}) {
      if ($ascode) {
        push @data, "&lt;code&gt;\n";
      } elsif (!$is_xml) {
        push @data, " &lt;tr&gt;\n";
      } else {
        $xml-&gt;start('fields');
      }
      if ($ascode) {
         push @data,join("\t",@hdr),"\n";
      } else {
        foreach (  0..$#hdr  )
        {
          my $v=$hdr[$_];
          if ($is_xml) {
            $xml-&gt;element('field',
                          (defined $v ? () : ('undef'=&gt;1)),
                          (defined $v ? $v : ())
                         );
          } else {
            if(  ! defined $v  ) {
              $v= "";
            } elsif(  "" eq $v  ) {
              $v= "&amp;nbsp;";
            } else {
              $v= $q-&gt;escapeHTML($v);
            }
            push @data, qq[  &lt;td align="center" bgcolor="#CC99CC"&gt;]
                      . qq[&lt;font color="#000000"&gt;$v&lt;/font&gt;&lt;/td&gt;\n];
          }
        } 
        unless ($is_xml) {
          push @data, "&lt;/tr&gt;\n";
        } else {
          $xml-&gt;end('fields');
        }
      }
    } elsif ($is_xml) {
      my %dupe;
      @hdr=map { 
        if ( $dupe{$_} ) {
          my $counter = 1;
          $counter++ while $dupe{ $_ . "_$counter" };
          $_ . "_$counter";
        } else {
          $_
        }
      } @hdr;
    }
    while(my @row = $cursor-&gt;fetchrow_array)
    {

      $has_recs++;

      
      if ($is_xml) {
        $xml-&gt;start('record');        
      } elsif ($ascode) {
        push @data,join("\t",@row)."\n";  
        next;
      } else {
        push @data, " &lt;tr&gt;\n";        
      }
      foreach my $idx ( 0..$#row )
      {
        my $k=$hdr[$idx];
        my $v=$row[$idx];
        unless ($is_xml) {
          if(  ! defined $v  ) {
            $v= "";
          } elsif(  "" eq $v  ) {
            $v= "&amp;nbsp;";
          } elsif ($k =~/passwd/i) {
            $v= "&lt;i&gt;restricted&lt;/i&gt;";
          } elsif(  $k =~ /_/  &amp;&amp;  $v !~ /\D/  ) {
            my $n= getNodeById($v,"light");
            $v = linkNode($v,$v);
            if(  $n  ) {
              my $t= $q-&gt;escapeHTML( $n-&gt;{title} );
              $v =~ s/href=/title="$t" href=/i;
            }
          } else {
            my $maxlen= $VARS-&gt;{sqlmaxlen} || 1024;
            if(  $maxlen &lt; length($v)  and  ! $q-&gt;param('fulldoctext')  ) {
              $v= $q-&gt;escapeHTML( substr($v,0,$maxlen) )
                . " &lt;b&gt;(Only $maxlen of " . length($v) . " bytes)&lt;/b&gt;";
            } else {

              $v= $q-&gt;escapeHTML($v);
            }
            $v =~ s#  # &amp;nbsp;#g;
            $v =~ s#\n#&lt;br /&gt;\n#g;
          }
          push @data, "  &lt;td&gt;$v&lt;/td&gt;\n";
        } elsif ($xmlstyle{array}) {
          $xml-&gt;element('v',
                      (defined $v ? () : ('undef'=&gt;1)),
                      (defined $v ? $v : ())
                     );
        } else {
          $xml-&gt;element($k,
                      (defined $v ? () : ('undef'=&gt;1)),
                      (defined $v ? $v : ())
                     );
        } 
      }
      unless ($is_xml) {
        push @data, "&lt;/tr&gt;\n";
      } else {
        $xml-&gt;end('record');
      }
      #if (!$is_xml and $has_recs&gt;5000 and !$q-&gt;param('no_limit')) {
      #  push @data,qq[&lt;tr&gt;&lt;td colspan="].scalar(@{$cursor-&gt;{NAME}})
      #            .qq["&gt;&lt;b&gt;Terminated fetch at 1000 records.&lt;/b&gt;&lt;/td&gt;&lt;/tr&gt;];
      #  last

      #}
    }
    $cursor-&gt;finish();
    if (!$is_xml &amp;&amp; !$ascode) {
      push @data, "&lt;/table&gt;\n";
    }
    if(!$has_recs &amp;&amp; !$ascode)
    {
      push @data, "&lt;b&gt;Zero rows returned.&lt;/b&gt;\n";
    } elsif ($ascode) {
      push @data,"&lt;/code&gt;\n";
    }
  }
  my $elapsed = time() - $start_time;
  push @data, "&lt;br /&gt;Elapsed time $elapsed s."
     if !$is_xml &amp;&amp; !$ascode;
 
  unless ($is_xml or $error or $opts-&gt;{no_form}) {
    if ( $opts-&gt;{copytopad} &amp;&amp; 
         ( my $pad_id = htmlcode( 'scratchpad_link','',
             getId($USER),'',{},1,1 ) ) )
    {
       my $str= join("","&lt;hr /&gt;",htmlcode('wrapcode','',$execstr),"\n",
                @data[$pretable+1 .. $#data]);
       my $pad= getNodeById($pad_id);
       
       $pad-&gt;{privatetext} .= $str."&lt;!--SQLQUERY--&gt;"
          unless  $pad-&gt;{privatetext}=~ s/(&lt;!--SQLQUERY--&gt;)/$str\n$1/i;
       updateNode( $pad, $USER ) &amp;&amp;
          push @data,"&lt;p&gt;Pad updated.&lt;/p&gt;";
    }
    $data[$pretable].=join "\n",
        'Query successful. If you wish to create a node to execute this',
        'query enter the name for the query and hit the "Create" button.',
        '&lt;/br&gt;',
        "Query Name:\n",
        htmlcode('openform'),
        $q-&gt;hidden( -name=&gt;"op",      -force=&gt;1, -value=&gt; "new", -force=&gt;1 ),
        $q-&gt;hidden( -name=&gt;"type",    -force=&gt;1, -value=&gt; "sqlquery",  ),
        $q-&gt;hidden( -name=&gt;"sqlquery_doctext", -force=&gt;1,
                    -value=&gt; "&lt;p&gt;&lt;!-- Your description goes here--&gt;&lt;/p&gt;" ),
        $q-&gt;hidden( -name=&gt;"sqlquery_code", -force=&gt;1, -value=&gt; $execstr ),
        $q-&gt;hidden( -name=&gt;"displaytype", -force=&gt;1, -value=&gt; 'edit' ),
        $q-&gt;textfield( -name=&gt;'node', -force=&gt;1, -default=&gt;'', -maxlength=&gt;200 ),
        $q-&gt;submit("Create"),
        $q-&gt;end_form(),
        '&lt;hr /&gt;'
  }
}
if ($is_xml) {
  $xml-&gt;done;
}
return join "",@data;</live_code>
<reason>errors from DBI need to be captured.</reason>
<field>code</field>
</record>
<record><htmlcode_id>406011</htmlcode_id>
<patch_code>  my ($id,$str,$enc,$remove)=@_;

  my ($lt,$gt)=$enc ? qw( &amp;lt; &amp;gt; ) : qw( &lt; &gt; );


  if ($remove) {
    my $open=
    $str=~s# $lt \s* readmore \s* (?:(?!$gt).)* $gt
           # $lt . 'div class="readmore"' . $gt
           #xigse;
    my $closed=
    $str=~s# $lt \s* / \s* readmore \s* $gt
           # $lt . "/div". $gt
           #gixse;
    if ($open != $closed)
    {
       $str.="$lt/div\n$gt" x ($open-$closed);
    }
  } else {
    $str =~ s{
             $lt \s* readmore                     # start tag
             (?: \s+
                 title \s* = \s*                  # title attribute
                 (?: ([""''])                     # $1 quoted string?
                     (                            # $2 content of quoted string
                       (?:(?!\1|$gt).)+           # Not tag finish nor close quote
                     )
                     \1                           # end quote
                   |
                     (                            # $3 unquoted content
                       (?:(?!$gt|[""''\s]).)+     # unquote attribute text
                     )
                 )
             )?
             \s* $gt                              # finish of start tag
             (.*?)                                # $4 content
             (?:
                 $lt \s* / \s* readmore \s* $gt   # close tag
               | $                                # end of string
             )
            }
    {
      my $title=$2 || $3 || '';
      my $length = htmlcode('shorten_num_bytes', '', length($4));
      "&lt;div class='readmore-link'&gt;".
      linkNode($id,"Read more...").
      ($title ? "&lt;span class='readmore-title'&gt; ".
                decodeHTML($title,'squarebrackets').
                "&lt;/span&gt;" 
              : "" ).
      "&lt;span class='readmore-size'&gt; ($length)&lt;/span&gt;".
      "&lt;/div&gt;"
    }xegis
  }
  $str;</patch_code>
<applied>2004-11-08 04:46:40</applied>
<htmlcode_id>401302</htmlcode_id>
<live_code>  my ($id,$str,$enc,$remove)=@_;

  my ($lt,$gt)=$enc ? qw( &amp;lt; &amp;gt; ) : qw( &lt; &gt; );


  if ($remove) {
    my $open=
    $str=~s# $lt \s* readmore \s* (?:(?!$gt).)* $gt
           # $lt . 'div class="readmore"' . $gt
           #xigse;
    my $closed=
    $str=~s# $lt \s* / \s* readmore \s* $gt
           # $lt . "/div". $gt
           #gixse;
    if ($open != $closed)
    {
       $str.="$lt/div\n$gt" x ($open-$closed);
    }
  } else {
    $str =~ s{
             $lt \s* readmore                     # start tag
             (?: \s+
                 title \s* = \s*                  # title attribute
                 (?: ([""''])                     # $1 quoted string?
                     (                            # $2 content of quoted string
                       (?:(?!\1|$gt).)+           # Not tag finish nor close quote
                     )
                     \1                           # end quote
                   |
                     (                            # $3 unquoted content
                       (?:(?!$gt|[""''\s]).)+     # unquote attribute text
                     )
                 )
             )?
             \s* $gt                              # finish of start tag
             (.*?)                                # $4 content
             (?:
                 $lt \s* / \s* readmore \s* $gt   # close tag
               | $                                # end of string
             )
            }
    {
      my $title=$2 || $3 || '';
      my $length = htmlcode('shorten_num_bytes', '', length($4));
      "&lt;div class='readmore-link'&gt;".
      linkNode($id,"Read more...").
      ($title ? "&lt;span class='readmore-title'&gt; ".
                $title.
                "&lt;/span&gt;" 
              : "" ).
      "&lt;span class='readmore-size'&gt; ($length)&lt;/span&gt;".
      "&lt;/div&gt;"
    }xegis
  }
  $str;</live_code>
<reason>add span wrapper</reason>
<field>code</field>
</record>
<record><htmlcode_id>628320</htmlcode_id>
<patch_code>#[ParseLinksInContent]

# Note this is intended to be the canonical parser for PM content
#  intended to replace most of [{ParseLinks}], [{ParseLinksInString}]
#  [{ParseLinksInNodeField}], and [{ParseLinksInChatter}]
my ( $text, %opts ) = @_;

# Currently supported %opts:
#   id              =&gt; id used for readmore, spoiler and dl link support
#                      THE ID OF THE NODE BEING RENDERED
#   node_id         =&gt; the current node id (defaults to $NODE-&gt;{node_id})
#   do_spoiler      =&gt; defaults to true, determines if spoiler handling occurs
#   do_perlfunc     =&gt; defaults to true, determines if perlfunc handling occurs
#   do_readmore     =&gt; defaults to true, determines if readmore handling occurs
#   readmore_remove =&gt; handle readmores specially
#   overridefilter  =&gt; used for changing filtering behaviour.

#   approvedtags    =&gt; name of setting, or settings hash which will be used
#                      instead of the default 'approved html tags'
#   bookscan        =&gt; if true will scan for book references
#   pmlinkparser    =&gt; name of htmlcode to use for parsing pmlinks
#                      overrides default of handleLinks()
#   simplecode      =&gt; if true then CB style code escaping occurs.
#   no_dl           =&gt; do not show download links.
#   preview         =&gt; in preview mode
#   parsecode       =&gt; do superdoc style code parsing.
#   nodetype        =&gt; used for parsecode
#   htmlnest        =&gt; if present overrides users htmlnest rules.
#   htmlerror       =&gt; if present overrides users htmlerror rules.

#
# *** NOTE ABOUT 'id' &amp; 'node_id' ***
# 'id' is the id of the node being rendered. Wheras node_id is the id of the
# node being _displayed_. Do not confuse them. Readmore support, auto download
# link supprt, and spoiler support all require a valid 'id' if the string being
# rendered isn't content from the node being displayed ($NODE).
# IE, if SOPW is the node being displayed, then for each node rendered below
# the 'id' would be set as appropriate. If one of those nodes was viewed directly
# then 'id' would not be set.
#
# OTOH, 'node_id' is just the $NODE-&gt;{node_id} in almost every situation, and
# defaults this way.

$opts{do_spoiler}=1
  unless defined $opts{do_spoiler};

$opts{do_readmore}=1
  unless defined $opts{do_readmore};

$opts{do_perlfunc}=1
  unless defined $opts{do_perlfunc};

$opts{node_id} = getId($NODE)
  unless $opts{node_id};

my $node_id = $opts{node_id};
# used by both spoiler and readmore handling and also code d/l link support.
my $item_id = $opts{id};

### PARSECODE  ###
my ($start,$end)=("","");
if ($opts{parsecode} and $opts{nodetype}) {
   $text= parseCode( $text )
      unless grep $_ eq $opts{nodetype},
         qw/sourcecode snippet/;

   if ($opts{nodetype}=~/superdoc/i &amp;&amp;
       $text=~m,
         ^
         (\s*(?:&lt;![^&gt;]*&gt;\s*)?&lt;html[^&gt;]*&gt;.*?&lt;body[^&gt;]*&gt;)
         (.*?)
         (&lt;/body&gt;\s*&lt;/html&gt;\s*)
         $
        ,ixs
   ){
       ($start,$text,$end)=($1,$2,$3);
   }
}

### BOOKSCAN ###
if ( $opts{bookscan} ) {
    $HTMLVARS{buybook} ||= $text =~ /(book)|(reference)/i;
}

### CONVERT CODE ###
my $partnum;
$text =~ s{(&lt;(c(?:ode)?)&gt;(.*?)&lt;/\2&gt;)}{

    my $whole = $1;
    my $code = $3;

    $HTMLVARS{code} .= $whole
      if $opts{do_perlfunc};

    if ($opts{simplecode}) {
        "&lt;tt&gt;" . $q-&gt;escapeHTML($code) . "&lt;/tt&gt;"
    } elsif(  $HTMLVARS{codereplaceoff}  ) {
        $whole;
    } else {
        my $dllink;
        if (!$VARS-&gt;{no_emded_code_dl} &amp;&amp; !$opts{no_dl}) {
              $dllink = linkNode($item_id||$node_id, "&amp;#91;download&amp;#93;",
                            { displaytype =&gt; 'displaycode',
                              abspart =&gt; 1,
                              part =&gt; ++$partnum
                            });
              if(Everything::isApproved($USER, getNode('editors','usergroup'))) {
                  $dllink .= ' ' . linkNode(
                      $item_id||$node_id, "&amp;#91;add readmore&amp;#93;",
                      { 
                          op   =&gt; 'addreadmore',                            
                          part =&gt; $partnum,
                      }
                  );  
              }                            
        }
        htmlcode( 'wrapcode','', $code, $dllink,$opts{preview});
    }
}seig;



### SPOILER ###
if ( $opts{do_spoiler} ) {
    my $spoiler_pat = "%TEXT%"; # this value should be overriden below
    my $spoiler_style = $VARS-&gt;{spoiler_style} || 'link';
    my $count;
    my $donefirst;
    while ( $text =~ m{&lt;spoiler&gt;((?:[^&lt;]+|(?!&lt;/?spoiler&gt;).)*?)&lt;/spoiler&gt;}sgi ) {
        $count++
    }
    if ($count) {
        my %show;
        if (my $show_spoilers=$q-&gt;param('showspoiler')) {
            $show{$_}++ for split /,/,$show_spoilers;
        }

        my $rel_id= $item_id || $node_id;
        if ($spoiler_style eq 'link') {
            #[Reveal this spoiler] or all spoilers [in this node].
            #Reveal [only this spoiler] or [only this node]
            #  or all [in this thread].

            #[Reveal this spoiler] or [only this spoiler]

            my $addthis= linkNode($node_id,'Reveal this spoiler',
                            {
                                showspoiler =&gt; join (",","$rel_id-N-U-M",keys %show)
                            }
                       );
            my $thread=linkNode($node_id,'in this thread',{spoil=&gt;1});
            if ( $count &gt;1 ) {
                my $only=linkNode($node_id,'only this spoiler',
                            {showspoiler=&gt;"$rel_id-N-U-M"});
                my $addnode=linkNode($node_id,'in this node',
                        {showspoiler=&gt;join (",",$rel_id,
                            grep { !/^$rel_id(-|$)/ } keys %show)});
                my $onlynode=linkNode($node_id,'reveal only this node',
                        {showspoiler=&gt;"$rel_id"});

                $spoiler_pat = "&lt;div class = 'spoil_link'&gt;&amp;lt;"
                       . "$addthis\{ or all spoilers $addnode "
                       . "or all $thread}"
                       . "&lt;!--\n%TEXT%\n--&gt;&amp;gt;"
                       . "&lt;/div&gt;";
             } else {
                $spoiler_pat = "&lt;div class = 'spoil_link'&gt;&amp;lt;"
                       . "$addthis or all $thread"
                       . "&lt;!--\n%TEXT%\n--&gt;&amp;gt;"
                       . "&lt;/div&gt;";
             }
        } elsif ($spoiler_style eq 'table') {
            $spoiler_pat = "&lt;table&gt;&lt;tr&gt;&lt;td class='spoiler'&gt;".
                       "%TEXT%".
                       "&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;";
        } elsif ($spoiler_style eq 'div' or $spoiler_style eq 'span') {
            $spoiler_pat = "&lt;$spoiler_style class='spoiler'&gt;%TEXT%&lt;/$spoiler_style&gt;";
        }
        # now allow ;spoil=1 to override whatever setting they have.
        my $reveal_pat="&lt;div class = 'spoiled'&gt;%TEXT%&lt;/div&gt;";
        if ($q-&gt;param('spoil') or $spoiler_style eq 'reveal') {
            $spoiler_pat=$reveal_pat;
        }
        # Question: why isnt this a /g modifier?
        my $num;
        while ( $text =~ m{&lt;spoiler&gt;((?:[^&lt;]+|(?!&lt;/?spoiler&gt;).)*?)&lt;/spoiler&gt;}si ) {
            my $spoiler = $1;
            ++$num;
            my $show = $show{$rel_id} || $show{"$rel_id-$num"};
            my $repl;
            if ($show) {
                $repl=$reveal_pat;
            } else {
                $repl=$spoiler_pat;
                $repl =~ s/-N-U-M/-$num/;
                $repl =~ s/\{([^}]+)\}/$donefirst ? "" : $1/ge;
                $donefirst++;
            }
            $repl =~ s/%TEXT%/$spoiler/;
            $text =~ s{&lt;spoiler&gt;((?:[^&lt;]+|(?!&lt;/?spoiler&gt;).)*?)&lt;/spoiler&gt;}{$repl}si;
        }
    }
}

### PERLFUNCADDER ###
# XXX this should be reworked. [demerphq]
if ($opts{do_perlfunc}) {
  htmlcode( "perlfuncadder" );
}

### READMORE ###
if ( $opts{do_readmore} ) {
  $text = htmlcode( 'handle_readmore', '',
    $item_id||$node_id, $text, 0, $opts{readmore_remove}
  );
}


### PM LINKS ##
my $special={
              142755 =&gt; 'linkHandler',   # [tye&amp;nbsp;] for testing
              # 108447 =&gt; "demerphq's linkparser",  # [demerphq] for testing
            };
my $parser = $special-&gt;{$node_id} || $opts{pmlinkparser};
$text=htmlcode('convert_links_to_html','',$text,$parser);


### FILTER APPROVED TAGS ###
# XXX NOTE: we cache the approved filter in HTMLVARS
my $approved;
my $overridefilter = $opts{overridefilter};
$overridefilter="" unless defined $overridefilter;

if ( $opts{approvedtags} ) {
    $approved = $opts{approvedtags};
    unless (ref $approved) {
        $approved = getVars( getNode( $approved, 'setting' ) )
    }
} else {
    $HTMLVARS{'approved html tags setting'} ||=
        getVars( getNode('approved html tags','setting') );
    $approved = $HTMLVARS{'approved html tags setting'};
}

# $approved is now a hashref for sure
if( ref $overridefilter ) {
    $approved-&gt;{$_} = $overridefilter-&gt;{$_}
        for keys %$overridefilter;
} elsif( $overridefilter eq 'allowImg' ) {
    $approved-&gt;{img} = 'alt,border,height,src,width'
        unless exists $approved-&gt;{img};
}

unless ( $overridefilter eq "override" ) {
    local $VARS-&gt;{htmlnest}=
        exists $opts{htmlnest} ? $opts{htmlnest} : $VARS-&gt;{htmlnest};
    local $VARS-&gt;{htmlerror}=
        exists $opts{htmlerror} ? $opts{htmlerror} : $VARS-&gt;{htmlerror};
    $text = htmlScreen( $text, $approved );
}

### THATS ALL FOLKS! ###
return $start.$text.$end;
</patch_code>
<applied>2007-08-02 17:31:35</applied>
<htmlcode_id>450667</htmlcode_id>
<live_code>#[ParseLinksInContent]

# Note this is intended to be the canonical parser for PM content
#  intended to replace most of [{ParseLinks}], [{ParseLinksInString}]
#  [{ParseLinksInNodeField}], and [{ParseLinksInChatter}]
my ( $text, %opts ) = @_;

# Currently supported %opts:
#   id              =&gt; id used for readmore, spoiler and dl link support
#                      THE ID OF THE NODE BEING RENDERED
#   node_id         =&gt; the current node id (defaults to $NODE-&gt;{node_id})
#   do_spoiler      =&gt; defaults to true, determines if spoiler handling occurs
#   do_perlfunc     =&gt; defaults to true, determines if perlfunc handling occurs
#   do_readmore     =&gt; defaults to true, determines if readmore handling occurs
#   readmore_remove =&gt; handle readmores specially
#   overridefilter  =&gt; used for changing filtering behaviour.

#   approvedtags    =&gt; name of setting, or settings hash which will be used
#                      instead of the default 'approved html tags'
#   bookscan        =&gt; if true will scan for book references
#   pmlinkparser    =&gt; name of htmlcode to use for parsing pmlinks
#                      overrides default of handleLinks()
#   simplecode      =&gt; if true then CB style code escaping occurs.
#   no_dl           =&gt; do not show download links.
#   preview         =&gt; in preview mode
#   parsecode       =&gt; do superdoc style code parsing.
#   nodetype        =&gt; used for parsecode
#   htmlnest        =&gt; if present overrides users htmlnest rules.
#   htmlerror       =&gt; if present overrides users htmlerror rules.

#
# *** NOTE ABOUT 'id' &amp; 'node_id' ***
# 'id' is the id of the node being rendered. Wheras node_id is the id of the
# node being _displayed_. Do not confuse them. Readmore support, auto download
# link supprt, and spoiler support all require a valid 'id' if the string being
# rendered isn't content from the node being displayed ($NODE).
# IE, if SOPW is the node being displayed, then for each node rendered below
# the 'id' would be set as appropriate. If one of those nodes was viewed directly
# then 'id' would not be set.
#
# OTOH, 'node_id' is just the $NODE-&gt;{node_id} in almost every situation, and
# defaults this way.

$opts{do_spoiler}=1
  unless defined $opts{do_spoiler};

$opts{do_readmore}=1
  unless defined $opts{do_readmore};

$opts{do_perlfunc}=1
  unless defined $opts{do_perlfunc};

$opts{node_id} = getId($NODE)
  unless $opts{node_id};

my $node_id = $opts{node_id};
# used by both spoiler and readmore handling and also code d/l link support.
my $item_id = $opts{id};

### PARSECODE  ###
my ($start,$end)=("","");
if ($opts{parsecode} and $opts{nodetype}) {
   $text= parseCode( $text )
      unless grep $_ eq $opts{nodetype},
         qw/sourcecode snippet/;

   if ($opts{nodetype}=~/superdoc/i &amp;&amp;
       $text=~m,
         ^
         (\s*(?:&lt;![^&gt;]*&gt;\s*)?&lt;html[^&gt;]*&gt;.*?&lt;body[^&gt;]*&gt;)
         (.*?)
         (&lt;/body&gt;\s*&lt;/html&gt;\s*)
         $
        ,ixs
   ){
       ($start,$text,$end)=($1,$2,$3);
   }
}

### BOOKSCAN ###
if ( $opts{bookscan} ) {
    $HTMLVARS{buybook} ||= $text =~ /(book)|(reference)/i;
}

### CONVERT CODE ###
my $partnum;
$text =~ s{(&lt;(c(?:ode)?)&gt;(.*?)&lt;/\2&gt;)}{

    my $whole = $1;
    my $code = $3;

    $HTMLVARS{code} .= $whole
      if $opts{do_perlfunc};

    if ($opts{simplecode}) {
        "&lt;tt&gt;" . $q-&gt;escapeHTML($code) . "&lt;/tt&gt;"
    } elsif(  $HTMLVARS{codereplaceoff}  ) {
        $whole;
    } else {
        my $dllink;
        if (!$VARS-&gt;{no_emded_code_dl} &amp;&amp; !$opts{no_dl}) {
              $dllink = linkNode($item_id||$node_id, "&amp;#91;download&amp;#93;",
                            { displaytype =&gt; 'displaycode',
                              abspart =&gt; 1,
                              part =&gt; ++$partnum
                            });
              if(Everything::isApproved($USER, getNode('editors','usergroup'))) {
                  $dllink .= ' ' . linkNode(
                      $item_id||$node_id, "&amp;#91;add readmore&amp;#93;",
                      { 
                          op   =&gt; 'addreadmore',                            
                          part =&gt; $partnum,
                      }
                  );  
              }                            
        }
        htmlcode( 'wrapcode','', $code, $dllink,$opts{preview});
    }
}seig;



### SPOILER ###
if ( $opts{do_spoiler} ) {
    my $spoiler_pat = "%TEXT%"; # this value should be overriden below
    my $spoiler_style = $VARS-&gt;{spoiler_style} || 'link';
    my $count;
    my $donefirst;
    while ( $text =~ m{&lt;spoiler&gt;((?:[^&lt;]+|&lt;(?!/?spoiler&gt;))*?)&lt;/spoiler&gt;}sgi ) {
        $count++
    }
    if ($count) {
        my %show;
        if (my $show_spoilers=$q-&gt;param('showspoiler')) {
            $show{$_}++ for split /,/,$show_spoilers;
        }

        my $rel_id= $item_id || $node_id;
        if ($spoiler_style eq 'link') {
            #[Reveal this spoiler] or all spoilers [in this node].
            #Reveal [only this spoiler] or [only this node]
            #  or all [in this thread].

            #[Reveal this spoiler] or [only this spoiler]

            my $addthis= linkNode($node_id,'Reveal this spoiler',
                            {
                                showspoiler =&gt; join (",","$rel_id-N-U-M",keys %show)
                            }
                       );
            my $thread=linkNode($node_id,'in this thread',{spoil=&gt;1});
            if ( $count &gt;1 ) {
                my $only=linkNode($node_id,'only this spoiler',
                            {showspoiler=&gt;"$rel_id-N-U-M"});
                my $addnode=linkNode($node_id,'in this node',
                        {showspoiler=&gt;join (",",$rel_id,
                            grep { !/^$rel_id(-|$)/ } keys %show)});
                my $onlynode=linkNode($node_id,'reveal only this node',
                        {showspoiler=&gt;"$rel_id"});

                $spoiler_pat = "&lt;div class = 'spoil_link'&gt;&amp;lt;"
                       . "$addthis\{ or all spoilers $addnode "
                       . "or all $thread}"
                       . "&lt;!--\n%TEXT%\n--&gt;&amp;gt;"
                       . "&lt;/div&gt;";
             } else {
                $spoiler_pat = "&lt;div class = 'spoil_link'&gt;&amp;lt;"
                       . "$addthis or all $thread"
                       . "&lt;!--\n%TEXT%\n--&gt;&amp;gt;"
                       . "&lt;/div&gt;";
             }
        } elsif ($spoiler_style eq 'table') {
            $spoiler_pat = "&lt;table&gt;&lt;tr&gt;&lt;td class='spoiler'&gt;".
                       "%TEXT%".
                       "&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;";
        } elsif ($spoiler_style eq 'div' or $spoiler_style eq 'span') {
            $spoiler_pat = "&lt;$spoiler_style class='spoiler'&gt;%TEXT%&lt;/$spoiler_style&gt;";
        }
        # now allow ;spoil=1 to override whatever setting they have.
        my $reveal_pat="&lt;div class = 'spoiled'&gt;%TEXT%&lt;/div&gt;";
        if ($q-&gt;param('spoil') or $spoiler_style eq 'reveal') {
            $spoiler_pat=$reveal_pat;
        }
        # Question: why isnt this a /g modifier?
        my $num;
        while ( $text =~ m{&lt;spoiler&gt;((?:[^&lt;]+|&lt;(?!/?spoiler&gt;))*?)&lt;/spoiler&gt;}si ) {
            my $spoiler = $1;
            ++$num;
            my $show = $show{$rel_id} || $show{"$rel_id-$num"};
            my $repl;
            if ($show) {
                $repl=$reveal_pat;
            } else {
                $repl=$spoiler_pat;
                $repl =~ s/-N-U-M/-$num/;
                $repl =~ s/\{([^}]+)\}/$donefirst ? "" : $1/ge;
                $donefirst++;
            }
            $repl =~ s/%TEXT%/$spoiler/;
            $text =~ s{&lt;spoiler&gt;((?:[^&lt;]+|&lt;(?!/?spoiler&gt;))*?)&lt;/spoiler&gt;}{$repl}si;
        }
    }
}

### PERLFUNCADDER ###
# XXX this should be reworked. [demerphq]
if ($opts{do_perlfunc}) {
  htmlcode( "perlfuncadder" );
}

### READMORE ###
if ( $opts{do_readmore} ) {
  $text = htmlcode( 'handle_readmore', '',
    $item_id||$node_id, $text, 0, $opts{readmore_remove}
  );
}


### PM LINKS ##
my $special={
              142755 =&gt; 'linkHandler',   # [tye&amp;nbsp;] for testing
              # 108447 =&gt; "demerphq's linkparser",  # [demerphq] for testing
            };
my $parser = $special-&gt;{$node_id} || $opts{pmlinkparser};
$text=htmlcode('convert_links_to_html','',$text,$parser);


### FILTER APPROVED TAGS ###
# XXX NOTE: we cache the approved filter in HTMLVARS
my $approved;
my $overridefilter = $opts{overridefilter};
$overridefilter="" unless defined $overridefilter;

if ( $opts{approvedtags} ) {
    $approved = $opts{approvedtags};
    unless (ref $approved) {
        $approved = getVars( getNode( $approved, 'setting' ) )
    }
} else {
    $HTMLVARS{'approved html tags setting'} ||=
        getVars( getNode('approved html tags','setting') );
    $approved = $HTMLVARS{'approved html tags setting'};
}

# $approved is now a hashref for sure
if( ref $overridefilter ) {
    $approved-&gt;{$_} = $overridefilter-&gt;{$_}
        for keys %$overridefilter;
} elsif( $overridefilter eq 'allowImg' ) {
    $approved-&gt;{img} = 'alt,border,height,src,width'
        unless exists $approved-&gt;{img};
}

unless ( $overridefilter eq "override" ) {
    local $VARS-&gt;{htmlnest}=
        exists $opts{htmlnest} ? $opts{htmlnest} : $VARS-&gt;{htmlnest};
    local $VARS-&gt;{htmlerror}=
        exists $opts{htmlerror} ? $opts{htmlerror} : $VARS-&gt;{htmlerror};
    $text = htmlScreen( $text, $approved );
}

### THATS ALL FOLKS! ###
return $start.$text.$end;
</live_code>
<reason>Show link for letting janitors add readmore tags</reason>
<field>code</field>
</record>
<record><htmlcode_id>460584</htmlcode_id>
<patch_code>   #originally from [send chatter], htmlcode'ified to allow XML passthrough
   my $resp = $q-&gt;param("sentmessage");
   my $nothing_to_do= ! grep "message" eq $_, $q-&gt;param("op");
   if ($q-&gt;param('displaytype') ne 'xml') {
       my $hd= getHttpHeader("text/html"); # text/plain
       return $hd . $resp   
           if  $resp;
       return $hd . "No chatter to send."
           if  $nothing_to_do;
       return $hd . "Chatter accepted.";
   } else {

       my($xml,@data,%xmlstyle);
       return "&lt;error&gt;Error creating fling object&lt;/error&gt;"
          unless htmlcode('new_xml_fling','',\($xml,@data,%xmlstyle));

       $xml-&gt;start('send_chatter_result');
       if  ( $resp ) {
          $xml-&gt;element( $resp=~/^(&lt;[^&gt;]+&gt;|\s+)*Whoa/ ? 'error' : 'response', $resp );
       } elsif ( $nothing_to_do ) {
          $xml-&gt;element( error =&gt; 'Nothing To Send' );
       } else {
          $xml-&gt;element( accepted =&gt; 'Chatter Accepted' );
       }
       $xml-&gt;end( 'send_chatter_result' );
       return join "",@data;

   }</patch_code>
<applied>2005-05-26 05:19:27</applied>
<htmlcode_id>460583</htmlcode_id>
<live_code>   #originally from [send chatter], htmlcode'ified to allow XML passthrough
   my $resp = $q-&gt;param("sentmessage");
   my $nothing_to_do= ! grep "message" eq $_, $q-&gt;param("op");
   if ($q-&gt;param('displaytype') ne 'xml') {
       my $hd= getHttpHeader("text/html"); # text/plain
       return $hd . $resp   
           if  $resp;
       return $hd . "No chatter to send."
           if  $nothing_to_do;
       return $hd . "Chatter accepted.";
   } else {

       my($xml,@data,%xmlstyle);
       return "&lt;error&gt;Error creating fling object&lt;/error&gt;"
          unless htmlcode('new_xml_fling','',\($xml,@data,%xmlstyle));
       $xml-&gt;start('send_chatter_result');
       if  ( $resp ) {
          $xml-&gt;element( $resp=~/^(&lt;[^&gt;]+&gt;|\s+)*Whoa/ ? 'error' : 'sent', $resp );
       } elsif ( $nothing_to_do ) {
          $xml-&gt;element( error =&gt; 'Nothing To Send' );
       } else {
          $xml-&gt;element( accept =&gt; 'Chatter Accepted' );
       }
       $xml-&gt;end( 'send_chatter_result' );
       my $data = join "",@data;       
       htmlcode('postProcessXML','',\$data);
       return $data;

   }</live_code>
<reason>create</reason>
<field>code</field>
</record>
<record><htmlcode_id>752226</htmlcode_id>
<patch_code>my ( $style, $timeout, $limit )= @_;

my $ustyle= $q-&gt;param('xmlstyle');

if ( $ustyle &amp;&amp; 
     $ustyle=~/^(old|new|modern)$/i ) 
{
    $style = lc $ustyle;
}
$style='modern' if !$style or $style!~/^(old|new|modern)$/i;


my $code_id= $HTMLVARS{"xml_chatter_cache_code_id_$style"} 
   or return 
     qq[&lt;error&gt;]
   . qq[no "xml_chatter_cache_code_id_$style" in system settings]
   . qq[&lt;/error&gt;];

my ($fromid)= $q-&gt;param('fromid')=~/^(\d+)$/;
my $hadfromid= $fromid;
my $ukey= "$style/$ENV{REMOTE_ADDR}/$ENV{HTTP_USER_AGENT}";
my $ukexpect=2;
if ($VARS-&gt;{ukeyclear}!=$ukexpect) {
  $VARS-&gt;{ukeyclear}=$ukexpect;
  $VARS-&gt;{ukeyhash}={};
}

my $ukeyhash= ref $VARS-&gt;{ukeyhash} ? $VARS-&gt;{ukeyhash} : {};

if ( !$fromid &amp;&amp; $ukeyhash-&gt;{$ukey} &amp;&amp; $ENV{HTTP_USER_AGENT}!~/framechat/i ) {
  my ( $id, $time )= split/,/, $ukeyhash-&gt;{$ukey};
  $fromid= $id;
}

$timeout=$1 if $q-&gt;param('timeout')=~/^(\d+)$/;
$timeout=600 if !$timeout or ($timeout&gt;600 &amp;&amp; !isGod($USER)); #for debugging
$limit=$1 if $q-&gt;param('limit')=~/^(\d+)$/;
$limit=10 if !defined $limit and !$fromid;

#------------

require XML::Fling;
my ($xml,@data,%xmlstyle);
push @data,getHttpHeader("text/xml");
$xmlstyle{$style}=1;

if ($style eq 'old') {
    $xml= XML::Fling-&gt;new( \@data, ("&lt;","&gt;\n")x3 );
} else {
    $xmlstyle{clean} = 1;
    $xml= XML::Fling-&gt;new( \@data );
}
$xml-&gt;header("Windows-1252");
push @data,"\n" if $style ne 'old';


$xml-&gt;start($style eq 'old' ? 'CHATTER' : 'chatter');
push @data,"\n" if $style ne 'old';

my @and_clause=("code_id = $code_id");

my $ignore_list = $VARS-&gt;{ignoredusers};
$ignore_list =~ s/\|//g;
$ignore_list =~ s/,$//;
push @and_clause,"updateinterval not in ($ignore_list)"
    if $ignore_list;

push @and_clause, sprintf "cachekey &gt; '%08d'",$fromid
  if $fromid;

push @and_clause, "subdate( now(), INTERVAL $timeout SECOND ) &lt; lastupdate"
  if $timeout;

$limit=$limit ? "limit $limit" : "";

my $csr = $DB-&gt;sqlSelectMany(
    "cachekey, cachedata",
    "cachedinfo",
    join(" and ",@and_clause),
    "order by cachekey desc $limit",
);

my $array= $csr-&gt;fetchall_arrayref({});

my $lastid= ($array &amp;&amp; @$array) ? 0+$array-&gt;[0]{cachekey} : 0;

htmlcode( 'xml_info_tag', '', $xml, \%xmlstyle, 0,
          $fromid ? ( 'fromid' =&gt; $fromid ) : (),
          $lastid ? ( 'lastid' =&gt; $lastid ) : (),
          'count' =&gt; ($lastid ? 0+@$array : 0),
);
push @data,"\n" if $style ne 'old';

foreach my $msg ( reverse @$array ) {
  my $text= $msg-&gt;{cachedata};  
  if ($style eq 'modern') {
     $text=~s{(&lt;parsed&gt;)(.*?)(&lt;/parsed&gt;)}
             {my ($o,$v,$e)=($1,$2,$3); 
              $o.htmlcode('convert_links_to_html','',$v,0,0,1).$e
             }se;
  }
  push @data, $text;
  push @data,"\n" if $style ne 'old';
}
$xml-&gt;end();
my $max= @$array ? $array-&gt;[0]{cachekey} : $fromid;

htmlcode('log_ticker','', $style, 
         "$hadfromid/$fromid/$max - $timeout/$limit - " . (0+@$array) ) 
  or Everything::printLog( 
       "CB - $style - $hadfromid/$fromid/$max - $timeout/$limit - " .
      (0+@$array) . " - " .
      "$USER-&gt;{title} ($ENV{REMOTE_ADDR}) - $ENV{'HTTP_USER_AGENT'}" );

if ( !$hadfromid ) {
  my $time= time;
  foreach my $key ( keys %$ukeyhash ) {
     my ( $id, $rtime )= split /,/, $ukeyhash-&gt;{$key};
     if ( $time - $rtime &gt; 60*60 ) {
       delete $ukeyhash-&gt;{$key};
     }
  }
  $ukeyhash-&gt;{$ukey}= "$max,$time";
  $VARS-&gt;{ukeyhash}= $ukeyhash; # yah this works!
}

return join "", @data;</patch_code>
<applied>2009-03-21 09:11:00</applied>
<htmlcode_id>468108</htmlcode_id>
<live_code>my ( $style, $timeout, $limit )= @_;

my $ustyle= $q-&gt;param('xmlstyle');

if ( $ustyle &amp;&amp; 
     $ustyle=~/^(old|new|modern)$/i ) 
{
    $style = lc $ustyle;
}
$style='modern' if !$style or $style!~/^(old|new|modern)$/i;


my $code_id= $HTMLVARS{"xml_chatter_cache_code_id_$style"} 
   or return 
     qq[&lt;error&gt;]
   . qq[no "xml_chatter_cache_code_id_$style" in system settings]
   . qq[&lt;/error&gt;];

my ($fromid)= $q-&gt;param('fromid')=~/^(\d+)$/;
my $hadfromid= $fromid;
my $ukey= "$style/$ENV{REMOTE_ADDR}/$ENV{HTTP_USER_AGENT}";
my $ukexpect=2;
if ($VARS-&gt;{ukeyclear}!=$ukexpect) {
  $VARS-&gt;{ukeyclear}=$ukexpect;
  $VARS-&gt;{ukeyhash}={};
}

my $ukeyhash= ref $VARS-&gt;{ukeyhash} ? $VARS-&gt;{ukeyhash} : {};

if ( !$fromid &amp;&amp; $ukeyhash-&gt;{$ukey} &amp;&amp; $ENV{HTTP_USER_AGENT}!~/framechat/i ) {
  my ( $id, $time )= split/,/, $ukeyhash-&gt;{$ukey};
  $fromid= $id;
}

$timeout=$1 if $q-&gt;param('timeout')=~/^(\d+)$/;
$timeout=600 if !$timeout or ($timeout&gt;600 &amp;&amp; !isGod($USER)); #for debugging
$limit=$1 if $q-&gt;param('limit')=~/^(\d+)$/;
$limit=10 if !defined $limit and !$fromid;

#------------

require XML::Fling;
my ($xml,@data,%xmlstyle);
push @data,getHttpHeader("text/xml");
$xmlstyle{$style}=1;

if ($style eq 'old') {
    $xml= XML::Fling-&gt;new( \@data, ("&lt;","&gt;\n")x3 );
} else {
    $xmlstyle{clean} = 1;
    $xml= XML::Fling-&gt;new( \@data );
}
$xml-&gt;header("Windows-1252");
push @data,"\n" if $style ne 'old';


$xml-&gt;start($style eq 'old' ? 'CHATTER' : 'chatter');
push @data,"\n" if $style ne 'old';

my @and_clause=("code_id = $code_id");

my $ignore_list = $VARS-&gt;{ignoredusers};
$ignore_list =~ s/\|//g;
$ignore_list =~ s/,$//;
push @and_clause,"updateinterval not in ($ignore_list)"
    if $ignore_list;

push @and_clause, sprintf "cachekey &gt; '%08d'",$fromid
  if $fromid;

push @and_clause, "subdate( now(), INTERVAL $timeout SECOND ) &lt; lastupdate"
  if $timeout;

$limit=$limit ? "limit $limit" : "";

my $csr = $DB-&gt;sqlSelectMany(
    "cachekey, cachedata",
    "cachedinfo",
    join(" and ",@and_clause),
    "order by cachekey desc $limit",
);

my $array= $csr-&gt;fetchall_arrayref({});

my $lastid= ($array &amp;&amp; @$array) ? 0+$array-&gt;[0]{cachekey} : 0;

htmlcode( 'xml_info_tag', '', $xml, \%xmlstyle, 0,
          $fromid ? ( 'fromid' =&gt; $fromid ) : (),
          $lastid ? ( 'lastid' =&gt; $lastid ) : (),
          'count' =&gt; ($lastid ? 0+@$array : 0),
);
push @data,"\n" if $style ne 'old';

foreach my $msg ( reverse @$array ) {
  my $text= $msg-&gt;{cachedata};  
  if ($style eq 'modern') {
     $text=~s{(&lt;parsed&gt;)(.*?)(&lt;/parsed&gt;)}
             {my ($o,$v,$e)=($1,$2,$3); 
              $o.htmlcode('convert_links_to_html','',$v,0,0,1).$e
             }se;
  }
  htmlcode('postProcessXML','',\$text);
  push @data, $text;
  push @data,"\n" if $style ne 'old';
}
$xml-&gt;end();
my $max= @$array ? $array-&gt;[0]{cachekey} : $fromid;

htmlcode('log_ticker','', $style, 
         "$hadfromid/$fromid/$max - $timeout/$limit - " . (0+@$array) ) 
  or Everything::printLog( 
       "CB - $style - $hadfromid/$fromid/$max - $timeout/$limit - " .
      (0+@$array) . " - " .
      "$USER-&gt;{title} ($ENV{REMOTE_ADDR}) - $ENV{'HTTP_USER_AGENT'}" );

if ( !$hadfromid ) {
  my $time= time;
  foreach my $key ( keys %$ukeyhash ) {
     my ( $id, $rtime )= split /,/, $ukeyhash-&gt;{$key};
     if ( $time - $rtime &gt; 60*60 ) {
       delete $ukeyhash-&gt;{$key};
     }
  }
  $ukeyhash-&gt;{$ukey}= "$max,$time";
  $VARS-&gt;{ukeyhash}= $ukeyhash; # yah this works!
}

return join "", @data;</live_code>
<reason>encoding in xml header -- see [id://752159]</reason>
<field>code</field>
</record>
<record><htmlcode_id>654053</htmlcode_id>
<patch_code>use Everything::Experience;

return ''
    if  ! $USER-&gt;{votesleft}
    or  getId($USER) == $HTMLVARS{default_user};

my $votes= '';
if(  $USER-&gt;{voteavg} &lt; 0  ) {
    $votes= "&lt;a href='?node_id=654038' title='Why?'&gt;down&lt;sup&gt;?&lt;/sup&gt;&lt;/a&gt;";
}
$votes .=  $USER-&gt;{votesleft} &gt; 1  ?  'votes'  :  'vote';

return join '',
    "You have &lt;b&gt;$USER-&gt;{votesleft}&lt;/b&gt; $votes left today.",
    "&lt;a href='?node_id=5938' title='voting/experience system'&gt;",
    "&lt;sup&gt;?&lt;/sup&gt;&lt;/a&gt;";
</patch_code>
<applied>2007-11-30 14:25:18</applied>
<htmlcode_id>476319</htmlcode_id>
<live_code>use Everything::Experience;

return ''
    if  ! $USER-&gt;{votesleft}
    or  getId($USER) == $HTMLVARS{default_user};

my $votes = 1!=$USER-&gt;{votesleft} ? 'votes' : 'vote';
$votes = qq(&lt;a href="?node_id=5938" title="Voting/Experience System"&gt;$votes&lt;/a&gt;);
if(  $USER-&gt;{voteavg} &lt; 0  ) {
  $votes = qq(&lt;a href="?node_id=654038" title="What does 'dog' mean?"&gt;dog&lt;/a&gt; ) . $votes;
}

"You have &lt;b&gt;$USER-&gt;{votesleft}&lt;/b&gt; $votes left today.";
</live_code>
<reason>Show when your voteavg is negative</reason>
<field>code</field>
</record>
<record><htmlcode_id>783063</htmlcode_id>
<patch_code>=head1 NAME

handle_node_edits

=head1 DESCRIPTION

Provides edit display type for janitors, pedagogues and SiteDocClan,
incorporating edit histories and locking.

=cut

use Digest::MD5 qw(md5_hex);

my ($group) = @_;

my %options = (
    editors =&gt; {
        is_ok_type      =&gt; 'isJanitorable',
        not_ok_type_msg =&gt; "Not a janitor editable type",
        not_member_msg  =&gt;
        "You're not a janitor get away, there is no Perl Illuminati",
    },
    SiteDocClan =&gt; {
        is_ok_type      =&gt; 'CanSdcEdit',
        not_ok_type_msg =&gt; "Not a SiteDocClan editable type",
        not_member_msg  =&gt;
        "You're not SiteDocClan get away, there is no Perl Illuminati",
    },
    pedagogues =&gt; {
        is_ok_type      =&gt; 'CanPedagoguesEdit',
        not_ok_type_msg =&gt; "Not a Pedagogues editable type",
        not_member_msg  =&gt; "You're not a Pedagogue get away, there is no Perl Illuminati",
    },
    QandAEditors =&gt; {
        is_ok_type      =&gt; 'CanQAEdit',
        not_ok_type_msg =&gt; "Not a QandAEditors editable type",
        not_member_msg  =&gt; "You're not a QandAEditor get away, there is no Perl Illuminati",
    },
);

exists $options{$group}
    or die "\$group is $group, but should be one of ". join ', ', keys %options;

return $options{$group}{not_ok_type_msg}
  unless htmlcode($options{$group}{is_ok_type});

return $options{$group}{not_member_msg}
    unless Everything::isApproved($USER, getNode($group,'usergroup'));

unless(htmlcode('getOrRenewLock')){
    return "Sorry, " . linkNode($NODE-&gt;{lockedby_user})
       . " has a lock on this node right now";
}

my $preview_on=(!$query-&gt;param('disable preview'));
my $update=($query-&gt;param('blah') eq "update");
my $private = $query-&gt;param('update_private') || 0;

#
# update fields
#

my $str;
my @fields=grep{/^update_(.+)/} $query-&gt;param();

if($update){
    my @badfields;
    foreach(@fields){
        my $field;
        ($field) = /update_(.*)/;
        next if $field eq "private";
        next if $field eq 'group';
        my $old_digest= $query-&gt;param("digest_$field");
        my $new_digest= md5_hex($NODE-&gt;{$field});
        if($new_digest eq $old_digest){
            if($NODE-&gt;{$field} ne $query-&gt;param("update_$field")){
                $DB-&gt;sqlInsert('edithistory',{
                    starttext=&gt;$NODE-&gt;{$field},
                    endtext=&gt;$query-&gt;param("update_$field"),
                    editor_user=&gt;getId($USER),-
                    edittime=&gt;"now()",
                    fieldname=&gt;$field,
                    private=&gt;$private,
                    edithistory_id=&gt;getId($NODE)});
                $NODE-&gt;{$field}=$query-&gt;param("update_$field");
                $query-&gt;param("digest_$field",md5_hex($NODE-&gt;{$field}));
            }
        } else {
            push @badfields, $field;
        }
    }
    updateNode($NODE,-1);
    $str.='&lt;br /&gt;&lt;font color="red"&gt;The following fields'
        . ' weren\'t updated because they have been updated'
        . ' since you started editing: ' . join(',',@badfields)
        . '&lt;/font&gt;&lt;p&gt;'
        if @badfields;
}

my $tables = $DB-&gt;getNodetypeTables($NODE-&gt;{type_nodetype});
my %titletype;

foreach my $table (@$tables,'node')
{
    my @fields = $DB-&gt;getFieldsHash($table);

    foreach my $field (@fields)
    {
        $titletype{$field-&gt;{Field}} = $field-&gt;{Type};
    }
}

local *fieldorder = sub {
  my $f = shift;
  local $_ = $titletype{$f}||'';
  return 0 if /title/i;
  return 1 if /core/;
  return 2 if /char\(/;
  return 3 if /text/;
  return 4;
};

#
# preview section
#
if($query-&gt;param('update_title')){
    $str.="&lt;h3&gt;Preview title:&lt;/h3&gt;" . $query-&gt;param('update_title') . "&lt;br /&gt;"
        if $preview_on;
}

my %Skip=(group=&gt;1, vars=&gt;1);

foreach( sort { fieldorder($a) &lt;=&gt; fieldorder($b) or $a cmp $b } @fields){
    my $field;
    ($field)=/update_(.*)/;
    next if $_ eq "update_title";
    next if $Skip{$field};
    $HTMLVARS{embed_node}{doctext}=$query-&gt;param($_);
    if ($preview_on) {
        $str.="&lt;h3&gt;Preview $field:&lt;/h3&gt;";
        if ($NODE-&gt;{type}{title} eq "perlcraft") {
            $str.=htmlcode('previewdisplayperlcraft')."&lt;br /&gt;";
        } elsif ( $NODE-&gt;{type}{title} eq 'sitedoclet' ) {
            $str.=htmlcode('get_sitedoclet','',
                {   title=&gt;$query-&gt;param('update_title'),
                    doctext=&gt;$HTMLVARS{embed_node}{doctext}
                });
        } else {
            $str.=htmlcode('parselinksinstring')."&lt;br /&gt;";
        }
    }
}
$str= "&lt;hr /&gt;$str&lt;hr /&gt;&lt;br /&gt;&lt;br /&gt;" if $str;

$str.="\n".htmlcode('openform', '', 'name' =&gt; 'edit_node');

# This edit page displays each field of a node with a
# (usually) appropriate form item in which to edit the
# contents of each field.  This is useful to edit a node's
# data that is usually not accessable through a standard
# edit page (like createtime, or hits)

local* hiddenMD5=sub{
    my($field)=@_;
    $query-&gt;hidden(
        -name=&gt;"digest_$field",
        -value=&gt;($query-&gt;param("digest_$field") or md5_hex($NODE-&gt;{$field}))
    )."\n";
};

# This code generates the form fields and the stuff that
# the user sees.

foreach my $field ( sort { fieldorder($a) &lt;=&gt; fieldorder($b) or $a cmp $b } keys %titletype)
{
    next if $Skip{$field};
    if($field eq "core"){
    }
    elsif($titletype{$field} =~ /char\((.*)\)/)
    {
        my $size = 80;
        $str.="&lt;h3&gt;$field:&lt;/h3&gt;";
        $size = $1 if($size &gt; $1);
        $str .= $query-&gt;textfield(
            -name =&gt; "update_$field",
            -default =&gt; ($query-&gt;param("pu_$field") or $NODE-&gt;{$field}),
            -size =&gt; $size,
            -maxlength =&gt; $1 ) . "&lt;br&gt;\n";
        $str.=hiddenMD5($field);
    }
    elsif($titletype{$field} =~ /text/)
    {
        $str.="&lt;h3&gt;$field:&lt;/h3&gt;";
        $str .= $query-&gt;textarea(
            -name=&gt;"update_$field",
            -default=&gt;($query-&gt;param("pu_$field") or $NODE-&gt;{$field}),
            -rows=&gt;20, -cols=&gt;80, -wrap=&gt;"virtual") . "&lt;br /&gt;\n";
        $str.=hiddenMD5($field);
    }
}
$str.=$query-&gt;checkbox('disable preview')."&lt;br /&gt;\n";
$str.=$query-&gt;checkbox(
    -name =&gt; 'update_private',
    -label =&gt;'set private flag',
    -value =&gt; '1'
)."&lt;br /&gt;\n"
    if $group eq 'editors';
#$str.=htmlcode('groupeditor')."&lt;br /&gt;"
#  if $NODE-&gt;{type}{title} eq 'faqlist';
$str.=  $query-&gt;submit('blah','preview') . "\n"
    .   $query-&gt;submit('blah','update') . "&lt;/form&gt;\n";

if(     $update
    &amp;&amp;  $group eq 'editors'
    &amp;&amp;  $NODE-&gt;{author_user} != $HTMLVARS{guest_user}
) {
   $str .= htmlcode(
        'msguser', $NODE-&gt;{'author_user'},
        "I've edited ". linkNode( getId($NODE) ).
        ". See ". linkNode( getId($NODE),
          "node history", { displaytype =&gt; 'edithistory' } )
   );
}
return $str;
</patch_code>
<applied>2009-07-24 13:54:52</applied>
<htmlcode_id>481659</htmlcode_id>
<live_code>=head1 NAME

handle_node_edits

=head1 DESCRIPTION

Provides edit display type for janitors, pedagogues and SiteDocClan,
incorporating edit histories and locking.

=cut

use Digest::MD5 qw(md5_hex);

my ($group) = @_;

my %options = (
    editors =&gt; {
        is_ok_type      =&gt; 'isJanitorable',
        not_ok_type_msg =&gt; "Not a janitor editable type",
        not_member_msg  =&gt;
        "You're not a janitor get away, there is no Perl Illuminati",
    },
    SiteDocClan =&gt; {
        is_ok_type      =&gt; 'CanSdcEdit',
        not_ok_type_msg =&gt; "Not a SiteDocClan editable type",
        not_member_msg  =&gt;
        "You're not SiteDocClan get away, there is no Perl Illuminati",
    },
    pedagogues =&gt; {
        is_ok_type      =&gt; 'CanPedagoguesEdit',
        not_ok_type_msg =&gt; "Not a Pedagogues editable type",
        not_member_msg  =&gt; "You're not a Pedagogue get away, there is no Perl Illuminati",
    },
    QandAEditors =&gt; {
        is_ok_type      =&gt; 'CanQAEdit',
        not_ok_type_msg =&gt; "Not a QandAEditors editable type",
        not_member_msg  =&gt; "You're not a QandAEditor get away, there is no Perl Illuminati",
    },
);

exists $options{$group}
    or die "\$group is $group, but should be one of ". join ', ', keys %options;

return $options{$group}{not_ok_type_msg}
  unless htmlcode($options{$group}{is_ok_type});

return $options{$group}{not_member_msg}
    unless Everything::isApproved($USER, getNode($group,'usergroup'));

unless(htmlcode('getOrRenewLock')){
    return "Sorry, " . linkNode($NODE-&gt;{lockedby_user})
       . " has a lock on this node right now";
}

my $preview_on=(!$query-&gt;param('disable preview'));
my $update=($query-&gt;param('blah') eq "update");
my $private = $query-&gt;param('update_private') || 0;

#
# update fields
#

my $str;
my @fields=grep{/^update_(.+)/} $query-&gt;param();

if($update){
    my @badfields;
    foreach(@fields){
        my $field;
        ($field) = /update_(.*)/;
        next if $field eq "private";
        next if $field eq 'group';
        my $old_digest= $query-&gt;param("digest_$field");
        my $new_digest= md5_hex($NODE-&gt;{$field});
        if($new_digest eq $old_digest){
            if($NODE-&gt;{$field} ne $query-&gt;param("update_$field")){
                $DB-&gt;sqlInsert('edithistory',{
                    starttext=&gt;$NODE-&gt;{$field},
                    endtext=&gt;$query-&gt;param("update_$field"),
                    editor_user=&gt;getId($USER),
                    -edittime=&gt;"now()",
                    fieldname=&gt;$field,
                    private=&gt;$private,
                    edithistory_id=&gt;getId($NODE)});
                $NODE-&gt;{$field}=$query-&gt;param("update_$field");
                $query-&gt;param("digest_$field",md5_hex($NODE-&gt;{$field}));
            }
        } else {
            push @badfields, $field;
        }
    }
    updateNode($NODE,-1);
    $str.='&lt;br /&gt;&lt;font color="red"&gt;The following fields'
        . ' weren\'t updated because they have been updated'
        . ' since you started editing: ' . join(',',@badfields)
        . '&lt;/font&gt;&lt;p&gt;'
        if @badfields;
}

my $tables = $DB-&gt;getNodetypeTables($NODE-&gt;{type_nodetype});
my %titletype;

foreach my $table (@$tables,'node')
{
    my @fields = $DB-&gt;getFieldsHash($table);

    foreach my $field (@fields)
    {
        $titletype{$field-&gt;{Field}} = $field-&gt;{Type};
    }
}

local *fieldorder = sub {
  my $f = shift;
  local $_ = $titletype{$f}||'';
  return 0 if /title/i;
  return 1 if /core/;
  return 2 if /char\(/;
  return 3 if /text/;
  return 4;
};

#
# preview section
#
if($query-&gt;param('update_title')){
    $str.="&lt;h3&gt;Preview title:&lt;/h3&gt;" . $query-&gt;param('update_title') . "&lt;br /&gt;"
        if $preview_on;
}

my %Skip=(group=&gt;1, vars=&gt;1);

foreach( sort { fieldorder($a) &lt;=&gt; fieldorder($b) or $a cmp $b } @fields){
    my $field;
    ($field)=/update_(.*)/;
    next if $_ eq "update_title";
    next if $Skip{$field};
    $HTMLVARS{embed_node}{doctext}=$query-&gt;param($_);
    if ($preview_on) {
        $str.="&lt;h3&gt;Preview $field:&lt;/h3&gt;";
        if ($NODE-&gt;{type}{title} eq "perlcraft") {
            $str.=htmlcode('previewdisplayperlcraft')."&lt;br /&gt;";
        } elsif ( $NODE-&gt;{type}{title} eq 'sitedoclet' ) {
            $str.=htmlcode('get_sitedoclet','',
                {   title=&gt;$query-&gt;param('update_title'),
                    doctext=&gt;$HTMLVARS{embed_node}{doctext}
                });
        } else {
            $str.=htmlcode('parselinksinstring')."&lt;br /&gt;";
        }
    }
}
$str= "&lt;hr /&gt;$str&lt;hr /&gt;&lt;br /&gt;&lt;br /&gt;" if $str;

$str.="\n".htmlcode('openform', '', 'name' =&gt; 'edit_node');

# This edit page displays each field of a node with a
# (usually) appropriate form item in which to edit the
# contents of each field.  This is useful to edit a node's
# data that is usually not accessable through a standard
# edit page (like createtime, or hits)

local* hiddenMD5=sub{
    my($field)=@_;
    $query-&gt;hidden(
        -name=&gt;"digest_$field",
        -value=&gt;($query-&gt;param("digest_$field") or md5_hex($NODE-&gt;{$field}))
    )."\n";
};

# This code generates the form fields and the stuff that
# the user sees.

foreach my $field ( sort { fieldorder($a) &lt;=&gt; fieldorder($b) or $a cmp $b } keys %titletype)
{
    next if $Skip{$field};
    if($field eq "core"){
    }
    elsif($titletype{$field} =~ /char\((.*)\)/)
    {
        my $size = 80;
        $str.="&lt;h3&gt;$field:&lt;/h3&gt;";
        $size = $1 if($size &gt; $1);
        $str .= $query-&gt;textfield(
            -name =&gt; "update_$field",
            -default =&gt; ($query-&gt;param("pu_$field") or $NODE-&gt;{$field}),
            -size =&gt; $size,
            -maxlength =&gt; $1 ) . "&lt;br&gt;\n";
        $str.=hiddenMD5($field);
    }
    elsif($titletype{$field} =~ /text/)
    {
        $str.="&lt;h3&gt;$field:&lt;/h3&gt;";
        $str .= $query-&gt;textarea(
            -name=&gt;"update_$field",
            -default=&gt;($query-&gt;param("pu_$field") or $NODE-&gt;{$field}),
            -rows=&gt;20, -cols=&gt;80, -wrap=&gt;"virtual") . "&lt;br /&gt;\n";
        $str.=hiddenMD5($field);
    }
}
$str.=$query-&gt;checkbox('disable preview')."&lt;br /&gt;\n";
$str.=$query-&gt;checkbox(
    -name =&gt; 'update_private',
    -label =&gt;'set private flag',
    -value =&gt; '1'
)."&lt;br /&gt;\n"
    if $group eq 'editors';
#$str.=htmlcode('groupeditor')."&lt;br /&gt;"
#  if $NODE-&gt;{type}{title} eq 'faqlist';
$str.=  $query-&gt;submit('blah','preview') . "\n"
    .   $query-&gt;submit('blah','update') . "&lt;/form&gt;\n";

if(     $update
    &amp;&amp;  $group eq 'editors'
    &amp;&amp;  $NODE-&gt;{author_user} != $HTMLVARS{guest_user}
) {
   $str .= htmlcode(
        'msguser', $NODE-&gt;{'author_user'},
        "I've edited ". linkNode( getId($NODE) ).
        ". See ". linkNode( getId($NODE),
          "node history", { displaytype =&gt; 'edithistory' } )
   );
}
return $str;
</live_code>
<reason>add support for [QandAEditors]</reason>
<field>code</field>
</record>
<record><htmlcode_id>717073</htmlcode_id>
<patch_code>my ($node)=@_;
$node||=$NODE;
my $html;
my $sdcname=$node-&gt;{title}." sitedoclet";
my $SDC=getNode('SiteDocClan','usergroup');
my $is_sdc=$DB-&gt;isApproved($USER,$SDC);
if (my $sdl=getNode($sdcname,'sitedoclet')) {
  $html=htmlcode('get_sitedoclet','',$sdl);
  if ($is_sdc) {
     $html='&lt;p align="right"&gt;&lt;small&gt;'
          .linkNode($sdl,'Edit SiteDoclet',{displaytype=&gt;'edit'})
          .'&lt;/small&gt;&lt;/p&gt;'
          .$html;
  }
} else {
  if ($is_sdc) {
    my $href=urlGen({ op   =&gt; 'new',
                      type =&gt; 'sitedoclet',
                      node =&gt; $sdcname,
                      addToGroup=&gt;481919,
                    });
    $html=qq[&lt;p align="right"&gt;&lt;small&gt;&lt;a href=$href&gt;Create SiteDoclet&lt;/a&gt;&lt;/small&gt;&lt;/p&gt;]
  } else {
    $html=qq[&lt;p&gt;&lt;i&gt;No additional documentation found. Questions? Consult the ]
        . linkNode( 591016, 'SiteDocClan' )
        . qq[.&lt;/i&gt;&lt;/p&gt;\n];
  }
 
}
return $html
</patch_code>
<applied>2009-02-03 11:21:57</applied>
<htmlcode_id>485569</htmlcode_id>
<live_code>my( $title )= @_;
$title ||= $NODE-&gt;{title};
my $html= '';
my $sdlname= "$title sitedoclet";
my $SDC= getNode( 'SiteDocClan', 'usergroup' );
my $is_sdc= $DB-&gt;isApproved( $USER, $SDC );
if(  my $sdl= getNode( $sdlname, 'sitedoclet' )  ) {
    if(  $is_sdc  ) {
        $html .= join '',
            "&lt;div class='sdc-buttons'&gt;",
            linkNode( $sdl, 'Edit SiteDoclet', {displaytype=&gt;'edit'} ),
            "&lt;/div&gt;\n";
    }
    $html .= htmlcode( 'get_sitedoclet','', $sdl );
} elsif(  $is_sdc  ) {
    $html .= join '',
        "&lt;div class='sdc-buttons'&gt;\n",
        genLink(
            "\nCreate " . encodeHTML($sdlname),
            {
                op          =&gt; 'new',
                type        =&gt; 'sitedoclet',
                node        =&gt; $sdlname,
                addToGroup  =&gt; 481919,
            },
        ),
        "&lt;/div&gt;\n";
} else {
    $html .= join '',
        "&lt;p&gt;&lt;i&gt;No additional documentation found. ",
        "Questions? Consult the ",
        linkNode( 591016, 'SiteDocClan' ),
        ".&lt;/i&gt;&lt;/p&gt;\n";
}
return join '',
    "&lt;!-- showsitedoclet:title=",
    encodeHTML($title),
    " --&gt;\n",
    "&lt;div class='sitedoclet'&gt;\n$html&lt;/div&gt;\n";
</live_code>
<reason>tone down the nag message</reason>
<field>code</field>
</record>
<record><htmlcode_id>489564</htmlcode_id>
<patch_code>    my $user = $query-&gt;param("user");
    my $passwd = $query-&gt;param("passwd");
    my $user_id;
    my $cookie;

    $user_id = confirmUser( $user, crypt($passwd,$user),
      ( $query-&gt;param('ticker') eq 'yes' ) );
   
    # If the user/passwd was correct, set a cookie on the users
    # browser.
    $cookie = $query-&gt;cookie(
        -name =&gt; "userpass",
        -value =&gt; $query-&gt;escape( $user . '|' . crypt($passwd,$user)
            . '|' . ( $query-&gt;param('ticker') eq "yes" )
        ),
        -expires =&gt; $query-&gt;param("expires")
    )   if  $user_id;

    $user_id ||= $HTMLVARS{guest_user};

    $USER = getNodeById($user_id);
    $VARS = getVars($USER);

    $$USER{cookie} = $cookie if($cookie);
</patch_code>
<applied>2005-09-06 11:46:31</applied>
<htmlcode_id>489563</htmlcode_id>
<live_code>my $user= $q-&gt;param("user");
return   if  ! $user;
my $passwd= $q-&gt;param("passwd");
return   if  ! $passwd; # This also disallows "0" as a password.
my $salt= join '', map(
    ('a'..'z','A'..'Z',0..9,'.','/')[rand 64],
     1,2 );
my $U= getNode( $user, 'user' );
if(  ! $U  ) {
    htmlcode( 'verifyNewUser','',
        $user, $passwd, $salt, \$U );
}
return
    if  ! $U
    ||  ! confirmUser(
            $U,
            $salt,
            $q-&gt;param('ticker') eq 'yes',
            $passwd,
        );

$USER-&gt;{cookie}= $q-&gt;cookie(
    -name =&gt; "userpass",
    -value =&gt; $q-&gt;escape( join '|',
        $user,
        crypt( $passwd, $salt ),
        $q-&gt;param('ticker') eq "yes",
    ),
    -expires =&gt; $q-&gt;param("expires")
);
</live_code>
<reason>create login opcode overriding opLogin</reason>
<field>code</field>
</record>
<record><htmlcode_id>583555</htmlcode_id>
<patch_code>Everything::isApproved($USER, getNode('editors', 'usergroup'));</patch_code>
<applied>2006-11-12 16:21:18</applied>
<htmlcode_id>493913</htmlcode_id>
<live_code># Please don't use this node.  It makes no sense to have
# an access rule that just checks if you belong to a group!
# And the check should be for belonging to [janitors] not
# the defunct [editors] group! -Tye
Everything::isApproved($USER, getNode
('editors', 'usergroup'));</live_code>
<reason>For controlling access to janitor functions</reason>
<field>code</field>
</record>
<record><htmlcode_id>768170</htmlcode_id>
<patch_code>my ( $movetotype, $sectid, $oldsect, $newsect ) = @_;

my $SETTING= getVars( getNode('approval nodelet settings','setting') );
my %nonapprovable = (
  perltutorial =&gt; "pending Tutorials",
  offtopicroot =&gt; "the offtopic ghetto",
  perlnews =&gt; "Perl News"
);
my %allowedTypes =
  map { $_ =&gt; 1 } (split(/,/, $SETTING-&gt;{types}), keys %nonapprovable );

return "Type unchanged" if $movetotype eq $NODE-&gt;{type}{title};
return "Not allowed to move to type $movetotype" if ! $allowedTypes{$movetotype};

my $section_id = $SETTING-&gt;{ "${movetotype}_node" };
if ($section_id) {
  $$newsect = getNodeById( $section_id )-&gt;{title};
} elsif ($nonapprovable{$movetotype}) {
  $$newsect = $nonapprovable{$movetotype};
} else {
  return "unexpected node type $movetotype";
}

$$oldsect = getNodeById( $$sectid )-&gt;{title};
$NODE-&gt;{type_nodetype} = getId(getType($movetotype));
updateNode($NODE,-1);

$DB-&gt;sqlInsert( 'edithistory', {
  starttext      =&gt; $$oldsect,
  endtext        =&gt; $$newsect,
  editor_user    =&gt; getId($USER),
  edittime       =&gt; 'now()',
  fieldname      =&gt; '-section',
  edithistory_id =&gt; getId($NODE),
});

return 0;  # done
</patch_code>
<applied>2009-06-03 17:32:27</applied>
<htmlcode_id>499687</htmlcode_id>
<live_code>my ( $movetotype, $sectid, $oldsect, $newsect ) = @_;

my $SETTING= getVars( getNode('approval nodelet settings','setting') );
my %nonapprovable = (
  perltutorial =&gt; "pending Tutorials",
  offtopicroot =&gt; "the offtopic ghetto",
  perlnews =&gt; "Perl News"
);
my %allowedTypes =
  map { $_ =&gt; 1 } (split(/,/, $SETTING-&gt;{types}), keys %nonapprovable );

return "Type unchanged" if $movetotype eq $NODE-&gt;{type}{title};
return "Not allowed to move to type $movetotype" if ! $allowedTypes{$movetotype};

my $section_id = $SETTING-&gt;{ "${movetotype}_node" };
if ($section_id) {
  $$newsect = getNodeById( $section_id )-&gt;{title};
} elsif ($nonapprovable{$movetotype}) {
  $$newsect = $nonapprovable{$movetotype};
} else {
  return "unexpected node type $movetotype";
}

$$oldsect = getNodeById( $$sectid )-&gt;{title};
$NODE-&gt;{type_nodetype} = getId(getType($movetotype));
updateNode($NODE,-1);

$DB-&gt;sqlInsert( 'edithistory', {
  starttext      =&gt; $$oldsect,
  endtext        =&gt; $$newsect,
  editor_user    =&gt; getId($USER),
  -edittime       =&gt; 'now()',
  fieldname      =&gt; '-section',
  edithistory_id =&gt; getId($NODE),
});

return 0;  # done
</live_code>
<reason>log section moves in the edithistory</reason>
<field>code</field>
</record>
<record><htmlcode_id>499690</htmlcode_id>
<patch_code>use Everything::Experience;

my ($type,$frontpage,$title,$length,@options)=@_;
my ($showunapproved) = grep (/showunapproved/, @options);
my ($showall)        = grep (/showall/, @options);
my ($navbar)         = grep (/navbar/, @options);
my $count            = $query-&gt;param("next") || 0;
if( $count &gt; 100 ) { $count= 100 };
$length            ||= 10;
my $isGod            = isGod($USER);
my $level            = getLevel($USER);
my $nodetype         = getNode( $type, 'nodetype')-&gt;{node_id};
my $settings         = getVars(getNode('listapproved settings','setting'));
my $daysBeforeExpire = $frontpage ? $settings-&gt;{daysOnFrontPage} || 7 : 300;
my $updateinterval   = $settings-&gt;{updateInterval} || 180;
my $sectionshowsize  = $settings-&gt;{sectionShowSize} || 300;

my $htmlcode_id=getId(getNode('cachedlistapproved','htmlcode'));
my $cachekey = join(':', 
                    getId($NODE),
                    $type,
                    $length,
                    $count,
                    $showunapproved,
                    $navbar );
my $csr = $DB-&gt;getDatabaseHandle()-&gt;prepare_cached(&lt;&lt;SQL) or printLog("newcachedlistapproved: $DBI::errstr\n");
SELECT 
  cachedata
FROM
  cachedinfo
WHERE
  code_id = ? AND
  cachekey = ? AND
  (unix_timestamp(now()) - unix_timestamp(lastupdate) &lt; updateinterval)
SQL
$csr-&gt;execute($htmlcode_id, $cachekey) or printLog("newcachedlistapproved: $DBI::errstr ($htmlcode_id $cachekey)\n");
my $cacheinfo = $csr-&gt;fetchrow_hashref();
$csr-&gt;finish;

my (%approved, %unapproved);
if(!$cacheinfo)
{
    my $sql = &lt;&lt; "SQL";
    select 
        n.node_id, st.status, h.section_id
    from
        node n 
        left join approvalstatus as st on st.approved_id = n.node_id
        left join approvalhistory as h on n.node_id = h.approves_id and
                                     h.whenapproves = st.whenapproved
    where 
        n.type_nodetype = ? and
        n.createtime &gt; from_unixtime(unix_timestamp(now()) - 86400 * $daysBeforeExpire)
    order by 
        n.createtime desc
    limit 
        $count, 100
SQL

    my $sth = $DB-&gt;getDatabaseHandle()-&gt;prepare_cached($sql) or printLog("newcachedlistapproved: $DBI::errstr ($sql)\n");
    $sth-&gt;execute($nodetype) or printLog("newcachedlistapproved: $DBI::errstr\n ($sql, $nodetype, $daysBeforeExpire)");

    my $nodes = $sth-&gt;fetchall_arrayref({});
    my $numshown = 0;
    foreach my $row (@$nodes)
    {
        last if(!$row);
        if($row-&gt;{status} eq 'fp' and $frontpage)
        {
            $numshown++;
            $approved{$row-&gt;{node_id}} = 1;
        } 
        elsif ($row-&gt;{status} and !$frontpage) 
        {
            $numshown++;
            $approved{$row-&gt;{node_id}} = 1;
        } 
        elsif(!$row-&gt;{status})
        {
            $unapproved{$row-&gt;{node_id}} = 1;
        }
        last if($numshown == $length);
    }
    $sth-&gt;finish();
    my $cachedata = join(',', keys %approved, map { -$_ } keys %unapproved);
    
    my $sqlupdatecache = &lt;&lt; "SQL";
REPLACE INTO 
  cachedinfo
(code_id, cachedata, updateinterval, lastupdate, cachekey)
VALUES
  (?, ?, ?, now(), ?)
SQL

    my $sthupdatecache = $DB-&gt;getDatabaseHandle()-&gt;prepare_cached($sqlupdatecache);
    $sthupdatecache-&gt;execute($htmlcode_id, 
                             $cachedata,
                             $updateinterval,
                             $cachekey 
                             );

    return '' if(!%approved);

} else {
    my @cachednodes = split(/,/, $cacheinfo-&gt;{cachedata});
    foreach (@cachednodes)
    {
        $approved{$_} = 1 if($_&gt;0);
        $unapproved{-$_} = 1 if($_&lt;0);
    }
}

my $outercontainer= $settings-&gt;{"outerContainerForType_".$type} || $settings-&gt;{defaultOuterContainer};
my $innercontainer= $settings-&gt;{"innerContainerForType_".$type} || $settings-&gt;{defaultInnerContainer};
my $innerhtmlcode=  $settings-&gt;{"innerHtmlcodeForType_".$type}  || $settings-&gt;{defaultInnerHtmlcode};

$HTMLVARS{listapproved}{title} = $title;
my $sthreplies = $DB-&gt;getDatabaseHandle-&gt;prepare_cached('select * from repliesinfo where parent=?');

my $containednodes = '';
my $numshown = 0;
# Look at both lists, as unapproved nodes may have been approved since we
# cached them
foreach (reverse sort (keys %approved, keys %unapproved))
{
    next if($unapproved{$_} and 
            !($$VARS{unapprovedcontent} and $showunapproved or $showall));
    $numshown++;
    $HTMLVARS{embed_node} = selectNode($_);
    $sthreplies-&gt;execute($_);
    my $replies = $sthreplies-&gt;fetchrow_hashref();
    $sthreplies-&gt;finish();
    my $typeofreplies=$$VARS{repliesdisplay};
    $typeofreplies||="directreplies";
    $HTMLVARS{embed_node}{numreplies}=$replies-&gt;{$typeofreplies};
    $HTMLVARS{embed_node}{numreplies}||="0";
    $containednodes .= containHtml($innercontainer, htmlcode($innerhtmlcode));

    last if $numshown == $length;
}

if(($isGod or $level &gt; 5))
{
    $HTMLVARS{unapproved} = [keys %unapproved];
}

my $result = containHtml($outercontainer, $containednodes);

if($navbar) {
   my $max = $count + $length;
   $result .= "&lt;table width='100%' bgcolor='";
   $result .= $$THEME{clr_highlight} || "EEDDDD'";
   $result .= " border='0' cellpadding='2' cellspacing='0'&gt;&lt;tr&gt;&lt;td align='left' width='100'&gt;";
   my $next = $count - $length;     
   $next = 0 if ($count - $length &lt; 0);
   $result .= "&lt;a href=" . urlGen ({node_id =&gt; getId ($NODE), next =&gt; $next}) . "&gt;&lt;--Previous entries&lt;/a&gt;" if ($count &gt; 0);
   $result .= "&amp;nbsp;";
   $result .= "" if($count &lt;= 0);   

   $result .= "&lt;/td&gt;&lt;td align='center'&gt;";
   $result .= "(" . 
              ($count+1) . 
              "-$max) of " if($max &lt; $sectionshowsize);
   $result .= "&amp;nbsp;&lt;/td&gt;&lt;td align='center'&gt;(" . 
              ($count+1) . 
              "-" . 
              ($sectionshowsize) . 
              ") of " if($max &gt;= $sectionshowsize);
   $result .= $sectionshowsize . 
           "&lt;/td&gt;&lt;td align='right' width='100'&gt;";
   $next = $count+$length; 
   my $num = $length;
   if ($next + $length &gt; $sectionshowsize) {
       $num = $sectionshowsize - $next;
   }
   $result .= "&lt;a href=" 
   .urlGen ({node_id =&gt; getId ($NODE),next =&gt; $max}) 
   ."&gt;Next entries--&gt;&lt;/a&gt;" if ($max &lt; $sectionshowsize);
   $result .= "&amp;nbsp;&lt;/td&gt;&lt;/tr&gt;";
   $result .= "&lt;/table&gt;&lt;/center&gt;";
}

return $numshown ? $result : '';
</patch_code>
<applied>2005-10-12 17:18:30</applied>
<htmlcode_id>499689</htmlcode_id>
<live_code>die "newcachedlistapproved is not used!"</live_code>
<reason>From DEV</reason>
<field>code</field>
</record>
<record><htmlcode_id>741534</htmlcode_id>
<patch_code># my $html= htmlcode('render_doclist_group','',$optional_node_or_id);
my ( $node, %opts )= @_;

$node= $NODE if !$node;
getRef($node);

my %list_type= (
                  doclist =&gt; 1,
                  catqalist =&gt; 1,
                  faqlist =&gt; 1,
                  tutlist =&gt; 1
               );

my $type= $node-&gt;{type}{title};

return "&lt;b&gt;Can't render list of type '$type' in 'render_doclist_group'&lt;/b&gt;"
    unless $list_type{$type};

# Handle Options. Options are provided by the nodes 'vars' and may be
# overridden by arguments. Defaults are provided if nothing is provided
# from either sources.

my $vars= getVars( $node );
%opts= ( %$vars, %opts );

# Do we recurse into sublists when we render?
$opts{recurse}= 1
  unless defined $opts{recurse};

# Do we show the nodetypes when viewing.
# Provides list maintainers more info
$opts{showtype}= 1
  if !exists $opts{showtype} and canUpdateNode($USER,$node);

# let list maintainers override
$opts{showtype}= 0
  if $q-&gt;param('normal_user_view');

$opts{showauthor}= ($node-&gt;{type}{title} eq 'tutlist'
  || $node-&gt;{type}{title} eq 'catqalist')
   unless defined $opts{showauthor};

# all ids we have seen already in the traverse.
my %seen_id;

# lists we have seen before.
my %seen_list= ( $NODE-&gt;{node_id} =&gt; 1);

# recursive routine, so we use local to prevent it from leaking
# due to self references.
local *make_tree= sub {
   my ( $NODE, $html )= @_;

   $html||=[];

   my @GROUP= @{ $NODE-&gt;{group}||[] };

   return unless @GROUP;

   push @$html,"&lt;ul&gt;";

   foreach my $id (@GROUP) {
      my $node= getNodeById($id);
      my $have_seen= $seen_id{$id}++;

      # nodetypes starting in alpha shouldnt show up normally.
      next if   $node-&gt;{type}{title}=~/^alpha/
                and !$opts{showtype};

      my $is_list= $list_type{ $node-&gt;{type}{title} };

      my $content="";
      my $is_string;
      # not clear if this
      if (  $node-&gt;{type}{title} =~ /string$/
            &amp;&amp; (   !$opts{no_string}
                || $q-&gt;param('normal_user_view') )
      ) {
        $is_string= 1;
        $content=qq[&lt;span class="$node-&gt;{type}{title}"&gt;]
                .htmlcode( 'parselinksinchatter', '', $node-&gt;{text} )
                .qq[&lt;/span&gt;];
      } else {
        $content = linkNode($node);
        $content.= qq[&lt;span class="$node-&gt;{type}{title}-itemauthor"&gt; by ]
                . linkNode($node-&gt;{author_user}) 
                . "&lt;/span&gt;"
          if !$is_list 
          &amp;&amp; $opts{showauthor} 
          &amp;&amp; $node-&gt;{author_user} != 113; # don't show "by root" as its not helpful
      }
      if (  $opts{showtype}  ) {
        $content .= " &lt;span class='$node-&gt;{type}{title}-itemtype'&gt;("
                 .  linkNode($node-&gt;{type});
        if ($is_string) {
            $content .= " : ".linkNode($node,"#".$node-&gt;{node_id});
        }
        $content.= ')&lt;/span&gt;';
      }
      push @$html,
            "&lt;li&gt;"
          . ($have_seen ? "&lt;span class='$type-seen'&gt;" : "")
          . ($is_list ? "&lt;span class='$type-islist'&gt;" : "")
          . $content
          . ($is_list ? "&lt;/span&gt;" : "")
          . ($have_seen ? "&lt;/span&gt;" : "")
      ;
      if (  $is_list  &amp;&amp;  $opts{recurse}  ) {
          if (  ! $seen_list{$id}++  ) {
             make_tree( $node, $html );
          } elsif (  $id == $NODE-&gt;{node_id}  ) {
             push @$html," &lt;span class='$type-thislist'&gt;(This list)&lt;/span&gt;";
          }
      }
      push @$html, "&lt;/li&gt;";
   }
   push @$html, "&lt;/ul&gt;";
   return $html;
};


local *make_sections= sub {
   my ( $NODE, $html )= @_;
   $html||=[];
   my @GROUP= @{ $NODE-&gt;{group}||[] };
   return unless @GROUP;

   my @items;
   my @out;
   foreach my $item (@GROUP) {
        my $node=getNodeById($item);
        next if !@{ $node-&gt;{group}||[] } &amp;&amp; !$opts{showtype};
        my $anchor=$node-&gt;{title};
        $anchor=~s/\W+/-/g;
        $anchor=~s/^-+//;
        $anchor=~s/-+$//;
        $anchor=~s/-sitedoclet$//;
        my $title=$node-&gt;{title};
        $title=~s/ sitedoclet$//;
        push @items,qq[&lt;li&gt;&lt;a href="#$anchor"&gt;$title&lt;/a&gt;&lt;/li&gt;];
        push @out, qq[&lt;hr width ="80%" align="left" /&gt;]
                  .qq[&lt;a name="$anchor"&gt;]
                  .qq[&lt;h3&gt;]
                  .linkNode($node,$title)
                  .qq[&amp;nbsp;&amp;nbsp;&lt;i&gt;]
                  .qq[&lt;small&gt;(&lt;a href="#toc"&gt;Top&lt;/a&gt;)&lt;/small&gt;]
                  .qq[&lt;/i&gt;&lt;/h3&gt;&lt;/a&gt;]
        ;
        if (my $sdl=getNode("$node-&gt;{title} sitedoclet",'sitedoclet')) {
          push @out,htmlcode('get_sitedoclet','',$sdl);
        }
        elsif ( $node-&gt;{doctext} ) {
          push @out,htmlcode('ParseLinksInContent','',
            $node-&gt;{doctext},
            id=&gt;$node-&gt;{node_id},
            readmore_remove=&gt;1,
          );
        }
        make_tree( $node, \@out );
   } ;

   my $first=join "", @items[0..$#items/2];
   my $second=join "", @items[$#items/2+1..$#items];

   push @$html,
    qq[&lt;a name="toc"&gt;&lt;h3&gt;$node-&gt;{title}&lt;/h3&gt;&lt;/a&gt;]
    . qq[&lt;table width="100%" align="center" valign="top" cellspacing="0" cellpadding="1" border="0"&gt;]
    . qq[&lt;tr align="center"&gt;]
    . qq[&lt;td width="45%" align="left" valign="top"&gt;]
    . qq[&lt;ul&gt;$first&lt;/ul&gt;&lt;/td&gt;]
    . qq[&lt;td width="55%" align="left" valign="top"&gt;]
    . qq[&lt;ul&gt;$second&lt;/ul&gt;&lt;/td&gt;]
    . qq[&lt;td width="20%"&gt;&amp;nbsp;&lt;/td&gt;]
    . qq[&lt;/tr&gt;&lt;/table&gt;]
    . join "",@out;
   return $html;
};

my @html;
if ($opts{showtext}) {
  push @html,
  htmlcode ( 'ParseLinksInContent', '', 
    $node-&gt;{doctext}, 
    id =&gt; $node-&gt;{node_id},
    readmore_remove =&gt; 1,
    overridefilter =&gt; {
         form =&gt; 'method,action,enctype',
         input =&gt; 'type,name,value,size,/',
       },
  );
}
if ($opts{sections}) {
    make_sections( $node, \@html );
} else {
    make_tree( $node, \@html );
}
return join "", @html;
</patch_code>
<applied>2009-07-24 13:45:19</applied>
<htmlcode_id>519034</htmlcode_id>
<live_code># my $html= htmlcode('render_doclist_group','',$optional_node_or_id);
my ( $node, %opts )= @_;

$node= $NODE if !$node;
getRef($node);

my %list_type= (
                  doclist =&gt; 1,
                  catqalist =&gt; 1,
                  faqlist =&gt; 1,
                  tutlist =&gt; 1
               );

my $type= $node-&gt;{type}{title};

return "&lt;b&gt;Can't render list of type '$type' in 'render_doclist_group'&lt;/b&gt;"
    unless $list_type{$type};

# Handle Options. Options are provided by the nodes 'vars' and may be
# overridden by arguments. Defaults are provided if nothing is provided
# from either sources.

my $vars= getVars( $node );
%opts= ( %$vars, %opts );

# Do we recurse into sublists when we render?
$opts{recurse}= 1
  unless defined $opts{recurse};

# Do we show the nodetypes when viewing.
# Provides list maintainers more info
$opts{showtype}= 1
  if !exists $opts{showtype} and canUpdateNode($USER,$node);

# let list maintainers override
$opts{showtype}= 0
  if $q-&gt;param('normal_user_view');

$opts{showauthor}= ($node-&gt;{type}{title} eq 'tutlist'
  || $node-&gt;{type}{title} eq 'catqalist')
   unless defined $opts{showauthor};

# all ids we have seen already in the traverse.
my %seen_id;

# lists we have seen before.
my %seen_list= ( $NODE-&gt;{node_id} =&gt; 1);

# recursive routine, so we use local to prevent it from leaking
# due to self references.
local *make_tree= sub {
   my ( $NODE, $html )= @_;

   $html||=[];

   my @GROUP= @{ $NODE-&gt;{group}||[] };

   return unless @GROUP;

   push @$html,"&lt;ul&gt;";

   foreach my $id (@GROUP) {
      my $node= getNodeById($id);
      my $have_seen= $seen_id{$id}++;

      # nodetypes starting in alpha shouldnt show up normally.
      next if   $node-&gt;{type}{title}=~/^alpha/
                and !$opts{showtype};

      my $is_list= $list_type{ $node-&gt;{type}{title} };

      my $content="";
      my $is_string;
      # not clear if this
      if (  $node-&gt;{type}{title} =~ /string$/
            &amp;&amp; (   !$opts{no_string}
                || $q-&gt;param('normal_user_view') )
      ) {
        $is_string= 1;
        $content=qq[&lt;span class="$node-&gt;{type}{title}"&gt;]
                .htmlcode( 'parselinksinchatter', '', $node-&gt;{text} )
                .qq[&lt;/span&gt;];
      } else {
        $content = linkNode($node);
        $content.= qq[&lt;span class="$node-&gt;{type}{title}-itemauthor"&gt; by ]
                . linkNode($node-&gt;{author_user}) 
                . "&lt;/span&gt;"
          if !$is_list 
          &amp;&amp; $opts{showauthor} 
          &amp;&amp; $node-&gt;{author_user} != 113; # don't show "by root" as its not helpful
      }
      if (  $opts{showtype}  ) {
        $content .= " &lt;span class='$node-&gt;{type}{title}-itemtype'&gt;("
                 .  linkNode($node-&gt;{type});
        if ($is_string) {
            $content .= " : ".linkNode($node,"#".$node-&gt;{node_id});
        }
        $content.= ')&lt;/span&gt;';
      }
      push @$html,
            "&lt;li&gt;"
          . ($have_seen ? "&lt;span class='$type-seen'&gt;" : "")
          . ($is_list ? "&lt;span class='$type-islist'&gt;" : "")
          . $content
          . ($is_list ? "&lt;/span&gt;" : "")
          . ($have_seen ? "&lt;/span&gt;" : "")
      ;
      if (  $is_list  &amp;&amp;  $opts{recurse}  ) {
          if (  ! $seen_list{$id}++  ) {
             make_tree( $node, $html );
          } elsif (  $id == $NODE-&gt;{node_id}  ) {
             push @$html," &lt;span class='$type-thislist'&gt;(This list)&lt;/span&gt;";
          }
      }
      push @$html, "&lt;/li&gt;";
   }
   push @$html, "&lt;/ul&gt;";
   return $html;
};


local *make_sections= sub {
   my ( $NODE, $html )= @_;
   $html||=[];
   my @GROUP= @{ $NODE-&gt;{group}||[] };
   return unless @GROUP;

   my @items;
   my @out;
   foreach my $item (@GROUP) {
        my $node=getNodeById($item);
        #next if !@{ $node-&gt;{group}||[] } &amp;&amp; !$opts{showtype};
        my $anchor=$node-&gt;{title};
        $anchor=~s/\W+/-/g;
        $anchor=~s/^-+//;
        $anchor=~s/-+$//;
        $anchor=~s/-sitedoclet$//;
        my $title=$node-&gt;{title};
        $title=~s/ sitedoclet$//;
        push @items,qq[&lt;li&gt;&lt;a href="#$anchor"&gt;$title&lt;/a&gt;&lt;/li&gt;];
        push @out, qq[&lt;hr width ="80%" align="left" /&gt;]
                  .qq[&lt;a name="$anchor"&gt;]
                  .qq[&lt;h3&gt;]
                  .linkNode($node,$title)
                  .qq[&amp;nbsp;&amp;nbsp;&lt;i&gt;]
                  .qq[&lt;small&gt;(&lt;a href="#toc"&gt;Top&lt;/a&gt;)&lt;/small&gt;]
                  .qq[&lt;/i&gt;&lt;/h3&gt;&lt;/a&gt;]
        ;
        if (my $sdl=getNode("$node-&gt;{title} sitedoclet",'sitedoclet')) {
          push @out,htmlcode('get_sitedoclet','',$sdl);
        }
        elsif ( $node-&gt;{doctext} ) {
          push @out,htmlcode('ParseLinksInContent','',
            $node-&gt;{doctext},
            id=&gt;$node-&gt;{node_id},
            readmore_remove=&gt;1,
          );
        }
        make_tree( $node, \@out );
   } ;

   my $first=join "", @items[0..$#items/2];
   my $second=join "", @items[$#items/2+1..$#items];

   push @$html,
    qq[&lt;a name="toc"&gt;&lt;h3&gt;$node-&gt;{title}&lt;/h3&gt;&lt;/a&gt;]
    . qq[&lt;table width="100%" align="center" valign="top" cellspacing="0" cellpadding="1" border="0"&gt;]
    . qq[&lt;tr align="center"&gt;]
    . qq[&lt;td width="45%" align="left" valign="top"&gt;]
    . qq[&lt;ul&gt;$first&lt;/ul&gt;&lt;/td&gt;]
    . qq[&lt;td width="55%" align="left" valign="top"&gt;]
    . qq[&lt;ul&gt;$second&lt;/ul&gt;&lt;/td&gt;]
    . qq[&lt;td width="20%"&gt;&amp;nbsp;&lt;/td&gt;]
    . qq[&lt;/tr&gt;&lt;/table&gt;]
    . join "",@out;
   return $html;
};

my @html;
if ($opts{showtext}) {
  push @html,
  htmlcode ( 'ParseLinksInContent', '', 
    $node-&gt;{doctext}, 
    id =&gt; $node-&gt;{node_id},
    readmore_remove =&gt; 1,
    overridefilter =&gt; {
         form =&gt; 'method,action,enctype',
         input =&gt; 'type,name,value,size,/',
       },
  );
}
if ($opts{sections}) {
    make_sections( $node, \@html );
} else {
    make_tree( $node, \@html );
}
return join "", @html;
</live_code>
<reason>add support for catqalist</reason>
<field>code</field>
</record>
<record><htmlcode_id>731179</htmlcode_id>
<patch_code>my( $TYPE, $title )= @_;
return 0
    if  getId($USER) != $HTMLVARS{guest_user};
return 1
    if  "snippet" eq $TYPE-&gt;{title}
    ||  "sourcecode" eq $TYPE-&gt;{title}
    ||  $title =~ m-^\s*https?://-i;

# AM may not (really) change the node title
return 1
    if "note" eq $TYPE-&gt;{title}
    &amp;&amp; $title !~ /^Re(\^\d+)?:/;

if ($title !~ /\S\s+\S/ and "user" ne $TYPE-&gt;{title}) {
       Everything::printLog(
            join ", ",
            "Rejected spam: Single word title",
            $ENV{REMOTE_ADDR},
            $TYPE-&gt;{title},
       );
       return 1
};

my $bad_words = qr/phentermine|valium|tramadol|xanax|viagra|cialis|cipro|soma|ultram/;
my $bad_phrase = qr/buy \w+ online|^buy /;

if (   $title =~ /\b($bad_words)\b/i
    or $title =~ /\b(Your site has very much liked me)\b/i
    or $title =~ /\b($bad_phrase)\b/i
) {
       Everything::printLog(
            join ", ",
            "Rejected spam: Bad word '$1' in title",
            $ENV{REMOTE_ADDR},
            $TYPE-&gt;{title},
       );
       return 1
};

for my $p (  $q-&gt;param()  ) {
    for(  $q-&gt;param($p)  ) {
        my $reason;
        my $check= $q-&gt;unescapeHTML( $_ );
        $reason ||= "Rejected spam: fixed subject"
            if $check eq 'Comment on&lt;*1*&gt;http://www.perlmonks.org/?&lt;*2*&gt;node_id=3333';
        my $links= ()= $check =~ m&lt;
            href=["' ]*http://
        &gt;gix;
        $reason ||= "Rejected spam: $links generic absolute links"
            if $links &gt; 4;

        if ($check=~ /title="evden eve nakliyat"/) {
            $reason ||= "Rejected spam: Links with spammy link title"
        };

        # Check+ban phrases
        if (! $reason) {
            my $phrases= ()= $check =~ m&lt;
              \bbuy\s+
              (?:$bad_words)
              (?:\s+online\b)?
            &gt;gix;
            # This might still be too generous
            $reason ||= "Rejected spam: $phrases banned phrases"
                if ($phrases &gt; 2);
        };

        $links= ()= $check =~ m&lt;
            http://[-\w.]*\b(?:
                (?:blogspot|freewebtown|hubpages|tripod|tabletpcbuzz|yeahost
                  |blinklist|bebo
                  |firehotsite|dk-drugs|sexpills\.wikidot|weebly)[.]com
              | (?:ehnine|riavas|tielat|xucone)[.]org
              | (?:shurl)[.]net
              | (?:[^/]*online.?pharmacy)
              | [.]info(?![.])
              | planetnana\.co\.il\/atarim2008
              | groups\.msn\.com/buy-soma
              | conversation\.cgu\.edu
            )\b
          | (?:\[\s*url[^\[]*?)?\[\s*/\s*url\s*\]
        &gt;gix;
        if (! $reason) {
            next
                if  $links &lt; 1 # zero bogo-links: good
                or  $links &lt; 3 # more bogo-links: ok, as long as...
                 &amp;&amp; $title =~ /^Re(\^\d+)?:/; # title looks legit.
        };
        $reason ||= "Rejected spam: $links specific links";
        my $link=       substr( $check, $-[0], $+[0]-$-[0] );
        my $escTitle=   substr( $title, 0, 120 );
        my $escText=    substr( $_, 0, 120 );
        s/ ([^ -Z^-~]) / "\\x" . unpack "H*", $1 /gex
            for  $escTitle, $escText;
        Everything::printLog(
            join ", ",
            $reason,
            $ENV{REMOTE_ADDR},
            "&lt;$link&gt;",
            $TYPE-&gt;{title},
            "[$escTitle]" . length($title),
            "$p=[$escText]" . length($_),
        );
        return 1;
    }
}
return 0;
</patch_code>
<applied>2008-12-18 02:19:49</applied>
<htmlcode_id>611863</htmlcode_id>
<live_code>my( $TYPE, $title )= @_;

my $reject= sub {
    my( $reason, $match, $param, $text )= @_;
    my $escTitle=   substr( $title, 0, 120 );
    my $escText=    substr( $text || '', 0, 120 );
    s/ ([^ -Z^-~]) / "\\x" . unpack "H*", $1 /gex
        for  $escTitle, $escText;
    Everything::printLog( join ", ",
        "Block spam? $reason",
        $ENV{REMOTE_ADDR},
        $match ? "&lt;$match&gt;" : (),
        "type=$TYPE-&gt;{title}",
        "[$escTitle]" . length($title),
        $param ? "$param=[$escText]" . length($text) : (),
    );
    return $reason;
};

my $level=
        getId($USER) == $HTMLVARS{guest_user}   ?   -2
    :   $USER-&gt;{experience} &lt; 0                 ?   -1
    :   $USER-&gt;{experience} == 0                ?   0
                                                :   getLevel( $USER );

if(  -2 != $level  ) {
    my( $nodes, $min, $max )= $DB-&gt;getDatabaseHandle()-&gt;selectrow_array(
        join ' ',
        "select count(*), min(reputation), max(reputation) from (",
            "select reputation from node",
            "where author_user = $USER-&gt;{user_id}",
            "and type_nodetype not in ( 15, 182711 )",  # user, scratchpad
            "order by node_id desc limit 5",
        ") as q",
    );
    if(     0 == $nodes
        ||  0 == $min  &amp;&amp;  0 == $max
    ) {
        $level= 0;
    } elsif(  $min &lt; 0  &amp;&amp;  $max &lt;= 0  ) {
        $level= -1
    } elsif(  1 &lt; $nodes  &amp;&amp;  0 &lt;= $min  &amp;&amp;  0 &lt; $max  ) {
        $level++;
    }
    return ''
        if  4 &lt; $level;
}

if(  $level &lt; 3  ) {
    return $reject-&gt;( "Level&lt;3 $TYPE-&gt;{title}" )
        if  "snippet" eq $TYPE-&gt;{title}
        ||  "sourcecode" eq $TYPE-&gt;{title};
    return $reject-&gt;( "Level&lt;3 title containing link", $1 )
        if  $title =~ m-(\bhttps?://\w+\.\w+\S*)-i;
    return $reject-&gt;( "Level&lt;3 note w/ 'Re:' prefix replaced" )
        if  "note" eq $TYPE-&gt;{title}
        &amp;&amp;  $title !~ /^Re(\^\d+)?:/;
    return $reject-&gt;( "Level&lt;3 single-word title" )
        if  'user' ne $TYPE-&gt;{title}
        &amp;&amp;  $title !~ /\S\s+\S/;
}

my $drugs = join '|', qw&lt;
    boniva cialis cipro diazepam lozol phentermine
    soma tramadol ultram valium viagra xanax
&gt;;
my $bad_phrase = qr/buy \S+ on.?line|^buy /;
if(     $title =~ /\b($drugs)\b/i
    ||  $title =~ /\b(Your site .*liked me)\b/i
    ||  $title =~ /\b($bad_phrase)\b/i
) {
    return $reject-&gt;( "Bad words in title", $1 );
}

for my $p (  $q-&gt;param()  ) {
    for my $v (  $q-&gt;param($p)  ) {
        my $reason;
        local $_= $q-&gt;unescapeHTML( $v );

        return $reject-&gt;( "Fixed string", $1, $p, $v )
            if  m{(Comment on&lt;\*1\*&gt;http://[\w.]+/\?&lt;\*2\*&gt;node_id=3333)}
            ||  m{(shenzhenelectronic|plzzshop|http://qr.net/|http://50.gd/|http://nirl.eu/|nike,jordan,prada|\bAir\s*jordan\b|\bUGG\s*BOOT\b)}i;

        my $links= 0;
        my $allowed= getVars( getNode( 'non-spam URL hosts', 'setting' ) );
        my $url;
        while(
            m{
                (?: \[\s*
                |   href (?: \s*=\s*['"]? | \s*\]\s* )
                )
                https?://
                ( [-\w]+ \. [-\w]+ [^\s/'"&lt;&gt;\[\]|]+ )
            }gix
        ) {
            my $part= $1;
            my $ok= 0;
            while(  $part  ) {
                $ok ||= $allowed-&gt;{$part}
                    and last;
                $part =~ s{[^.]+[.]}{}
                    or  last;
            }
            next
                if  $ok;
            $links++;
            $url= $1;
        }
        return $reject-&gt;( "$links links", $url, $p, $_ )
            if  0 &lt; $links  &amp;&amp;  $level &lt; $links;

        #return $reject-&gt;( "Spammy title attrib", $1, $p, $_ )
        #    if  $check=~ /(title="evden eve nakliyat")/;

        return $reject-&gt;( "Selling stuff", $1, $p, $_ )
            if  m&lt;
                    ( \bbuy\s+(?:$drugs)\b
                    | \bbuy\s+.{0,30}(?:on.?line\b) )
                &gt;ix;
    }
}
return 0;
</live_code>
<reason>Add ?turkish? spam site</reason>
<field>code</field>
</record>
<record><htmlcode_id>774932</htmlcode_id>
<patch_code>my( $title, $flag, $targetnodeid )= @_;
$title ||= 'RJE';
$flag ||= '(&lt;b&gt;%d&lt;/b&gt;)';
$targetnodeid= ''
    if  $targetnodeid =~ /\D/; # bad value

if(  $VARS-&gt;{'rje_lastchecked'}  ) {
    my( $newcount )= $DB-&gt;sqlSelect(
        'count(*)',
        'edithistory',
        join( ' AND ',
            'starttext != endtext',
            $DB-&gt;quote( $VARS-&gt;{'rje_lastchecked'} ) . '&lt; edittime',
            ! $targetnodeid
                ? () : "edithistory_id = $targetnodeid",
        ),
    );
    $flag= !$newcount ? '' : sprintf $flag, $newcount;
} else {
    $flag= '';
}

my $url= $targetnodeid
    ? "?node_id=$targetnodeid;displaytype=edithistory;limit=25"
    : "?node_id=434853";

return qq(&lt;a href="$url" title="Recent Janitorial Edits"&gt;$title$flag&lt;/a&gt;);
</patch_code>
<applied>2009-06-26 02:12:18</applied>
<htmlcode_id>774789</htmlcode_id>
<live_code>my( $title, $flag, $targetnodeid )= @_;
$title ||= 'RJE';
$flag ||= '(&lt;b&gt;%d&lt;/b&gt;)';
$targetnodeid= ''
    if  $targetnodeid =~ /\D/; # bad value

if(  $VARS-&gt;{'rje_lastchecked'}  ) {
    my( $newcount )= $DB-&gt;sqlSelect(
        'count(*)',
        'edithistory',
        join( ' AND ',
            $DB-&gt;quote( $VARS-&gt;{'rje_lastchecked'} ) . '&lt; edittime',
            ! $targetnodeid
                ? () : "edithistory_id = $targetnodeid",
        ),
    );
    $flag= !$newcount ? '' : sprintf $flag, $newcount;
} else {
    $flag= '';
}

my $link= genLink(
    $title,
    {   ! $targetnodeid
            ? ( node_id =&gt; 434853 )
            : ( node_id =&gt; $targetnodeid,
                displaytype =&gt; 'edithistory',
                limit =&gt; 25,
              ),
    },
    { title =&gt; 'Recent Janitorial Edits' }
);

my $class = 'rjelink';

if ( $flag ) {
    $link .= $q-&gt;span( { class =&gt; 'rjeupdate' }, $flag );
    $class .= ' updated';
}

return qq(&lt;span class="$class"&gt;$link&lt;/span&gt;);


</live_code>
<reason>Preserve existing features (title= for hover)</reason>
<field>code</field>
</record>
<record><htmlcode_id>741555</htmlcode_id>
<patch_code>[{get_sitedoclet:Choosing a username}]
[%
  my $str;

  local *generateLogin = sub
  {
    return &lt;&lt;"END";
    &lt;form action="@{[ $ENV{SCRIPT_NAME} ]}" method="post"&gt;
      &lt;input type="hidden" name="node_id" value="@{[ getId($NODE) ]}" /&gt;
      &lt;input type="hidden" name="op" value="newuser" /&gt;

      &lt;table&gt;
        &lt;tr&gt;
          &lt;td&gt;Preferred username:&lt;/td&gt;
          &lt;td&gt;&lt;input type="text" name="nu_name" size="20" maxlength="20" /&gt; (See [id://156912] for helpful advice.)&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;Real&amp;#153; Name:&lt;/td&gt;
          &lt;td&gt;&lt;input type="text" name="nu_realname" size="20" maxlength="40" /&gt;&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;Email Address&lt;/td&gt;
          &lt;td&gt;&lt;input type="text" name="nu_email" size="20" maxlength="255" /&gt;&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;&lt;/td&gt;
          &lt;td&gt;&lt;input type="submit" name="sexisgood" value="submit" /&gt;&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/table&gt;

    &lt;/form&gt;
END
  };

  unless ( $query-&gt;param('op') eq 'newuser' ) {
    return &lt;&lt;"END";
    &lt;p&gt;
      To create a new user on PerlMonks, we need a smattering of information:
    &lt;/p&gt;
    @{[ generateLogin() ]}
    &lt;p&gt;
      &lt;b&gt;Please note:&lt;/b&gt;
    &lt;/p&gt;
    &lt;p&gt;
      We are not going to send you junk email "member updates", sell your
      address to spammers, or display your email address for people to see.
      This email exists so that you can receive your password, and/or retrieve
      it if you forget.  There may be future email functionality, which
      you will have the option to turn on from your user settings page.
    &lt;/p&gt;
    &lt;p&gt;Once you have a PerlMonks account, there are 
       some rules you should be aware of; please read 
       [id://538727].
    &lt;/p&gt;
END
  }

  my $realname  = $query-&gt;param("nu_realname");
  my $email     = $query-&gt;param("nu_email");
  my $name      = $query-&gt;param("nu_name");

  if ($email =~ /^(?:
                    email1?\@gmail[.]com
                   |emai1l\@gmail[.]com
                  )$/x) {
    Everything::printLog("Blocked spam: Invalid registration email address '$email'" );
    return sprintf &lt;&lt;'END',
    &lt;p&gt;
      Sorry, this email address does not seem valid.
      Please use a valid email address.
    &lt;/p&gt;
    %s
END
    generateLogin();
  };


  my @pass;
  $name =~ s/\s*$//;
  if ( $name =~ /[_ ][_ ]/  ) {
    return sprintf &lt;&lt;'END',
    &lt;p&gt;
      Sorry, you can't have a space or underscore next to another.
      Try another name...
    &lt;/p&gt;
    %s
END
    generateLogin();
  }
  if ( my $olduser = $DB-&gt;getNode($name,'user') ) {
    return sprintf &lt;&lt;'END',
    &lt;p&gt;
      Sorry, %s already exists.  Try another name...
    &lt;/p&gt;
    %s
END
    linkNode($olduser), generateLogin();
  }

  # Check if we have any '_' vs ' ' clashing
  # that could lead to chatterbox conflicts.

  # Deny people the power of _ and ' ' at the beginning of usernames
  if ( $name =~ /^[_ ]/ ) {

    return &lt;&lt;"END";
    &lt;p&gt;
      Sorry, ' ' and '_' are not allowed at the beginning of usernames.
      Try again, do not pass Go, and do not collect \$200.
    &lt;/p&gt;
    @{[ generateLogin() ]}
END

  }

  if( $name =~ /[\[\]&lt;&gt;|]/ ) {

    return &lt;&lt;"END";
    &lt;p&gt;
      Sorry &amp;lt;, &amp;gt;, |, &amp;#091; and &amp;#093; are not allowed in usernames.  Try again.
    &lt;/p&gt;
    @{[ generateLogin() ]}
END

  }

  if( $name !~ /\D/ ) {

    return &lt;&lt;"END";
    &lt;p&gt;
      Sorry usernames can no longer be just digits.  Try again.
    &lt;/p&gt;
    @{[ generateLogin() ]}
END

  }

  my $match = quotemeta( lc($name) ); # Have regex treat all chars as literals
  # $match =~ s/([a-z])/'['.$1.uc($1).']'/eg; # MySQL regex already ignore case
  $match =~ s/_|\\ /[_ ]/g;  # Have "_" and " " match each other
  $match =~ s/([\\'])/\\$1/g; # Survive quoting
  $match = q('^).$match.q($');   # Anchor and quote regex

  my ($closeuser) = $DB-&gt;sqlSelect(
    "node_id,title",
    "node",
    "title rlike $match
     and type_nodetype in(" .
     join( ",", map
       getId(getType($_)), qw( user usergroup )
     ) . ")"
  );
  if($closeuser) {
    return "Sorry, your username clashes with " . linkNode($closeuser)
    . " which already exists.  Pick a variation, or try another name...&lt;p&gt;\n"
    . generateLogin();
  }

  if( getNode($name,'superdoc') || getNode($name,'usergroup')
    || getNode($name,'sitefaqlet') || getNode($name,'sitedoclet')
    || getNode($name,'faqlist') || getNode($name,'faqstring')
    || getNode($name,'catqalist') || getNode($name,'catqastring')
    || getNode($name,'tutlist') || getNode($name,'tutstring')
    || getNode($name,'fullpage') || getNode($name,'htmlpage')
    || getNode($name,'htmlcode') || getNode($name,'nodelet')
    || getNode($name,'setting') || getNode($name,'dbtable')
    || getNode($name,'wiki')
    || getNode($name,'perlman') || getNode("perlman:$name", 'perlman')
    || getNode($name,'perlfunc') || getNode("perlfunc:$name", 'perlfunc') ) {
    return &lt;&lt;"END";
    &lt;p&gt;
      Sorry there is already a system document or usergroup with that name.
      Pick a name that doesn't clash with important system documents.
    &lt;/p&gt;
    @{[ generateLogin() ]}
END

  }


  # Generate the passwd and send it out on email.
  my @chars = ( 'A'..'Z', 'a'..'k', 2..9 );
  my $passwd = join('', @chars[ map { rand @chars } 1 .. 8 ]);


  my $NEWUSER = {
                  realname  =&gt; $realname,
                  email     =&gt; $email,
                  passwd    =&gt; $passwd,
                  title     =&gt; $name,
                  lastupdate =&gt; undef,
  };

  # if they already tried to register, update the password and timestamp
  $DB-&gt;getDatabaseHandle()-&gt;do(
    "REPLACE INTO newuser (title, passwd, realname, email, lastupdate) VALUES (?,?,?,?,?)",
    undef, @$NEWUSER{qw/title passwd realname email lastupdate/}
  );

  # Send some email;
  my $msg = getNode('New User Mail', 'mail');

  $msg-&gt;{doctext} =~ s/&lt;name&gt;/$NEWUSER-&gt;{realname}/;
  $msg-&gt;{doctext} =~ s/&lt;user&gt;/$NEWUSER-&gt;{title}/;
  $msg-&gt;{doctext} =~ s/&lt;passwd&gt;/$NEWUSER-&gt;{passwd}/;
  $msg-&gt;{doctext} =~ s/&lt;site_name&gt;/$HTMLVARS{site_name}/;
  $msg-&gt;{doctext} =~ s/&lt;homenode&gt;/$HTMLVARS{site_url}index\.pl\?node=$NEWUSER-&gt;{title}\&amp;type=user/;
  $msg-&gt;{doctext} =~ s/&lt;site_url&gt;/$HTMLVARS{site_url}/;
  $msg-&gt;{doctext} =~ s/&lt;login&gt;/$HTMLVARS{site_url}index\.pl\?node_id=$HTMLVARS{login_node}/;

  use Everything::MAIL;
  node2mail($NEWUSER-&gt;{email}, $msg);
  $HTMLVARS{mailsent} = 1;

  # Record sign-up information for later reference.
  # $DB-&gt;sqlInsert('emailpwd', { user_id =&gt; getId($NEWUSER), ip =&gt; $ENV{REMOTE_ADDR}, email =&gt; $email, reason =&gt; 'New user' });


  return sprintf &lt;&lt;'END',
  &lt;p&gt;
    Your new user account (%s) has been created.  You (%s)
    should be getting an email soon telling you your generated
    password.
  &lt;/p&gt;
END

  $NEWUSER-&gt;{title}, $NEWUSER-&gt;{email};
%]
[%
  return unless exists $HTMLVARS{newuser}
          and not exists $HTMLVARS{mailsent};

  my $NU = getNodeById $HTMLVARS{newuser};

  return "Our mail server isn't working right now.  Sorry.  You get your password now: $NU-&gt;{passwd}";
%]</patch_code>
<applied>2009-07-24 13:47:38</applied>
<htmlcode_id>101</htmlcode_id>
<live_code>[%
  my $str;

  my $loginForm= &lt;&lt;"END";
    &lt;form action="?" method="post"&gt;
      &lt;input type="hidden" name="node_id" value="@{[ getId($NODE) ]}" /&gt;
      &lt;input type="hidden" name="op" value="newuser" /&gt;

      &lt;table&gt;
        &lt;tr&gt;
          &lt;td&gt;Preferred username:&lt;/td&gt;
          &lt;td&gt;&lt;input type="text" name="nu_name" size="20" maxlength="20" /&gt;
          (See above for helpful advice.)&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;Real&amp;#153; Name:&lt;/td&gt;
          &lt;td&gt;&lt;input type="text" name="nu_realname" size="20" maxlength="40" /&gt;
          &lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;Email Address&lt;/td&gt;
          &lt;td&gt;&lt;input type="text" name="nu_email" size="20" maxlength="255" /&gt;
          &lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;&lt;/td&gt;
          &lt;td&gt;&lt;input type="submit" name="sexisgood" value="submit" /&gt;&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/table&gt;

    &lt;/form&gt;
END

  if(  'newuser' ne $query-&gt;param('op')  ) {
    return &lt;&lt;"END";
    @{[ htmlcode('get_sitedoclet','Choosing a username') ]}
    &lt;p&gt;
      To create a new user on PerlMonks, we need a smattering of information:
    &lt;/p&gt;
    $loginForm
    &lt;p&gt;
      When your account has been created, you will receive an email at your
      given address, from &lt;tt&gt;vroom\@perlmonks.org&lt;/tt&gt;, containing your
      randomly-generated eight-character password.  When you have logged in
      with this password, you may proceed to your Profile and change it to
      something else.
    &lt;/p&gt;
    &lt;p&gt;
      &lt;b&gt;Please note:&lt;/b&gt;
    &lt;/p&gt;
    &lt;p&gt;
      We are not going to send you junk email "member updates", sell your
      address to spammers, or display your email address for people to see.
      This email exists so that you can receive your password, and/or retrieve
      it if you forget.  There may be future email functionality, which
      you will have the option to turn on from your user settings page.
    &lt;/p&gt;
    &lt;p&gt;
      Once you have a PerlMonks account, there are some rules you should
      be aware of; please read [id://538727].
    &lt;/p&gt;
END
  }

  my $realname  = $query-&gt;param("nu_realname");
  my $email     = $query-&gt;param("nu_email");
  my $name      = $query-&gt;param("nu_name");

  if(  $email =~ /^email1?l?\@gmail[.]com$/x  ) {
    Everything::printLog(
      "Blocked spam: Invalid registration email address '$email'" );
    return join '', &lt;&lt;'END', $loginForm;
    &lt;p&gt;
      Sorry, this email address does not seem valid.
      Please use a valid email address.
    &lt;/p&gt;
END
  }

  my @pass;
  $name =~ s/\s*$//;
  if ( $name =~ /[_ ][_ ]/  ) {
    return join '', &lt;&lt;'END', $loginForm;
    &lt;p&gt;
      Sorry, you can't have a space or underscore next to another.
      Try another name...
    &lt;/p&gt;
END
  }
  if ( my $olduser = $DB-&gt;getNode($name,'user') ) {
    return join '', &lt;&lt;'END', $loginForm;
    &lt;p&gt;
      Sorry, @{[linkNode($olduser)]} already exists.  Try another name...
    &lt;/p&gt;
END
  }

  # Check if we have any '_' vs ' ' clashing
  # that could lead to chatterbox conflicts.

  # Deny people the power of _ and ' ' at the beginning of usernames
  if ( $name =~ /^[_ ]/ ) {

    return join '', &lt;&lt;"END", $loginForm;
    &lt;p&gt;
      Sorry, ' ' and '_' are not allowed at the beginning of usernames.
      Try again, do not pass Go, and do not collect \$200.
    &lt;/p&gt;
END

  }

  if( $name =~ /[\[\]&lt;&gt;|]/ ) {

    return join '', &lt;&lt;"END", $loginForm;
    &lt;p&gt;
      Sorry, &amp;lt;, &amp;gt;, |, &amp;#091;, and &amp;#093; are not allowed in
      usernames.  Try again.
    &lt;/p&gt;
END

  }
  if( $name =~ /[\x00-\x1f]/ ) {

    return join '', &lt;&lt;"END", $loginForm;
    &lt;p&gt;
      Sorry, low-byte characters are not allowed in usernames.  Try again.
    &lt;/p&gt;
END

  }

  if( $name !~ /\D/ ) {

    return join '', &lt;&lt;"END", $loginForm;
    &lt;p&gt;
      Sorry usernames can no longer be just digits.  Try again.
    &lt;/p&gt;
END

  }

  my $match = quotemeta( lc($name) ); # Have regex treat all chars as literals
  # $match =~ s/([a-z])/'['.$1.uc($1).']'/eg; # MySQL regex already ignore case
  $match =~ s/_|\\ /[_ ]/g;  # Have "_" and " " match each other
  $match =~ s/([\\'])/\\$1/g; # Survive quoting
  $match = q('^).$match.q($');   # Anchor and quote regex

  my ($closeuser) = $DB-&gt;sqlSelect(
    "node_id,title",
    "node",
    "title rlike $match
     and type_nodetype in(" .
     join( ",", map
       getId(getType($_)), qw( user usergroup )
     ) . ")"
  );
  if($closeuser) {
    return "Sorry, your username clashes with " . linkNode($closeuser)
    . " which already exists.  Pick a variation, or try another name...&lt;p&gt;\n"
    . $loginForm;
  }

  if( getNode($name,'superdoc') || getNode($name,'usergroup')
    || getNode($name,'sitefaqlet') || getNode($name,'sitedoclet')
    || getNode($name,'faqlist') || getNode($name,'faqstring')
    || getNode($name,'catqalist') || getNode($name,'catqastring')
    || getNode($name,'tutlist') || getNode($name,'tutstring')
    || getNode($name,'fullpage') || getNode($name,'htmlpage')
    || getNode($name,'htmlcode') || getNode($name,'nodelet')
    || getNode($name,'setting') || getNode($name,'dbtable')
    || getNode($name,'wiki')
    || getNode($name,'perlman') || getNode("perlman:$name", 'perlman')
    || getNode($name,'perlfunc') || getNode("perlfunc:$name", 'perlfunc') ) {
    return join '', &lt;&lt;"END", $loginForm;
    &lt;p&gt;
      Sorry there is already a system document or usergroup with that name.
      Pick a name that doesn't clash with important system documents.
    &lt;/p&gt;
END

  }

  # Generate the passwd and send it out on email.
  my @chars = ( 'A'..'Z', 'a'..'k', 2..9 );
  my $passwd = join('', @chars[ map { rand @chars } 1 .. 8 ]);

  my $NEWUSER = {
    realname  =&gt; $realname,
    email     =&gt; $email,
    passwd    =&gt; $passwd,
    title     =&gt; $name,
    lastupdate =&gt; undef,
  };

  # if they already tried to register, update the password and timestamp
  $DB-&gt;getDatabaseHandle()-&gt;do(
    join( '',
      "REPLACE INTO newuser (title, passwd, realname, email, lastupdate)",
      "VALUES (?,?,?,?,?)",
    ),
    undef, @$NEWUSER{qw/title passwd realname email lastupdate/},
  );

  # Send some email;
  my $msg = getNode('New User Mail', 'mail');
  local $msg-&gt;{doctext} = $msg-&gt;{doctext};
  $msg-&gt;{doctext} =~ s/&lt;name&gt;/$NEWUSER-&gt;{realname}/;
  $msg-&gt;{doctext} =~ s/&lt;user&gt;/$NEWUSER-&gt;{title}/;
  $msg-&gt;{doctext} =~ s/&lt;passwd&gt;/$NEWUSER-&gt;{passwd}/;
  $msg-&gt;{doctext} =~ s/&lt;site_name&gt;/$HTMLVARS{site_name}/;
  $msg-&gt;{doctext} =~ s/&lt;homenode&gt;/
    "$HTMLVARS{site_url}index.pl?node=$NEWUSER-&gt;{title}&amp;type=user"
  /e;
  $msg-&gt;{doctext} =~ s/&lt;site_url&gt;/$HTMLVARS{site_url}/;
  $msg-&gt;{doctext} =~ s/&lt;login&gt;/
    "$HTMLVARS{site_url}index.pl?node_id=$HTMLVARS{login_node}"
  /e;

  use Everything::MAIL;
  node2mail( $NEWUSER-&gt;{email}, $msg );
  $HTMLVARS{mailsent} = 1;

  # Record sign-up information for later reference.
  # $DB-&gt;sqlInsert('emailpwd', { user_id =&gt; getId($NEWUSER),
  # ip =&gt; $ENV{REMOTE_ADDR}, email =&gt; $email, reason =&gt; 'New user' });

  return &lt;&lt;END,
  &lt;p&gt;
    Your new user account ($NEWUSER-&gt;{title}) has been created.
    You ($NEWUSER-&gt;{email};) should be getting an email soon telling
    you your generated password.
  &lt;/p&gt;
END

%]
[%
  return unless exists $HTMLVARS{newuser}
          and not exists $HTMLVARS{mailsent};

  my $NU = getNodeById( $HTMLVARS{newuser} );

  return join '', "Our mail server isn't working right now.",
    "  Sorry.  You get your password now: $NU-&gt;{passwd}";
%]
</live_code>
<reason>add checking for CatQA lists/strings</reason>
<field>doctext</field>
</record>
<record><htmlcode_id>740759</htmlcode_id>
<patch_code>Multiple nodes named "&lt;b&gt;[% $query-&gt;param('node') || 'Bob' %]&lt;/b&gt;" were drunk:&lt;br&gt;

[%
  $q-&gt;table(
    map {
      $q-&gt;Tr(
        $q-&gt;td([
          htmlcode( 'parseTimeInString','', $_-&gt;{createtime} ),
          linkNode($_),
          '(' . linkNode($_-&gt;{type}) . ')',
          'by ' . linkNode($_-&gt;{author_user}),
        ])
      )
    } 
    map { getNodeById($_, 'light') }
    sort { $b &lt;=&gt; $a }
    @{ $NODE-&gt;{group} || [] }
  )
%]

</patch_code>
<applied>2009-02-02 16:12:06</applied>
<htmlcode_id>102</htmlcode_id>
<live_code>Multiple nodes named "&lt;b&gt;[%
    $q-&gt;escapeHTML(
        $q-&gt;param('node') || $NODE-&gt;{title},
    );
%]&lt;/b&gt;" were drunk:&lt;br&gt;

[%
  $q-&gt;table(
    map {
      $q-&gt;Tr(
        $q-&gt;td([
          htmlcode( 'parseTimeInString','', $_-&gt;{createtime} ),
          linkNode($_),
          '(' . linkNode($_-&gt;{type}) . ')',
          'by ' . linkNode($_-&gt;{author_user}),
        ]),
      );
    }
    map { getNodeById( $_, 'light' ) }
    sort { $b &lt;=&gt; $a }
    @{ $NODE-&gt;{group} || [$NODE] },
  )
%]
</live_code>
<reason>convert to table; show date instead of node id</reason>
<field>doctext</field>
</record>
<record><htmlcode_id>782296</htmlcode_id>
<patch_code>&lt;p align=right&gt;
&lt;a href="/?node_id=156909"&gt;Help for this page&lt;/a&gt;
&lt;/p&gt;
[%
  my $html= "";

  my $user_id = getId($USER);
  if(  'login' ne ($q-&gt;param('op'))[0]  ) {
    $html .= "Hey, " . linkNode($USER) . "...  this is where you log in:";
  } elsif(  $user_id != $HTMLVARS{guest_user}  ) {
    my $lastnode_id = $q-&gt;param("lastnode_id") || 0;
    my $rat           = 397425; # Recently Active Threads
    my $other_default = 3628;   # Newest Nodes
    my %id_link = (
      $user_id =&gt; "to your " . linkNode($USER, "home node"),
      $HTMLVARS{default_node} =&gt; "to " . linkNode($HTMLVARS{default_node}),
      $rat           =&gt; 'to ' . linkNode($rat),
      $other_default =&gt; "to " . linkNode($other_default),
    );
    my @a = map {
      $lastnode_id != $_ ? $id_link{$_} : ()
    } $user_id, $HTMLVARS{default_node}, $other_default, $rat;
    $id_link{$lastnode_id} ||= 'to ' . linkNode($lastnode_id)
       if $lastnode_id;
    $a[-1] = "or ".$a[-1];
    local $" = @a &gt; 2 ? ", " : " ";
    $html .= "Hey.  Glad you're back.  Would you like to go @a?&lt;br /&gt;";
    $html .= "...or back $id_link{$lastnode_id}?&lt;br /&gt;" if $lastnode_id;
    $html .= "Or perhaps you want to [SoPW|ask a Perl question]?&lt;br /&gt;";
    return $html;
  } else {
    $html .= "Oops.  You must have the wrong login or password or something:";
  }

  $html .= "\n&lt;p&gt;\n";

  # users may set tabindices under 100 by client-side or free nodelet scripts
  # this is not a pm-wide convention yet but let's start it now
  $html .= htmlcode('openform')
    . qq(&lt;input type="hidden" name="op" value="login"&gt;)
    . $q-&gt;hidden( "node_id", getId($NODE) ) . "\n"
    . $q-&gt;hidden( "lastnode_id" ) . "\n"
    . $q-&gt;textfield( -name=&gt;"user", -size=&gt;20, -maxlength=&gt;254, -tabindex=&gt;100 ) . "&lt;br /&gt;\n"
    . $q-&gt;password_field( -name=&gt;"passwd", -size=&gt;10, -maxlength=&gt;8, -tabindex=&gt;101 ) . "&lt;br /&gt;\n"
    . $q-&gt;checkbox( -name=&gt;"expires", -checked=&gt;"", -value=&gt;"+10y",
        -label=&gt;"save me a permanent cookie, cowboy!", -tabindex=&gt;102 ) . "&lt;br /&gt;\n";
  $html .= $q-&gt;checkbox( -name=&gt;"ticker", -checked=&gt;"", -value=&gt;"yes",
        -label=&gt;"pretend I'm not here", -tabindex=&gt;104 ) . "&lt;br /&gt;\n"
    if  $q-&gt;param("ticker");
  $html .= $q-&gt;submit( -name=&gt;"sexisgood", -value=&gt;"submit", -tabindex=&gt;103 ) . "\n"
    . $q-&gt;end_form();
  $html .= qq(
    &lt;p&gt;
      Can't remember your username or password?
      [id://2513|Request a reminder].
    &lt;/p&gt;
    &lt;p&gt;
      Haven't got an account yet?
      [Create A New User]!
    &lt;/p&gt;);
  return $html;
%]
</patch_code>
<applied>2009-07-24 14:30:45</applied>
<htmlcode_id>109</htmlcode_id>
<live_code>&lt;p align=right&gt;
&lt;a href="/?node_id=156909"&gt;Help for this page&lt;/a&gt;
&lt;/p&gt;
[{get_sitedoclet}]
[%
  my $html= "";

  my $user_id = getId($USER);
  if(  'login' ne ($q-&gt;param('op'))[0]  ) {
    $html .= "Hey, " . linkNode($USER) . "...  this is where you log in:";
  } elsif(  $user_id != $HTMLVARS{guest_user}  ) {
    my $lastnode_id = $q-&gt;param("lastnode_id") || 0;
    my $rat           = 397425; # Recently Active Threads
    my $other_default = 3628;   # Newest Nodes
    my %id_link = (
      $user_id =&gt; "to your " . linkNode($USER, "home node"),
      $HTMLVARS{default_node} =&gt; "to " . linkNode($HTMLVARS{default_node}),
      $rat           =&gt; 'to ' . linkNode($rat),
      $other_default =&gt; "to " . linkNode($other_default),
    );
    my @a = map {
      $lastnode_id != $_ ? $id_link{$_} : ()
    } $user_id, $HTMLVARS{default_node}, $other_default, $rat;
    $id_link{$lastnode_id} ||= 'to ' . linkNode($lastnode_id)
       if $lastnode_id;
    $a[-1] = "or ".$a[-1];
    local $" = @a &gt; 2 ? ", " : " ";
    $html .= "Hey.  Glad you're back.  Would you like to go @a?&lt;br /&gt;";
    $html .= "...or back $id_link{$lastnode_id}?&lt;br /&gt;" if $lastnode_id;
    $html .= "Or perhaps you want to [SoPW|ask a Perl question]?&lt;br /&gt;";
    return $html;
  } else {
    $html .= "Oops.  You must have the wrong login or password or something:";
  }

  $html .= "\n&lt;p&gt;\n";

  # users may set tabindices under 100 by client-side or free nodelet scripts
  # this is not a pm-wide convention yet but let's start it now
  $html .= htmlcode('openform')
    . qq(&lt;input type="hidden" name="op" value="login"&gt;)
    . $q-&gt;hidden( "node_id", getId($NODE) ) . "\n"
    . $q-&gt;hidden( "lastnode_id" ) . "\n"
    . $q-&gt;textfield( -name=&gt;"user", -size=&gt;20, -maxlength=&gt;254, -tabindex=&gt;100 ) . "&lt;br /&gt;\n"
    . $q-&gt;password_field( -name=&gt;"passwd", -size=&gt;10, -maxlength=&gt;8, -tabindex=&gt;101 ) . "&lt;br /&gt;\n"
    . $q-&gt;checkbox( -name=&gt;"expires", -checked=&gt;"", -value=&gt;"+10y",
        -label=&gt;"save me a permanent cookie, cowboy!", -tabindex=&gt;102 ) . "&lt;br /&gt;\n";
  $html .= $q-&gt;checkbox( -name=&gt;"ticker", -checked=&gt;"", -value=&gt;"yes",
        -label=&gt;"pretend I'm not here", -tabindex=&gt;104 ) . "&lt;br /&gt;\n"
    if  $q-&gt;param("ticker");
  $html .= $q-&gt;submit( -name=&gt;"sexisgood", -value=&gt;"submit", -tabindex=&gt;103 ) . "\n"
    . $q-&gt;end_form();
  $html .= qq(
    &lt;p&gt;
      Can't remember your username or password?
      [id://2513|Get it emailed to you].
    &lt;/p&gt;
    &lt;p&gt;
      Haven't got an account yet?
      [Create A New User]!
    &lt;/p&gt;);
  return $html;
%]
</live_code>
<reason>wording, linkage edits</reason>
<field>doctext</field>
</record>
<record><htmlcode_id>784284</htmlcode_id>
<patch_code>&lt;center&gt;&lt;b&gt;[Offering Plate|Donations gladly accepted]&lt;/b&gt;&lt;/center&gt;
[{get_sitedoclet}]
&lt;!--
&lt;table width="100%" cellpadding="0" cellspacing="0" align="left"&gt;
  &lt;tr align="left"&gt;
    &lt;td valign="top"&gt;
--&gt;
    [{votehead}]
    [%
        #$VARS-&gt;{frontpagehits}++
        #      if getId($USER)==$HTMLVARS{guest_user};

        my $sopwnum  =$VARS-&gt;{fp_max_sopw}  || 12;
        my $mednum   =$VARS-&gt;{fp_max_med}   || 4;
        my $craftnum =$VARS-&gt;{fp_max_craft} || 2;
        my $cufpnum  =$VARS-&gt;{fp_max_cufp}  || 2;
        my $poemnum  =$VARS-&gt;{fp_max_poem}  || 2;
        my $obfunum  =$VARS-&gt;{fp_max_obfu}  || 2;
        my $discnum  =$VARS-&gt;{fp_max_disc}  || 3;

        $HTMLVARS{data_displaytype}="";

        my (@stuff);

        my $render = $ENV{HTTP_HOST} =~ /^css/
            ? 'simple_cachedlistapproved'
            : 'cachedlistapproved';

        # see htmlcode('simple_cachedlistapproved')
        # and htmlcode('cachedlistapproved')
        # for details of their arguments and returns.

        push @stuff,
                "&lt;center&gt;If you're new here please read ",
                linkNodeTitle("PerlMonks FAQ"),
                "&lt;br /&gt; and ",
                linkNodeTitle( "Create a new user" ),
                ".&lt;/center&gt;&lt;br /&gt;"
            if(getId($USER) == $HTMLVARS{guest_user});

        push @stuff,'&lt;p align="left"&gt;'.htmlcode("questinfo")."&lt;/p&gt;";

        push @stuff, htmlcode(
                $render,'',"perlquestion","frontpage linktype",
                "New Questions",$sopwnum,0,0,"Seekers+of+Perl+Wisdom")
            unless ($VARS-&gt;{fp_sopw_off} eq "on");

        push @stuff,htmlcode(
                $render,'',"perlmeditation","frontpage linktype",
                "New Meditations",$mednum,0,0,"Meditations")
            unless ($VARS-&gt;{fp_med_off} eq "on");

        push @stuff,htmlcode(
                $render,'',"CUFP","frontpage linktype",
                "New Cool Uses for Perl",$cufpnum,0,0,"Cool+Uses+For+Perl")
            unless ($VARS-&gt;{fp_cufp_off} eq "on");

        $HTMLVARS{data_displaytype}="code";
        push @stuff,htmlcode(
                $render,'',"perlcraft","frontpage linktype",
                "New Craft",$craftnum,0,0,"Craft")
            unless ($VARS-&gt;{fp_craft_off} eq "on");

        $HTMLVARS{data_displaytype}="";
        push @stuff,htmlcode(
                $render,'',"poem","frontpage linktype",
                "New Perl Poetry",$poemnum,0,0,"Perl+Poetry")
            unless ($VARS-&gt;{fp_poem_off} eq "on");

        push @stuff,htmlcode(
                $render,'',"obfuscated","frontpage linktype",
                "New Obfuscated Code",$obfunum,0,0,"Obfuscated+Code")
            unless ($VARS-&gt;{fp_obfu_off} eq "on");

        push @stuff,htmlcode(
                $render,'',"monkdiscuss","frontpage linktype",
                "New Monk Discussion",$discnum,0,0,"Perl+Monks+Discussion")
            unless ($VARS-&gt;{fp_disc_off} eq "on");

        push @stuff,htmlcode('votefoot');
        return join "",@stuff;
    %]
&lt;!--
    &lt;/td&gt;
    &lt;/tr&gt;
&lt;/table&gt;
--&gt;
</patch_code>
<applied>2009-07-29 12:07:25</applied>
<htmlcode_id>131</htmlcode_id>
<live_code>[{get_sitedoclet}]
[{votehead}]
[%
  #$VARS-&gt;{frontpagehits}++
  #      if getId($USER)==$HTMLVARS{guest_user};

  my $sopwnum  =$VARS-&gt;{fp_max_sopw}  || 12;
  my $mednum   =$VARS-&gt;{fp_max_med}   || 4;
  my $cufpnum  =$VARS-&gt;{fp_max_cufp}  || 2;
  my $poemnum  =$VARS-&gt;{fp_max_poem}  || 2;
  my $obfunum  =$VARS-&gt;{fp_max_obfu}  || 2;
  my $discnum  =$VARS-&gt;{fp_max_disc}  || 3;

  $HTMLVARS{data_displaytype}="";

  my (@stuff);

  my $render = $ENV{HTTP_HOST} =~ /^css/
    ? 'simple_cachedlistapproved'
    : 'cachedlistapproved';

  # see htmlcode('simple_cachedlistapproved')
  # and htmlcode('cachedlistapproved')
  # for details of their arguments and returns.

  push @stuff,
      "&lt;center&gt;If you're new here please read ",
      linkNodeTitle("PerlMonks FAQ"),
      "&lt;br /&gt; and ",
      linkNodeTitle( "Create a new user" ),
      ".&lt;/center&gt;&lt;br /&gt;"
    if(getId($USER) == $HTMLVARS{guest_user});

  push @stuff,'&lt;p align="left"&gt;'.htmlcode("questinfo")."&lt;/p&gt;";

  push @stuff, htmlcode(
      $render,'',"perlquestion","frontpage linktype",
      "New Questions",$sopwnum,0,0,"Seekers+of+Perl+Wisdom")
    unless ($VARS-&gt;{fp_sopw_off} eq "on");

  push @stuff,htmlcode(
      $render,'',"perlmeditation","frontpage linktype",
      "New Meditations",$mednum,0,0,"Meditations")
    unless ($VARS-&gt;{fp_med_off} eq "on");

  push @stuff,htmlcode(
      $render,'',"CUFP","frontpage linktype",
      "New Cool Uses for Perl",$cufpnum,0,0,"Cool+Uses+For+Perl")
    unless ($VARS-&gt;{fp_cufp_off} eq "on");

  push @stuff,htmlcode(
      $render,'',"poem","frontpage linktype",
      "New Perl Poetry",$poemnum,0,0,"Perl+Poetry")
    unless ($VARS-&gt;{fp_poem_off} eq "on");

  push @stuff,htmlcode(
      $render,'',"obfuscated","frontpage linktype",
      "New Obfuscated Code",$obfunum,0,0,"Obfuscated+Code")
    unless ($VARS-&gt;{fp_obfu_off} eq "on");

  push @stuff,htmlcode(
      $render,'',"monkdiscuss","frontpage linktype",
      "New Monk Discussion",$discnum,0,0,"Perl+Monks+Discussion")
    unless ($VARS-&gt;{fp_disc_off} eq "on");

  push @stuff,htmlcode('votefoot');
  return join "",@stuff;
%]
</live_code>
<reason>add sitedoclet</reason>
<field>doctext</field>
</record>
<record><htmlcode_id>637851</htmlcode_id>
<patch_code>[{rssLink:perlquestion}]
[{get_sitedoclet}]
[{votehead}]
[{newlistapproved:perlquestion,perlquestion approved linktype,User Questions,10,navbaron,showunapproved}]
[{votefoot}]
[{newmoderatelist:perlquestion,perlquestion approved linktype,Unapproved Questions,showunapproved}]
[{addnewform:perlquestion,Add your question,Your question:}]
[{showhints}]
</patch_code>
<applied>2007-09-09 07:01:54</applied>
<htmlcode_id>479</htmlcode_id>
<live_code>[{get_sitedoclet}]
[{votehead}]
[{newlistapproved:perlquestion,perlquestion approved linktype,User Questions,10,navbaron,showunapproved}]
[{votefoot}]
[{newmoderatelist:perlquestion,perlquestion approved linktype,Unapproved Questions,showunapproved}]
[{addnewform:perlquestion,Add your question,Your question:}]
</live_code>
<reason>RSS for sections: Add RSS link</reason>
<field>doctext</field>
</record>
<record><htmlcode_id>760958</htmlcode_id>
<patch_code>[{get_sitedoclet}]
[{votehead}]
[{newlistapproved:perlmeditation,perlmeditation approved linktype,User Meditations,15,navbaron,showunapproved}]
[{votefoot}]
[{newmoderatelist:perlmeditation,perlmeditation approved linktype,Unapproved Meditations}]
[{addnewform:perlmeditation,Add your Meditation,Meditation}]
[{showhints}]
</patch_code>
<applied>2009-04-29 15:05:34</applied>
<htmlcode_id>480</htmlcode_id>
<live_code>[{get_sitedoclet}]
[{votehead}]
[{newlistapproved:perlmeditation,perlmeditation approved linktype,User Meditations,15,navbaron,showunapproved}]
[{votefoot}]
[{newmoderatelist:perlmeditation,perlmeditation approved linktype,Unapproved Meditations}]
[{addnewform:perlmeditation,Add your Meditation,Meditation}]
</live_code>
<reason>RSS links are now centralized</reason>
<field>doctext</field>
</record>
<record><htmlcode_id>664690</htmlcode_id>
<patch_code>[% 
   $HTMLVARS{data_displaytype}="code";
   return;
%]
&lt;h4&gt;This section is obsolete. To post new code, see [id://237057]&lt;/h4&gt;
[{newlistapproved:perlcraft,perlcraft approved linktype,User craft,10,navbaron,showunapproved}]


</patch_code>
<applied>2008-01-28 13:06:08</applied>
<htmlcode_id>481</htmlcode_id>
<live_code>[% 
   $HTMLVARS{data_displaytype}="code";
   return;
%]
&lt;p&gt;This section is obsolete. To post new code, please use [Cool Uses For Perl].&lt;/p&gt;
[{newlistapproved:perlcraft,perlcraft approved linktype,User craft,10,navbaron,showunapproved}]


</live_code>
<reason>Deprecate "Craft" even further</reason>
<field>doctext</field>
</record>
<record><htmlcode_id>680618</htmlcode_id>
<patch_code>[%
  my $node=getNodeById(510154);
  return unless canUpdateNode($USER,$node);
  if ( grep { $_ eq "normal_user_view" } $q-&gt;param ) {
     if ( $q-&gt;param("normal_user_view") ) {
        $VARS-&gt;{"tutorials_normal_view"}=1;
     } else {
        delete $VARS-&gt;{"tutorials_normal_view"}
     }
  } elsif ( $VARS-&gt;{"tutorials_normal_view"} ) {
     $q-&gt;param("normal_user_view",1);
  }
  qq[&lt;p align="right"&gt;&lt;small&gt;&lt;b&gt;]
  .linkNode(
          $node,
          'Edit',
          { displaytype =&gt; 'edit' }
   )
  ."&lt;br /&gt; "
  .($q-&gt;param('normal_user_view') ?
    linkNode(
          $NODE,
          'Pedagogues View',
          { normal_user_view =&gt; '0' }
   ):linkNode(
          $NODE,
          'Normal View',
          { normal_user_view =&gt; '1' }
   ))
  .qq[&lt;/b&gt;&lt;/small&gt;&lt;p&gt;];
%]
[%
my $str= htmlcode('nodesWithinDays',"perltutorial,30");
return $str 
       ? "&lt;H3&gt;Tutorials written within the last month&lt;/H3&gt;$str" 
       : "";
%]
[{render_doclist_group:510154,showtext,1}]
[{get_sitedoclet}]
[%
# if( getId($USER) != $HTMLVARS{guest_user} ) # original test
if( canCreateNode($USER, getType('perltutorial')) )
{
    htmlcode('addnewform', 'perltutorial', 'Add a tutorial');
}
%]
[{showhints}]
</patch_code>
<applied>2008-04-15 14:33:23</applied>
<htmlcode_id>954</htmlcode_id>
<live_code>[%
  my $node=getNodeById(510154);
  return unless canUpdateNode($USER,$node);
  if ( grep { $_ eq "normal_user_view" } $q-&gt;param ) {
     if ( $q-&gt;param("normal_user_view") ) {
        $VARS-&gt;{"tutorials_normal_view"}=1;
     } else {
        delete $VARS-&gt;{"tutorials_normal_view"}
     }
  } elsif ( $VARS-&gt;{"tutorials_normal_view"} ) {
     $q-&gt;param("normal_user_view",1);
  }
  qq[&lt;p align="right"&gt;&lt;small&gt;&lt;b&gt;]
  .linkNode(
          $node,
          'Edit',
          { displaytype =&gt; 'edit' }
   )
  ."&lt;br /&gt; "
  .($q-&gt;param('normal_user_view') ?
    linkNode(
          $NODE,
          'Pedagogues View',
          { normal_user_view =&gt; '0' }
   ):linkNode(
          $NODE,
          'Normal View',
          { normal_user_view =&gt; '1' }
   ))
  .qq[&lt;/b&gt;&lt;/small&gt;&lt;p&gt;];
%]
[{get_sitedoclet}]
[{nodesWithinDays:perltutorial,30,0,0,Tutorials written within the last month}]
[{render_doclist_group:510154,showtext,1}]
[{addnewform:perltutorial,Add a tutorial}]
</live_code>
<reason>Clean up names to make them case sensitive</reason>
<field>doctext</field>
</record>
<record><htmlcode_id>367688</htmlcode_id>
<patch_code>&lt;p&gt;
Welcome to the Perl Monastery.  We hope your stay is long 
and enjoyable.  You are probably wondering what PerlMonks 
is all about. Hopefully this page will answer some of those 
questions.
&lt;/p&gt;&lt;p&gt;
&lt;b&gt;What Perl Monks is:&lt;/b&gt;&lt;br /&gt;
&lt;li&gt;Our attempt to make learning Perl as nonintimidating 
and easy to use as possible
&lt;li&gt;A place for you and others to polish, improve, and 
showcase your Perl skills
&lt;li&gt;A community which allows everyone to grow and learn 
from each other.
&lt;/p&gt;
&lt;p&gt;&lt;B&gt;Areas within the monastery:&lt;/B&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;p&gt;&lt;li&gt;[Seekers of Perl Wisdom]-The place you can go when 
you have got a question on how to do something or are 
unsure why something just isn't working.  Then other monks 
can offer you their wisdom and suggestions.  
&lt;/p&gt;
&lt;p&gt;&lt;li&gt;[Meditations]-Have you found out something amazing 
about Perl that you just need to share with everyone.  
Have you had a Perl epiphany, or found something in Perl 
that just blows your mind.  This is the place for 
those neat little tricks and amazing discoveries.  
&lt;/p&gt;
&lt;p&gt;&lt;li&gt;[Craft]-Want to showcase your code here's the 
place.  Want an audience to ooh and aah over your code.  
If its cool enough, and we deem it worthy, it just might 
end up on the frontpage.  Then you can gain the 
fame or notoriety you deserve.  Craft are also 
automatically displayed as code so you don't have to worry 
about pesky html to make it look nice just cut and paste it 
in.
&lt;/p&gt;
&lt;p&gt;&lt;li&gt;[Code Catacombs]-The place to put your full blown 
programs and scripts that others might find useful.  
&lt;/p&gt;
&lt;p&gt;&lt;li&gt;[Perl Poetry]-The name pretty much says it all 
&lt;/p&gt;
&lt;p&gt;&lt;li&gt;[Obfuscated Code]-Got code that it would take a Perl 
grand master to understand?  Put it here so we can stare at 
it in awe after we've run it and found out what it does.  
&lt;/p&gt;
&lt;p&gt;&lt;li&gt;[Tutorials]-Just what you would imagine.  This will 
hopefully amount to an ever-growing online textbook.  
Which will allow you to start learning the basics of perl, 
or begin to learn some new groovy stuff that you 
haven't tried before.  If you've got an idea for a 
tutorial, or would like to write one yourself let us know.  
In the future we might like to add some exercises for you 
to test your understanding.  We'll also offer links to 
answers.
&lt;/p&gt;
&lt;p&gt;&lt;li&gt;[Cool Uses For Perl]-Have you automated a part of 
your life that wouldn't have been possible without the 
power of Perl.  Are you using Perl to do something unique 
and humorous that you're convinced no one else has 
thought of.  Tell us about it and if you want throw in the 
code as a piece of Craft. 
&lt;/p&gt;
&lt;p&gt;&lt;li&gt;[Library]-This is the place to find all of the Perl 
documentation you need.  Right now we've got the basic 
man pages in for core language.  This will grow in the 
future to include documentation for often used modules as 
well. 
&lt;/p&gt;
&lt;p&gt;&lt;li&gt;[perlman:perlfaq|Perl FAQ]-These are often asked 
questions about Perl issues.  A lot of times the answers 
to your questions can be found here.  
&lt;/p&gt;
&lt;/ul&gt;
&lt;p&gt;
Wondering about some of the procedures you should be 
knowledgeable in as a Perl Monk(linking etc.) check 
[Perl Monk procedures|PerlMonk procedures]
&lt;/p&gt;</patch_code>
<applied>2004-06-17 13:20:28</applied>
<htmlcode_id>972</htmlcode_id>
<live_code>&lt;!--
2004-09-23 [jdporter] Removed Craft and the FAQ thing at the end. Added PMD, Snippets, Q&amp;A, News, Reviews, NN, Offering Plate. Rearranged to the same order as in the "menu bar".  However, even though the order is the now the same as on the menu bar, the titles are drawn directly from the nodes.  The most egregious case is "Q&amp;A".  Can we rely on the novice to connect the name of the section listed here with the link in the menu bar?
2005-03-14 [ysth] added recently active threads; reordered the comment listing the sections to how the menu bar is now
2006-06-13 [jdporter] re-workd to follow the organization used in the three nodelets, with some minor adjustments.
--&gt;

&lt;h1&gt;The Perl Monks Guide to the Monastery&lt;/h1&gt;

&lt;p&gt;
Welcome to PerlMonks, the Monastery of Perl.
We hope your stay is long and enjoyable.
You are probably wondering what this is all about.
Hopefully this page will answer some of those questions.
&lt;/p&gt;

&lt;!-- &lt;p&gt;&lt;i&gt;What is this all about, exactly?&lt;/i&gt;&lt;/p&gt; --&gt;

&lt;p&gt;
PerlMonks is many things to many people, including:
&lt;ul&gt;
&lt;li&gt;A medium for making Perl as non-intimidating to learn and as easy to use as possible&lt;/li&gt;
&lt;li&gt;A place for Perl programmers (such as you) to improve your skills and share your expertise&lt;/li&gt;
&lt;li&gt;A community which allows everyone to grow and learn from everyone else&lt;/li&gt;
&lt;/ul&gt;
&lt;/p&gt;


&lt;!-- According to the "menu bar":

 131	The Monastery Gates
 3989	Super Search

 479	Seekers of Perl Wisdom
 480	Meditations
 1040	Perl Monks Discussion			PerlMonks Discussion
 1967	Snippets Section			Snippets

 1597	Obfuscated code				Obfuscation
 21144	Reviews
 1044	Cool Uses For Perl
 23771	Perl News
 1843	Categorized Questions and Answers	Q&amp;A
 954	Tutorials

 1747	Code Catacombs				Code
 1590	Perl Poetry				Poetry
 397425 Recently Active Threads
 3628	Newest Nodes
 71130	Offering Plate

--&gt;

&lt;h3&gt;Finding Your Way Around&lt;/h3&gt;

&lt;p&gt;
First, the Monastery has some repositories of information useful to the
Perl Monk, designed to help you get the most out of your experience here.
Second, we have a number of areas, called &lt;i&gt;sections&lt;/i&gt;, where people can
post code, questions, and responses (known generically as "nodes") in a
threaded forum-like format.
As an adjunct to those sections, there are various views into the great
node repository which assist you in finding nodes of interest to you
&amp;mdash; recently posted nodes, say, or meditations posted by a certain monk.
Finally, we have an assortment of pages not easily classifiable elsewhere.
&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt; &lt;a href="#info"&gt; &lt;b&gt;Information&lt;/b&gt; &lt;/a&gt;&lt;/li&gt;
&lt;li&gt; &lt;a href="#sections"&gt; &lt;b&gt;Sections&lt;/b&gt; &lt;/a&gt;&lt;/li&gt;
&lt;li&gt; &lt;a href="#find"&gt; &lt;b&gt;Find Interesting Nodes&lt;/b&gt; &lt;/a&gt;&lt;/li&gt;
&lt;li&gt; &lt;a href="#misc"&gt; &lt;b&gt;Additional Miscellany&lt;/b&gt; &lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;
This is just an overview. Exhaustive documentation on every aspect
of the PerlMonks web site can be found in the [PerlMonks FAQ].
&lt;/p&gt;
&lt;hr/&gt;

&lt;a name="info"&gt;&lt;/a&gt;
&lt;h4&gt;Information&lt;/h4&gt;
[pmdev://1053|(based on the Information nodelet)|]
&lt;blockquote&gt;

    &lt;p&gt;
    &lt;b&gt;The [PerlMonks FAQ]&lt;/b&gt; -
    Your one-stop shop for Nearly Everything You Ever
    Wanted To Know About PerlMonks.
    Maintained by the [SiteDocClan].
    &lt;/p&gt;

    &lt;p&gt;
    &lt;b&gt;[id://545862]&lt;/b&gt; -
    What's New at PerlMonks.
    &lt;/p&gt;

    &lt;p&gt;
    &lt;b&gt;[id://5938]&lt;/b&gt; -
    Many newcomers are confused by this aspect of
    PerlMonks. This should clear things up.
    &lt;/p&gt;

    &lt;p&gt;
    &lt;b&gt;[id://382|Perl FAQ]&lt;/b&gt; and &lt;b&gt;[id://148]&lt;/b&gt; -
    Our local copy of the standard Perl documentation set,
    for your convenience. Note, however, that the content is
    not being maintained and is now a couple versions old.
    &lt;/p&gt;

    &lt;p&gt;
    &lt;b&gt;[id://483101]&lt;/b&gt; -
    &lt;!-- replaces the obsolete [Outside Links]. --&gt;
    Various other sites which Perl Monks might find useful.&lt;br/&gt;
    See especially [id://579676].
    &lt;/p&gt;

&lt;/blockquote&gt;

&lt;a name="sections"&gt;&lt;/a&gt;
&lt;h4&gt;Sections&lt;/h4&gt;
[pmdev://1052|(based on the Sections nodelet)|]
&lt;blockquote&gt;

    &lt;p&gt;
    &lt;b&gt;[id://479]&lt;/b&gt; -
    The place you can go when you have got a question on how to
    do something or are unsure why something just isn't working.
    Then other Perl Monks can offer you their wisdom and suggestions.  
    &lt;/p&gt;

    &lt;p&gt;
    &lt;b&gt;[id://480]&lt;/b&gt; -
    Have you found out something amazing about Perl which you
    just need to share with everyone? 
    Have you had a Perl epiphany, or found something in Perl 
    which just blows your mind?
    This is the place for those neat little tricks and amazing
    discoveries.  
    &lt;/p&gt;

    &lt;p&gt;
    &lt;b&gt;[id://1040|PerlMonks Discussion]&lt;/b&gt; - 
    For discussions relating specifically to this web site, and
    how things work around here.  For example, if you think the
    Monastery could be improved in some particular way, raise
    it for discussion here.
    &lt;/p&gt;

    &lt;p&gt;
    &lt;b&gt;[id://1843]&lt;/b&gt; - 
    Our own ever-growing compendium of "frequently asked" 
    Perl-related questions and their answers.
    If you're faced with a problem and you think it might be common
    enough that others have already solved it, then
    check here before you go posting to [id://479].
    &lt;/p&gt;

    &lt;p&gt;
    &lt;b&gt;[id://954]&lt;/b&gt; - An ever-growing online textbook from which
    you can learn the basics of Perl or some nifty stuff
    you haven't tried before.
    This area is managed by the [Pedagogues].
    &lt;/p&gt;

    &lt;p&gt;
    &lt;b&gt;[id://1597]&lt;/b&gt; - Got code which would take a Perl 
    grand master to understand?
    Post it here so we can stare at it in awe.
    &lt;/p&gt;

    &lt;p&gt;
    &lt;b&gt;[id://1590]&lt;/b&gt; - The name pretty much says it all.
    &lt;/p&gt;

    &lt;p&gt;
    &lt;b&gt;[id://1044]&lt;/b&gt; - This is the place to share or show off
    your work of Perl prose. Posts can be of any size &amp;mdash;
    from the brilliant one-liner to the work-horse module to the
    full-blown application program. 
    &lt;/p&gt;

    &lt;p&gt;
    &lt;b&gt;[id://21144]&lt;/b&gt; -
    If you are shopping around for the Perl module
    or book which is just right for your needs,
    read these reviews &amp;mdash; written by your fellow
    Perl Monks &amp;mdash; to help you make an informed decision.
    &lt;br/&gt;
    Conversely, if you have used a module or read a book,
    and you think other Perl Monks might benefit from your
    experiences, please share them here by writing a review!
    &lt;/p&gt;

    &lt;p&gt;
    &lt;b&gt;[id://23771]&lt;/b&gt; - 
    Timely news and announcements for, and from, the Perl Monks, and from the wider Perl community.
    &lt;/p&gt;

&lt;/blockquote&gt;

&lt;a name="find"&gt;&lt;/a&gt;
&lt;h4&gt;Find Interesting Nodes&lt;/h4&gt;
[pmdev://1054|(based on the Find Nodes nodelet)|]
&lt;blockquote&gt;

    &lt;p&gt;
    &lt;b&gt;[The Monastery Gates]&lt;/b&gt; -
    The "default" page of the web site, it shows recent nodes
    from all sections which have been deemed most worthy of
    public exposure &amp;mdash; the "face" of PerlMonks.
    &lt;/p&gt;

    &lt;p&gt;
    &lt;b&gt;[id://3989]&lt;/b&gt; -
    Full-text and title searches, with additional filtering
    by section, age, author, and many other criteria.
    &lt;/p&gt;

    &lt;!--&lt;p&gt;[Perl Monks User Search|List Nodes By Users]&lt;/p&gt;--&gt;

    &lt;p&gt;
    &lt;b&gt;[id://3628]&lt;/b&gt; -
    An up-to-the minute listing of all the nodes which
    were created since "the last time you checked".
    &lt;/p&gt;

    &lt;p&gt;
    &lt;b&gt;[id://16902]&lt;/b&gt; -
    Similar to [id://3628], a listing of the user homenodes which
    have been modified since "the last time you checked".
    (Note that only changes designated by their authors as
    "significant" will register in this list.)
    &lt;/p&gt;

    &lt;p&gt;
    &lt;b&gt;[id://397425]&lt;/b&gt; -
    A threaded view of the Monastery's active content.
    It's like [Newest Nodes] on steroids.
    &lt;/p&gt;

    &lt;p&gt;
    &lt;b&gt;[id://328478]&lt;/b&gt; -
    A random selection of 50 of the top 2000 nodes of all time,
    as ranked by node [id://18538|reputation]. 
    The selection is re-sampled daily.
    &lt;/p&gt;

    &lt;p&gt;
    &lt;b&gt;[id://9066]&lt;/b&gt; -
    The top 10 nodes of the Day, the Week, and the
    Month, and the top 20 nodes of the Year.
    &lt;/p&gt;

    &lt;p&gt;
    &lt;b&gt;[id://9488]&lt;/b&gt; -
    The bottom 10 nodes of the Day, the Week, and the
    Month, and the bottom 20 nodes of the Year.
    &lt;/p&gt;

    &lt;p&gt;
    &lt;b&gt;[id://3559]&lt;/b&gt; -
    "Saints" here is more figurative, or honorary;
    this is a list of Monks who have at least 3000 
    [id://5938|experience points], which technically
    makes them [id://504005], not [id://244022].
    &lt;/p&gt;

&lt;/blockquote&gt;

&lt;a name="misc"&gt;&lt;/a&gt;
&lt;h4&gt;Additional Miscellany&lt;/h4&gt;
[pmdev://1055|(based on the Leftovers nodelet)|]
&lt;blockquote&gt;

    &lt;p&gt;
    &lt;b&gt;[The St. Larry Wall Shrine]&lt;/b&gt; - 
    A neat compendium of articles by and about the creator of Perl.
    &lt;/p&gt;

    &lt;p&gt;
    &lt;b&gt;[id://71130]&lt;/b&gt; -
    If you find this place to be of value, you can show
    your appreciation by helping defray the costs of
    keeping the site up and running.
    &lt;/p&gt;

    &lt;p&gt;
    &lt;b&gt;[Awards]&lt;/b&gt; - 
    Accolades and other noteworthy public mentions of
    PerlMonks.
    &lt;/p&gt;

    &lt;p&gt;
    &lt;p&gt;
    &lt;b&gt;[id://29195]&lt;/b&gt; -
    Yes, you can actually buy Perl and PerlMonks-related gear...
    such as a t-shirt with the famous [id://45213] obfu on it!
    &lt;/p&gt;

    &lt;p&gt;
    &lt;b&gt;[id://1967|Snippets] (deprecated)&lt;/b&gt; - 
    This was a place to show off clever, useful, &lt;i&gt;short&lt;/i&gt; bits of code, such as one-liners.
    As such, it was redundant with [Cool Uses For Perl],
    but it still makes an interesting read.
    &lt;/p&gt;

    &lt;p&gt;
    &lt;b&gt;[id://1747] (deprecated)&lt;/b&gt; -
    This was intended as a place to post full-blown programs and modules.
    As such, it was redundant with [Cool Uses For Perl],
    but much interesting and useful code can still be found there.
    &lt;/p&gt;

    &lt;b&gt;[id://481|Craft] (deprecated)&lt;/b&gt; -
    This was a place for perlsmiths to showcase their code. 
    As such, it was redundant with [Cool Uses For Perl], 
    but it still makes an interesting read.
    &lt;/p&gt;

&lt;!-- someone should add notes to explain how these are used: --&gt;

    &lt;!-- &lt;p&gt;&lt;b&gt;[Quests]&lt;/b&gt;&lt;/p&gt; --&gt;

    &lt;!-- &lt;p&gt;&lt;b&gt;[Editor Requests]&lt;/b&gt;&lt;/p&gt; --&gt;

&lt;/blockquote&gt;

&lt;hr/&gt;
&lt;!-- end of new layout --&gt;

&lt;p&gt;
Please read the &lt;b&gt;[id://483077|Posting on PerlMonks]&lt;/b&gt;
section of the [PerlMonks FAQ] before posting.
You won't regret it!
&lt;/p&gt;

&lt;hr/&gt;&lt;i&gt;Back to the [PerlMonks FAQ]&lt;/i&gt;
</live_code>
<reason>synch target cause of type change blocking synch nodelet</reason>
<field>doctext</field>
</record>
<record><htmlcode_id>782533</htmlcode_id>
<patch_code>[{get_sitedoclet}]
[{votehead}]
[{newlistapproved:monkdiscuss,monkdiscuss approved linktype,User Discussion,15,navbaron,showunapproved}]
[{votefoot}]
[{newmoderatelist:monkdiscuss,monkdiscuss approved linktype,Unapproved Discussions}]
[{addnewform:monkdiscuss,Discussion Item,Give us your input}]
[{showhints}]
</patch_code>
<applied>2009-07-23 12:30:00</applied>
<htmlcode_id>1040</htmlcode_id>
<live_code>[{get_sitedoclet}]
[{votehead}]
[{newlistapproved:monkdiscuss,monkdiscuss approved linktype,PerlMonks Discussions,15,navbaron,showunapproved}]
[{votefoot}]
[{newmoderatelist:monkdiscuss,monkdiscuss approved linktype,Unapproved Discussions}]
[{addnewform:monkdiscuss,Discussion Item,Give us your input}]
</live_code>
<reason>the convention is to let [get_sitedoclet] figure out the sitedoclet name</reason>
<field>doctext</field>
</record>
<record><htmlcode_id>712732</htmlcode_id>
<patch_code>[{get_sitedoclet}]
[{votehead}]
[{newlistapproved:CUFP,CUFP Approved Linktype,CUFP's,15,navbaron,showunapproved}]
[{votefoot}]
[{newmoderatelist:CUFP,CUFP Approved Linktype,Unapproved CUFP}]
[{addnewform:CUFP,Add your CUFP,CUFP}]
[{showhints}]</patch_code>
<applied>2008-09-20 09:35:41</applied>
<htmlcode_id>1044</htmlcode_id>
<live_code>[{get_sitedoclet}]
[{votehead}]
[{newlistapproved:CUFP,CUFP Approved Linktype,CUFP's,15,navbaron,showunapproved}]
[{votefoot}]
[{newmoderatelist:CUFP,CUFP Approved Linktype,Unapproved CUFP}]
[{addnewform:CUFP,Add your CUFP,CUFP}]
</live_code>
<reason>Change case so a direct SQL match instead of a case insensitive match works</reason>
<field>doctext</field>
</record>
<record><htmlcode_id>487853</htmlcode_id>
<patch_code>[{get_sitedoclet}]
[{votehead}]
[{newlistapproved:poem,poem approved linktype,New Poems,10,navbaron,showunapproved}]
[{votefoot}]
[{newmoderatelist:poem,poem approved linktype,Unapproved Poems}]
[{addnewform:poem,Add your poem,Text}]
[{showhints}]</patch_code>
<applied>2005-08-30 13:28:25</applied>
<htmlcode_id>1590</htmlcode_id>
<live_code>[{get_sitedoclet}]
[{votehead}]
[{newlistapproved:poem,poem approved linktype,New Poems,10,navbaron,showunapproved}]
[{votefoot}]
[{newmoderatelist:poem,poem approved linktype,Unapproved Poems}]
[{addnewform:poem,Add your poem,Text}]
</live_code>
<reason>use sitedoclet for section text</reason>
<field>doctext</field>
</record>
<record><htmlcode_id>676726</htmlcode_id>
<patch_code>[{get_sitedoclet}]
[{votehead}]
[{newlistapproved:obfuscated,obfuscated approved linktype,New Less than Readable Code,10,navbaron,showunapproved}]
[{votefoot}]
[{newmoderatelist:obfuscated,obfuscated approved linktype,Unapproved obfuscation}]
[{addnewform:obfuscated,Set the new obfuscation standard,code@?#!}]
[{shownotes}]
[{showhints}]
</patch_code>
<applied>2008-03-27 14:48:16</applied>
<htmlcode_id>1597</htmlcode_id>
<live_code>[{get_sitedoclet}]
[{votehead}]
[{newlistapproved:obfuscated,obfuscated approved linktype,New Less than Readable Code,10,navbaron,showunapproved}]
[{votefoot}]
[{newmoderatelist:obfuscated,obfuscated approved linktype,Unapproved obfuscation}]
[{addnewform:obfuscated,Set the new obfuscation standard,code@?#!}]
</live_code>
<reason>showhints</reason>
<field>doctext</field>
</record>
<record><htmlcode_id>728082</htmlcode_id>
<patch_code>[{get_sitedoclet}]
[%
join "\n", '',
  htmlcode('openform'),
  $query-&gt;hidden("type", 'sourcecode'),
  'Title:&lt;br /&gt;',
  '&lt;input type="hidden" name="lastnode_id", value="'. getId($NODE) .'"&gt;',
  '&lt;input type="text" name="node" value=""&gt;&lt;br /&gt;&lt;br /&gt;',
  '&lt;input type="hidden" name="op" value="new"&gt;',
  'Category/Proposed Category:&lt;br /&gt;',
  '&lt;input type="text" name="sourcecode_codecategory" value=""&gt;&lt;br /&gt;&lt;br /&gt;',
  'Author/Contact Info:&lt;br /&gt;',
  '&lt;textarea name="sourcecode_codeauthor" rows=3 &gt;&lt;/textarea&gt;&lt;br /&gt;',
  'Description:&lt;br /&gt;',
  '&lt;textarea name="sourcecode_codedescription" rows=5 &gt;&lt;/textarea&gt;&lt;br /&gt;',
  'Code:&lt;br /&gt;',
  '&lt;textarea name="sourcecode_doctext" rows=30 &gt;&amp;lt;code&amp;gt;',
  '',
  '',
  '&amp;lt;/code&amp;gt;&lt;/textarea&gt;&lt;br /&gt;',
  $query-&gt;submit("create"),
  $query-&gt;endform
%]
[{showhints}]
</patch_code>
<applied>2008-12-04 15:34:44</applied>
<htmlcode_id>1758</htmlcode_id>
<live_code>[{get_sitedoclet}]</live_code>
<reason>don't coerce width of textareas (also: massive reformatting)</reason>
<field>doctext</field>
</record>
<record><htmlcode_id>782532</htmlcode_id>
<patch_code>[{get_sitedoclet}]
[{newlistapproved:snippet,perlquestion approved linktype,New Snippets,15,navbaron,showall}]
[{addnewsnippet}]
[{showhints}]</patch_code>
<applied>2009-07-23 12:30:03</applied>
<htmlcode_id>1967</htmlcode_id>
<live_code>[{get_sitedoclet}]
[{newlistapproved:snippet,perlquestion approved linktype,New Snippets,15,navbaron,showall}]
</live_code>
<reason>the convention is to let [get_sitedoclet] figure out the sitedoclet name</reason>
<field>doctext</field>
</record>
<record><htmlcode_id>696219</htmlcode_id>
<patch_code>[%
  return qq(&lt;div class="tough-beans"&gt;).(
    $HTMLVARS{reject_reason} ||
    qq[
        &lt;p&gt;You don't have access to that node.&lt;/p&gt;
        &lt;p&gt;Tough beans.&lt;/p&gt;
    ]
  ).qq(&lt;/div&gt;)
%]</patch_code>
<applied>2008-07-08 16:54:57</applied>
<htmlcode_id>2294</htmlcode_id>
<live_code>[%
  my $reason = $HTMLVARS{reject_reason} || '';
  if ( ! $reason ) {
    $reason .= 
      qq(&lt;p&gt;You don't have access to )
      . linkNode( $HTMLVARS{requested_node}{node_id} ) 
      . '.&lt;/p&gt;'
        if $HTMLVARS{requested_node}{node_id};
    $reason .= qq(&lt;p&gt;Tough beans.&lt;/p&gt;)
  }
  return qq(&lt;div class="tough-beans"&gt;$reason&lt;/div&gt;);
%]
[%
   my $title = $HTMLVARS{requested_node}{title}  # set in Ev/HTML.pm
      || 'Permission Denied';
   htmlcode('showsitedoclet','', $title )
%]</live_code>
<reason>add some style</reason>
<field>doctext</field>
</record>
<record><htmlcode_id>775729</htmlcode_id>
<patch_code>/* This CSS controls the Red theme. */

body {
  color: #000;
  background-color: #FFF;
}
td { color: #000; }
tr.titlebar { background-color: #B64234; }
tr.section_title {
  color:            #FFF;
  background-color: #B64234;
}
td.section_title {
  color:            #FFF;
  background-color: #B64234;
}

td.titlebar { color: #FFF; }
table.nodelet_container { background-color: #B64234; }
a:link    { color: #933  }
a:visited { color: #339 }

a.titlebar:link, a.titlebar:visited { color: #FFF; }

tbody.nodelet td, td.nodebody { background-color: #FFF; }
tbody.nodelet th, th.nodehead {
  color:             #FFF;
  background-color:  #B64234;
}

tr.post_head, tr.ntc-head, .highlight {
  background-color: #EDD;
}

tbody.nodelet th a:link, tbody.nodelet th a:visited { color: #FFF; }
.chatsubmit { background-color: #B64234; }
.comment-on { background-color: #B64234; }
</patch_code>
<applied>2009-06-29 12:40:08</applied>
<htmlcode_id>2877</htmlcode_id>
<live_code>/* This CSS controls the Red theme. */

body {
  color: #000;
  background-color: #FFF;
}
td { color: #000; }
tr.titlebar, h2.titlebar { background-color: #B64234; }
tr.section_title {
  color:            #FFF;
  background-color: #B64234;
}
td.section_title {
  color:            #FFF;
  background-color: #B64234;
}

td.titlebar { color: #FFF; }
table.nodelet_container { background-color: #B64234; }
a:link    { color: #933  }
a:visited { color: #339 }

a.titlebar:link, a.titlebar:visited { color: #FFF; }

tbody.nodelet td, td.nodebody { background-color: #FFF; }
tbody.nodelet th, th.nodehead {
  color:             #FFF;
  background-color:  #B64234;
}

tr.post_head, tr.ntc-head, .highlight {
  background-color: #EDD;
}

tbody.nodelet th a:link, tbody.nodelet th a:visited { color: #FFF; }
.chatsubmit { background-color: #B64234; }
.comment-on { background-color: #B64234; }
table#replies_table { background-color: #B64234; }
</live_code>
<reason>replace 'highlight' in ntc</reason>
<field>doctext</field>
</record>
<record><htmlcode_id>680957</htmlcode_id>
<patch_code>&lt;!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Frameset//EN"&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;title&gt;Perlmonks FullPage Chat&lt;/title&gt;
    [{htmlhead}]
  &lt;/head&gt;
  &lt;frameset class="fpc" rows="160,*"&gt;
    &lt;frame class="talk" src="[% urlGen({ node =&gt; 'ad_and_talk', displaytype =&gt; 'raw' }, -1) %]" marginwidth="0" marginheight="0" /&gt;
    &lt;frameset class="lower" cols="80%,20%"&gt;
      &lt;frameset class="left" rows="30%,70%"&gt;
        &lt;frame class="privatemessages" src="[% urlGen({ node =&gt; 'privatemessages', displaytype =&gt; 'raw', type =&gt; 'superdoc' }, -1) %]" /&gt;
        &lt;frame class="chatmessages" src="[% urlGen({ node =&gt; 'showchatmessages', displaytype =&gt; 'raw' }, -1) %]" /&gt;
      &lt;/frameset&gt;
      &lt;frame class="otherusers" src="[% urlGen({ node =&gt; 'showotherusers', displaytype =&gt; 'raw' }, -1) %]" /&gt;
    &lt;/frameset&gt;
  &lt;noframes&gt;
    &lt;p&gt;No Frames?  &lt;a href="[% urlGen({ node =&gt; 'showchatmessages', displaytype =&gt; 'raw' }, -1) %]"&gt;Chat Here&lt;/a&gt;&lt;/p&gt;
   &lt;/noframes&gt;
  &lt;/frameset&gt;
&lt;/html&gt;</patch_code>
<applied>2008-04-19 15:34:00</applied>
<htmlcode_id>3184</htmlcode_id>
<live_code>&lt;!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Frameset//EN"&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;title&gt;Perlmonks FullPage Chat&lt;/title&gt;
    [{htmlhead}]
  &lt;/head&gt;
  &lt;frameset class="fpc" rows="160,*"&gt;
    &lt;frame class="talk" src="[% urlGen({ node =&gt; 'ad_and_talk', displaytype =&gt; 'raw' }, -1) %]" marginwidth="0" marginheight="0" /&gt;
    &lt;frameset class="lower" cols="80%,20%"&gt;
      &lt;frameset class="left" rows="30%,70%"&gt;
        &lt;frame class="privatemessages" src="[% urlGen({ node =&gt; 'privatemessages', type =&gt; 'fullpage' }, -1) %]" /&gt;
        &lt;frame class="chatmessages" src="[% urlGen({ node =&gt; 'showchatmessages', displaytype =&gt; 'raw' }, -1) %]" /&gt;
      &lt;/frameset&gt;
      &lt;frame class="otherusers" src="[% urlGen({ node =&gt; 'showotherusers', displaytype =&gt; 'raw' }, -1) %]" /&gt;
    &lt;/frameset&gt;
  &lt;noframes&gt;
    &lt;p&gt;No Frames?  &lt;a href="[% urlGen({ node =&gt; 'showchatmessages', displaytype =&gt; 'raw' }, -1) %]"&gt;Chat Here&lt;/a&gt;&lt;/p&gt;
   &lt;/noframes&gt;
  &lt;/frameset&gt;
&lt;/html&gt;</live_code>
<reason>give frames IDs for styling</reason>
<field>doctext</field>
</record>
<record><htmlcode_id>669579</htmlcode_id>
<patch_code>[%
# Only parameter is parent.
# reply settings: replyTypes all get replied to by notes.
# others are parent type =&gt; reply type.
# preview settings: FIXME.

  my $pid = $query-&gt;param('parent');

  my $parent = getNodeById($pid)
    or return 'No such parent node';

  my $type = $parent-&gt;{type}{title};

  # disable anonymous replies
  # return qq[No anonymonk replies] if getId($USER) == $HTMLVARS{default_user};

  return qq[You can't reply to $type nodes]
    unless ( $DB-&gt;canReadNode($USER, $parent) );

  my $ps = getVars( getNode('preview settings','setting') );
  my $rs = getVars( getNode('reply settings', 'setting') );

  my %replytypes = map { $_ =&gt; "note" } 
      split( ",", $rs-&gt;{replyTypes} ); 

  foreach (grep {$_ ne "replyTypes"} keys %$rs) {
    $replytypes{$_} = $rs-&gt;{$_} ;
  }

  my $kidtype = $replytypes{$type};
  return qq[Can't reply to $type nodes]
    unless ( $kidtype );

  my $displaycode = $ps-&gt;{"displayHtmlcodeForType_$type"}
                 || $ps-&gt;{defaultDisplayHtmlcode};

  $HTMLVARS{embed_node}{doctext} = $parent-&gt;{doctext};

  return $q-&gt;div(
    { class =&gt; 'preview' },
    htmlcode($displaycode),
    $q-&gt;hr,
    $pid ? htmlcode('addnewnoteform', '', $kidtype, $pid) : (),
    $q-&gt;br,
    htmlcode('showhints')
  );
%]</patch_code>
<applied>2008-02-22 11:50:03</applied>
<htmlcode_id>3333</htmlcode_id>
<live_code>[%
# Only parameter is parent.
# reply settings: replyTypes all get replied to by notes.
# others are parent type =&gt; reply type.
# preview settings: FIXME.

  my $pid = $query-&gt;param('parent');

  my $parent = getNodeById($pid)
    or return 'No such parent node';

  my $type = $parent-&gt;{type}{title};

  # disable anonymous replies
  # return qq[No anonymonk replies] if getId($USER) == $HTMLVARS{default_user};

  return qq[&lt;p class="cant-reply"&gt;You can't reply to $type nodes, because you don't have permission to read them.&lt;/p&gt;]
    unless ( $DB-&gt;canReadNode($USER, $parent) );

  my $ps = getVars( getNode('preview settings','setting') );
  my $rs = getVars( getNode('reply settings', 'setting') );

  my %replytypes = map { $_ =&gt; "note" } 
      split( ",", $rs-&gt;{replyTypes} ); 

  foreach (grep {$_ ne "replyTypes"} keys %$rs) {
    $replytypes{$_} = $rs-&gt;{$_} ;
  }

  my $kidtype = $replytypes{$type};
  return qq[&lt;p class="cant-reply"&gt;Replying to $type nodes is not supported.&lt;/p&gt;]
    unless ( $kidtype );

  my $displaycode = $ps-&gt;{"displayHtmlcodeForType_$type"}
                 || $ps-&gt;{defaultDisplayHtmlcode};

  $HTMLVARS{embed_node}{doctext} = $parent-&gt;{doctext};

  return $q-&gt;div(
    { class =&gt; 'preview' },
    htmlcode($displaycode),
    $q-&gt;hr,
    $pid ? htmlcode('addnewnoteform', '', $kidtype, $pid) : (),
    $q-&gt;br,
    htmlcode('showhints')
  );
%]</live_code>
<reason>showhints</reason>
<field>doctext</field>
</record>
<record><htmlcode_id>743656</htmlcode_id>
<patch_code>&lt;p&gt;These are our most cherished users... quantitatively speaking;
work hard and you will receive the recognition you deserve.&lt;/p&gt;
&lt;p&gt;..and remember there are a lot of things monks are supposed
to be but lazy is &lt;I&gt;not&lt;/I&gt; one of them&lt;/p&gt;

&lt;table border="0" align="center"&gt;
&lt;tr&gt;&lt;th&gt;#&lt;/th&gt;&lt;th&gt;User&lt;/th&gt;&lt;th&gt;Experience&lt;/th&gt;&lt;th&gt;Level&lt;/th&gt;
&lt;th&gt;&lt;a href="?node_id=3557"&gt;Writeups&lt;/a&gt;&lt;/th&gt;&lt;th&gt;User Since&lt;/th&gt;&lt;th&gt;Last Here&lt;/th&gt;&lt;/tr&gt;
[%
  require Everything::Experience;
  my $csr = $Everything::dbh-&gt;prepare(
    "select node_id,title,experience,vars,createtime,lasttime
     from user left join node on node_id=user_id
     left join setting on setting_id=user_id
     where experience&gt;=3000 order by experience DESC"
  );

  return "Ack!  Something's broken..." unless($csr-&gt;execute);

  # Skip these users
  my %skip = ( "dbrown" =&gt; 1, "nate" =&gt; 1,
    "Webster 1913" =&gt; 1, "ShadowLost" =&gt; 1, "superuser"=&gt;1 );
  my $PMUS = 6364; # getNode("Perl Monks User Search","superdoc");

  my $html = "";
  my $index = 1;
  my $node;
  my $level_titles=getVars(getNode('level titles','setting'));
  my $level_experience=getVars(getNode('level experience','setting'));
  my $level=0;
  for my $l (keys %$level_experience) {
    $level=$l if $l&gt;$level;
  }
  # The default format makes the table too wide; override it temporarily
  { local $VARS-&gt;{timeformat} = '%Y-%m-%d';
    while(  $node = $csr-&gt;fetchrow_hashref()  ) {
      next   if  exists $skip{$node-&gt;{title}};
      while ($node-&gt;{experience}&lt;$level_experience-&gt;{$level}) {
        $level--;
      }
      my $vars = getVars($node);
      $html .= ( 1 &amp; $index ) ? qq[&lt;tr class="highlight"&gt;] : qq[&lt;tr&gt;];
      $html .= qq[&lt;td align="right"&gt;$index&lt;/td&gt;]
          . qq[&lt;td&gt;&lt;span class="user-$node-&gt;{node_id}"&gt;]
	  . linkNode($node)
	  . qq[&lt;/span&gt;&lt;/td&gt;]
          . qq[&lt;td align="right"&gt;$node-&gt;{experience}&lt;/td&gt;]
          . qq[&lt;td&gt;$level_titles-&gt;{$level} ($level)&lt;/td&gt;]
	  . qq[&lt;td align="right"&gt;]
	  . linkNode( $PMUS, $vars-&gt;{numwriteups}||"None", {
              usersearch =&gt; $node-&gt;{title},
	    } )
	  . qq[&lt;/td&gt;&lt;td align="right"&gt;]
	  . htmlcode('parseTimeInString', '', $node-&gt;{createtime}, '', '', 'short')
	  . qq[&lt;/td&gt;&lt;td align="right"&gt;]
	  . htmlcode('timesince', '', $node-&gt;{lasttime}, '')
	  . qq[&lt;/td&gt;&lt;/tr&gt;\n];

      $index++;
    }
  } # end local
  $html;
%]

[%
  return ""; # By number of writeups.  Turn off for now.
  my $type1 = getId(getType('writeup'));
  my $type2 = getId(getType('superdoc'));
  my $csr = $Everything::dbh-&gt;prepare("
    select DISTINCT author_user, count(author_user)
    from node
    where type_nodetype=$type1 OR type_nodetype=$type2
    group by author_user");
  $csr-&gt;execute;
  my %usrHash;
  my %hide;

  # Remove these users from the list
  $hide{getId(getNode("Webster 1913", "user"))} = 1;
  $hide{getId(getNode("ShadowLost", "user"))} = 1;

  while (my ($user, $count) = $csr-&gt;fetchrow) {
    # skip these users
    next if(exists $hide{$user});
    $usrHash{$user} = $count;
  }
  $csr-&gt;finish;
  delete $usrHash{''};
  my @author = sort {$usrHash{$b} &lt;=&gt; $usrHash{$a}} (keys (%usrHash));
  use Everything::Experience;
  my ($min, $max, $steps) = (160, 255, 50);

  my $count = 0;
  my $num;
  my $html = '';
  while ($count &lt; $steps) {
    unless($author[$count]) {
      $count++;
      next;
    }
    $num = sprintf "%lx", ($max-((($max-$min)*$count) / $steps));
    my $bg = $num . $num . 'CC';
    my ($u) = getNodeWhere({node_id=&gt;$author[$count]},getType('user'));
    $html .= qq[&lt;tr bgcolor="#$bg"&gt;]
      . qq[&lt;td&gt;&lt;span class="user-$author[$count]"&gt;]
      . linkNode( $author[$count], $$u{title} )
      . qq[&lt;/span&gt;&lt;/td&gt;]
      . qq[&lt;td align="center"&gt;$usrHash{$author[$count]} &lt;/td&gt;]
      . qq[&lt;td&gt;Level: ] . getLevel($u) . qq[&lt;/td&gt;&lt;/tr&gt;\n];
    $count++;
  }

  if (getId($USER) ne $HTMLVARS{guest_user} and
    $usrHash{getId($USER)}&lt;$usrHash{$author[$count-1]}) {

     $html.= "&lt;tr bgcolor=#FF6666&gt;&lt;td&gt;"
    .linkNode($USER)
    ."&lt;/td&gt;&lt;td align=center&gt;"
    .$usrHash{getId($USER)}
    ."&lt;/td&gt;&lt;td&gt;Level: "
    .getLevel($USER)."&lt;/td&gt;&lt;/tr&gt;"; # can`t accessrule
  }
  return $html;
%]
&lt;/table&gt;
</patch_code>
<applied>2009-02-13 13:51:23</applied>
<htmlcode_id>3559</htmlcode_id>
<live_code>[{get_sitedoclet}]

&lt;table border="0" align="center"&gt;
&lt;tr&gt;&lt;th&gt;#&lt;/th&gt;&lt;th&gt;User&lt;/th&gt;&lt;th&gt;Experience&lt;/th&gt;&lt;th&gt;Level&lt;/th&gt;
&lt;th&gt;&lt;a href="?node_id=3557"&gt;Writeups&lt;/a&gt;&lt;/th&gt;&lt;th&gt;User Since&lt;/th&gt;&lt;th&gt;Last Here&lt;/th&gt;&lt;/tr&gt;
[%
  require Everything::Experience;
  my $csr = $Everything::dbh-&gt;prepare(
    "select node_id,title,experience,vars,createtime,lasttime
     from user left join node on node_id=user_id
     left join setting on setting_id=user_id
     where experience&gt;=3000 order by experience DESC"
  );

  return "Ack!  Something's broken..." unless($csr-&gt;execute);

  # Skip these users
  my %skip = ( "dbrown" =&gt; 1, "nate" =&gt; 1,
    "Webster 1913" =&gt; 1, "ShadowLost" =&gt; 1, "superuser"=&gt;1 );
  my $PMUS = 6364; # getNode("Perl Monks User Search","superdoc");

  my $html = "";
  my $index = 1;
  my $node;
  my $level_titles=getVars(getNode('level titles','setting'));
  my $level_experience=getVars(getNode('level experience','setting'));
  my $level=0;
  for my $l (keys %$level_experience) {
    $level=$l if $l&gt;$level;
  }
  # The default format makes the table too wide; override it temporarily
  { local $VARS-&gt;{timeformat} = '%Y-%m-%d';
    while(  $node = $csr-&gt;fetchrow_hashref()  ) {
      next   if  exists $skip{$node-&gt;{title}};
      while ($node-&gt;{experience}&lt;$level_experience-&gt;{$level}) {
        $level--;
      }
      my $vars = getVars($node);
      $html .= ( 1 &amp; $index ) ? qq[&lt;tr class="highlight"&gt;] : qq[&lt;tr&gt;];
      $html .= qq[&lt;td align="right"&gt;$index&lt;/td&gt;]
          . qq[&lt;td&gt;&lt;span class="user-$node-&gt;{node_id}"&gt;]
	  . linkNode($node)
	  . qq[&lt;/span&gt;&lt;/td&gt;]
          . qq[&lt;td align="right"&gt;$node-&gt;{experience}&lt;/td&gt;]
          . qq[&lt;td&gt;$level_titles-&gt;{$level} ($level)&lt;/td&gt;]
	  . qq[&lt;td align="right"&gt;]
	  . linkNode( $PMUS, $vars-&gt;{numwriteups}||"None", {
              usersearch =&gt; $node-&gt;{title},
	    } )
	  . qq[&lt;/td&gt;&lt;td align="right"&gt;]
	  . htmlcode('parseTimeInString', '', $node-&gt;{createtime}, '', '', 'short')
	  . qq[&lt;/td&gt;&lt;td align="right"&gt;]
	  . htmlcode('timesince', '', $node-&gt;{lasttime}, '')
	  . qq[&lt;/td&gt;&lt;/tr&gt;\n];

      $index++;
    }
  } # end local
  $html;
%]

[%
  return ""; # By number of writeups.  Turn off for now.
  my $type1 = getId(getType('writeup'));
  my $type2 = getId(getType('superdoc'));
  my $csr = $Everything::dbh-&gt;prepare("
    select DISTINCT author_user, count(author_user)
    from node
    where type_nodetype=$type1 OR type_nodetype=$type2
    group by author_user");
  $csr-&gt;execute;
  my %usrHash;
  my %hide;

  # Remove these users from the list
  $hide{getId(getNode("Webster 1913", "user"))} = 1;
  $hide{getId(getNode("ShadowLost", "user"))} = 1;

  while (my ($user, $count) = $csr-&gt;fetchrow) {
    # skip these users
    next if(exists $hide{$user});
    $usrHash{$user} = $count;
  }
  $csr-&gt;finish;
  delete $usrHash{''};
  my @author = sort {$usrHash{$b} &lt;=&gt; $usrHash{$a}} (keys (%usrHash));
  use Everything::Experience;
  my ($min, $max, $steps) = (160, 255, 50);

  my $count = 0;
  my $num;
  my $html = '';
  while ($count &lt; $steps) {
    unless($author[$count]) {
      $count++;
      next;
    }
    $num = sprintf "%lx", ($max-((($max-$min)*$count) / $steps));
    my $bg = $num . $num . 'CC';
    my ($u) = getNodeWhere({node_id=&gt;$author[$count]},getType('user'));
    $html .= qq[&lt;tr bgcolor="#$bg"&gt;]
      . qq[&lt;td&gt;&lt;span class="user-$author[$count]"&gt;]
      . linkNode( $author[$count], $$u{title} )
      . qq[&lt;/span&gt;&lt;/td&gt;]
      . qq[&lt;td align="center"&gt;$usrHash{$author[$count]} &lt;/td&gt;]
      . qq[&lt;td&gt;Level: ] . getLevel($u) . qq[&lt;/td&gt;&lt;/tr&gt;\n];
    $count++;
  }

  if (getId($USER) ne $HTMLVARS{guest_user} and
    $usrHash{getId($USER)}&lt;$usrHash{$author[$count-1]}) {

     $html.= "&lt;tr bgcolor=#FF6666&gt;&lt;td&gt;"
    .linkNode($USER)
    ."&lt;/td&gt;&lt;td align=center&gt;"
    .$usrHash{getId($USER)}
    ."&lt;/td&gt;&lt;td&gt;Level: "
    .getLevel($USER)."&lt;/td&gt;&lt;/tr&gt;"; # can`t accessrule
  }
  return $html;
%]
&lt;/table&gt;
</live_code>
<reason>link to [Our Best Users]</reason>
<field>doctext</field>
</record>
<record><htmlcode_id>732089</htmlcode_id>
<patch_code>[%
  if ( getId($USER) != $HTMLVARS{default_user} ) {
    if ( $q-&gt;param('viewedNewNodes') ) {
      $VARS-&gt;{lastviewednewestnodes} = $q-&gt;param('pageloadtime');
    }
    if ( $q-&gt;param('clearNewNodesFlag') ) {
      $VARS-&gt;{lastviewednewestnodes} = '';
    }
  }

  my $str = '';
  my @array = ( 1..14 );

  $str .= qq(&lt;p align="right"&gt;&lt;a href="?node_id=244019"&gt;Help for this page&lt;/a&gt;&lt;/p&gt;\n);

  $str .= htmlcode('openform');
  $q-&gt;param( pageloadtime =&gt; time() );  # For future hidden params
  $str .= $q-&gt;hidden( 'pageloadtime' ); # This one isn't used, however

  if(  ! $VARS-&gt;{lastviewednewestnodes}  ) {
    $str .= join $/,
      'Show nodes created within the past',
      $q-&gt;popup_menu( 'numdays', \@array ),
      'days',
      $q-&gt;submit("Submit"),
      '&amp;nbsp;More&amp;nbsp;' . linkNodeTitle('Newest Nodes Settings'),
      '&lt;br /&gt;';
  } elsif(  getId($USER) != $HTMLVARS{default_user}  ) {
    $str .= join $/,
      'Showing nodes created since',
      htmlcode(
        'convertEpochSecs','',
        $VARS-&gt;{lastviewednewestnodes},
      ),
      '&lt;br /&gt;',
      $q-&gt;submit(
        clearNewNodesFlag =&gt; "Clear my 'last checked' time" ),
      '&amp;nbsp;More&amp;nbsp;' . linkNodeTitle('Newest Nodes Settings'),
  } else {
    # Yuck! Someone (impossibly?) set this for AnonyMonk.
    $VARS-&gt;{lastviewednewestnodes}= '';
  }
  return $str . $/ . '&lt;/form&gt;';
%]
[%
  my $style=
        $q-&gt;param('nn_toc_style')
    ||  $VARS-&gt;{nn_toc_style}
    ||  ( $VARS-&gt;{no_nn_toc} ? 'none' : 'banner' );
  my $ref= {};
  my $num_new= 0;
  local *newNodesForType= sub {
    my($tocref,$type,$numdays,$showauthor,$title,$link,$linkoff)= @_;

    ( my $anchor= $title ) =~ s/\s/-/g;

    my $nodestr= htmlcode(
      'nodesWithinDays','',
      $type, $numdays, 0, $showauthor, $ref );
    return '' unless $nodestr;

    $num_new += $ref-&gt;{count};

    if(  $style eq 'long'  ||  $style eq 'counted_banner'  ) {
      my $toc_title= "$ref-&gt;{count} $title";
      if(  $ref-&gt;{count} == 1  ) {
        $toc_title =~ s/ies\b/y/g;
        $toc_title =~ s/(Patch)es\b/$1/g;
        $toc_title =~ s/(\w+)s\b/$1/g
          if  $toc_title !~ m/\bNews\b/i;
      } else {
        $toc_title.='s' unless $toc_title=~/s\b/;
      }

      $toc_title=~s/ /&amp;nbsp;/g;

      my $toclink= $q-&gt;a(
        { href =&gt; "#toc-$anchor" },
        $toc_title,
      );
      if(  ! $ref-&gt;{firstcount}  ||  $ref-&gt;{firstcount} &gt; 1  ) {
        push @$tocref, $toclink;
        $ref-&gt;{firstcount} ||= $ref-&gt;{count};
      } else {
        unshift @$tocref, $toclink;
        $ref-&gt;{firstcount}= $ref-&gt;{count};
      }
    } elsif(  $style eq 'banner'  ) {
        ( my $toc_title= $title ) =~ s/ /&amp;nbsp;/g;
        push @$tocref, $q-&gt;a( {href=&gt;"#toc-$anchor"}, $toc_title );
    }

    my $top=
          $style ne 'banner'
      &amp;&amp;  $style ne 'long'
      &amp;&amp;  $style ne 'counted_banner'
        ? ''
        :   '&amp;nbsp;&lt;font size="2"&gt;'
          . $q-&gt;a( {href=&gt;"#toc-top"}, "(Top)" )
          . '&lt;/font&gt;';

    my $str= '';
    $str .= "&lt;h3&gt;";
    if(  ! $linkoff  ) {
      if(  $link  ) {
        $str .= join '',
          $q-&gt;a(
            { href =&gt; "$ENV{SCRIPT_NAME}?node=$link",
              name =&gt; "toc-$anchor",
            },
            $title ),
          $top;
      } else {
        $str .= join '',
          $q-&gt;a(
            { href =&gt; "$ENV{SCRIPT_NAME}?node=$title",
              name =&gt; "toc-$anchor",
            },
            $title ),
          $top;
      }
    } else {
       $str .= join '',
         $q-&gt;a(
           { name =&gt; "toc-$anchor" },
           $title,
         ),
         $top;
    }

    $str .= "&lt;/h3&gt;";
    return $str . $nodestr;
  };

  my $str= '';
  my $numdays= $q-&gt;param('numdays');

  my $h={};
  htmlcode( 'handle_nn_settings','', $h );

  my @toc;
  my( $title, $link, $showauthor, $linkoff );
  foreach my $type (  @{$h-&gt;{types}}  ) {
    ( $title, $link, $showauthor, $linkoff )= @{$h-&gt;{typedata}{$type}};
    $str .= newNodesForType(
      \@toc, $type, $numdays, $showauthor, $title, $link, $linkoff );
  }
  my @blurbs=(
    'awaiting your attention',
    'still to be read',
    'not yet reviewed',
    'since your last visit',
  );

  my $return= "";

  if(  ! $num_new  ) {
     $return= "&lt;p&gt;There are no new nodes at this time.&lt;/p&gt;";
  } elsif(  $style eq 'long'  ) {
    my $and= '';
    $and= "&lt;br /&gt;and " . pop(@toc)
      if 1 &lt; @toc;
    if(  @toc  &amp;&amp;  ! $VARS-&gt;{no_nn_toc}  ) {
      $return= join '',
        '&lt;p class="nnSummary"&gt;',
        $q-&gt;a(
          { name =&gt; "toc-top" },
          "There ".($ref-&gt;{firstcount}&gt;1 ? "are" : "is")
        ),
        '&lt;ul&gt;',
        join( ", &lt;br /&gt;", @toc ),
        $and, '&lt;/ul&gt;',
        $blurbs[rand @blurbs],
        '...&lt;/p&gt;&lt;hr /&gt;';
    }
    $return .= $str;
  } elsif(  $style eq 'banner'  ||  $style eq 'counted_banner'  ) {
    $return= join '',
      '&lt;p class="nnSummary"&gt;',
      $q-&gt;a(
        { name =&gt; "toc-top" },
        "Jump to",
      ),
      ": ",
      join(
        '&lt;span class="link-sep"&gt;&lt;span class="NN-link-sep"&gt;'
          . ' | &lt;/span&gt;&lt;/span&gt;',
        @toc,
      ),
      '&lt;/p&gt;&lt;hr /&gt;',
      $str;
  } else {
    $return= $str;
  };

  my $viewed_message = $num_new
    ? "I've checked all of these"
    : "Check for newer nodes";

  if(  getId($USER) != $HTMLVARS{default_user}  ) {
    $return.= join $/, '',
      htmlcode( 'openform','', -node_id =&gt; getId($NODE) ),
      $q-&gt;hidden( 'pageloadtime' ),
      $q-&gt;submit( viewedNewNodes =&gt; $viewed_message ),
      '&lt;/form&gt;&lt;/p&gt;';
  }
  return $return;
%]
&lt;p&gt;
 Or maybe you want to see [Recently Updated Home Nodes]
&lt;/p&gt;
&lt;link
   rel="alternate" title="Newest Nodes RSS"
   href="?node_id=30175;xmlstyle=rss"
   type="application/rss+xml"
&gt;&lt;/link&gt;
</patch_code>
<applied>2008-12-24 08:11:08</applied>
<htmlcode_id>3628</htmlcode_id>
<live_code>[%
  if ( getId($USER) != $HTMLVARS{default_user} ) {
    if ( $q-&gt;param('viewedNewNodes') ) {
      $VARS-&gt;{lastviewednewestnodes} = $q-&gt;param('pageloadtime');
    }
    if ( $q-&gt;param('clearNewNodesFlag') ) {
      $VARS-&gt;{lastviewednewestnodes} = '';
    }
  }

  my $str = '';
  my @array = ( 1..14 );

  $str .= qq(&lt;p align="right"&gt;&lt;a href="?node_id=244019"&gt;Help for this page&lt;/a&gt;&lt;/p&gt;\n);

  $str .= htmlcode('openform');
  $q-&gt;param( pageloadtime =&gt; time() );  # For future hidden params
  $str .= $q-&gt;hidden( 'pageloadtime' ); # This one isn't used, however

  if(  ! $VARS-&gt;{lastviewednewestnodes}  ) {
    $str .= join $/,
      'Show nodes created within the past',
      $q-&gt;popup_menu( 'numdays', \@array ),
      'days',
      $q-&gt;submit("Submit"),
      '&amp;nbsp;More&amp;nbsp;' . linkNodeTitle('Newest Nodes Settings'),
      '&lt;br /&gt;';
  } elsif(  getId($USER) != $HTMLVARS{default_user}  ) {
    $str .= join $/,
      'Showing nodes created since',
      htmlcode(
        'convertEpochSecs','',
        $VARS-&gt;{lastviewednewestnodes},
      ),
      '&lt;br /&gt;',
      $q-&gt;submit(
        clearNewNodesFlag =&gt; "Clear my 'last checked' time" ),
      '&amp;nbsp;More&amp;nbsp;' . linkNodeTitle('Newest Nodes Settings'),
  } else {
    # Yuck! Someone (impossibly?) set this for AnonyMonk.
    $VARS-&gt;{lastviewednewestnodes}= '';
  }
  return $str . $/ . '&lt;/form&gt;';
%]
[%
  my $style=
        $q-&gt;param('nn_toc_style')
    ||  $VARS-&gt;{nn_toc_style}
    ||  ( $VARS-&gt;{no_nn_toc} ? 'none' : 'banner' );
  my $ref= {};
  my $num_new= 0;
  local *newNodesForType= sub {
    my($tocref,$type,$numdays,$showauthor,$title,$link,$linkoff)= @_;

    ( my $anchor= $title ) =~ s/\s/-/g;

    my $nodestr= htmlcode(
      'nodesWithinDays','',
      $type, $numdays, 0, $showauthor, '', $ref );
    return '' unless $nodestr;

    $num_new += $ref-&gt;{count};

    if(  $style eq 'long'  ||  $style eq 'counted_banner'  ) {
      my $toc_title= "$ref-&gt;{count} $title";
      if(  $ref-&gt;{count} == 1  ) {
        $toc_title =~ s/ies\b/y/g;
        $toc_title =~ s/(Patch)es\b/$1/g;
        $toc_title =~ s/(\w+)s\b/$1/g
          if  $toc_title !~ m/\bNews\b/i;
      } else {
        $toc_title.='s' unless $toc_title=~/s\b/;
      }

      $toc_title=~s/ /&amp;nbsp;/g;

      my $toclink= $q-&gt;a(
        { href =&gt; "#toc-$anchor" },
        $toc_title,
      );
      if(  ! $ref-&gt;{firstcount}  ||  $ref-&gt;{firstcount} &gt; 1  ) {
        push @$tocref, $toclink;
        $ref-&gt;{firstcount} ||= $ref-&gt;{count};
      } else {
        unshift @$tocref, $toclink;
        $ref-&gt;{firstcount}= $ref-&gt;{count};
      }
    } elsif(  $style eq 'banner'  ) {
        ( my $toc_title= $title ) =~ s/ /&amp;nbsp;/g;
        push @$tocref, $q-&gt;a( {href=&gt;"#toc-$anchor"}, $toc_title );
    }

    my $top=
          $style ne 'banner'
      &amp;&amp;  $style ne 'long'
      &amp;&amp;  $style ne 'counted_banner'
        ? ''
        :   '&amp;nbsp;&lt;font size="2"&gt;'
          . $q-&gt;a( {href=&gt;"#toc-top"}, "(Top)" )
          . '&lt;/font&gt;';

    my $str= '';
    $str .= "&lt;h3&gt;";
    if(  ! $linkoff  ) {
      if(  $link  ) {
        $str .= join '',
          $q-&gt;a(
            { href =&gt; "$ENV{SCRIPT_NAME}?node=$link",
              name =&gt; "toc-$anchor",
            },
            $title ),
          $top;
      } else {
        $str .= join '',
          $q-&gt;a(
            { href =&gt; "$ENV{SCRIPT_NAME}?node=$title",
              name =&gt; "toc-$anchor",
            },
            $title ),
          $top;
      }
    } else {
       $str .= join '',
         $q-&gt;a(
           { name =&gt; "toc-$anchor" },
           $title,
         ),
         $top;
    }

    $str .= "&lt;/h3&gt;";
    return $str . $nodestr;
  };

  my $str= '';
  my $numdays= $q-&gt;param('numdays');

  my $h={};
  htmlcode( 'handle_nn_settings','', $h );

  my @toc;
  my( $title, $link, $showauthor, $linkoff );
  foreach my $type (  @{$h-&gt;{types}}  ) {
    ( $title, $link, $showauthor, $linkoff )= @{$h-&gt;{typedata}{$type}};
    $str .= newNodesForType(
      \@toc, $type, $numdays, $showauthor, $title, $link, $linkoff );
  }
  my @blurbs=(
    'awaiting your attention',
    'still to be read',
    'not yet reviewed',
    'since your last visit',
  );

  my $return= "";

  if(  ! $num_new  ) {
     $return= "&lt;p&gt;There are no new nodes at this time.&lt;/p&gt;";
  } elsif(  $style eq 'long'  ) {
    my $and= '';
    $and= "&lt;br /&gt;and " . pop(@toc)
      if 1 &lt; @toc;
    if(  @toc  &amp;&amp;  ! $VARS-&gt;{no_nn_toc}  ) {
      $return= join '',
        '&lt;p class="nnSummary"&gt;',
        $q-&gt;a(
          { name =&gt; "toc-top" },
          "There ".($ref-&gt;{firstcount}&gt;1 ? "are" : "is")
        ),
        '&lt;ul&gt;',
        join( ", &lt;br /&gt;", @toc ),
        $and, '&lt;/ul&gt;',
        $blurbs[rand @blurbs],
        '...&lt;/p&gt;&lt;hr /&gt;';
    }
    $return .= $str;
  } elsif(  $style eq 'banner'  ||  $style eq 'counted_banner'  ) {
    $return= join '',
      '&lt;p class="nnSummary"&gt;',
      '&lt;ul class="inline-list"&gt;',
      $q-&gt;a(
        { name =&gt; "toc-top" },
        "Jump to",
      ),
      ": ",
      join(
        '&lt;li&gt;',
        @toc,
      ),
      '&lt;/ul&gt;&lt;/p&gt;&lt;hr /&gt;',
      $str;
  } else {
    $return= $str;
  };

  my $viewed_message = $num_new
    ? "I've checked all of these"
    : "Check for newer nodes";

  if(  getId($USER) != $HTMLVARS{default_user}  ) {
    $return.= join $/, '',
      htmlcode( 'openform','', -node_id =&gt; getId($NODE) ),
      $q-&gt;hidden( 'pageloadtime' ),
      $q-&gt;submit( viewedNewNodes =&gt; $viewed_message ),
      '&lt;/form&gt;&lt;/p&gt;';
  }
  return $return;
%]
&lt;p&gt;
 Or maybe you want to see [Recently Updated Home Nodes]
&lt;/p&gt;
&lt;link
   rel="alternate" title="Newest Nodes RSS"
   href="?node_id=30175;xmlstyle=rss"
   type="application/rss+xml"
&gt;&lt;/link&gt;
</live_code>
<reason>s/flag/time/</reason>
<field>doctext</field>
</record>
<record><htmlcode_id>734240</htmlcode_id>
<patch_code>[%
    use Everything::Experience;
    my @errors;

    my @types= q(
        Wi  perlquestion            SoPW        Seekers of Perl Wisdom
        D   monkdiscuss             PMD         PM Discussions
        Ob  obfuscated              Obfu        Obfuscation
        CU  CUFP                    CUFP        Cool Uses For Perl
        CC  sourcecode              Code        Code Catacombs
        CQ  categorized_question    CatQ        Categorized Questions
        CA  categorized_answer      CatA        Categorized Answers
        IS  pmdevtopic              InScpt      Inner Scriptorium
        OT  offtopicroot            OT          Off-topic root nodes
        --
        Tu  perltutorial            Tut         Tutorial
        U   user                    User
        Po  poem                    Poem
        Cr  perlcraft               Craft
        Sn  snippet                 Snippet
        N   perlnews                News
        Q   quest                   Quest
        Pol poll                    Poll
        --
        M   perlmeditation          Med         Meditations
        SP  scratchpad              SPad        Scratch Pad
        MR  modulereview            ModRev      Module Review
        BR  bookreview              BkRev       Book Review
        pPd perlman                 perlman     Perl Manpage
        pFn perlfunc                perlfunc    Perl Function
        pFq perlfaq_nodetype        perlfaq     Perl FAQ
        Hlp sitefaqlet              Help        Monk Help

    ) =~ /(\S.*\S)/g;
    #     Seekers of Perl Wisdom    Tutorial    Meditations
    #     PM Discussions            User        Scratch Pad
    #     Obfuscation               Poem        Module Review
    #     Cool Uses For Perl        Craft       Book Review
    #     Code Catacombs            Snippet     Perl Manpage
    #     Categorized Questions     News        Perl Function
    #     Categorized Answers       Quest       Perl FAQ
    #     Inner Scriptorium         Poll        Monk Help
    #     Off-topic root nodes      [Wiki]      (Patch replies)
    #     (Any)

    my( %abbr, %desc, %typeId, %link, %linktext, @typeRows );
    {
        my( $row, $idx )= (0,0);
        @types= map {
            if(  "--" eq $_  ) {
                $row= 0;
                (); # Skip this one
            } else {
                my( $abbr, $type, $linktext, $desc )= split " ", $_, 4;
                $type =~ tr/_/ /;
                my $id= getId( getType($type) );
                $typeId{$type}= $id;
                $abbr{$type}= $abbr;
                $desc{$type}= $desc || $linktext;
                $link{ $id }= linkNode( $id, $linktext );
                $linktext{$id}= $linktext;
                push @{ $typeRows[$row++] }, $idx++;
                $type;  # Store this in @types
            }
        } @types;
    }

    if(  ! $q-&gt;can("delete_param")  ) {
        *CGI::delete_param= sub {
            my( $self, $param )= @_;
            @{$self-&gt;{'.parameters'}}=
                grep $_ ne $param, @{$self-&gt;{'.parameters'}};
            delete $self-&gt;{$param};
        };
    }

    my %typeTable= qw(
        snippet         snippet
        bookreview      review
        modulereview    review
        sourcecode      sourcecode
        poll            polls
    );
    my %fieldOfTable= (
        snippet =&gt; [qw( snippetdesc snippetcode )],
        review =&gt; [qw( itemdescription usercomment doctext )],
        sourcecode =&gt; [qw( codedescription doctext )],
        polls =&gt; ['choices'],
    );

    # Make &amp;Wi check the box like &amp;Wi= does
    # And make &amp;Wi=0 uncheck a box:
    for my $abbr (  values %abbr  ) {
        my @vals= $q-&gt;param( $abbr );
        if(  @vals  &amp;&amp;  "0" ne $vals[-1]  ) {
            $q-&gt;param( $abbr, "1" );
        } else {
            $q-&gt;delete_param( $abbr );
        }
    }
    for my $p (  qw( xa xpa xr xs )  ) {
        my @vals= $q-&gt;param( $p );
        $q-&gt;delete_param( $p )
            if  @vals  &amp;&amp;  "0" eq $vals[-1];
    }

    # Build URL that would repeat this search
    my $url= do {
        my %p= map { $_ =&gt; ( '', $q-&gt;param($_) )[-1] } $q-&gt;param();
        delete @p{qw/ node_id nx go n0 BIR HIR BER HER as_user /}; # keep HIR/HER?
        for my $p (  qw( BIS HIS BES HES )  ) {
            delete $p{$p}   if  " " eq $p{$p};
        }
        for my $p (  keys %p  ) {
            delete $p{$p}   if  '' eq $p{$p};
        }
        delete $p{re}   if  "S" eq $p{re};
        delete $p{BH}   if  $p{BH};
        delete $p{nf}   if  $p{nf};
        # Use short form for section checkboxes:
        my $sect= '';
        for my $abbr (  values %abbr  ) {
            $sect .= ";$abbr"
                if  delete $p{$abbr};
        }
        join '',
            "?node_id=$NODE-&gt;{node_id}",
            join( ';', '',
                map "$_=" . $q-&gt;escape($p{$_}),
                grep exists $p{$_}, $q-&gt;param() ),
            $sect;
    };

    my @sects;
    my $sects= do {
        my $negSects= ( $q-&gt;param("xs") )[-1] ? 1 : 0;
        my %checked;
        @checked{keys %abbr}= map {
            ( ()= $q-&gt;param($abbr{$_}) ) ? 1 : 0;
        } keys %abbr;
        @sects= grep $negSects != $checked{$_}, keys %abbr;
        @sects= @types   if  ! @sects;
        join ", ", map $typeId{$_}, @sects;
    };

    my @criteria;

    my $umsg= '&lt;br /&gt;';
    my $pmsg= '&lt;br /&gt;replies to nodes ';
    foreach my $tuple (
        ['a','xa','n',\$umsg],
        ['pa','xpa','parent',\$pmsg]
    ) {
        my ($txtparam,$xparam,$talias,$msgref)=@$tuple;

        my @users= grep length, $q-&gt;param($txtparam);  #[
        if(  1 == @users  &amp;&amp;  $users[0] =~ m#^(\s*\[[^\]]+\])+\s*$#  ) {   #[
            @users= $users[0] =~ m#\[([^\]]+)\]#g;
        }
        for my $user (  @users  ) {
            my $type = "user";
            my $reason = "does not exist";
            my $U;
            if(  $user !~ m#^id://(\d+)$#  ) {
                $U = getNode( $user, "user" ) || getNode( $user, "usergroup" );
            } else {
                ( $type, $user ) = ( "node ID", $1 );
                $U = getNodeById( $user )   if  $user;
                if(  $U  &amp;&amp;  $U-&gt;{type}{title} !~ /^user/ ) {
                    undef $U;
                    $reason = "is not a user";
                }
            }
            if(  $U  ) {
                $user= getId($U);
            } else {
                push @errors, qq[\u$type "]
                    . $q-&gt;escapeHTML($user) . qq[" $reason.];
                $user= 0;
            }
        }
        @users= grep $_, @users;
        my $negAuthor= ( $q-&gt;param($xparam) )[-1] ? 1 : 0;
        $negAuthor= $negAuthor ? " NOT" : "";
        if(  @users  ) {
            push @criteria, "$talias.author_user$negAuthor IN ( "
                . join( ", ", @users ) . " )";
            $$msgref .= qq[written by ]
                  . ( $negAuthor ? "anyone but " : "any of " )
                  . join ", ", map linkNode($_), @users;
        } else {
            $$msgref="";
        }
    }

    my $replies= ( $q-&gt;param("re") )[-1];
    $q-&gt;param( "re", $replies );
    my $xRoots= ()= $q-&gt;param("xr");
    my $note= getId( getType("note") );

    push @criteria, do {
        if(  "N" eq $replies  ) {           # No replies:
            push @errors,
                "No root nodes and no replies means no search."
                if  $xRoots;
            $xRoots
                ? "n.node_id = 0"
                : "n.type_nodetype IN ( $sects )";
        } elsif(  "A" eq $replies           # All replies (same as
              ||  @sects == @types  ) {     #  re.s from all sects):
            $xRoots
                ? "n.type_nodetype = $note"
                : "n.type_nodetype IN ( $note, $sects )";
        } else {                            # Replies from selected sections:
            $q-&gt;param( "re", undef );
            my $c= "( n.type_nodetype = $note"
                . " AND root.type_nodetype IN ( $sects ) )";
            $xRoots
                ? $c
                : "( n.type_nodetype IN ( $sects ) OR $c )";
        }
    };

    # ( Head Body ) + ( Includes Excludes ) + ( Terms Separator Regex=0|1 )
    my $bir= ( $q-&gt;param("BIR") )[-1] ? 1 : 0;  # @bodyHas are regexes
    my $ber= ( $q-&gt;param("BER") )[-1] ? 1 : 0;  # @bodyLacks are regexes
    my $hir= ( $q-&gt;param("HIR") )[-1] ? 1 : 0;  # @headHas are regexes
    my $her= ( $q-&gt;param("HER") )[-1] ? 1 : 0;  # @headLacks are regexes
    my $isGod= isGod($USER);
    if(  !$isGod  and  ( $bir || $ber )  ) {
        push @errors, "Unfortunately, regexes use too much"
            . " server CPU time, so their use is reserved for [gods]."
    }

    my $getTerms= sub {
        my( $textParam, $sepParam )= @_;
        my $str= $q-&gt;param( $textParam );
        my $sep= $q-&gt;param( $sepParam );
        $sep =~ s/^\s*//;
        $sep =~ s/\s*$//;
        $sep= " "   if  ! length $sep;
        $q-&gt;param( $sepParam, $sep );
        my @terms= grep length, split /\Q$sep/, $str;
        $q-&gt;param( $textParam, join $sep, @terms );
        return @terms;
    };
    my @headHas=   $getTerms-&gt;( "HIT", "HIS" );
    my @headLacks= $getTerms-&gt;( "HET", "HES" );
    my @bodyHas=   $getTerms-&gt;( "BIT", "BIS" );
    my @bodyLacks= $getTerms-&gt;( "BET", "BES" );

    my( @tables, @fields );
    push @tables, 'note',
        "left join node as root on root.node_id=root_node";
    if(  $pmsg  ) {
        push @tables,
          "left join node as parent on parent.node_id=parent_node";
    }
    if(  @bodyHas  ||  @bodyLacks  ) {
        my( %tables, %fields );
        push @sects, 'note'
            unless  'N' eq $replies;
        for my $type (  @sects  ) {
            if(  $typeTable{$type}  ) {
                ++$tables{ $typeTable{$type} };
                ++$fields{$_}
                    for  @{  $fieldOfTable{ $typeTable{$type} }  };
            } else {
                ++$tables{document};
                ++$fields{doctext};
            }
        }
        push @tables, keys %tables;
        push @fields, keys %fields;
    }

    my $tables= "node as n";
    for my $table (  @tables  ) {
        if(  $table =~ / /  ) {
            $tables .= "\n$table";
        } else {
            $tables .= "\nleft join $table on ${table}_id=n.node_id";
        }
    }

    my $termMatch= sub {
        my( $not, $regex, $avFields, @terms )= @_;
        if(  ! @terms  ) {
            ; # Nothing.
        } elsif(  $regex  ) {
            for my $term (  @terms  ) {
                my $safe= htmlcode('saferegex','',$term);
                if(  $safe =~ s#^\\9##  ) {
                    push @errors, $safe;
                    last;
                }
                $safe =~ s#([\\'])#\\$1#g;
                push @criteria, "( " . join( " OR ", map {
                    "$_ RLIKE '$safe'";
                } @$avFields ) . " )";
                $criteria[-1]= "NOT COALESCE( $criteria[-1], 0=1 )"
                    if  $not;
            }
        } else {
            push @criteria, map {
                my $quoted= $_;
                $quoted =~ s#\\#\\\\#g;     # MySQL quirk
                $quoted =~ s#([\\'%_])#\\$1#g;
                ( $not ? "NOT COALESCE( " : "" )
                .  "( " . join( " OR ", map {
                    "$_ LIKE '%$quoted%'";
                } @$avFields ) . " )"
                . ( $not ? ", 0=1 )" : "" )
            } @terms;
        }
    };
    $termMatch-&gt;( "",    $hir, ["n.title"], @headHas );
    $termMatch-&gt;( "NOT", $her, ["n.title"], @headLacks );
    $termMatch-&gt;( "NOT", $ber, \@fields,    @bodyLacks );
    if(  ( $q-&gt;param("BH") )[-1]  ) {
        push @fields, 'n.title';
    }
    $termMatch-&gt;( "",    $bir, \@fields,    @bodyHas );

    my $oldFirst= ! ( $q-&gt;param("nf") )[-1];
    my $dir= $oldFirst ? +1 : -1;
    my $lastNode= $DB-&gt;sqlSelect( "max(node_id)", "node" );

    my $n0= 0;
    if(  $q-&gt;param("nx")  ) {                           # Continue search:
        $n0= ( $q-&gt;param("n0") )[-1]
            or  push @errors, qq[Strange, you asked me to continue]
                    . qq[ but I don't know where to continue from.];
    } elsif(  ( $q-&gt;param("yr") )[-1]  ) {      # Search from date:
        my( $yr, $mo, $dy )= map { ( $q-&gt;param($_) )[-1] } qw( yr mo dy );
        $mo ||= 1;
        $dy ||= 1;
        my $date= join "-", map sprintf("%02d",$_), $yr, $mo, $dy;
        $n0= $DB-&gt;sqlSelect(
            "node_id",
            "node",
            "createtime &gt;= '$date'",
            "order by createtime limit 1"
        );
    } elsif(  $q-&gt;param("go")  ) {              # New search:
        $n0= $oldFirst ? 1 : $lastNode;
    }

    my $doSearch=  $n0  &amp;&amp;  ! @errors  ||  0;

    push @criteria, "n.node_id BETWEEN !TBD!";

    my $html= '';
    my $limit= 50;
    if(     $doSearch
        &amp;&amp;  "POST" ne uc $q-&gt;request_method()
        &amp;&amp;  $USER-&gt;{user_id} != ( $q-&gt;param("as_user") )[-1]
        &amp;&amp;  $USER-&gt;{title}   ne ( $q-&gt;param("as_user") )[-1]
    ) {
        $html .= join '',
            qq[&lt;p&gt;You must specify as_user=$USER-&gt;{user_id}],
            qq[ in the URL to have the search start immediately\n],
            qq[ when the link is followed (or send the request],
            qq[ by POSTing from a form instead).\n  Simply press],
            qq[ the Search button below, now.&lt;/p&gt;\n];
        $doSearch= 0;
    }
    if(  ! $doSearch  ) {
        $html .= qq[&lt;p align="right"&gt;&lt;a href="/?node_id=590032"&gt;]
          . qq[Help for this page&lt;/a&gt;&lt;/p&gt;];
        $html .= qq[&lt;p&gt;You can also try using]
          . qq[ &lt;a href="http://www.google.com/advanced_search]
          . qq[?hl=en&amp;as_sitesearch=www.perlmonks.org"&gt;Google's]
          . qq[ advanced search&lt;/a&gt; against PerlMonks.&lt;/p&gt;\n];
        if(  $isGod  ) {
            $html .= qq[&lt;p&gt;]
              . qq[Please use regex searches sparingly.  A regex search uses]
              . qq[ much more CPU time on the database server.]
              . qq[&lt;/p&gt;];
        }
    } else {
        Everything::printLog( "node=$NODE-&gt;{node_id}($NODE-&gt;{node_title})"
            . " ip=$ENV{REMOTE_ADDR} user=$USER-&gt;{title}"
            . " q=" . $q-&gt;query_string() );
        require Time::HiRes;
        my @matches;
        my $start= $n0;
        my $startTime= Time::HiRes::time();
        while(  1  ) {

            my( $min, $max );
            if(  $oldFirst  ) {
                ( $min, $max )= ( $n0, $n0+10000 );
                $max= 1000 * int( $max/1000 + 0.5 );
                $max= $lastNode   if  $lastNode &lt; $max;
            } else {
                ( $min, $max )= ( $n0-10000, $n0 );
                $min= 1000 * int( $min/1000 + 0.5 );
                $min= 1   if  $min &lt; 1;
            }
            $criteria[-1]= "n.node_id BETWEEN $min AND $max";

            my $explainTime= Time::HiRes::time();
            my $sql= qq[
                SELECT n.node_id, n.title, n.type_nodetype,
                       n.author_user, n.createtime, root.type_nodetype
                FROM   $tables
                WHERE  ] . join( " AND ", @criteria ) . qq[
                ORDER BY n.node_id ] . ( $oldFirst ? "" : "DESC" ) . qq[
                LIMIT ] . ( $limit - @matches );
            my $explain= $DB-&gt;getDatabaseHandle()-&gt;prepare(
                "EXPLAIN $sql" );
            $explain-&gt;execute();
            my $rec= $explain-&gt;fetchrow_hashref();
            $explain-&gt;finish();
            my $key_used= $rec-&gt;{key};
            my $key_rows= $rec-&gt;{rows};
            my $comment= $rec-&gt;{Comment};

            if(  $start == $n0  ) {
                $html .= "\n&lt;!--\n$sql\n";
                $html .= $/ . $q-&gt;table(
                    map {
                        my $val= delete $rec-&gt;{$_};
                        ( my $head= $_ ) =~ s/.*_//;
                        defined $val
                            ? $q-&gt;Tr( $q-&gt;td($head), $q-&gt;td($val) )
                            : ();
                    } qw( table type rows possible_keys key
                          key_len Extra ), keys %$rec
                ) . "\n--&gt;\n";
            }

            $explainTime= Time::HiRes::time() - $explainTime;
            if(  3 &lt; $explainTime  ) {
                push @errors, ( $start==$n0 ? "Q" : "Remainder of q" )
                  . qq[uery was not run;  Server is too busy ]
                  . sprintf
                      qq[("explain" took %.2f seconds)], $explainTime;
                last;
            }

#            if(  15000 &lt; $key_rows  ) {
            if ( 25000 &lt; $key_rows ) {
                push @errors, ( $start==$n0 ? "Q" : "Remainder of q" )
                  . "uery would not run quickly"
                  . ( $comment ? " ($comment)" : "" ) . ".";
                last;
            }

            my $cursor= $DB-&gt;sqlSelectMany(
                "n.node_id as node_id, n.title as title,
                 n.type_nodetype as type_nodetype,
                 n.author_user as author_user, n.createtime as createtime,
                 root.node_id as root_node_id,
                 root.type_nodetype as root_nodetype",
                $tables,
                join( " AND ", @criteria ),
                "ORDER BY n.node_id " . ( $oldFirst ? "" : "DESC" )
                . " LIMIT " . ( $limit - @matches ),
            );
            my $results = $cursor-&gt;fetchall_arrayref({});
            push @matches, @$results;
            $cursor-&gt;finish();

            if(  $limit &lt;= @matches  ) {
                $n0= $dir + $matches[-1]{node_id};
                last;
            }
            $n0= $dir + ( $oldFirst ? $max : $min );
            last   if  $n0 &lt; 1  ||  $lastNode &lt; $n0;
            my $runTime= Time::HiRes::time() - $startTime;
            if(  10 &lt; $runTime  ) {
                push @errors, ( $start==$n0 ? "Q" : "Remainder of q" )
                    . qq[uery was not run ] . sprintf
                      qq[(used %.2f seconds so far)], $runTime;
                last;
            }
        }
        if(  $n0 == $start  ) {
            $doSearch= 2;       # "Retry"
        }
        if(  $n0 &lt; 1  ||  $lastNode &lt; $n0  ) {
            $doSearch= -1;      # Search finished.
        }

        my $startDate= ( split " ", $DB-&gt;sqlSelect(
            "createtime","node","node_id=$start") )[0];
        my $endDate= ( split " ", $DB-&gt;sqlSelect(
            "createtime","node","node_id=".($n0-$dir)) )[0];
        my $matches= @matches;

        $html .= qq[&lt;p&gt;&lt;hr /&gt;&lt;div class="ss-result-summary"&gt;
            &lt;b&gt;Found $matches node] . ( 1==$matches ? "" : "s" ) .qq[&lt;/b&gt;]
          #. ( 0 &lt; $doSearch ? " (so far)" : "" )
          . qq[ roughly between $startDate and $endDate]
          . qq[ (searched ] . sprintf( "%.2f",
              100*( abs($n0-$start)+1 ) / $lastNode
            ) . qq[% of DB).&lt;/div&gt;&lt;br /&gt;\n&lt;div class="ss-criteria-summary"&gt;\n];

        if(  @bodyHas  ||  @bodyLacks  ||  @headHas  ||  @headLacks  ) {
            $html .= qq[&lt;br /&gt;where ] . join qq[&lt;br /&gt;and ],
                map {
                    my( $desc, $regex, $plur, @terms )= @$_;
                    if(  ! @terms  ) {
                        ();
                    } else {
                        if(  $regex  ) {
                            $desc =~ s/ contain / match /;
                            $desc =~ s/ contains / matches /;
                        }
                        $desc .= $plur    if  1 &lt; @terms;
                        $desc . join( ", ", map {
                            qq["&lt;tt&gt;] . $q-&gt;escapeHTML($_) . qq[&lt;/tt&gt;"]
                        } @terms )
                    }
                } ["any text contains ",$bir,"all of ",@bodyHas],
                  ["no text contains ",$ber,"any of ",@bodyLacks],
                  ["title contains ",$hir,"all of ",@headHas],
                  ["title doesn't contain ",$her,"any of ",@headLacks],
        }


        $html .= $umsg; # user message
        $html .= $pmsg; # parent message

        $html .= qq[&lt;/div&gt;&lt;/p&gt;\n];

        $html .= qq[&lt;p&gt;&lt;table width="100%" class="ss-result-table"&gt;];
        for my $rec (  @matches  ) {
            my( $date )= split " ", $rec-&gt;{createtime};
            $date =~ s!-!&amp;#8209;!g;
            $html .= $/." "x4 . $q-&gt;Tr(
                $q-&gt;td( $date ), $/." "x8,
                $q-&gt;td( linkNode($rec-&gt;{author_user}) ), $/." "x8,
                $q-&gt;td( linkNode($rec) ),
                $/." "x8, $q-&gt;td(
                    $note == $rec-&gt;{type_nodetype}
                        ? "Re:" . linkNode($rec-&gt;{root_node_id}, $linktext{ $rec-&gt;{root_nodetype} })
                        : $link{ $rec-&gt;{type_nodetype} }
                ),
            );
        }
        $html .= qq[&lt;/table&gt;&lt;/p&gt;\n];
    }

    $q-&gt;param( "n0", $n0 );
    $html .= $/ . htmlcode('openform')
        . $q-&gt;hidden("n0") . $/;

    if(  $doSearch  ) {
        $html .= qq[\n&lt;p class="ss-search-continue"&gt;];
        if(  -1 == $doSearch  ) {
            $html .= qq[Finished searching database.\n];
        } else {
            my( $min, $max )= $oldFirst ? ( $n0, $lastNode ) : ( 1, $n0 );
            my $pct= sprintf "%.2f%%", 100*($max-$min+1)/$lastNode;
            if(  1 == $doSearch  ) {
                $html .= qq[Press ]
                  . $q-&gt;submit( "nx", "Next &gt;" )
                  . qq[ to &lt;b&gt;continue&lt;/b&gt; searching remaining $pct of DB.];
            } else {
                $pct= " remaining $pct of DB";
                $pct= ""   if  1 == $min  &amp;&amp;  $max == $lastNode;
                $html .= qq[Press ]
                  . $q-&gt;submit( "nx", "Retry" )
                  . qq[ to &lt;b&gt;retry&lt;/b&gt; searching$pct.];
            }
            $html .= qq[&lt;br /&gt;\n]
                . qq[Please be patient after submitting your search.\n];
        }
        $html .= qq[&lt;/p&gt;\n&lt;p class="ss-preload-link"&gt;Link to preload this search: ]
            . qq[&lt;a href="$url"&gt;&amp;#91;href://$url&amp;#93;&lt;/a&gt;&lt;/p&gt;]
            . "&lt;hr /&gt;\n";
    }

    $html .= qq[&lt;p&gt;] . linkNode( $NODE, "Reset search form" ) . qq[&lt;/p&gt;\n];

    $html .= qq[&lt;p&gt;
        Match &lt;b&gt;text&lt;/b&gt; containing ]
      . $q-&gt;textfield( "BIT", "", 60 )
      . qq[&lt;br /&gt;(separate ]
      . ( !$isGod
            ? "strings"
            : $q-&gt;radio_group( "BIR", [ "0", "1" ], "0", 0,
                { 0=&gt;"strings -or- regexes", 1=&gt;"" } )
        ) . qq[ with ]
      . $q-&gt;textfield( "BIS", " ", 2 )
      . qq[ -- default is spaces)&lt;br /&gt;]
      . $q-&gt;radio_group( "BH", [ "0", "1" ], "1", 0,
            { 0=&gt;"Don't match -or-", 1=&gt;"Also match" },
        ) . qq[ &lt;b&gt;titles&lt;/b&gt; against above.&lt;/p&gt;];

    $html .= $/ . "&lt;p&gt;"
      . ( 0&lt;$doSearch ? qq[New ] : "" )
      . $q-&gt;submit( "go", "Search" )
      . qq[ Please be patient after submitting your search.\n&lt;/p&gt;];

    $html .= qq[&lt;p&gt;
        Match &lt;b&gt;titles&lt;/b&gt; containing ]
      . $q-&gt;textfield( "HIT", "", 60 )
      . qq[&lt;br /&gt;(separate ]
      . ( !$isGod
            ? "strings"
            : $q-&gt;radio_group( "HIR", [ "0", "1" ], "0", 0,
                { 0=&gt;"strings -or- regexes", 1=&gt;"" } )
        ) . qq[ with ]
      . $q-&gt;textfield( "HIS", " ", 2 )
      . qq[ -- default is spaces)&lt;/p&gt;];

    $html .= qq[&lt;p&gt;
        ] . $q-&gt;radio_group(
            "xa", [ "0", "1" ], "0", 0, { 0=&gt;"Match -or-", 1=&gt;"Exclude" },
        ) . qq[ &lt;b&gt;authors&lt;/b&gt; ] . $q-&gt;textfield( "a", "", 20 ) . qq[&lt;br /&gt;
        (use "&amp;#91;one&amp;#93; &amp;#91;two&amp;#93;" to list multiple authors)&lt;br /&gt;
        (Searching by author doesn't work for Categorized Questions and
        Answers yet.)&lt;/p&gt;];

    $html .= qq[&lt;p&gt;
        Search ] . $q-&gt;radio_group(
            -name=&gt;"nf", -values=&gt;[ "1", "0" ], -default=&gt;"1",
            -labels=&gt;{ 1=&gt;"Newest first -or-", 0=&gt;"Oldest first" },
        ) . qq[,&lt;br /&gt;starting at ];
    $html .= do {
        my $yr= 1900 + (localtime)[5];
        my @yr= ( "", 2000..$yr );
        my %yr;  @yr{@yr}= ( "Year", map {
            my $k= ('','A'..'Z')[$_];
            $k &amp;&amp;= "$k) ";
            "$k$yr[$_]"
        } 1..$#yr );
        $q-&gt;popup_menu( "yr", \@yr, "", \%yr );
    };
    $html .= " - " . do {
        my @mo= ( "", '01'..'12' );
        my %mo;  @mo{@mo}= ( "Month", map {
            $_ . " " .
            (qw( Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec ))[$_-1];
        } 1..12 );
        $q-&gt;popup_menu( "mo", \@mo, "", \%mo );
    };
    $html .= " - " . do {
        my @dy= ( "", '01'..'31' );
        my %dy;  @dy{@dy}= ( "Day", '01'..'31' );
        $q-&gt;popup_menu( "dy", \@dy, "", \%dy );
    };
    $html .= qq[.&lt;/p&gt;];

    # $html .= qq[&lt;!-- &lt;p&gt; Show {10|20|50} matches per page.&lt;/p&gt; --&gt;];

    $html .= qq[&lt;p&gt;
        Search ] . $q-&gt;radio_group(
            "xs", [0,1], 0, 0, {0=&gt;"only -or-",1=&gt;"all but"},
        ) . qq[&lt;br /&gt;the following &lt;b&gt;sections&lt;/b&gt;:];
    $html .= qq[&lt;ul&gt;] . $q-&gt;table(
        map(
            "\n    "
            . $q-&gt;Tr(
                map "\n        " . $q-&gt;td(
                    $q-&gt;checkbox(
                        -name =&gt; $abbr{$types[$_]},
                        -value =&gt; "1",
                        -label =&gt; $desc{$types[$_]},
                        )
                ), @$_
            ), @typeRows,
        ), $/
    ) . qq[&lt;/ul&gt;\n];

    $html .= qq[&lt;p&gt;
        &lt;i&gt;Skip&lt;/i&gt; &lt;b&gt;text&lt;/b&gt; containing ]
      . $q-&gt;textfield( "BET", "", 60 )
      . qq[&lt;br /&gt;(separate ]
      . ( !$isGod
            ? "strings"
            : $q-&gt;radio_group( "BER", [ "0", "1" ], "0", 0,
                { 0=&gt;"strings -or- regexes", 1=&gt;"" } )
        ) . qq[ with ]
      . $q-&gt;textfield( "BES", " ", 2 )
      . qq[ -- default is spaces)&lt;br /&gt;
        (Does not exclude based on titles)&lt;/p&gt;];

    $html .= qq[&lt;p&gt;
        &lt;i&gt;Skip&lt;/i&gt; &lt;b&gt;titles&lt;/b&gt; containing ]
      . $q-&gt;textfield( "HET", "", 60 )
      . qq[&lt;br /&gt;(separate ]
      . ( !$isGod
            ? "strings"
            : $q-&gt;radio_group( "HER", [ "0", "1" ], "0", 0,
                { 0=&gt;"strings -or- regexes", 1=&gt;"" } )
        ) . qq[ with ]
      . $q-&gt;textfield( "HES", " ", 2 )
      . qq[ -- default is spaces)&lt;/p&gt;];

    $html .= qq[&lt;/p&gt;&lt;p&gt;\n] . $q-&gt;radio_group(
        "xr", ["0","1"], "0", 1, {
            0 =&gt; "Include &lt;b&gt;root&lt;/b&gt; nodes from selected sections",
            1 =&gt; "Don't include &lt;b&gt;root&lt;/b&gt; nodes",
        },
    );

    $html .= qq[&lt;/p&gt;&lt;p&gt;\n] . $q-&gt;radio_group(
        "re", [qw( A S N )], "S", 1, {
            A =&gt; "Include &lt;b&gt;replies&lt;/b&gt; from &lt;i&gt;any&lt;/i&gt; section",
            S =&gt; "Include &lt;b&gt;replies&lt;/b&gt; from &lt;i&gt;selected&lt;/i&gt; sections",
            N =&gt; "&lt;i&gt;Don't&lt;/i&gt; include &lt;b&gt;replies&lt;/b&gt;",
        },
    );
    $html .= join $/, '&lt;p&gt;',
        $q-&gt;radio_group(
            "xpa", [ "0", "1" ], "0", 0, { 0=&gt;"Match -or-", 1=&gt;"Exclude" },
        ),
        qq[&lt;b&gt;parent node's author&lt;/b&gt;],
        $q-&gt;textfield( "pa", "", 20 ),
        '&lt;br /&gt;',
        '(use "&amp;#91;one&amp;#93; &amp;#91;two&amp;#93;" to list multiple authors)&lt;br /&gt;',
        "(This doesn't work for Categorized Questions and Answers yet.)&lt;/p&gt;";

    $html .= $/ . "&lt;p&gt;"
      . ( 0&lt;$doSearch ? qq[New ] : "" )
      . $q-&gt;submit( "go", "Search" )
      . qq[ Please be patient after submitting your search.\n&lt;/p&gt;];

    $html .= qq[&lt;/form&gt;\n];

    $html .= qq[\n&lt;!-- CGI::VERSION=$CGI::VERSION --&gt;\n];

    $_ .= "&lt;br /&gt;\n"   for  @errors;
    return "&lt;b&gt;" . join( "", @errors ) . "&lt;/b&gt;$html";
%]
</patch_code>
<applied>2009-01-05 14:10:03</applied>
<htmlcode_id>3989</htmlcode_id>
<live_code>[%
    use Everything::Experience;
    my @errors;

    my @types= q(
        Wi  perlquestion            SoPW        Seekers of Perl Wisdom
        D   monkdiscuss             PMD         PM Discussions
        Ob  obfuscated              Obfu        Obfuscation
        CU  CUFP                    CUFP        Cool Uses For Perl
        CC  sourcecode              Code        Code Catacombs
        CQ  categorized_question    CatQ        Categorized Questions
        CA  categorized_answer      CatA        Categorized Answers
        IS  pmdevtopic              InScpt      Inner Scriptorium
        OT  offtopicroot            OT          Off-topic root nodes
        --
        Tu  perltutorial            Tut         Tutorial
        U   user                    User
        Po  poem                    Poem
        Cr  perlcraft               Craft
        Sn  snippet                 Snippet
        N   perlnews                News
        Q   quest                   Quest
        Pol poll                    Poll
        --
        M   perlmeditation          Med         Meditations
        SP  scratchpad              SPad        Scratch Pad
        MR  modulereview            ModRev      Module Review
        BR  bookreview              BkRev       Book Review
        pPd perlman                 perlman     Perl Manpage
        pFn perlfunc                perlfunc    Perl Function
        pFq perlfaq_nodetype        perlfaq     Perl FAQ
        Hlp sitefaqlet              Help        Monk Help

    ) =~ /(\S.*\S)/g;
    #     Seekers of Perl Wisdom    Tutorial    Meditations
    #     PM Discussions            User        Scratch Pad
    #     Obfuscation               Poem        Module Review
    #     Cool Uses For Perl        Craft       Book Review
    #     Code Catacombs            Snippet     Perl Manpage
    #     Categorized Questions     News        Perl Function
    #     Categorized Answers       Quest       Perl FAQ
    #     Inner Scriptorium         Poll        Monk Help
    #     Off-topic root nodes      [Wiki]      (Patch replies)
    #     (Any)

    my( %abbr, %desc, %typeId, %link, %linktext, @typeRows );
    {
        my( $row, $idx )= (0,0);
        @types= map {
            if(  "--" eq $_  ) {
                $row= 0;
                (); # Skip this one
            } else {
                my( $abbr, $type, $linktext, $desc )= split " ", $_, 4;
                $type =~ tr/_/ /;
                my $id= getId( getType($type) );
                $typeId{$type}= $id;
                $abbr{$type}= $abbr;
                $desc{$type}= $desc || $linktext;
                $link{ $id }= linkNode( $id, $linktext );
                $linktext{$id}= $linktext;
                push @{ $typeRows[$row++] }, $idx++;
                $type;  # Store this in @types
            }
        } @types;
    }

    if(  ! $q-&gt;can("delete_param")  ) {
        *CGI::delete_param= sub {
            my( $self, $param )= @_;
            @{$self-&gt;{'.parameters'}}=
                grep $_ ne $param, @{$self-&gt;{'.parameters'}};
            delete $self-&gt;{$param};
        };
    }

    my %typeTable= qw(
        snippet         snippet
        bookreview      review
        modulereview    review
        sourcecode      sourcecode
        poll            polls
    );
    my %fieldOfTable= (
        snippet =&gt; [qw( snippetdesc snippetcode )],
        review =&gt; [qw( itemdescription usercomment doctext )],
        sourcecode =&gt; [qw( codedescription doctext )],
        polls =&gt; ['choices'],
    );

    # Make &amp;Wi check the box like &amp;Wi= does
    # And make &amp;Wi=0 uncheck a box:
    for my $abbr (  values %abbr  ) {
        my @vals= $q-&gt;param( $abbr );
        if(  @vals  &amp;&amp;  "0" ne $vals[-1]  ) {
            $q-&gt;param( $abbr, "1" );
        } else {
            $q-&gt;delete_param( $abbr );
        }
    }
    for my $p (  qw( xa xpa xr xs )  ) {
        my @vals= $q-&gt;param( $p );
        $q-&gt;delete_param( $p )
            if  @vals  &amp;&amp;  "0" eq $vals[-1];
    }

    # Build URL that would repeat this search
    my $url= do {
        my %p= map { $_ =&gt; ( '', $q-&gt;param($_) )[-1] } $q-&gt;param();
        delete @p{qw/ node_id nx go n0 BIR HIR BER HER as_user /}; # keep HIR/HER?
        for my $p (  qw( BIS HIS BES HES )  ) {
            delete $p{$p}   if  " " eq $p{$p};
        }
        for my $p (  keys %p  ) {
            delete $p{$p}   if  '' eq $p{$p};
        }
        delete $p{re}   if  "S" eq $p{re};
        delete $p{BH}   if  $p{BH};
        delete $p{nf}   if  $p{nf};
        # Use short form for section checkboxes:
        my $sect= '';
        for my $abbr (  values %abbr  ) {
            $sect .= ";$abbr"
                if  delete $p{$abbr};
        }
        join '',
            "?node_id=$NODE-&gt;{node_id}",
            join( ';', '',
                map "$_=" . $q-&gt;escape($p{$_}),
                grep exists $p{$_}, $q-&gt;param() ),
            $sect;
    };

    my @sects;
    my $sects= do {
        my $negSects= ( $q-&gt;param("xs") )[-1] ? 1 : 0;
        my %checked;
        @checked{keys %abbr}= map {
            ( ()= $q-&gt;param($abbr{$_}) ) ? 1 : 0;
        } keys %abbr;
        @sects= grep $negSects != $checked{$_}, keys %abbr;
        @sects= @types   if  ! @sects;
        join ", ", map $typeId{$_}, @sects;
    };

    my @criteria;

    my $umsg= '&lt;br /&gt;';
    my $pmsg= '&lt;br /&gt;replies to nodes ';
    foreach my $tuple (
        ['a','xa','n',\$umsg],
        ['pa','xpa','parent',\$pmsg]
    ) {
        my ($txtparam,$xparam,$talias,$msgref)=@$tuple;

        my @users= grep length, $q-&gt;param($txtparam);  #[
        if(  1 == @users  &amp;&amp;  $users[0] =~ m#^(\s*\[[^\]]+\])+\s*$#  ) {   #[
            @users= $users[0] =~ m#\[([^\]]+)\]#g;
        }
        for my $user (  @users  ) {
            my $type = "user";
            my $reason = "does not exist";
            my $U;
            if(  $user !~ m#^id://(\d+)$#  ) {
                $U = getNode( $user, "user" ) || getNode( $user, "usergroup" );
            } else {
                ( $type, $user ) = ( "node ID", $1 );
                $U = getNodeById( $user )   if  $user;
                if(  $U  &amp;&amp;  $U-&gt;{type}{title} !~ /^user/ ) {
                    undef $U;
                    $reason = "is not a user";
                }
            }
            if(  $U  ) {
                $user= getId($U);
            } else {
                push @errors, qq[\u$type "]
                    . $q-&gt;escapeHTML($user) . qq[" $reason.];
                $user= 0;
            }
        }
        @users= grep $_, @users;
        my $negAuthor= ( $q-&gt;param($xparam) )[-1] ? 1 : 0;
        $negAuthor= $negAuthor ? " NOT" : "";
        if(  @users  ) {
            push @criteria, "$talias.author_user$negAuthor IN ( "
                . join( ", ", @users ) . " )";
            $$msgref .= qq[written by ]
                  . ( $negAuthor ? "anyone but " : "any of " )
                  . join ", ", map linkNode($_), @users;
        } else {
            $$msgref="";
        }
    }

    my $replies= ( $q-&gt;param("re") )[-1];
    $q-&gt;param( "re", $replies );
    my $xRoots= 0 + grep '0' ne $_, $q-&gt;param("xr");
    my $note= getId( getType("note") );

    push @criteria, do {
        if(  "N" eq $replies  ) {           # No replies:
            push @errors,
                "No root nodes and no replies means no search."
                if  $xRoots;
            $xRoots
                ? "n.node_id = 0"
                : "n.type_nodetype IN ( $sects )";
        } elsif(  "A" eq $replies           # All replies (same as
              ||  @sects == @types  ) {     #  re.s from all sects):
            $xRoots
                ? "n.type_nodetype = $note"
                : "n.type_nodetype IN ( $note, $sects )";
        } else {                            # Replies from selected sections:
            $q-&gt;param( "re", undef );
            my $c= "( n.type_nodetype = $note"
                . " AND root.type_nodetype IN ( $sects ) )";
            $xRoots
                ? $c
                : "( n.type_nodetype IN ( $sects ) OR $c )";
        }
    };

    # ( Head Body ) + ( Includes Excludes ) + ( Terms Separator Regex=0|1 )
    my $bir= ( $q-&gt;param("BIR") )[-1] ? 1 : 0;  # @bodyHas are regexes
    my $ber= ( $q-&gt;param("BER") )[-1] ? 1 : 0;  # @bodyLacks are regexes
    my $hir= ( $q-&gt;param("HIR") )[-1] ? 1 : 0;  # @headHas are regexes
    my $her= ( $q-&gt;param("HER") )[-1] ? 1 : 0;  # @headLacks are regexes
    my $isGod= isGod($USER);
    if(  !$isGod  and  ( $bir || $ber )  ) {
        push @errors, "Unfortunately, regexes use too much"
            . " server CPU time, so their use is reserved for [gods]."
    }

    my $getTerms= sub {
        my( $textParam, $sepParam )= @_;
        my $str= $q-&gt;param( $textParam );
        my $sep= $q-&gt;param( $sepParam );
        $sep =~ s/^\s*//;
        $sep =~ s/\s*$//;
        $sep= " "   if  ! length $sep;
        $q-&gt;param( $sepParam, $sep );
        my @terms= grep length, split /\Q$sep/, $str;
        $q-&gt;param( $textParam, join $sep, @terms );
        return @terms;
    };
    my @headHas=   $getTerms-&gt;( "HIT", "HIS" );
    my @headLacks= $getTerms-&gt;( "HET", "HES" );
    my @bodyHas=   $getTerms-&gt;( "BIT", "BIS" );
    my @bodyLacks= $getTerms-&gt;( "BET", "BES" );

    my( @tables, @fields );
    push @tables, 'note',
        "left join node as root on root.node_id=root_node";
    if(  $pmsg  ) {
        push @tables,
          "left join node as parent on parent.node_id=parent_node";
    }
    if(  @bodyHas  ||  @bodyLacks  ) {
        my( %tables, %fields );
        push @sects, 'note'
            unless  'N' eq $replies;
        for my $type (  @sects  ) {
            if(  $typeTable{$type}  ) {
                ++$tables{ $typeTable{$type} };
                ++$fields{$_}
                    for  @{  $fieldOfTable{ $typeTable{$type} }  };
            } else {
                ++$tables{document};
                ++$fields{doctext};
            }
        }
        push @tables, keys %tables;
        push @fields, keys %fields;
    }

    my $tables= "node as n";
    for my $table (  @tables  ) {
        if(  $table =~ / /  ) {
            $tables .= "\n$table";
        } else {
            $tables .= "\nleft join $table on ${table}_id=n.node_id";
        }
    }

    my $termMatch= sub {
        my( $not, $regex, $avFields, @terms )= @_;
        if(  ! @terms  ) {
            ; # Nothing.
        } elsif(  $regex  ) {
            for my $term (  @terms  ) {
                my $safe= htmlcode('saferegex','',$term);
                if(  $safe =~ s#^\\9##  ) {
                    push @errors, $safe;
                    last;
                }
                $safe =~ s#([\\'])#\\$1#g;
                push @criteria, "( " . join( " OR ", map {
                    "$_ RLIKE '$safe'";
                } @$avFields ) . " )";
                $criteria[-1]= "NOT COALESCE( $criteria[-1], 0=1 )"
                    if  $not;
            }
        } else {
            push @criteria, map {
                my $quoted= $_;
                $quoted =~ s#\\#\\\\#g;     # MySQL quirk
                $quoted =~ s#([\\'%_])#\\$1#g;
                ( $not ? "NOT COALESCE( " : "" )
                .  "( " . join( " OR ", map {
                    "$_ LIKE '%$quoted%'";
                } @$avFields ) . " )"
                . ( $not ? ", 0=1 )" : "" )
            } @terms;
        }
    };
    $termMatch-&gt;( "",    $hir, ["n.title"], @headHas );
    $termMatch-&gt;( "NOT", $her, ["n.title"], @headLacks );
    $termMatch-&gt;( "NOT", $ber, \@fields,    @bodyLacks );
    if(  ( $q-&gt;param("BH") )[-1]  ) {
        push @fields, 'n.title';
    }
    $termMatch-&gt;( "",    $bir, \@fields,    @bodyHas );

    my $oldFirst= ! ( $q-&gt;param("nf") )[-1];
    my $dir= $oldFirst ? +1 : -1;
    my $lastNode= $DB-&gt;sqlSelect( "max(node_id)", "node" );

    my $n0= 0;
    if(  $q-&gt;param("nx")  ) {                           # Continue search:
        $n0= ( $q-&gt;param("n0") )[-1]
            or  push @errors, qq[Strange, you asked me to continue]
                    . qq[ but I don't know where to continue from.];
    } elsif(  ( $q-&gt;param("yr") )[-1]  ) {      # Search from date:
        my( $yr, $mo, $dy )= map { ( $q-&gt;param($_) )[-1] } qw( yr mo dy );
        $mo ||= 1;
        $dy ||= 1;
        my $date= join "-", map sprintf("%02d",$_), $yr, $mo, $dy;
        $n0= $DB-&gt;sqlSelect(
            "node_id",
            "node",
            "createtime &gt;= '$date'",
            "order by createtime limit 1"
        );
    } elsif(  $q-&gt;param("go")  ) {              # New search:
        $n0= $oldFirst ? 1 : $lastNode;
    }

    my $doSearch=  $n0  &amp;&amp;  ! @errors  ||  0;

    push @criteria, "n.node_id BETWEEN !TBD!";

    my $html= '';
    my $limit= 50;
    if(     $doSearch
        &amp;&amp;  "POST" ne uc $q-&gt;request_method()
        &amp;&amp;  $USER-&gt;{user_id} != ( $q-&gt;param("as_user") )[-1]
        &amp;&amp;  $USER-&gt;{title}   ne ( $q-&gt;param("as_user") )[-1]
    ) {
        $html .= join '',
            qq[&lt;p&gt;You must specify as_user=$USER-&gt;{user_id}],
            qq[ in the URL to have the search start immediately\n],
            qq[ when the link is followed (or send the request],
            qq[ by POSTing from a form instead).\n  Simply press],
            qq[ the Search button below, now.&lt;/p&gt;\n];
        $doSearch= 0;
    }
    if(  ! $doSearch  ) {
        $html .= qq[&lt;p align="right"&gt;&lt;a href="/?node_id=590032"&gt;]
          . qq[Help for this page&lt;/a&gt;&lt;/p&gt;];
        $html .= qq[&lt;p&gt;You can also try using]
          . qq[ &lt;a href="http://www.google.com/advanced_search]
          . qq[?hl=en&amp;as_sitesearch=www.perlmonks.org"&gt;Google's]
          . qq[ advanced search&lt;/a&gt; against PerlMonks.&lt;/p&gt;\n];
        if(  $isGod  ) {
            $html .= qq[&lt;p&gt;]
              . qq[Please use regex searches sparingly.  A regex search uses]
              . qq[ much more CPU time on the database server.]
              . qq[&lt;/p&gt;];
        }
    } else {
        Everything::printLog( "node=$NODE-&gt;{node_id}($NODE-&gt;{node_title})"
            . " ip=$ENV{REMOTE_ADDR} user=$USER-&gt;{title}"
            . " q=" . $q-&gt;query_string() );
        require Time::HiRes;
        my @matches;
        my $start= $n0;
        my $startTime= Time::HiRes::time();
        while(  1  ) {

            my( $min, $max );
            if(  $oldFirst  ) {
                ( $min, $max )= ( $n0, $n0+10000 );
                $max= 1000 * int( $max/1000 + 0.5 );
                $max= $lastNode   if  $lastNode &lt; $max;
            } else {
                ( $min, $max )= ( $n0-10000, $n0 );
                $min= 1000 * int( $min/1000 + 0.5 );
                $min= 1   if  $min &lt; 1;
            }
            $criteria[-1]= "n.node_id BETWEEN $min AND $max";

            my $explainTime= Time::HiRes::time();
            my $sql= qq[
                SELECT n.node_id, n.title, n.type_nodetype,
                       n.author_user, n.createtime, root.type_nodetype
                FROM   $tables
                WHERE  ] . join( " AND ", @criteria ) . qq[
                ORDER BY n.node_id ] . ( $oldFirst ? "" : "DESC" ) . qq[
                LIMIT ] . ( $limit - @matches );
            my $explain= $DB-&gt;getDatabaseHandle()-&gt;prepare(
                "EXPLAIN $sql" );
            $explain-&gt;execute();
            my $rec= $explain-&gt;fetchrow_hashref();
            $explain-&gt;finish();
            my $key_used= $rec-&gt;{key};
            my $key_rows= $rec-&gt;{rows};
            my $comment= $rec-&gt;{Comment};

            if(  $start == $n0  ) {
                $html .= "\n&lt;!--\n$sql\n";
                $html .= $/ . $q-&gt;table(
                    map {
                        my $val= delete $rec-&gt;{$_};
                        ( my $head= $_ ) =~ s/.*_//;
                        defined $val
                            ? $q-&gt;Tr( $q-&gt;td($head), $q-&gt;td($val) )
                            : ();
                    } qw( table type rows possible_keys key
                          key_len Extra ), keys %$rec
                ) . "\n--&gt;\n";
            }

            $explainTime= Time::HiRes::time() - $explainTime;
            if(  3 &lt; $explainTime  ) {
                push @errors, ( $start==$n0 ? "Q" : "Remainder of q" )
                  . qq[uery was not run;  Server is too busy ]
                  . sprintf
                      qq[("explain" took %.2f seconds)], $explainTime;
                last;
            }

#            if(  15000 &lt; $key_rows  ) {
            if ( 25000 &lt; $key_rows ) {
                push @errors, ( $start==$n0 ? "Q" : "Remainder of q" )
                  . "uery would not run quickly"
                  . ( $comment ? " ($comment)" : "" ) . ".";
                last;
            }

            my $cursor= $DB-&gt;sqlSelectMany(
                "n.node_id as node_id, n.title as title,
                 n.type_nodetype as type_nodetype,
                 n.author_user as author_user, n.createtime as createtime,
                 root.node_id as root_node_id,
                 root.type_nodetype as root_nodetype",
                $tables,
                join( " AND ", @criteria ),
                "ORDER BY n.node_id " . ( $oldFirst ? "" : "DESC" )
                . " LIMIT " . ( $limit - @matches ),
            );
            my $results = $cursor-&gt;fetchall_arrayref({});
            push @matches, @$results;
            $cursor-&gt;finish();

            if(  $limit &lt;= @matches  ) {
                $n0= $dir + $matches[-1]{node_id};
                last;
            }
            $n0= $dir + ( $oldFirst ? $max : $min );
            last   if  $n0 &lt; 1  ||  $lastNode &lt; $n0;
            my $runTime= Time::HiRes::time() - $startTime;
            if(  10 &lt; $runTime  ) {
                push @errors, ( $start==$n0 ? "Q" : "Remainder of q" )
                    . qq[uery was not run ] . sprintf
                      qq[(used %.2f seconds so far)], $runTime;
                last;
            }
        }
        if(  $n0 == $start  ) {
            $doSearch= 2;       # "Retry"
        }
        if(  $n0 &lt; 1  ||  $lastNode &lt; $n0  ) {
            $doSearch= -1;      # Search finished.
        }

        my $startDate= ( split " ", $DB-&gt;sqlSelect(
            "createtime","node","node_id=$start") )[0];
        my $endDate= ( split " ", $DB-&gt;sqlSelect(
            "createtime","node","node_id=".($n0-$dir)) )[0];
        my $matches= @matches;

        $html .= qq[&lt;p&gt;&lt;hr /&gt;&lt;div class="ss-result-summary"&gt;
            &lt;b&gt;Found $matches node] . ( 1==$matches ? "" : "s" ) .qq[&lt;/b&gt;]
          #. ( 0 &lt; $doSearch ? " (so far)" : "" )
          . qq[ roughly between $startDate and $endDate]
          . qq[ (searched ] . sprintf( "%.2f",
              100*( abs($n0-$start)+1 ) / $lastNode
            ) . qq[% of DB).&lt;/div&gt;&lt;br /&gt;\n&lt;div class="ss-criteria-summary"&gt;\n];

        if(  @bodyHas  ||  @bodyLacks  ||  @headHas  ||  @headLacks  ) {
            $html .= qq[&lt;br /&gt;where ] . join qq[&lt;br /&gt;and ],
                map {
                    my( $desc, $regex, $plur, @terms )= @$_;
                    if(  ! @terms  ) {
                        ();
                    } else {
                        if(  $regex  ) {
                            $desc =~ s/ contain / match /;
                            $desc =~ s/ contains / matches /;
                        }
                        $desc .= $plur    if  1 &lt; @terms;
                        $desc . join( ", ", map {
                            qq["&lt;tt&gt;] . $q-&gt;escapeHTML($_) . qq[&lt;/tt&gt;"]
                        } @terms )
                    }
                } ["any text contains ",$bir,"all of ",@bodyHas],
                  ["no text contains ",$ber,"any of ",@bodyLacks],
                  ["title contains ",$hir,"all of ",@headHas],
                  ["title doesn't contain ",$her,"any of ",@headLacks],
        }


        $html .= $umsg; # user message
        $html .= $pmsg; # parent message

        $html .= qq[&lt;/div&gt;&lt;/p&gt;\n];

        $html .= qq[&lt;p&gt;&lt;table width="100%" class="ss-result-table"&gt;];
        for my $rec (  @matches  ) {
            my( $date )= split " ", $rec-&gt;{createtime};
            $html .= $/." "x4 . $q-&gt;Tr(
                $q-&gt;td( $date ), $/." "x8,
                $q-&gt;td( linkNode($rec-&gt;{author_user}) ), $/." "x8,
                $q-&gt;td( linkNode($rec) ),
                $/." "x8, $q-&gt;td(
                    $note == $rec-&gt;{type_nodetype}
                        ? "Re:" . linkNode($rec-&gt;{root_node_id}, $linktext{ $rec-&gt;{root_nodetype} })
                        : $link{ $rec-&gt;{type_nodetype} }
                ),
            );
        }
        $html .= qq[&lt;/table&gt;&lt;/p&gt;\n];
    }

    $q-&gt;param( "n0", $n0 );
    $html .= $/ . htmlcode('openform')
        . $q-&gt;hidden("n0") . $/;

    if(  $doSearch  ) {
        $html .= qq[\n&lt;p class="ss-search-continue"&gt;];
        if(  -1 == $doSearch  ) {
            $html .= qq[Finished searching database.\n];
        } else {
            my( $min, $max )= $oldFirst ? ( $n0, $lastNode ) : ( 1, $n0 );
            my $pct= sprintf "%.2f%%", 100*($max-$min+1)/$lastNode;
            if(  1 == $doSearch  ) {
                $html .= qq[Press ]
                  . $q-&gt;submit( "nx", "Next &gt;" )
                  . qq[ to &lt;b&gt;continue&lt;/b&gt; searching remaining $pct of DB.];
            } else {
                $pct= " remaining $pct of DB";
                $pct= ""   if  1 == $min  &amp;&amp;  $max == $lastNode;
                $html .= qq[Press ]
                  . $q-&gt;submit( "nx", "Retry" )
                  . qq[ to &lt;b&gt;retry&lt;/b&gt; searching$pct.];
            }
            $html .= qq[&lt;br /&gt;\n]
                . qq[Please be patient after submitting your search.\n];
        }
        $html .= qq[&lt;/p&gt;\n&lt;p class="ss-preload-link"&gt;Link to preload this search: ]
            . qq[&lt;a href="$url"&gt;&amp;#91;href://$url&amp;#93;&lt;/a&gt;&lt;/p&gt;]
            . "&lt;hr /&gt;\n";
    }

    $html .= qq[&lt;p&gt;] . linkNode( $NODE, "Reset search form" ) . qq[&lt;/p&gt;\n];

    $html .= qq[&lt;p&gt;
        Match &lt;b&gt;text&lt;/b&gt; containing ]
      . $q-&gt;textfield( "BIT", "", 60 )
      . qq[&lt;br /&gt;(separate ]
      . ( !$isGod
            ? "strings"
            : $q-&gt;radio_group( "BIR", [ "0", "1" ], "0", 0,
                { 0=&gt;"strings -or- regexes", 1=&gt;"" } )
        ) . qq[ with ]
      . $q-&gt;textfield( "BIS", " ", 2 )
      . qq[ -- default is spaces)&lt;br /&gt;]
      . $q-&gt;radio_group( "BH", [ "0", "1" ], "1", 0,
            { 0=&gt;"Don't match -or-", 1=&gt;"Also match" },
        ) . qq[ &lt;b&gt;titles&lt;/b&gt; against above.&lt;/p&gt;];

    $html .= $/ . "&lt;p&gt;"
      . ( 0&lt;$doSearch ? qq[New ] : "" )
      . $q-&gt;submit( "go", "Search" )
      . qq[ Please be patient after submitting your search.\n&lt;/p&gt;];

    $html .= qq[&lt;p&gt;
        Match &lt;b&gt;titles&lt;/b&gt; containing ]
      . $q-&gt;textfield( "HIT", "", 60 )
      . qq[&lt;br /&gt;(separate ]
      . ( !$isGod
            ? "strings"
            : $q-&gt;radio_group( "HIR", [ "0", "1" ], "0", 0,
                { 0=&gt;"strings -or- regexes", 1=&gt;"" } )
        ) . qq[ with ]
      . $q-&gt;textfield( "HIS", " ", 2 )
      . qq[ -- default is spaces)&lt;/p&gt;];

    $html .= qq[&lt;p&gt;
        ] . $q-&gt;radio_group(
            "xa", [ "0", "1" ], "0", 0, { 0=&gt;"Match -or-", 1=&gt;"Exclude" },
        ) . qq[ &lt;b&gt;authors&lt;/b&gt; ] . $q-&gt;textfield( "a", "", 20 ) . qq[&lt;br /&gt;
        (use "&amp;#91;one&amp;#93; &amp;#91;two&amp;#93;" to list multiple authors)&lt;br /&gt;
        (Searching by author doesn't work for Categorized Questions and
        Answers yet.)&lt;/p&gt;];

    $html .= qq[&lt;p&gt;
        Search ] . $q-&gt;radio_group(
            -name=&gt;"nf", -values=&gt;[ "1", "0" ], -default=&gt;"1",
            -labels=&gt;{ 1=&gt;"Newest first -or-", 0=&gt;"Oldest first" },
        ) . qq[,&lt;br /&gt;starting at ];
    $html .= do {
        my $yr= 1900 + (localtime)[5];
        my @yr= ( "", 2000..$yr );
        my %yr;  @yr{@yr}= ( "Year", map {
            my $k= ('','A'..'Z')[$_];
            $k &amp;&amp;= "$k) ";
            "$k$yr[$_]"
        } 1..$#yr );
        $q-&gt;popup_menu( "yr", \@yr, "", \%yr );
    };
    $html .= " - " . do {
        my @mo= ( "", '01'..'12' );
        my %mo;  @mo{@mo}= ( "Month", map {
            $_ . " " .
            (qw( Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec ))[$_-1];
        } 1..12 );
        $q-&gt;popup_menu( "mo", \@mo, "", \%mo );
    };
    $html .= " - " . do {
        my @dy= ( "", '01'..'31' );
        my %dy;  @dy{@dy}= ( "Day", '01'..'31' );
        $q-&gt;popup_menu( "dy", \@dy, "", \%dy );
    };
    $html .= qq[.&lt;/p&gt;];

    # $html .= qq[&lt;!-- &lt;p&gt; Show {10|20|50} matches per page.&lt;/p&gt; --&gt;];

    $html .= qq[&lt;p&gt;
        Search ] . $q-&gt;radio_group(
            "xs", [0,1], 0, 0, {0=&gt;"only -or-",1=&gt;"all but"},
        ) . qq[&lt;br /&gt;the following &lt;b&gt;sections&lt;/b&gt;:];
    $html .= qq[&lt;ul&gt;] . $q-&gt;table(
        map(
            "\n    "
            . $q-&gt;Tr(
                map "\n        " . $q-&gt;td(
                    $q-&gt;checkbox(
                        -name =&gt; $abbr{$types[$_]},
                        -value =&gt; "1",
                        -label =&gt; $desc{$types[$_]},
                        )
                ), @$_
            ), @typeRows,
        ), $/
    ) . qq[&lt;/ul&gt;\n];

    $html .= qq[&lt;p&gt;
        &lt;i&gt;Skip&lt;/i&gt; &lt;b&gt;text&lt;/b&gt; containing ]
      . $q-&gt;textfield( "BET", "", 60 )
      . qq[&lt;br /&gt;(separate ]
      . ( !$isGod
            ? "strings"
            : $q-&gt;radio_group( "BER", [ "0", "1" ], "0", 0,
                { 0=&gt;"strings -or- regexes", 1=&gt;"" } )
        ) . qq[ with ]
      . $q-&gt;textfield( "BES", " ", 2 )
      . qq[ -- default is spaces)&lt;br /&gt;
        (Does not exclude based on titles)&lt;/p&gt;];

    $html .= qq[&lt;p&gt;
        &lt;i&gt;Skip&lt;/i&gt; &lt;b&gt;titles&lt;/b&gt; containing ]
      . $q-&gt;textfield( "HET", "", 60 )
      . qq[&lt;br /&gt;(separate ]
      . ( !$isGod
            ? "strings"
            : $q-&gt;radio_group( "HER", [ "0", "1" ], "0", 0,
                { 0=&gt;"strings -or- regexes", 1=&gt;"" } )
        ) . qq[ with ]
      . $q-&gt;textfield( "HES", " ", 2 )
      . qq[ -- default is spaces)&lt;/p&gt;];

    $html .= qq[&lt;/p&gt;&lt;p&gt;\n] . $q-&gt;radio_group(
        "xr", ["0","1"], "0", 1, {
            0 =&gt; "Include &lt;b&gt;root&lt;/b&gt; nodes from selected sections",
            1 =&gt; "Don't include &lt;b&gt;root&lt;/b&gt; nodes",
        },
    );

    $html .= qq[&lt;/p&gt;&lt;p&gt;\n] . $q-&gt;radio_group(
        "re", [qw( A S N )], "S", 1, {
            A =&gt; "Include &lt;b&gt;replies&lt;/b&gt; from &lt;i&gt;any&lt;/i&gt; section",
            S =&gt; "Include &lt;b&gt;replies&lt;/b&gt; from &lt;i&gt;selected&lt;/i&gt; sections",
            N =&gt; "&lt;i&gt;Don't&lt;/i&gt; include &lt;b&gt;replies&lt;/b&gt;",
        },
    );
    $html .= join $/, '&lt;p&gt;',
        $q-&gt;radio_group(
            "xpa", [ "0", "1" ], "0", 0, { 0=&gt;"Match -or-", 1=&gt;"Exclude" },
        ),
        qq[&lt;b&gt;parent node's author&lt;/b&gt;],
        $q-&gt;textfield( "pa", "", 20 ),
        '&lt;br /&gt;',
        '(use "&amp;#91;one&amp;#93; &amp;#91;two&amp;#93;" to list multiple authors)&lt;br /&gt;',
        "(This doesn't work for Categorized Questions and Answers yet.)&lt;/p&gt;";

    $html .= $/ . "&lt;p&gt;"
      . ( 0&lt;$doSearch ? qq[New ] : "" )
      . $q-&gt;submit( "go", "Search" )
      . qq[ Please be patient after submitting your search.\n&lt;/p&gt;];

    $html .= qq[&lt;/form&gt;\n];

    $html .= qq[\n&lt;!-- CGI::VERSION=$CGI::VERSION --&gt;\n];

    $_ .= "&lt;br /&gt;\n"   for  @errors;
    return "&lt;b&gt;" . join( "", @errors ) . "&lt;/b&gt;$html";
%]
</live_code>
<reason>exclude as_user from preload link url</reason>
<field>doctext</field>
</record>
<record><htmlcode_id>775728</htmlcode_id>
<patch_code>/* This CSS controls the Night Shift theme. */

.reply-new-body, .reply-body,
body {
  color:            #080;
  background-color: #000;
}
td { color: #007F00; }
tr.titlebar { background-color: #003600; }
tr.section_title {
  color:            #000;
  background-color: #003600;
}
td.section_title {
  color:            #000;
  background-color: #003600;
}
tr.post_head, tr.ntc-head { background-color: #003600; }
.highlight { background-color: #003600; }
td.titlebar  { color: #0A0; }
table.nodelet_container { background-color: #003600; }
a:link    { color: #00C600  }
a:visited { color: #0A0 }
a.titlebar:link, a.titlebar:visited { color: #0A0; }

tbody.nodelet td, td.nodebody { background-color: #000; }
tbody.nodelet th, th.nodehead {
  color:             "080";
  background-color:  #000;
}

tbody.nodelet th a:link, tbody.nodelet th a:visited { color: #080; }

div.readmore {background-color: #222;}
.chatsubmit { background-color: #003600; }
.comment-on { background-color: #003600; }

</patch_code>
<applied>2009-06-29 12:40:09</applied>
<htmlcode_id>5103</htmlcode_id>
<live_code>/* This CSS controls the Night Shift theme. */

.reply-new-body, .reply-body,
body {
  color:            #080;
  background-color: #000;
}
td { color: #007F00; }
tr.titlebar, h2.titlebar { background-color: #003600; }
tr.section_title {
  color:            #000;
  background-color: #003600;
}
td.section_title {
  color:            #000;
  background-color: #003600;
}
tr.post_head, tr.ntc-head { background-color: #003600; }
.highlight { background-color: #003600; }
td.titlebar  { color: #0A0; }
table.nodelet_container { background-color: #003600; }
a:link    { color: #00C600  }
a:visited { color: #0A0 }
a.titlebar:link, a.titlebar:visited { color: #0A0; }

tbody.nodelet td, td.nodebody { background-color: #000; }
tbody.nodelet th, th.nodehead {
  color:             "080";
  background-color:  #000;
}

tbody.nodelet th a:link, tbody.nodelet th a:visited { color: #080; }

div.readmore {background-color: #222;}
.chatsubmit { background-color: #003600; }
.comment-on { background-color: #003600; }
table#replies_table { background-color: #003600; }

</live_code>
<reason>replace 'highlight' in ntc</reason>
<field>doctext</field>
</record>
<record><htmlcode_id>775727</htmlcode_id>
<patch_code>/* This CSS controls the JBlue theme. */

.reply-new-body, .reply-body,
body {
  color:            #F0FC05;
  background-color: #010D5D;
}
td { color: #F0FC05; }
tr.titlebar { background-color: #800; }
tr.section_title {
  color:            #FFF;
  background-color: #800;
}
td.section_title {
  color:            #FFF;
  background-color: #800;
}
tr.post_head, tr.ntc-head, .highlight { background-color: #604; }
td.titlebar { color: #FFF; }
table.nodelet_container { background-color: #800; }
a:link    { color: #FFF  }
a:visited { color: #DDD }
a.titlebar:link, a.titlebar:visited { color: #FFF; }

tbody.nodelet td, td.nodebody { background-color: #010D5B; }
tbody.nodelet th, th.nodehead {
  color: #F0FC05;
  background-color: #800;
}

tbody.nodelet th a:link, tbody.nodelet th a:visited { color: #F0FC05; }

div.readmore {background-color: #222;}
.chatsubmit { background-color: #800; }
.comment-on { background-color: #800; }
</patch_code>
<applied>2009-06-29 12:40:10</applied>
<htmlcode_id>6181</htmlcode_id>
<live_code>/* This CSS controls the JBlue theme. */

.reply-new-body, .reply-body,
body {
  color:            #F0FC05;
  background-color: #010D5D;
}
td { color: #F0FC05; }
tr.titlebar, h2.titlebar { background-color: #800; }
tr.section_title {
  color:            #FFF;
  background-color: #800;
}
td.section_title {
  color:            #FFF;
  background-color: #800;
}
tr.post_head, tr.ntc-head, .highlight { background-color: #604; }
td.titlebar { color: #FFF; }
table.nodelet_container { background-color: #800; }
a:link    { color: #FFF  }
a:visited { color: #DDD }
a.titlebar:link, a.titlebar:visited { color: #FFF; }

tbody.nodelet td, td.nodebody { background-color: #010D5B; }
tbody.nodelet th, th.nodehead {
  color: #F0FC05;
  background-color: #800;
}

tbody.nodelet th a:link, tbody.nodelet th a:visited { color: #F0FC05; }

div.readmore {background-color: #222;}
.chatsubmit { background-color: #800; }
.comment-on { background-color: #800; }
table#replies_table { background-color: #800; }
</live_code>
<reason>replace 'highlight' in ntc</reason>
<field>doctext</field>
</record>
<record><htmlcode_id>775726</htmlcode_id>
<patch_code>/* This CSS controls the Green Web-Safe theme. */

body {
  color:            #000;
  background-color: #FFF;
}
td { color: #000; }
tr.titlebar { background-color: #030; }
tr.section_title {
  color:            #FFF;
  background-color: #050;
}
td.section_title {
  color:            #FFF;
  background-color: #050;
}
tr.post_head, tr.ntc-head, .highlight { background-color: #CCC; }
td.titlebar { color: #FFF; }
table.nodelet_container { background-color: #030; }
a:link    { color: #060  }
a:visited { color: #666 }
a.titlebar:link, a.titlebar:visited { color: #FFF; }

tbody.nodelet td, td.nodebody { background-color: #FFF; }
tbody.nodelet th, th.nodehead {
  color:             #FFF;
  background-color:  #030;
}
tbody.nodelet th a:link, tbody.nodelet th a:visited { color: #FFF; }
.chatsubmit { background-color: #030; }
.comment-on { background-color: #030; }
</patch_code>
<applied>2009-06-29 12:40:11</applied>
<htmlcode_id>6182</htmlcode_id>
<live_code>/* This CSS controls the Green Web-Safe theme. */

body {
  color:            #000;
  background-color: #FFF;
}
td { color: #000; }
tr.titlebar, h2.titlebar,
tr.titlebar td,
tr.section_title {
  color:            #FFF;
  background-color: #050;
}
td.section_title {
  color:            #FFF;
  background-color: #050;
}
tr.post_head, tr.ntc-head, .highlight { background-color: #CCC; }
td.titlebar { color: #FFF; }
table.nodelet_container { background-color: #030; }
a:link    { color: #060  }
a:visited { color: #666 }
a.titlebar:link, a.titlebar:visited { color: #FFF; }

tbody.nodelet td, td.nodebody { background-color: #FFF; }
tbody.nodelet th, th.nodehead {
  color:             #FFF;
  background-color:  #030;
}
tbody.nodelet th a:link, tbody.nodelet th a:visited { color: #FFF; }
.chatsubmit { background-color: #030; }
.comment-on { background-color: #030; }
table#replies_table { background-color: #030; }
</live_code>
<reason>replace 'highlight' in ntc</reason>
<field>doctext</field>
</record>
<record><htmlcode_id>676727</htmlcode_id>
<patch_code>[{get_sitedoclet}]
&lt;p&gt;
[{newlistapproved:request,perlcraft approved linktype,Your requests for the editor,10,navbaron,showall}]
[%
if(isGod($USER)){
   return htmlcode('newmoderatelist','request,perlcraft approved linktype,Moderate this');
}
"";
%] 
[{addnewform:request,Add your request,Request}]
[{showhints}]
</patch_code>
<applied>2008-03-27 14:48:14</applied>
<htmlcode_id>6345</htmlcode_id>
<live_code>[{get_sitedoclet}]
&lt;p&gt;
[{newlistapproved:request,perlcraft approved linktype,Your requests for the editor,10,navbaron,showall}]
[%
if(isGod($USER)){
   return htmlcode('newmoderatelist','request,perlcraft approved linktype,Moderate this');
}
"";
%] 
[{addnewform:request,Add your request,Request}]
</live_code>
<reason>showhints</reason>
<field>doctext</field>
</record>
<record><htmlcode_id>726990</htmlcode_id>
<patch_code>[%

  if(  $q-&gt;param('usersearch')
   &amp;&amp; !$q-&gt;param('user')  ) {
    $q-&gt;param( user =&gt; $q-&gt;param('usersearch') );
  }

  my %order= (
    nf =&gt; 'createtime DESC',
    of =&gt; 'createtime ASC',
    bt =&gt; 'title ASC',
    rt =&gt; 'title DESC',
    hr =&gt; 'reputation DESC',
    lr =&gt; 'reputation ASC',
    rn =&gt; 'RAND()',
  );

  my %labels = (
    nf =&gt; 'Newest First',
    of =&gt; 'Oldest First',
    bt =&gt; 'By Title',
    rt =&gt; 'By Title Reverse',
    hr =&gt; 'Highest Reputation First',
    lr =&gt; 'Lowest Reputation First',
    rn =&gt; 'Random',
  );

  my $is_pmdev=Everything::isApproved($USER,getNode( 'pmdev', 'usergroup' ) );

  my %types = (
    ''                     =&gt; 'All Types',
    'note'                 =&gt; 'Reply',
# these are handled by $showqa
#    'categorized answer'   =&gt; 'Q&amp;amp;A Answer',
#    'categorized question' =&gt; 'Q&amp;amp;A Question',
    'snippet'              =&gt; 'Snippet',
    'sourcecode'           =&gt; 'Source code',
    'perlquestion'         =&gt; 'Seekers of Perl Wisdom',
    'perlcraft'            =&gt; 'Craft',
    'perlmeditation'       =&gt; 'Meditation',
    'poem'                 =&gt; 'Perl Poetry',
    'CUFP'                 =&gt; 'Cool Uses for Perl',
    'obfuscated'           =&gt; 'Obfuscation',
    'perltutorial'         =&gt; 'Tutorial',
    'monkdiscuss'          =&gt; 'Perl Monks Discussion',
    'modulereview'         =&gt; 'Module Review',
    'bookreview'           =&gt; 'Book Review',
    'perlnews'             =&gt; 'Perl News',
    'pmdevtopic'           =&gt; 'Inner Scriptorium',
    'poll'                 =&gt; 'Poll',
    'offtopicroot'         =&gt; 'Off-Topic node',
    ($is_pmdev ? (
    'patch'                =&gt; 'Patch',
    'pmdevnote'            =&gt; 'PMDev Note',
    ) : ()),
  );
  my $str= '';

  if(  $q-&gt;param("orderby") =~ / /  ) {
    my %redro= reverse %order;
    $q-&gt;param( orderby =&gt;
      ( $redro{ $q-&gt;param("orderby") } || 'nf' ) );
  }

  $str .= qq[
    &lt;p&gt;
      This is where you can search for all the writeups contributed by any
      user.  Just enter the user name and select the order for the search.
    &lt;/p&gt;
    &lt;p&gt;
      ] . htmlcode( 'openform', -method =&gt; 'GET' ) . qq[
        &lt;table&gt;
          &lt;tr&gt;
            &lt;td align="right"&gt;
              Author:
            &lt;/td&gt;
            &lt;td&gt;
              ] . $q-&gt;textfield( 'user', htmlcode('randomusername') ) . qq[
            &lt;/td&gt;
            &lt;td width="5%"&gt;&lt;/td&gt;
            &lt;td align="right"&gt;
              Show ] . $q-&gt;textfield(
                            'length', $VARS-&gt;{pmuslen} || 50, 3 ) . qq[
            &lt;/td&gt;
            &lt;td&gt;
              nodes
            &lt;/td&gt;
          &lt;/tr&gt;
          &lt;tr&gt;
            &lt;td align="right"&gt;
              Order by:
            &lt;/td&gt;
            &lt;td&gt;
              ] . $q-&gt;popup_menu(
                    -name    =&gt; 'orderby',
                    -values  =&gt; [qw(nf of bt rt hr lr rn)],
                    -labels  =&gt; \%labels ) . qq[
            &lt;/td&gt;
            &lt;td&gt;&lt;/td&gt;
            &lt;td align="right"&gt;
              starting at
              ] . $q-&gt;textfield('start', '0', 3) . qq[
            &lt;/td&gt;
            &lt;td&gt;.&lt;/td&gt;
          &lt;/tr&gt;
          &lt;tr&gt;
            &lt;td align="right"&gt;
              Node Type:
            &lt;/td&gt;
            &lt;td&gt;
              ] . $q-&gt;popup_menu(
                    -name    =&gt; 'showtype',
                    -values  =&gt; [sort {$types{$a} cmp $types{$b}} keys %types],
                    -labels  =&gt; \%types ) . qq[
            &lt;/td&gt;
            &lt;td align="right"&gt;
              ] . $q-&gt;checkbox( -name =&gt; 'showqa', -label =&gt; '' ) . qq[
            &lt;/td&gt;
            &lt;td&gt;
              Show Categorized Q&amp;amp;A ([id://162297|Why?])
            &lt;/td&gt;
            &lt;td align="right"&gt;
              ] . $q-&gt;submit('sexisgood' =&gt; 'Search') . q[
            &lt;/td&gt;
          &lt;/tr&gt;
        &lt;/table&gt;
      &lt;/form&gt;
    &lt;hr /&gt;];

  my $showqa  = $q-&gt;param('showqa')     || 0;

  my $orderby = $q-&gt;param('orderby');
  $orderby= 'nf' if ! exists $order{$orderby};

  my $skip    = abs $q-&gt;param('start')  || 0;
  my $length  = abs $q-&gt;param('length') || $VARS-&gt;{pmuslen} || 50;

  if (  $q-&gt;param('user')  ) {
    my $user =
      getNode($q-&gt;param('user'), 'user')
      || getNode($q-&gt;param('user'), 'usergroup')
      || getNode($q-&gt;param('user'),'zombie_user')
    or return $str . q[It seems that "] . $q-&gt;escapeHTML( $q-&gt;param('user') )
         . q[" does not exist.  How very, very strange...];

    my $count = getVars($user)-&gt;{numwriteups};
    my $showrep =
         isGod($USER)
     ||     getId($user) == getId($USER)
         &amp;&amp; getId($USER) != $HTMLVARS{guest_user};

    # no sorting by hr or lr if $showtype set and $user ne $USER
    $orderby= 'nf' if ( $q-&gt;param('showtype')
                        and ($orderby eq 'hr' or $orderby eq 'lr')
                        and getId($user) != getId($USER)
                      );

    my @types = map {
      getId( getType($_) )
    } ( $q-&gt;param('showtype') || grep {length $_} keys %types );
    my $sql;

    if ( $showqa ) {
      $sql = sprintf q[
        SELECT    contributor_id
        FROM      contributor
        LEFT JOIN node
        ON        node_id = contributor_id
        WHERE     original_author = ?
        ORDER BY  %s
        LIMIT     %d, %d],
        $order{$orderby},
        $skip,
        1+$length;
    } else {
      $sql = sprintf q[
        SELECT    node_id
        FROM      node
        WHERE     author_user = ?
          AND     type_nodetype in (%s)
        ORDER BY  %s
        LIMIT     %d, %d],
      join(',', @types),
      $order{$orderby},
      $skip,
      1+$length;
    }

    my $sth  = $DB-&gt;getDatabaseHandle-&gt;prepare( $sql );

    $sth-&gt;execute( getId($user) );

    my @nodes;
    while ( my $id = $sth-&gt;fetchrow ) {
      push @nodes, $id;
    }

    return $str . sprintf(
        q[%s has no %swriteups, it seems.],
        linkNode($user), ($q-&gt;param('showtype')?"such ":"")
    ) if  not $skip  and  not @nodes;

    my @writeups;

    my $more= $length &lt; @nodes;
    pop @nodes   if  $more;
    my $i = 0;
    my $troll = $USER-&gt;{experience} &lt; -19;
    my $trollmin = - getVars(getNode('vote settings','setting'))-&gt;{norm} / 2;
    for my $id (@nodes) {
      my $writeup = getNodeById($id, 'light');
      my $title   = $writeup-&gt;{title};
      my $rep = $writeup-&gt;{reputation};
      $rep = '-' if $troll &amp;&amp; $rep &lt; $trollmin;

      push @writeups, sprintf qq[
          &lt;tr%s&gt;
            &lt;td&gt;%d&lt;/td&gt;
            &lt;td&gt;%s&lt;/td&gt;
            %s&lt;td align="right"&gt;%s&lt;/td&gt;
          &lt;/tr&gt;],
        $i % 2 == 0 ? ' class="highlight"' : '',
        getId( $writeup ),
        linkNode( $writeup ),
        ( $showrep ? qq[&lt;td align="right"&gt;$rep&lt;/td&gt;] : '' ),
        htmlcode(
          'parseTimeInString','',
          { string =&gt; $writeup-&gt;{createtime}, format =&gt; 'short' } );

      $i++;
    }

    my @params= qw( user orderby showqa showtype ); # start length
    my %params;
    @params{@params}= map $q-&gt;param($_) || '', @params;
    my $links= '';

    if ( $skip ) {
      $links .= sprintf q[
          &lt;td&gt;Previous &lt;a href="%s"&gt;%d&lt;/a&gt;&lt;/td&gt;],
        urlGen(
        {
          node_id  =&gt; getId($NODE),
          %params,
          start    =&gt; $skip - $length &lt; 0 ? 0 : $skip - $length,
          length   =&gt; $length,
        }, -1),
        $length;
    }

    if ( $more ) {
      $links .= sprintf q[
          &lt;td align="right"&gt;Next &lt;a href="%s"&gt;%d&lt;/a&gt;&lt;/td&gt;],
        urlGen(
        {
          node_id  =&gt; getId($NODE),
          %params,
          start    =&gt; $skip + $length,
          length   =&gt; $length,
        }, -1),
        $length;
    }

    $links = qq[&lt;table width="100%"&gt;&lt;tr&gt;$links&lt;/tr&gt;&lt;/table&gt;]
      if  $links;

    $str .= sprintf qq[
        &lt;p&gt;
          These nodes all have stuff by %s (showing %d-%d out of ~%d%s):
        &lt;/p&gt;
        %s
        &lt;table id="writeups" width="100%%" cellspacing="0" cellpadding="2"&gt;
          &lt;tr&gt;
            &lt;td width="10%%"&gt;Node ID&lt;/td&gt;
            &lt;td&gt;Writeup&lt;/td&gt;%s
            &lt;td align="right" width="25%%"&gt;Created&lt;/td&gt;
          &lt;/tr&gt;\n%s
        &lt;/table&gt;
        %s],
      linkNode($user),
      1+$skip,
      $skip + @nodes,
      $count,
      genLink( "&lt;sup&gt;?&lt;/sup&gt;", {node_id=&gt;656697} ),
      $links,
      ( $showrep ? qq[&lt;td align="right" width="5%%"&gt;Rep&lt;/td&gt;] : '' ),
      join('', @writeups),
      $links;
  }
  return $str;

%]
</patch_code>
<applied>2008-11-30 22:05:31</applied>
<htmlcode_id>6364</htmlcode_id>
<live_code>[%

  if(  $q-&gt;param('usersearch')
   &amp;&amp; !$q-&gt;param('user')  ) {
    $q-&gt;param( user =&gt; $q-&gt;param('usersearch') );
  }

  my %order= (
    nf =&gt; 'createtime DESC',
    of =&gt; 'createtime ASC',
    bt =&gt; 'title ASC',
    rt =&gt; 'title DESC',
    hr =&gt; 'reputation DESC',
    lr =&gt; 'reputation ASC',
    rn =&gt; 'RAND()',
  );

  my %labels = (
    nf =&gt; 'Newest First',
    of =&gt; 'Oldest First',
    bt =&gt; 'By Title',
    rt =&gt; 'By Title Reverse',
    hr =&gt; 'Highest Reputation First',
    lr =&gt; 'Lowest Reputation First',
    rn =&gt; 'Random',
  );

  my $is_pmdev=Everything::isApproved($USER,getNode( 'pmdev', 'usergroup' ) );

  my %types = (
    ''                     =&gt; 'All Types',
    'note'                 =&gt; 'Reply',
# these are handled by $showqa
#    'categorized answer'   =&gt; 'Q&amp;amp;A Answer',
#    'categorized question' =&gt; 'Q&amp;amp;A Question',
    'snippet'              =&gt; 'Snippet',
    'sourcecode'           =&gt; 'Source code',
    'perlquestion'         =&gt; 'Seekers of Perl Wisdom',
    'perlcraft'            =&gt; 'Craft',
    'perlmeditation'       =&gt; 'Meditation',
    'poem'                 =&gt; 'Perl Poetry',
    'CUFP'                 =&gt; 'Cool Uses for Perl',
    'obfuscated'           =&gt; 'Obfuscation',
    'perltutorial'         =&gt; 'Tutorial',
    'monkdiscuss'          =&gt; 'Perl Monks Discussion',
    'modulereview'         =&gt; 'Module Review',
    'bookreview'           =&gt; 'Book Review',
    'perlnews'             =&gt; 'Perl News',
    'pmdevtopic'           =&gt; 'Inner Scriptorium',
    'poll'                 =&gt; 'Poll',
    'offtopicroot'         =&gt; 'Off-Topic node',
    ($is_pmdev ? (
    'patch'                =&gt; 'Patch',
    'pmdevnote'            =&gt; 'PMDev Note',
    ) : ()),
  );
  my $str= '';

  if(  $q-&gt;param("orderby") =~ / /  ) {
    my %redro= reverse %order;
    $q-&gt;param( orderby =&gt;
      ( $redro{ $q-&gt;param("orderby") } || 'nf' ) );
  }

  $str .= qq[
    &lt;p&gt;
      This is where you can search for all the writeups contributed by any
      user.  Just enter the user name and select the order for the search.
    &lt;/p&gt;
    &lt;p&gt;
      ] . htmlcode( 'openform', -method =&gt; 'GET' ) . qq[
        &lt;table&gt;
          &lt;tr&gt;
            &lt;td align="right"&gt;
              Author:
            &lt;/td&gt;
            &lt;td&gt;
              ] . $q-&gt;textfield( 'user', htmlcode('randomusername') ) . qq[
            &lt;/td&gt;
            &lt;td width="5%"&gt;&lt;/td&gt;
            &lt;td align="right"&gt;
              Show ] . $q-&gt;textfield(
                            'length', $VARS-&gt;{pmuslen} || 50, 3 ) . qq[
            &lt;/td&gt;
            &lt;td&gt;
              nodes
            &lt;/td&gt;
          &lt;/tr&gt;
          &lt;tr&gt;
            &lt;td align="right"&gt;
              Order by:
            &lt;/td&gt;
            &lt;td&gt;
              ] . $q-&gt;popup_menu(
                    -name    =&gt; 'orderby',
                    -values  =&gt; [qw(nf of bt rt hr lr rn)],
                    -labels  =&gt; \%labels ) . qq[
            &lt;/td&gt;
            &lt;td&gt;&lt;/td&gt;
            &lt;td align="right"&gt;
              starting at
              ] . $q-&gt;textfield('start', '0', 3) . qq[
            &lt;/td&gt;
            &lt;td&gt;.&lt;/td&gt;
          &lt;/tr&gt;
          &lt;tr&gt;
            &lt;td align="right"&gt;
              Node Type:
            &lt;/td&gt;
            &lt;td&gt;
              ] . $q-&gt;popup_menu(
                    -name    =&gt; 'showtype',
                    -values  =&gt; [sort {$types{$a} cmp $types{$b}} keys %types],
                    -labels  =&gt; \%types ) . qq[
            &lt;/td&gt;
            &lt;td align="right"&gt;
              ] . $q-&gt;checkbox( -name =&gt; 'showqa', -label =&gt; '' ) . qq[
            &lt;/td&gt;
            &lt;td&gt;
              Show Categorized Q&amp;amp;A ([id://162297|Why?])
            &lt;/td&gt;
            &lt;td align="right"&gt;
              ] . $q-&gt;submit('sexisgood' =&gt; 'Search') . q[
            &lt;/td&gt;
          &lt;/tr&gt;
        &lt;/table&gt;
      &lt;/form&gt;
    &lt;hr /&gt;];

  my $showqa  = $q-&gt;param('showqa')     || 0;

  my $orderby = $q-&gt;param('orderby');
  $orderby= 'nf' if ! exists $order{$orderby};

  my $skip    = abs $q-&gt;param('start')  || 0;
  my $length  = abs $q-&gt;param('length') || $VARS-&gt;{pmuslen} || 50;

  if (  $q-&gt;param('user')  ) {
    my $user =
      getNodeById($q-&gt;param('user'))
      || getNode($q-&gt;param('user'), 'user')
      || getNode($q-&gt;param('user'), 'usergroup')
      || getNode($q-&gt;param('user'),'zombie_user')
    or return $str . q[It seems that "] . $q-&gt;escapeHTML( $q-&gt;param('user') )
         . q[" does not exist.  How very, very strange...];

    my $count = getVars($user)-&gt;{numwriteups};
    my $showrep =
         isGod($USER)
     ||     getId($user) == getId($USER)
         &amp;&amp; getId($USER) != $HTMLVARS{guest_user};

    # no sorting by hr or lr if $showtype set and $user ne $USER
    $orderby= 'nf' if ( $q-&gt;param('showtype')
                        and ($orderby eq 'hr' or $orderby eq 'lr')
                        and getId($user) != getId($USER)
                      );

    my @types = map {
      getId( getType($_) )
    } ( $q-&gt;param('showtype') || grep {length $_} keys %types );
    my $sql;

    if ( $showqa ) {
      $sql = sprintf q[
        SELECT    contributor_id
        FROM      contributor
        LEFT JOIN node
        ON        node_id = contributor_id
        WHERE     original_author = ?
        ORDER BY  %s
        LIMIT     %d, %d],
        $order{$orderby},
        $skip,
        1+$length;
    } else {
      $sql = sprintf q[
        SELECT    node_id
        FROM      node
        WHERE     author_user = ?
          AND     type_nodetype in (%s)
        ORDER BY  %s
        LIMIT     %d, %d],
      join(',', @types),
      $order{$orderby},
      $skip,
      1+$length;
    }

    my $sth  = $DB-&gt;getDatabaseHandle-&gt;prepare( $sql );

    $sth-&gt;execute( getId($user) );

    my @nodes;
    while ( my $id = $sth-&gt;fetchrow ) {
      push @nodes, $id;
    }

    return $str . sprintf(
        q[%s has no %swriteups, it seems.],
        linkNode($user), ($q-&gt;param('showtype')?"such ":"")
    ) if  not $skip  and  not @nodes;

    my @writeups;

    my $more= $length &lt; @nodes;
    pop @nodes   if  $more;
    my $i = 0;
    my $troll = $USER-&gt;{experience} &lt; -19;
    my $trollmin = - getVars(getNode('vote settings','setting'))-&gt;{norm} / 2;
    for my $id (@nodes) {
      my $writeup = getNodeById($id, 'light');
      my $title   = $writeup-&gt;{title};
      my $rep = $writeup-&gt;{reputation};
      $rep = '-' if $troll &amp;&amp; $rep &lt; $trollmin;

      push @writeups, sprintf qq[
          &lt;tr%s&gt;
            &lt;td&gt;%d&lt;/td&gt;
            &lt;td&gt;%s&lt;/td&gt;
            %s&lt;td align="right"&gt;%s&lt;/td&gt;
          &lt;/tr&gt;],
        $i % 2 == 0 ? ' class="highlight"' : '',
        getId( $writeup ),
        linkNode( $writeup ),
        ( $showrep ? qq[&lt;td align="right"&gt;$rep&lt;/td&gt;] : '' ),
        htmlcode(
          'parseTimeInString','',
          { string =&gt; $writeup-&gt;{createtime}, format =&gt; 'short' } );

      $i++;
    }

    my @params= qw( user orderby showqa showtype ); # start length
    my %params;
    @params{@params}= map $q-&gt;param($_) || '', @params;
    my $links= '';

    if ( $skip ) {
      $links .= sprintf q[
          &lt;td&gt;Previous &lt;a href="%s"&gt;%d&lt;/a&gt;&lt;/td&gt;],
        urlGen(
        {
          node_id  =&gt; getId($NODE),
          %params,
          start    =&gt; $skip - $length &lt; 0 ? 0 : $skip - $length,
          length   =&gt; $length,
        }, -1),
        $length;
    }

    if ( $more ) {
      $links .= sprintf q[
          &lt;td align="right"&gt;Next &lt;a href="%s"&gt;%d&lt;/a&gt;&lt;/td&gt;],
        urlGen(
        {
          node_id  =&gt; getId($NODE),
          %params,
          start    =&gt; $skip + $length,
          length   =&gt; $length,
        }, -1),
        $length;
    }

    $links = qq[&lt;table width="100%"&gt;&lt;tr&gt;$links&lt;/tr&gt;&lt;/table&gt;]
      if  $links;

    $str .= sprintf qq[
        &lt;p&gt;
          These nodes all have stuff by %s (showing %d-%d out of ~%d%s):
        &lt;/p&gt;
        %s
        &lt;table id="writeups" width="100%%" cellspacing="0" cellpadding="2"&gt;
          &lt;tr&gt;
            &lt;td width="10%%"&gt;Node ID&lt;/td&gt;
            &lt;td&gt;Writeup&lt;/td&gt;%s
            &lt;td align="right" width="25%%"&gt;Created&lt;/td&gt;
          &lt;/tr&gt;\n%s
        &lt;/table&gt;
        %s],
      linkNode($user),
      1+$skip,
      $skip + @nodes,
      $count,
      genLink( "&lt;sup&gt;?&lt;/sup&gt;", {node_id=&gt;656697} ),
      $links,
      ( $showrep ? qq[&lt;td align="right" width="5%%"&gt;Rep&lt;/td&gt;] : '' ),
      join('', @writeups),
      $links;
  }
  return $str;

%]
</live_code>
<reason>No, PM code display doesn't wrap</reason>
<field>doctext</field>
</record>
<record><htmlcode_id>581181</htmlcode_id>
<patch_code>[%
my $N;
my $csr=$DB-&gt;getDatabaseHandle-&gt;prepare(&lt;&lt;EOF);
 select node_id from node,document 
 where type_nodetype in(1888,11) 
 and node_id=document_id 
 and doctext="" 
 and unix_timestamp(createtime)&lt;unix_timestamp(now()-600)
EOF

$csr-&gt;execute;
my @array;
while($N=$csr-&gt;fetchrow_hashref){
   push @array, $$N{node_id};
}
$csr-&gt;finish;
my $str;
foreach(@array){
   $N=getNodeById($_);
   $str.=linkNode($N)."by ".linkNode($$N{author_user})."&lt;BR&gt;";
   nukeNode($N,-1);
}
$str;
%]</patch_code>
<applied>2006-10-30 16:23:27</applied>
<htmlcode_id>10666</htmlcode_id>
<live_code>[%
return 'or not';
my $N;
my $csr=$DB-&gt;getDatabaseHandle-&gt;prepare(&lt;&lt;EOF);
 select node_id from node,document 
 where type_nodetype in(1888,11) 
 and node_id=document_id 
 and doctext="" 
 and unix_timestamp(createtime)&lt;unix_timestamp(now()-600)
EOF

$csr-&gt;execute;
my @array;
while($N=$csr-&gt;fetchrow_hashref){
   push @array, $$N{node_id};
}
$csr-&gt;finish;
my $str;
foreach(@array){
   $N=getNodeById($_);
   $str.=linkNode($N)."by ".linkNode($$N{author_user})."&lt;BR&gt;";
   nukeNode($N,-1);
}
$str;
%]</live_code>
<reason>insert linewraps in a long sql string</reason>
<field>doctext</field>
</record>
<record><htmlcode_id>518827</htmlcode_id>
<patch_code>[%
  my @links = (
    q!id://108949;user=ar0n|my scratchpad!,
    q!pad://some\|stupid\|user|ar0n!,
    q!pm://images/|Image directory!,
    q!id://8948;me=ar0n's home\; welcome|My home node!,
    q!kobes://File::Copy|Hello, there ;)!,
    q!title://Petruchio#TheGoodStuff|pr0n!,
    q!title://tye\#MoreGoodStuff|More pr0n!,
    q!title://foo\|bar|baz!,
    q!id://300000|Oh, SURE. You're not really here, are you?!,
    q!id://Oh, no isn't this nice|Yep!,
    q!id://300000!
  );

  return $q-&gt;ul(
    map {
      $q-&gt;li(
        htmlcode('linkhandler', '', $_, 8948)
      )
    } @links
  );
%]</patch_code>
<applied>2005-12-23 15:20:03</applied>
<htmlcode_id>11603</htmlcode_id>
<live_code>[%
  return 'No. Thanks.';

  my @links = (
    q!id://108949;user=ar0n|my scratchpad!,
    q!pad://some\|stupid\|user|ar0n!,
    q!pm://images/|Image directory!,
    q!id://8948;me=ar0n's home\; welcome|My home node!,
    q!kobes://File::Copy|Hello, there ;)!,
    q!title://Petruchio#TheGoodStuff|pr0n!,
    q!title://tye\#MoreGoodStuff|More pr0n!,
    q!title://foo\|bar|baz!,
    q!id://300000|Oh, SURE. You're not really here, are you?!,
    q!id://Oh, no isn't this nice|Yep!,
    q!id://300000!
  );

  return $q-&gt;ul(
    map {
      $q-&gt;li(
        htmlcode('linkhandler', '', $_, 8948)
      )
    } @links
  );
%]</live_code>
<reason>old test</reason>
<field>doctext</field>
</record>
<record><htmlcode_id>388560</htmlcode_id>
<patch_code>[%
   my $type= $q-&gt;param( 'preview_type' );
   my $temp= $q-&gt;param( 'preview_'.$type.'_doctext' );
   my @params= $q-&gt;param();
   my $SETTING= getNode( 'preview settings', 'setting' );
   my $PS= getVars( $SETTING );
   my $displaycode= $PS-&gt;{"displayHtmlcodeForType_"."$type"}
      || $PS-&gt;{defaultDisplayHtmlcode};
   foreach my $param (  @params  ) {
      my $value= $q-&gt;param( $param );
      if(  $param =~ s/^preview_//  ) {
         $q-&gt;param( $param, $value );
      }
   }
   my $title= $q-&gt;param('node');
   $q-&gt;param( htmlerror =&gt; $VARS-&gt;{htmlpreview} || 3 )
      if  ! $q-&gt;param('htmlerror');
   $HTMLVARS{embed_node}{doctext}=
      $q-&gt;param( "preview_".$type."_doctext" );
   my $str= qq[
      &lt;hr /&gt;&lt;h3&gt;] . $q-&gt;escapeHTML( $q-&gt;param("preview_node") ) . qq[&lt;/h3&gt;
      ] . htmlcode($displaycode) . qq[
      &lt;hr /&gt;&lt;p&gt;
         If something looked unlike you expected
         it to you might need to check out
      ] . linkNodeTitle('Writeup Formatting Tips') . qq[&lt;p /&gt;
      ];
   if ( getId($USER) == $HTMLVARS{guest_user} ) {
       $str .= qq[&lt;h2&gt;You aren't logged in.&lt;/h2&gt; &lt;p&gt;] . 
               linkNodeTitle('Login') . 
               qq[, ] .
               linkNodeTitle('Create a new user') .
               qq[, or hit "Create" to proceed in ] .
               qq[ posting your node.&lt;/p&gt; ];
   }
   my $PFS= getVars( getNode('preview form settings','setting') );
   my $type= $q-&gt;param('preview_type');
   my $lookuptype= $type;
   $lookuptype =~ s/ /_/g;
   my $formcode= $PFS-&gt;{$lookuptype};

   # handle note inheritance. this could be a lot smarter.
   $formcode||='addnewnoteform' 
         if $lookuptype=~/note/;

   {
     # blech. there must be a better way.
     local $HTMLVARS{__ADD_SIG_WARNING}=1;
     if(  $formcode  ) {
        $str .= htmlcode( $formcode, 0 );
     } else {
        $str .= htmlcode( 'addnewform', '', $type, 'Add it', 'Add this' );
     }
   }
   $str.=htmlcode( 'showhints' );
   return $str;
%]</patch_code>
<applied>2004-09-05 11:18:19</applied>
<htmlcode_id>11911</htmlcode_id>
<live_code>[%
   my $type= $q-&gt;param( 'preview_type' );
   my $temp= $q-&gt;param( 'preview_'.$type.'_doctext' );
   my @params= $q-&gt;param();
   my $SETTING= getNode( 'preview settings', 'setting' );
   my $PS= getVars( $SETTING );
   my $displaycode= $PS-&gt;{"displayHtmlcodeForType_"."$type"}
      || $PS-&gt;{defaultDisplayHtmlcode};
   foreach my $param (  @params  ) {
      my $value= $q-&gt;param( $param );
      if(  $param =~ s/^preview_//  ) {
         $q-&gt;param( $param, $value );
      }
   }
   my $title= $q-&gt;param('node');
   $q-&gt;param( htmlerror =&gt; $VARS-&gt;{htmlpreview} || 3 )
      if  ! $q-&gt;param('htmlerror');
   $HTMLVARS{embed_node}{doctext}=
      $q-&gt;param( "preview_".$type."_doctext" );
   my $str= qq[
      &lt;hr /&gt;&lt;h3&gt;] . $q-&gt;escapeHTML( $q-&gt;param("preview_node") ) . qq[&lt;/h3&gt;
      ] . htmlcode($displaycode) . qq[
      &lt;hr /&gt;&lt;p&gt;
         If something looked unlike you expected
         it to you might need to check out
      ] . linkNodeTitle('Writeup Formatting Tips') . qq[&lt;p /&gt;
      ];
   if ( getId($USER) == $HTMLVARS{guest_user} ) {
       $str .= qq[&lt;h2&gt;You aren't logged in.&lt;/h2&gt; &lt;p&gt;] . 
               linkNodeTitle('Login') . 
               qq[, ] .
               linkNodeTitle('Create a new user') .
               qq[, or hit "Create" to proceed in ] .
               qq[ posting your node.&lt;/p&gt; ];
   }
   my $PFS= getVars( getNode('preview form settings','setting') );
   my $type= $q-&gt;param('preview_type');
   my $lookuptype= $type;
   $lookuptype =~ s/ /_/g;
   my $formcode= $PFS-&gt;{$lookuptype};

   # handle note inheritance. this could be a lot smarter.
   $formcode||='addnewnoteform' 
         if $lookuptype=~/note/;

   {
     # blech. there must be a better way.
     local $HTMLVARS{__ADD_SIG_WARNING}=1;
     if(  $formcode  ) {
        $str .= htmlcode( $formcode, 0 );
     } else {
        $str .= htmlcode( 'addnewform', '', $type, 'Add it', 'Add this' );
     }
   }
   return $str;
%]</live_code>
<reason>Make "You aren't logged in." MUCH more obvious.</reason>
<field>doctext</field>
</record>
<record><htmlcode_id>492826</htmlcode_id>
<patch_code>[{get_sitedoclet}]
&lt;p&gt;[{see_also:Settings Nodes;faqlist}]&lt;/p&gt;
&lt;hr /&gt;
&lt;form method="post" action="?"
    enctype="application/x-www-form-urlencoded"
    style="display:block"&gt;
&lt;!-- Netscape makes everything "inline" when
   inside of an inline &lt;form&gt;. *sigh* --&gt;
[%
    $q-&gt;hidden( "displaytype" ) .
    $q-&gt;hidden( "node_id", getId($NODE) );
%]
&lt;table border="1" class="user-settings" id="u-s-signature"&gt;
&lt;!-- signature stuff --&gt;
&lt;tr&gt;&lt;td&gt;
    &lt;p&gt;&lt;b&gt;Your &lt;a name="Node-Template"&gt;Node Template&lt;/a&gt;:&lt;/b&gt;
      You can put tags that you often use here so that they will be
      pre-loaded into the text area when you compose a new node.
      &lt;sup&gt;&lt;a target="_new" href="?node_id=323419"&gt;?&lt;/a&gt;&lt;/sup&gt;
      &lt;br /&gt;
      [{setvararea:template_text}]
    &lt;/p&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;
    &lt;p&gt;&lt;b&gt;Your &lt;a name="Signature"&gt;Signature:&lt;/a&gt;&lt;/b&gt;
      This is for a 'signature' that you would like to
      include at the bottom of each of your nodes.
      If you find that you have more than two short lines
      here, please move most of it to your home node instead.
      &lt;a target="_new" href="?node_id=323419"&gt;?&lt;/a&gt;
      &lt;br /&gt;
      [{setvararea:signature}]
    &lt;/p&gt;
&lt;/td&gt;&lt;/tr&gt;
&lt;/table&gt;
&lt;!-- end signature stuff --&gt;
[{closeform}]</patch_code>
<applied>2005-09-17 04:28:06</applied>
<htmlcode_id>14444</htmlcode_id>
<live_code>&lt;p&gt;[{see_also:Settings Nodes;faqlist}]&lt;/p&gt;
[{get_sitedoclet}]
&lt;form method="post" action="?"
    enctype="application/x-www-form-urlencoded"
    style="display:block"&gt;
&lt;!-- Netscape makes everything "inline" when
   inside of an inline &lt;form&gt;. *sigh* --&gt;
[%
    $q-&gt;hidden( "displaytype" ) .
    $q-&gt;hidden( "node_id", getId($NODE) );
%]
&lt;table border="1" class="user-settings" id="u-s-signature"&gt;
&lt;!-- signature stuff --&gt;
&lt;tr&gt;&lt;td&gt;
    &lt;p&gt;&lt;b&gt;Your &lt;a name="Node-Template"&gt;Node Template&lt;/a&gt;:&lt;/b&gt;
      You can put tags that you often use here so that they will be
      pre-loaded into the text area when you compose a new node.
      &lt;br /&gt;
      [{setvararea:template_text}]
    &lt;/p&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;
    &lt;p&gt;&lt;b&gt;Your &lt;a name="Signature"&gt;Signature:&lt;/a&gt;&lt;/b&gt;
      This is for a 'signature' that you would like to
      include at the bottom of each of your nodes.
      If you find that you have more than two short lines
      here, please move most of it to your home node instead.
      &lt;br /&gt;
      [{setvararea:signature}]
    &lt;/p&gt;
&lt;/td&gt;&lt;/tr&gt;
&lt;/table&gt;
&lt;!-- end signature stuff --&gt;
[{closeform}]</live_code>
<reason>add see also and sitedoclet.</reason>
<field>doctext</field>
</record>
<record><htmlcode_id>752238</htmlcode_id>
<patch_code>[%
  use XML::Fling;
  require POSIX;

  my $ARCHIVED_HARD_LIMIT=100;
  # this should change to $ARCHIVED_HARD_LIMIT eventually.
  my $PRIVATE_HARD_LIMIT=$ARCHIVED_HARD_LIMIT || 10000;
  my $DEFAULT_LIMIT=20;

  my $since_id = $q-&gt;param('since_id');
  my $prior_to = $q-&gt;param('prior_to');

  undef $prior_to if defined $since_id;
  my $has_id= defined($since_id) || defined($prior_to);

  my $archived = lc($q-&gt;param('archived')||'');

  $archived = "" if !$archived or $archived eq 'no';

  my $HARD_LIMIT = !$has_id ? $DEFAULT_LIMIT 
                            : $archived ? $ARCHIVED_HARD_LIMIT 
                                          : $PRIVATE_HARD_LIMIT;

  my $max_recs = $q-&gt;param('max_recs');

  $max_recs=$HARD_LIMIT 
      if !$max_recs or $max_recs&gt;$HARD_LIMIT or $max_recs&lt;1;

  { 
    my $id_str=!$has_id ? 'None' 
                        : defined $since_id ? "s:'$since_id'" 
                                            : "p:'$prior_to'";
    htmlcode('log_ticker','','',"$id_str a:'$archived' mr:'$max_recs'") 
    or Everything::printLog(
        "PMXT: $USER-&gt;{title} ($ENV{REMOTE_ADDR}) $id_str a:'$archived' mr:'$max_recs'"
        ." $ENV{'HTTP_USER_AGENT'}");
  }
  return if getId($USER) == $HTMLVARS{default_user};

##########################################################################
# Commented out caching related code has been removed. Please see 265756
##########################################################################


    my $query=qq[
        select message_id,
               msgtext,
               author_user,
               tstamp,
               for_user,
               archive
          from message
         where for_user = ? 
    ];
    $query.= "and message_id " .(defined $since_id ? "&gt;" : "&lt;"). " ?"
       if $has_id;

    $query.=" and archive = " . ($archived ? 1 : 0)
         if $archived ne 'both';

    $query.=" order by message_id " . 
            (defined $since_id ? " asc" : " desc") . 
            " limit $max_recs";

    my $stmt=$DB-&gt;getDatabaseHandle()-&gt;prepare_cached($query);

    $stmt-&gt;execute(getId($USER),($has_id ? ($since_id||$prior_to||0) 
                                         : ()));

    # the hashref argument heres causes an AoH to be returned
    my $msgs = $stmt-&gt;fetchall_arrayref( {} );
    @$msgs=reverse @$msgs
       unless defined $since_id;

    return "&lt;error&gt;Error creatng fling object&lt;/error&gt;"
        unless htmlcode('new_xml_fling','',\my($xml,@data,%xmlstyle),'add_header');
    require POSIX;


    $xml-&gt;header("windows-1252")-&gt;
      start('CHATTER')-&gt;
        element('INFO', site       =&gt; $HTMLVARS{site_url},
                        sitename   =&gt; $HTMLVARS{site_name},
                        min_poll_seconds =&gt; 30, 
                       (!$has_id ? () : defined $since_id ? 
                       (since_id   =&gt; $since_id) : 
                       (prior_to   =&gt; $prior_to) ),
                        archived   =&gt; (!$archived           ? 'no'  :
                                       $archived ne 'both' ? 'yes' :
                                       $archived),
                        max_recs   =&gt; $max_recs,
                        foruser    =&gt; $USER-&gt;{title},
                        foruser_id =&gt; $USER-&gt;{node_id},
                        hard_limit =&gt; $HARD_LIMIT,
                        style      =&gt; join(',',grep { $xmlstyle{$_} } keys %xmlstyle),
                        gentimeGMT =&gt; POSIX::strftime("%Y-%m-%d %H:%M:%S",
                                                     gmtime(time)),
                'Rendered by the Private Message XML Ticker' );

        foreach my $msg (@$msgs) {
          my $usr = getNodeById($msg-&gt;{author_user});

          $xml-&gt;element(
            'message',
              user_id     =&gt; $msg-&gt;{author_user},
              author      =&gt; $usr-&gt;{title},
              time        =&gt; $msg-&gt;{tstamp},
              message_id  =&gt; $msg-&gt;{message_id},
              status      =&gt; ($msg-&gt;{archive} ? 'archived' : 'active'),
              $msg-&gt;{msgtext} );
        }
    $xml-&gt;end();

    return join '', @data;

%]</patch_code>
<applied>2009-03-21 10:05:57</applied>
<htmlcode_id>15848</htmlcode_id>
<live_code>[%
  use XML::Fling;
  require POSIX;

  my $ARCHIVED_HARD_LIMIT=100;
  # this should change to $ARCHIVED_HARD_LIMIT eventually.
  my $PRIVATE_HARD_LIMIT=$ARCHIVED_HARD_LIMIT || 10000;
  my $DEFAULT_LIMIT=20;

  my $since_id = $q-&gt;param('since_id');
  my $prior_to = $q-&gt;param('prior_to');

  undef $prior_to if defined $since_id;
  my $has_id= defined($since_id) || defined($prior_to);

  my $archived = lc($q-&gt;param('archived')||'');

  $archived = "" if !$archived or $archived eq 'no';

  my $HARD_LIMIT = !$has_id ? $DEFAULT_LIMIT 
                            : $archived ? $ARCHIVED_HARD_LIMIT 
                                          : $PRIVATE_HARD_LIMIT;

  my $max_recs = $q-&gt;param('max_recs');

  $max_recs=$HARD_LIMIT 
      if !$max_recs or $max_recs&gt;$HARD_LIMIT or $max_recs&lt;1;

  { 
    my $id_str=!$has_id ? 'None' 
                        : defined $since_id ? "s:'$since_id'" 
                                            : "p:'$prior_to'";
    htmlcode('log_ticker','','',"$id_str a:'$archived' mr:'$max_recs'") 
    or Everything::printLog(
        "PMXT: $USER-&gt;{title} ($ENV{REMOTE_ADDR}) $id_str a:'$archived' mr:'$max_recs'"
        ." $ENV{'HTTP_USER_AGENT'}");
  }
  return if getId($USER) == $HTMLVARS{default_user};

##########################################################################
# Commented out caching related code has been removed. Please see 265756
##########################################################################


    my $query=qq[
        select message_id,
               msgtext,
               author_user,
               tstamp,
               for_user,
               archive
          from message
         where for_user = ? 
    ];
    $query.= "and message_id " .(defined $since_id ? "&gt;" : "&lt;"). " ?"
       if $has_id;

    $query.=" and archive = " . ($archived ? 1 : 0)
         if $archived ne 'both';

    $query.=" order by message_id " . 
            (defined $since_id ? " asc" : " desc") . 
            " limit $max_recs";

    my $stmt=$DB-&gt;getDatabaseHandle()-&gt;prepare_cached($query);

    $stmt-&gt;execute(getId($USER),($has_id ? ($since_id||$prior_to||0) 
                                         : ()));

    # the hashref argument heres causes an AoH to be returned
    my $msgs = $stmt-&gt;fetchall_arrayref( {} );
    @$msgs=reverse @$msgs
       unless defined $since_id;

    return "&lt;error&gt;Error creatng fling object&lt;/error&gt;"
        unless htmlcode('new_xml_fling','',\my($xml,@data,%xmlstyle),'add_header');
    require POSIX;


    $xml-&gt;header("windows-1252")-&gt;
      start('CHATTER')-&gt;
        element('INFO', site       =&gt; $HTMLVARS{site_url},
                        sitename   =&gt; $HTMLVARS{site_name},
                        min_poll_seconds =&gt; 30, 
                       (!$has_id ? () : defined $since_id ? 
                       (since_id   =&gt; $since_id) : 
                       (prior_to   =&gt; $prior_to) ),
                        archived   =&gt; (!$archived           ? 'no'  :
                                       $archived ne 'both' ? 'yes' :
                                       $archived),
                        max_recs   =&gt; $max_recs,
                        foruser    =&gt; $USER-&gt;{title},
                        foruser_id =&gt; $USER-&gt;{node_id},
                        hard_limit =&gt; $HARD_LIMIT,
                        style      =&gt; join(',',grep { $xmlstyle{$_} } keys %xmlstyle),
                        gentimeGMT =&gt; POSIX::strftime("%Y-%m-%d %H:%M:%S",
                                                     gmtime(time)),
                'Rendered by the Private Message XML Ticker' );

        foreach my $msg (@$msgs) {
          my $usr = getNodeById($msg-&gt;{author_user});

          $xml-&gt;element(
            'message',
              user_id     =&gt; $msg-&gt;{author_user},
              author      =&gt; $usr-&gt;{title},
              time        =&gt; $msg-&gt;{tstamp},
              message_id  =&gt; $msg-&gt;{message_id},
              status      =&gt; ($msg-&gt;{archive} ? 'archived' : 'active'),
              $msg-&gt;{msgtext} );
        }
    $xml-&gt;end();
    my $data = join "",@data;       
    htmlcode('postProcessXML','',\$data);
    return $data;

%]</live_code>
<reason>encoding in xml header</reason>
<field>doctext</field>
</record>
<record><htmlcode_id>728041</htmlcode_id>
<patch_code>&lt;p align="right"&gt;
&lt;a href="/?node_id=17642#ignored_users"&gt;Help for this page&lt;/a&gt;
&lt;/p&gt;
[%
    my $html= '';
    $html .= "&lt;p&gt;" . $query-&gt;param('sentmessage') . "&lt;/p&gt;"
        if  $query-&gt;param( 'sentmessage' );

    my $ignored= $VARS-&gt;{ignoredusers};
    $ignored =~ s/[|]//g;
    my @ignored= split /,/, $ignored;

    if(  @ignored  ) {
        $html .= "&lt;p&gt;You are currently ignoring the following users:\n&lt;ul&gt;\n";
        $html .= htmlcode('openform');
        $html .= $q-&gt;hidden( -name=&gt;'op', -value=&gt;'message', -force=&gt;1 );
    } else {
        $html .= "&lt;p&gt;You are not ignoring any users at the current time.&lt;/p&gt;\n";
    }
    foreach (  @ignored  ) {
        my $who= /^\d+$/ ? getNodeById($_) : getNode($_,'user');
        $html .= sprintf "&lt;li&gt;%s %s&lt;/li&gt;\n",
            linkNode( $who ),
            $q-&gt;submit( 'message', "/unignore $who-&gt;{title}" );
    }
    $html .= "\n&lt;/ul&gt;&lt;/p&gt;&lt;/form&gt;\n"
        if  @ignored;

    return $html;
%]
&lt;hr /&gt;
&lt;div class="chatter-filter"&gt;
[{openform}]
&lt;h4&gt;Chatter Content Filter&lt;/h4&gt;
&lt;p&gt;
Your comma-separated list of literal strings to be filtered:&lt;br /&gt;
[{setvar:chatter_filter,100}]&lt;br /&gt;
Note that filtering is case INsensitive.
&lt;/p&gt;
[{closeform}]
&lt;p align="right"&gt;
&lt;a href="/?node_id=17642#ignored_users"&gt;Help for this page&lt;/a&gt;
&lt;/p&gt;
&lt;/div&gt;
</patch_code>
<applied>2008-12-04 15:13:31</applied>
<htmlcode_id>16082</htmlcode_id>
<live_code>[%
    my $html= '';
    $html .= "&lt;p&gt;" . $query-&gt;param('sentmessage') . "&lt;/p&gt;"
        if  $query-&gt;param( 'sentmessage' );

    my $ignored= $VARS-&gt;{ignoredusers};
    $ignored =~ s/[|]//g;
    my @ignored= split /,/, $ignored;

    if(  @ignored  ) {
        $html .= "&lt;p&gt;You are currently ignoring the following users:\n&lt;ul&gt;\n";
        $html .= htmlcode('openform');
        $html .= $q-&gt;hidden( -name=&gt;'op', -value=&gt;'message', -force=&gt;1 );
    } else {
        $html .= "&lt;p&gt;You are not ignoring any users at the current time.&lt;/p&gt;\n";
    }
    foreach (  @ignored  ) {
        my $who= /^\d+$/ ? getNodeById($_) : getNode($_,'user');
        $html .= sprintf "&lt;li&gt;%s %s&lt;/li&gt;\n",
            linkNode( $who ),
            $q-&gt;submit( 'message', "/unignore $who-&gt;{title}" );
    }
    $html .= "\n&lt;/ul&gt;&lt;/p&gt;&lt;/form&gt;\n"
        if  @ignored;

    return $html;
%]
&lt;hr /&gt;
&lt;div class="chatter-filter"&gt;
[{openform}]
&lt;h4&gt;Chatter Content Filter&lt;/h4&gt;
&lt;p&gt;
Your comma-separated list of literal strings to be filtered:&lt;br /&gt;
[{setvar:chatter_filter,100}]&lt;br /&gt;
Note that filtering is case INsensitive.
&lt;/p&gt;
[{closeform}]
&lt;/div&gt;
[{get_sitedoclet}]</live_code>
<reason>fix tiny typo bug</reason>
<field>doctext</field>
</record>
<record><htmlcode_id>626450</htmlcode_id>
<patch_code>[%
    return "This page has been disabled. Use the regular Monastery Gates.\n";
__END__
&lt;TABLE width="100%" cellpadding=0 cellspacing=0&gt;
  &lt;TR align=right&gt;
     &lt;TD valign=top&gt;
     [{votehead}]
     [%
     my $str;
     htmlcode('logreferrer');
     my $sopwnum=$$VARS{fp_max_sopw};
     my $mednum=$$VARS{fp_max_med};
     my $craftnum=$$VARS{fp_max_craft};
     my $cufpnum=$$VARS{fp_max_cufp};
     my $poemnum=$$VARS{fp_max_poem};
     my $obfunum=$$VARS{fp_max_obfu};
     my $discnum=$$VARS{fp_max_disc};
     $sopwnum||=4;
     $craftnum||=2;
     $cufpnum||=2;
     $mednum||=2;
     $poemnum||=2;
     $obfunum||=2;
     $discnum||=3;

     $HTMLVARS{data_displaytype}="";

     $str.="&lt;CENTER&gt;If you're new here please read ".linkNodeTitle("The Perl Monks Guide to the Monastery")."&lt;/CENTER&gt;&lt;BR&gt;" if(getId($USER) == $HTMLVARS{guest_user});
     $str.="&lt;p align=left&gt;".htmlcode("questinfo")."&lt;/P&gt;";
     $str.=htmlcode('listapproved',"perlquestion,frontpage linktype,New Questions ,$sopwnum,0,0,Seekers+of+Perl+Wisdom") unless ($$VARS{fp_sopw_off} eq "on");
     $str.=htmlcode('listapproved',"perlmeditation,frontpage linktype,New Meditations ,$mednum,0,0,Meditations") unless ($$VARS{fp_med_off} eq "on");
     $str.=htmlcode('listapproved',"CUFP,frontpage linktype,New Cool Uses for Perl,$cufpnum,0,0,Cool+Uses+For+Perl") unless ($$VARS{fp_cufp_off} eq "on");
     $HTMLVARS{data_displaytype}="code";
     $str.=htmlcode('listapproved',"perlcraft,frontpage linktype,New Craft,$craftnum,0,0,Craft") unless ($$VARS{fp_craft_off} eq "on");
     $HTMLVARS{data_displaytype}="";
     $str.=htmlcode('listapproved',"poem,frontpage linktype,New Perl Poetry,$poemnum,0,0,Perl+Poetry") unless ($$VARS{fp_poem_off} eq "on");
     $str.=htmlcode('listapproved',"obfuscated,frontpage linktype,New Obfuscated Code,$obfunum,0,0,Obfuscated+Code") unless ($$VARS{fp_obfu_off} eq "on");
     $str.=htmlcode('listapproved',"monkdiscuss,frontpage linktype,New Monk Discussion,$discnum,0,0,Perl+Monks+Discussion") unless ($$VARS{fp_disc_off} eq "on");
     $str.=htmlcode('votefoot');
     $str;
%]&lt;!--
    &lt;/TD&gt;
    &lt;/TR&gt;
&lt;/TABLE&gt;
--&gt;
</patch_code>
<applied>2007-07-13 10:35:10</applied>
<htmlcode_id>16948</htmlcode_id>
<live_code>This page has been disabled. Use the regular Monastery Gates.</live_code>
<reason>Built-in DoS</reason>
<field>doctext</field>
</record>
<record><htmlcode_id>626128</htmlcode_id>
<patch_code>[%
return "This page has been disabled.  Please use the regular Monastery Gates.\n";
__END__
&lt;TABLE width="100%" cellpadding=0 cellspacing=0&gt;
  &lt;TR align=right&gt;
     &lt;TD valign=top&gt;
     [{votehead}]
     [%
     my $str;
     htmlcode('logreferrer');
     my $sopwnum=$$VARS{fp_max_sopw};
     my $mednum=$$VARS{fp_max_med};
     my $craftnum=$$VARS{fp_max_craft};
     my $cufpnum=$$VARS{fp_max_cufp};
     my $poemnum=$$VARS{fp_max_poem};
     my $obfunum=$$VARS{fp_max_obfu};
     my $discnum=$$VARS{fp_max_disc};
     $sopwnum||=4;
     $craftnum||=2;
     $cufpnum||=2;
     $mednum||=2;
     $poemnum||=2;
     $obfunum||=2;
     $discnum||=3;

     $HTMLVARS{data_displaytype}="";

     $str.="&lt;CENTER&gt;If you're new here please read ".linkNodeTitle("The Perl Monks Guide to the Monastery")."&lt;/CENTER&gt;&lt;BR&gt;" if(getId($USER) == $HTMLVARS{guest_user});
     $str.="&lt;p align=left&gt;".htmlcode("questinfo")."&lt;/P&gt;";
     $str.=htmlcode('listapproved',"perlquestion,frontpage linktype,New Questions ,$sopwnum,0,0,Seekers+of+Perl+Wisdom") unless ($$VARS{fp_sopw_off} eq "on");
     $str.=htmlcode('listapproved',"perlmeditation,frontpage linktype,New Meditations ,$mednum,0,0,Meditations") unless ($$VARS{fp_med_off} eq "on");
     $str.=htmlcode('listapproved',"CUFP,frontpage linktype,New Cool Uses for Perl,$cufpnum,0,0,Cool+Uses+For+Perl") unless ($$VARS{fp_cufp_off} eq "on");
     $HTMLVARS{data_displaytype}="code";
     $str.=htmlcode('listapproved',"perlcraft,frontpage linktype,New Craft,$craftnum,0,0,Craft") unless ($$VARS{fp_craft_off} eq "on");
     $HTMLVARS{data_displaytype}="";
     $str.=htmlcode('listapproved',"poem,frontpage linktype,New Perl Poetry,$poemnum,0,0,Perl+Poetry") unless ($$VARS{fp_poem_off} eq "on");
     $str.=htmlcode('listapproved',"obfuscated,frontpage linktype,New Obfuscated Code,$obfunum,0,0,Obfuscated+Code") unless ($$VARS{fp_obfu_off} eq "on");
     $str.=htmlcode('listapproved',"monkdiscuss,frontpage linktype,New Monk Discussion,$discnum,0,0,Perl+Monks+Discussion") unless ($$VARS{fp_disc_off} eq "on");
     $str.=htmlcode('votefoot');
     $str;
%]&lt;!--
    &lt;/TD&gt;
    &lt;/TR&gt;
&lt;/TABLE&gt;
--&gt;
</patch_code>
<applied>2007-07-13 13:32:47</applied>
<htmlcode_id>16949</htmlcode_id>
<live_code>This page has been disabled.  Please use the regular Monastery Gates.</live_code>
<reason>Built-in DoS ?</reason>
<field>doctext</field>
</record>
<record><htmlcode_id>493010</htmlcode_id>
<patch_code>[{get_sitedoclet}]
&lt;div class="user-settings"&gt;
&lt;form method="post" action="?"
    enctype="application/x-www-form-urlencoded"
    style="display:block" &gt;
&lt;!-- Netscape makes everything "inline" when
       inside of an inline &lt;form&gt;. *sigh* --&gt;
[%
  $q-&gt;hidden( "displaytype" ) .
  $q-&gt;hidden( "node_id", getId($NODE) );
%]

&lt;p&gt;
    [{see_also:Settings Nodes;faqlist}]
&lt;/p&gt;

&lt;br /&gt;
&lt;table class="user-pmdev" id="u-s-pmdev" border="1"&gt;
    &lt;tr&gt;&lt;td&gt;Diff Type:&lt;/td&gt;
        &lt;td&gt;[{listVarMenu:diff_mode,token,line,char,user}]&lt;/td&gt;&lt;/tr&gt;
    &lt;tr&gt;&lt;td&gt;Regex Diff:&lt;/td&gt;
        &lt;td&gt;[{setvar:regex_diff,50]}]&lt;/td&gt;&lt;/tr&gt;
    &lt;tr&gt;&lt;td&gt;Split Diff:&lt;/td&gt;
        &lt;td&gt;[{setvar:split_diff,50}]&lt;/td&gt;&lt;/tr&gt;
    &lt;tr&gt;&lt;td&gt;Deleted Code Style:&lt;/td&gt;
        &lt;td&gt;[{setvar:diff_deleted_style,50}]&lt;/td&gt;&lt;/tr&gt;
    &lt;tr&gt;&lt;td&gt;Inserted Code Style:&lt;/td&gt;
        &lt;td&gt;[{setvar:diff_inserted_style,50}]&lt;/td&gt;&lt;/tr&gt;
                       
    &lt;tr&gt;&lt;td&gt;Strike deleted:&lt;/td&gt;
        &lt;td&gt;[{checkvar:strike_deleted_in_diff}]&lt;/td&gt;&lt;/tr&gt;

    &lt;tr&gt;&lt;td&gt;Number when possible:&lt;/td&gt;
    &lt;td&gt;[{listVarMenu:diff_number,-1,1}]
        &lt;font size="2pt"&gt;-1 is &lt;u&gt;never&lt;/u&gt;, 
        default and 1 are "when possible"&lt;/font&gt;
    &lt;/td&gt;&lt;/tr&gt;

    &lt;tr&gt;&lt;td&gt;Default ordering for Patch Lister:&lt;/td&gt;
        &lt;td&gt;[{setvar:listpatches_default_order,50}]&lt;/td&gt;&lt;/tr&gt;

    &lt;tr&gt;&lt;td&gt;Default limit,skip for Patch Lister:&lt;/td&gt;
        &lt;td&gt;[{setvar:listpatches_default_limit,50}]&lt;/td&gt;&lt;/tr&gt;
    &lt;/tr&gt;&lt;/td&gt;

    &lt;tr&gt;&lt;td&gt;Show session cache stats:&lt;/td&gt;
        &lt;td&gt;[{checkvar:show_session_cache_stats}]&lt;/td&gt;&lt;/tr&gt;
&lt;/table&gt;


[{closeform}]
&lt;/div&gt;</patch_code>
<applied>2005-09-18 09:00:06</applied>
<htmlcode_id>17003</htmlcode_id>
<live_code>&lt;div class="user-settings"&gt;
&lt;form method="post" action="?"
    enctype="application/x-www-form-urlencoded"
    style="display:block" &gt;
&lt;!-- Netscape makes everything "inline" when
       inside of an inline &lt;form&gt;. *sigh* --&gt;
[%
  $q-&gt;hidden( "displaytype" ) .
  $q-&gt;hidden( "node_id", getId($NODE) );
%]

&lt;p&gt;
    [{see_also:Settings Nodes;faqlist}]
&lt;/p&gt;
&lt;p align="right"&gt;&lt;a href="?node_id=787708"&gt;&lt;b&gt;Help for this page&lt;/b&gt;&lt;/a&gt;&lt;/p&gt;

&lt;br /&gt;
&lt;table class="user-pmdev" id="u-s-pmdev" border="1"&gt;
    &lt;tr&gt;&lt;td&gt;Diff Type:&lt;/td&gt;
        &lt;td&gt;[{listVarMenu:diff_mode,token,line,char,user}]&lt;/td&gt;&lt;/tr&gt;
    &lt;tr&gt;&lt;td&gt;Regex Diff:&lt;/td&gt;
        &lt;td&gt;[{setvar:regex_diff,50]}]&lt;/td&gt;&lt;/tr&gt;
    &lt;tr&gt;&lt;td&gt;Split Diff:&lt;/td&gt;
        &lt;td&gt;[{setvar:split_diff,50}]&lt;/td&gt;&lt;/tr&gt;
    &lt;tr&gt;&lt;td&gt;Deleted Code Style:&lt;/td&gt;
        &lt;td&gt;[{setvar:diff_deleted_style,50}]&lt;/td&gt;&lt;/tr&gt;
    &lt;tr&gt;&lt;td&gt;Inserted Code Style:&lt;/td&gt;
        &lt;td&gt;[{setvar:diff_inserted_style,50}]&lt;/td&gt;&lt;/tr&gt;
                       
    &lt;tr&gt;&lt;td&gt;Strike deleted:&lt;/td&gt;
        &lt;td&gt;[{checkvar:strike_deleted_in_diff}]&lt;/td&gt;&lt;/tr&gt;

    &lt;tr&gt;&lt;td&gt;Number when possible:&lt;/td&gt;
    &lt;td&gt;[{listVarMenu:diff_number,-1,1}]
        &lt;font size="2pt"&gt;-1 is &lt;u&gt;never&lt;/u&gt;, 
        default and 1 are "when possible"&lt;/font&gt;
    &lt;/td&gt;&lt;/tr&gt;

    &lt;tr&gt;&lt;td&gt;Default ordering for Patch Lister:&lt;/td&gt;
        &lt;td&gt;[{setvar:listpatches_default_order,50}]&lt;/td&gt;&lt;/tr&gt;

    &lt;tr&gt;&lt;td&gt;Default limit,skip for Patch Lister:&lt;/td&gt;
        &lt;td&gt;[{setvar:listpatches_default_limit,50}]&lt;/td&gt;&lt;/tr&gt;
    &lt;/tr&gt;&lt;/td&gt;

    &lt;tr&gt;&lt;td&gt;Show session cache stats:&lt;/td&gt;
        &lt;td&gt;[{checkvar:show_session_cache_stats}]&lt;/td&gt;&lt;/tr&gt;
&lt;/table&gt;


[{closeform}]
&lt;/div&gt;</live_code>
<reason>add show_session_cache_stats</reason>
<field>doctext</field>
</record>
<record><htmlcode_id>664714</htmlcode_id>
<patch_code>[{get_sitedoclet}]
[{newlistapproved:perlnews,perlquestion approved linktype,Perl News,15,navbaron,showall}]
[{addnewform:perlnews,Add a piece of Perl News,Text}]
[{showhints}]
</patch_code>
<applied>2008-01-28 13:07:12</applied>
<htmlcode_id>23771</htmlcode_id>
<live_code>[{get_sitedoclet}]
[{newlistapproved:perlnews,perlquestion approved linktype,Perl News,15,navbaron,showall}]
[{addnewform:perlnews,Add a piece of Perl News,Text}]
</live_code>
<reason>delete extraneous markup</reason>
<field>doctext</field>
</record>
<record><htmlcode_id>543423</htmlcode_id>
<patch_code>&lt;p&gt;
This table shows how much [id://5938|XP] you can expect to get
from a node you wrote, as its reputation rises.
&lt;/p&gt;&lt;p&gt;
The numbers along the top are the reputation of a node.
(This number fluctuates as other monks up-vote and down-vote the node.
You hope it only goes up!)
&lt;/p&gt;&lt;p&gt;
The numbers down the left side are $NORM, explained in [id://5938].
&lt;/p&gt;&lt;p&gt;
For illustration purposes, look at the last row, where $NORM is 10.
If you have a node which has a reputation 21, you can expect that
you've gotten about 9 XP from that node. Of course, it's not accrued
to you all at once; XP from node rep is allotted as the node's rep
changes. And you may not have gotten &lt;i&gt;exactly&lt;/i&gt; 9 XP from that
node; perhaps the node has been around a while, and some of the
voting on it occurred when $NORM was 9.5, or even lower. In that
case, you may have gotten more than 9 XP from it.  Also note that
there is an element of chance in the allocation of an experience point;
see [id://5938] for details.
&lt;/p&gt;
[%
local *oddsUp=sub{
   my($norm,$rep)=@_;
   return 1/3 if $rep&lt;$norm;
   return 1/2 if $rep&lt;2*$norm;
   return 2/3 if $rep&lt;3*$norm;
   return 3/4 if $rep&lt;4*$norm;
   return 1 if $rep;
};
my $str;
my @norms;
for(1..20){
   push @norms,$_/2;
}

$str.="&lt;TABLE border=1&gt;";

$str.="&lt;TR&gt;&lt;TD&gt;&lt;/TD&gt;";
for(1..50){
   $str.="&lt;TD&gt;$_&lt;/TD&gt;";
}
$str.="&lt;/TR&gt;";
for my $norm(@norms){
$str.="&lt;TR&gt;&lt;TD&gt;$norm&lt;/TD&gt;";
my $cursum=0;
for(1..50){
  $cursum+=oddsUp($norm,$_);
  $str.="&lt;TD&gt;".int($cursum)."&lt;/TD&gt;";
}
$str.="&lt;/TR&gt;";
}
$str.="&lt;/TABLE&gt;";
$str;

%]

</patch_code>
<applied>2006-04-17 14:04:15</applied>
<htmlcode_id>26917</htmlcode_id>
<live_code>&lt;p&gt;
This table shows how much [id://5938|XP] you can expect to get
from a node you wrote, as its reputation rises.
&lt;/p&gt;&lt;p&gt;
The numbers along the top are the reputation of a node.
(This number fluctuates as other monks up-vote and down-vote the node.
You hope it only goes up!)
&lt;/p&gt;&lt;p&gt;
The numbers down the left side are $NORM, explained in [id://5938].
&lt;/p&gt;&lt;p&gt;
For illustration purposes, look at the last row, where $NORM is 10.
If you have a node which has a reputation 21, you can expect that
you've gotten about 9 XP from that node. Of course, it's not accrued
to you all at once; XP from node rep is allotted as the node's rep
changes. And you may not have gotten &lt;i&gt;exactly&lt;/i&gt; 9 XP from that
node; perhaps the node has been around a while, and some of the
voting on it occurred when $NORM was 9.5, or even lower. In that
case, you may have gotten more than 9 XP from it.
&lt;/p&gt;
[%
local *oddsUp=sub{
   my($norm,$rep)=@_;
   return 1/3 if $rep&lt;$norm;
   return 1/2 if $rep&lt;2*$norm;
   return 2/3 if $rep&lt;3*$norm;
   return 3/4 if $rep&lt;4*$norm;
   return 1 if $rep;
};
my $str;
my @norms;
for(1..20){
   push @norms,$_/2;
}

$str.="&lt;TABLE border=1&gt;";

$str.="&lt;TR&gt;&lt;TD&gt;&lt;/TD&gt;";
for(1..50){
   $str.="&lt;TD&gt;$_&lt;/TD&gt;";
}
$str.="&lt;/TR&gt;";
for my $norm(@norms){
$str.="&lt;TR&gt;&lt;TD&gt;$norm&lt;/TD&gt;";
my $cursum=0;
for(1..50){
  $cursum+=oddsUp($norm,$_);
  $str.="&lt;TD&gt;".int($cursum)."&lt;/TD&gt;";
}
$str.="&lt;/TR&gt;";
}
$str.="&lt;/TABLE&gt;";
$str;

%]

</live_code>
<reason>a little explanation is in order</reason>
<field>doctext</field>
</record>
<record><htmlcode_id>783309</htmlcode_id>
<patch_code>[%
  local *nodeurl = sub {
     my $n=shift;
     (my $site=$HTMLVARS{site_url})=~s!/+$!!;
     return $site.$ENV{SCRIPT_NAME}.
            urlGen({ node_id=&gt; ref $n ? $n-&gt;{node_id} : $n },1);
  };

  my $days = $q-&gt;param('days') || 1;
  my $since = $q-&gt;param('sinceunixtime')
    || $VARS-&gt;{lastviewednewestnodes}
    || time() - $days*86400;

  my $asked=$since;

  $since = $since&lt;$_ ? $_ : $since
    for  time() - 86400 * 8;

  my $lastchecked =  $DB-&gt;sqlSelect(
    "FROM_UNIXTIME($since)", "node", "", "limit 1" );
  $lastchecked    =~ s/\D//g;

  return "&lt;error&gt;Error creating fling object&lt;/error&gt;"
     unless htmlcode('new_xml_fling','',\my($xml,@data,%xmlstyle),'add_header');

  require POSIX;

  my $site={
      site        =&gt; $HTMLVARS{site_url},
      sitename    =&gt; $HTMLVARS{site_name},
      foruser     =&gt; $USER-&gt;{title},
      foruser_id  =&gt; $USER-&gt;{node_id},
      min_poll_seconds =&gt; 30,
      style      =&gt; join(',',grep $xmlstyle{$_}, keys %xmlstyle),
      gentimeGMT =&gt; POSIX::strftime("%Y-%m-%d %H:%M:%S",
                                    gmtime(time)),

      req_from    =&gt; "".localtime($asked),
      got_from    =&gt; "".localtime($since),
      lastchecked =&gt; $lastchecked,
  };

  $xml-&gt;header("windows-1252");
  unless ($xmlstyle{rss}) {
    $xml-&gt;start('NEWESTNODES');
    $xml-&gt;element( 'INFO',%$site,
                   'Rendered by the Perlmonks Newest Nodes XML Generator'
    );
  } else {
     $xml-&gt;start(rss=&gt;version=&gt;'2.0',
                      'xmlns:perlmonks'=&gt;nodeurl(393035),
                      'xmlns:dc'       =&gt;"http://purl.org/dc/elements/1.1/");
     $xml-&gt;start('channel');
     $xml-&gt;element(ttl=&gt;60);
     $xml-&gt;element(title=&gt;'PerlMonks - Newest Nodes');
     $xml-&gt;element(description=&gt;'New nodes appearing on PerlMonks');
     $xml-&gt;element(link=&gt;nodeurl($NODE));
     $xml-&gt;element(docs=&gt;'http://blogs.law.harvard.edu/tech/rss');
     $xml-&gt;element(generator=&gt;'PerlMonks Newest Nodes XML Generator');
     foreach my $key (keys %$site) {
        $xml-&gt;element("perlmonks:$key",$site-&gt;{$key});
     }
  }
  my $h={};
  htmlcode('handle_nn_settings','',$h);

  my %authors;
  foreach my $type (  @{$h-&gt;{types}}  ) {
    my $id = getId( getType($type) );
    next unless $id;

    my $sth = $DB-&gt;getDatabaseHandle-&gt;prepare("
      SELECT node.*,note.*,concat(left(doctext,200),'...') as abbreviated
      FROM node
      LEFT JOIN note ON node_id = note_id
      LEFT JOIN document ON document_id = node_id
      WHERE  createtime    &gt;= $lastchecked
        AND  type_nodetype  = $id
      ORDER  BY createtime DESC
    ");

    $sth-&gt;execute();

    while (  my $node = $sth-&gt;fetchrow_hashref  ) {
      $authors{ $node-&gt;{author_user} }||=getNodeById($node-&gt;{author_user});
      if( $authors{ $node-&gt;{author_user}} == -1) {
          $authors{ $node-&gt;{author_user} } = { 
              title =&gt; sprintf('No such user (%s)', $node-&gt;{author_user}),
          };
      };

      my $usertime=htmlcode('parseTimeInString','',$node-&gt;{createtime},undef,undef,"RFC822");
      my $time = $node-&gt;{createtime};
      $time    =~ s/\D//g;

      my @note = map {
        $_ =&gt; $node-&gt;{$_}
      } grep {
        $node-&gt;{$_}
      } qw/root_node parent_node/;

      unless ($xmlstyle{rss}) {
        $xml-&gt;element( 'NODE',
            nodetype    =&gt; $type,
            author_user =&gt; $node-&gt;{author_user},
            authortitle =&gt; $authors{ $node-&gt;{author_user} }-&gt;{title},
            createtime  =&gt; $time,
            # usercreatetime  =&gt; $usertime,
            node_id     =&gt; $node-&gt;{node_id},
            @note,
          $node-&gt;{title} );
      } else {
        $node-&gt;{abbreviated}||='';
        $node-&gt;{abbreviated}=~s#&lt;[^&gt;]*&gt;##g;
        $node-&gt;{abbreviated}=~s/&lt;[^&gt;]*\.\.\.$/.../;
        $node-&gt;{abbreviated}=htmlcode('parselinksinchatter','',$node-&gt;{abbreviated});
        $xml-&gt;start('item','perlmonks:itemtype'=&gt;'node');
          $xml-&gt;element('title'=&gt;$node-&gt;{title});
          $xml-&gt;element('dc:creator'=&gt;$authors{ $node-&gt;{author_user} }-&gt;{title});
          $xml-&gt;element('link' =&gt;nodeurl($node));
          $xml-&gt;element('description'=&gt;$node-&gt;{abbreviated})
            if $node-&gt;{abbreviated} ne '...';
          $xml-&gt;element('category'=&gt;$type);
          $xml-&gt;element('pubDate'=&gt;$usertime);
          $xml-&gt;element('guid'=&gt;nodeurl($node-&gt;{node_id}));
          $xml-&gt;element('perlmonks:node_id'=&gt;$node-&gt;{node_id});
          $xml-&gt;element('perlmonks:author_user'=&gt;$node-&gt;{author_user});
          $xml-&gt;element('perlmonks:createtime'=&gt;$node-&gt;{createtime});
          $xml-&gt;element('perlmonks:authortitle'=&gt;$authors{ $node-&gt;{author_user} }-&gt;{title});
        $xml-&gt;end('item');
      }
    }
  }

  unless ($xmlstyle{rss}) {
      foreach my $user (  sort { $a-&gt;{node_id}&lt;=&gt;$b-&gt;{node_id} } values %authors  )
      {
            unless ($xmlstyle{rss}) {
                $xml-&gt;element( 'AUTHOR',
                  node_id =&gt; $user-&gt;{node_id},
                $user-&gt;{title} );
            } else {
                $xml-&gt;start('item','perlmonks:itemtype'=&gt;'author');
                  $xml-&gt;element('title'=&gt;$user-&gt;{title});
                  $xml-&gt;element('link' =&gt;nodeurl($user));
                  #$xml-&gt;element('description'=&gt;$user-&gt;{abbreviated});
                  $xml-&gt;element('perlmonks:node_id'=&gt;$user-&gt;{node_id});
                  $xml-&gt;element('category','user');
                $xml-&gt;end('item');
            }
      }
  }
  unless ($xmlstyle{rss}) {
    $xml-&gt;end('NEWESTNODES');
  } else {
    $xml-&gt;end('channel');
    $xml-&gt;end('rss');
  }

  return join '', @data;
%]</patch_code>
<applied>2009-07-26 08:35:08</applied>
<htmlcode_id>30175</htmlcode_id>
<live_code>[%
  local *nodeurl = sub {
     my $n=shift;
     (my $site=$HTMLVARS{site_url})=~s!/+$!!;
     return $site.$ENV{SCRIPT_NAME}.
            urlGen({ node_id=&gt; ref $n ? $n-&gt;{node_id} : $n },1);
  };

  my $days = $q-&gt;param('days') || 0.25;
  my $since = $q-&gt;param('sinceunixtime')
    || $VARS-&gt;{lastviewednewestnodes}
    || time() - $days*86400;

  my $asked=$since;

  $since = $since&lt;$_ ? $_ : $since
    for  time() - 86400 * 3;

  my $lastchecked =  $DB-&gt;sqlSelect(
    "FROM_UNIXTIME($since)", "node", "", "limit 1" );
  $lastchecked    =~ s/\D//g;

  return "&lt;error&gt;Error creating fling object&lt;/error&gt;"
     unless htmlcode('new_xml_fling','',\my($xml,@data,%xmlstyle),'add_header');

  require POSIX;

  my $site={
      site        =&gt; $HTMLVARS{site_url},
      sitename    =&gt; $HTMLVARS{site_name},
      foruser     =&gt; $USER-&gt;{title},
      foruser_id  =&gt; $USER-&gt;{node_id},
      min_poll_seconds =&gt; 30,
      style      =&gt; join(',',grep $xmlstyle{$_}, keys %xmlstyle),
      gentimeGMT =&gt; POSIX::strftime("%Y-%m-%d %H:%M:%S",
                                    gmtime(time)),

      req_from    =&gt; "".localtime($asked),
      got_from    =&gt; "".localtime($since),
      lastchecked =&gt; $lastchecked,
  };

  $xml-&gt;header("windows-1252");
  unless ($xmlstyle{rss}) {
    $xml-&gt;start('NEWESTNODES');
    $xml-&gt;element( 'INFO',%$site,
                   'Rendered by the Perlmonks Newest Nodes XML Generator'
    );
  } else {
     $xml-&gt;start(rss=&gt;version=&gt;'2.0',
                      'xmlns:perlmonks'=&gt;nodeurl(393035),
                      'xmlns:dc'       =&gt;"http://purl.org/dc/elements/1.1/");
     $xml-&gt;start('channel');
     $xml-&gt;element(ttl=&gt;60);
     $xml-&gt;element(title=&gt;'PerlMonks - Newest Nodes');
     $xml-&gt;element(description=&gt;'New nodes appearing on PerlMonks');
     $xml-&gt;element(link=&gt;nodeurl($NODE));
     $xml-&gt;element(docs=&gt;'http://blogs.law.harvard.edu/tech/rss');
     $xml-&gt;element(generator=&gt;'PerlMonks Newest Nodes XML Generator');
     foreach my $key (keys %$site) {
        $xml-&gt;element("perlmonks:$key",$site-&gt;{$key});
     }
  }
  my $h={};
  htmlcode('handle_nn_settings','',$h);

  my %authors;
  foreach my $type (  @{$h-&gt;{types}}  ) {
    my $id = getId( getType($type) );
    next unless $id;

    my $sth = $DB-&gt;getDatabaseHandle-&gt;prepare("
      SELECT node.*,note.*,concat(left(doctext,200),'...') as abbreviated
      FROM node
      LEFT JOIN note ON node_id = note_id
      LEFT JOIN document ON document_id = node_id
      WHERE  createtime    &gt;= $lastchecked
        AND  type_nodetype  = $id
      ORDER  BY createtime DESC
    ");

    $sth-&gt;execute();

    while (  my $node = $sth-&gt;fetchrow_hashref  ) {
      $authors{ $node-&gt;{author_user} }||=getNodeById($node-&gt;{author_user});
      if( $authors{ $node-&gt;{author_user}} == -1) {
          $authors{ $node-&gt;{author_user} } = { 
              title =&gt; sprintf('No such user (%s)', $node-&gt;{author_user}),
          };
      };

      my $usertime=htmlcode('parseTimeInString','',$node-&gt;{createtime},undef,undef,"RFC822");
      my $time = $node-&gt;{createtime};
      $time    =~ s/\D//g;

      my @note = map {
        $_ =&gt; $node-&gt;{$_}
      } grep {
        $node-&gt;{$_}
      } qw/root_node parent_node/;

      unless ($xmlstyle{rss}) {
        $xml-&gt;element( 'NODE',
            nodetype    =&gt; $type,
            author_user =&gt; $node-&gt;{author_user},
            authortitle =&gt; $authors{ $node-&gt;{author_user} }-&gt;{title},
            createtime  =&gt; $time,
            # usercreatetime  =&gt; $usertime,
            node_id     =&gt; $node-&gt;{node_id},
            @note,
          $node-&gt;{title} );
      } else {
        $node-&gt;{abbreviated}||='';
        $node-&gt;{abbreviated}=~s#&lt;[^&gt;]*&gt;##g;
        $node-&gt;{abbreviated}=~s/&lt;[^&gt;]*\.\.\.$/.../;
        $node-&gt;{abbreviated}=htmlcode('parselinksinchatter','',$node-&gt;{abbreviated});
        $xml-&gt;start('item','perlmonks:itemtype'=&gt;'node');
          $xml-&gt;element('title'=&gt;$node-&gt;{title});
          $xml-&gt;element('dc:creator'=&gt;$authors{ $node-&gt;{author_user} }-&gt;{title});
          $xml-&gt;element('link' =&gt;nodeurl($node));
          $xml-&gt;element('description'=&gt;$node-&gt;{abbreviated})
            if $node-&gt;{abbreviated} ne '...';
          $xml-&gt;element('category'=&gt;$type);
          $xml-&gt;element('pubDate'=&gt;$usertime);
          $xml-&gt;element('guid'=&gt;nodeurl($node-&gt;{node_id}));
          $xml-&gt;element('perlmonks:node_id'=&gt;$node-&gt;{node_id});
          $xml-&gt;element('perlmonks:author_user'=&gt;$node-&gt;{author_user});
          $xml-&gt;element('perlmonks:createtime'=&gt;$node-&gt;{createtime});
          $xml-&gt;element('perlmonks:authortitle'=&gt;$authors{ $node-&gt;{author_user} }-&gt;{title});
        $xml-&gt;end('item');
      }
    }
  }

  unless ($xmlstyle{rss}) {
      foreach my $user (  sort { $a-&gt;{node_id}&lt;=&gt;$b-&gt;{node_id} } values %authors  )
      {
            unless ($xmlstyle{rss}) {
                $xml-&gt;element( 'AUTHOR',
                  node_id =&gt; $user-&gt;{node_id},
                $user-&gt;{title} );
            } else {
                $xml-&gt;start('item','perlmonks:itemtype'=&gt;'author');
                  $xml-&gt;element('title'=&gt;$user-&gt;{title});
                  $xml-&gt;element('link' =&gt;nodeurl($user));
                  #$xml-&gt;element('description'=&gt;$user-&gt;{abbreviated});
                  $xml-&gt;element('perlmonks:node_id'=&gt;$user-&gt;{node_id});
                  $xml-&gt;element('category','user');
                $xml-&gt;end('item');
            }
      }
  }
  unless ($xmlstyle{rss}) {
    $xml-&gt;end('NEWESTNODES');
  } else {
    $xml-&gt;end('channel');
    $xml-&gt;end('rss');
  }

  return join '', @data;
%]</live_code>
<reason>Add "dc:creator" tag for RSS, placate the validator gods</reason>
<field>doctext</field>
</record>
<record><htmlcode_id>673329</htmlcode_id>
<patch_code>[%
my $reviewtype=$query-&gt;param('reviewtype');

return "Try coming here from the ".linkNodeTitle('Reviews')." page" unless $reviewtype eq "book" or $reviewtype eq "module";

return "You must be logged in to post a new review"
    if getId($USER) == $HTMLVARS{guest_user};;

my $str;
$str.=htmlcode('openform');
$str.="Review type:&lt;B&gt;".ucfirst($reviewtype)."&lt;/B&gt;&lt;BR&gt;&lt;BR&gt;";
$str.='Book or Module Name:&lt;BR&gt;&lt;INPUT TYPE="text" name="node" value=""&gt;&lt;BR&gt;';
my %labels;

$str.="Book/Module Description:&lt;BR&gt;".$query-&gt;textfield(-name=&gt;$reviewtype.'review_itemdescription',-size=&gt;60,-maxlength=&gt;250)."&lt;BR&gt;";
$str.="ISBN number:&lt;BR&gt;".$query-&gt;textfield(-name=&gt;$reviewtype.'review_itemdescription',-size=&gt;60,-maxlength=&gt;250)."&lt;BR&gt;";
$str.="Review Synopsis:&lt;BR&gt;".$query-&gt;textfield(-name=&gt;$reviewtype.'review_identification',-size=&gt;60,-maxlength=&gt;250)."&lt;BR&gt;" if $reviewtype eq "book";

$str.="Review Text:&lt;BR&gt;".$query-&gt;textarea($reviewtype."review_doctext",'',10,60);
$str.='&lt;INPUT TYPE="hidden" name="op" value="new"&gt;';
$str.='&lt;INPUT TYPE="hidden" name="type" value="'.$reviewtype.'review"&gt;';
$str.=htmlcode('closeform');
$str;

%]</patch_code>
<applied>2008-03-10 15:41:22</applied>
<htmlcode_id>31673</htmlcode_id>
<live_code>[%
    my $reviewtype= $q-&gt;param('reviewtype');

    return join( ' ',
        "Try coming here from the",
        linkNodeTitle('Reviews'),
        "page"
    )
        if  $reviewtype ne "book"
        &amp;&amp;  $reviewtype ne "module";

    return "You must be logged in to post a new review"
        if  getId($USER) == $HTMLVARS{guest_user};

    my $what= ucfirst( $reviewtype );
    my $html= join( "\n",
        htmlcode('openform'),
        "&lt;p&gt;Review type: &lt;b&gt;$what&lt;/b&gt;&lt;/p&gt;",
        "$what name:&lt;br /&gt;",
        '&lt;input type="text" name="node" value=""&gt;&lt;br /&gt;',
        $reviewtype ne "book" ? '' : join("\n",
            "ISBN:&lt;br /&gt;",
            $q-&gt;textfield(
                -name =&gt; $reviewtype . 'review_identifier',
                -size =&gt; 32,
                -maxlength =&gt; 32,
            ),
            "&lt;br /&gt;",
        ),
        "$what Description:&lt;br /&gt;",
        $q-&gt;textfield(
            -name =&gt; $reviewtype . 'review_itemdescription',
            -size =&gt; 60,
            -maxlength =&gt; 255,
        ),
        "&lt;br /&gt;",
        "Review synopsis:&lt;br /&gt;",
        $q-&gt;textfield(
            -name =&gt; $reviewtype . 'review_usercomment',
            -size =&gt; 60,
            -maxlength =&gt; 255,
        ),
        "&lt;br /&gt;",
        "Review Text:&lt;br /&gt;",
        $q-&gt;textarea(
            $reviewtype . "review_doctext", '', 10, 60,
        ),
        '&lt;input type="hidden" name="op" value="new"&gt;',
        '&lt;input type="hidden" name="type" value="' . $reviewtype . 'review"&gt;',
        htmlcode('closeform'),
    '');
    return $html;
%]
</live_code>
<reason>Disallow anonymous access</reason>
<field>doctext</field>
</record>
<record><htmlcode_id>752235</htmlcode_id>
<patch_code>[%
  my @nodes = grep !/\D/, split ',', $query-&gt;param('nodes');
  return "&lt;error&gt;Error creatng fling object&lt;/error&gt;"
     unless htmlcode('new_xml_fling','',\my($xml,@data,%xmlstyle),"add_header");

  my $tag_info = $xmlstyle{clean} ? 'info' : 'INFO';
  my $tag_node = $xmlstyle{clean} ? 'node' : 'NODE';

  $xml-&gt;header("windows-1252")-&gt;
    start( $tag_info,
      site     =&gt; $HTMLVARS{site_url},
      sitename =&gt; $HTMLVARS{site_name},
      "Rendered by the Node query XML Generator"
    );

    foreach my $n ( grep ref $_, map getNodeById($_), @nodes ) {
      $n-&gt;{createtime} =~ s/\D//g;

      my @attrs = (
        node_id     =&gt; getId($n),
        author_user =&gt; $n-&gt;{author_user},
        createtime  =&gt; $n-&gt;{createtime},
        lastupdate  =&gt; $n-&gt;{lastupdate},
        nodetype    =&gt; $n-&gt;{type}{title}
      );

      my( $author_name )= $DB-&gt;sqlSelect('title', 'node', "node_id = $n-&gt;{author_user}");
      if (defined $author_name) {
       push @attrs, author_name =&gt; $author_name;
      }

      if ( $n-&gt;{type}{title} eq 'note'  ||  $n-&gt;{type}{title} eq 'categorized answer' ) {
        push @attrs,
          parent_node =&gt; $n-&gt;{parent_node},
          root_node =&gt; $n-&gt;{root_node},
          root_type =&gt; getNodeById( $n-&gt;{root_node} )-&gt;{type}{title};
      }

      $xml-&gt;element( $tag_node, @attrs, $n-&gt;{title} );
    }

  $xml-&gt;end;

  return join '', @data;
%]</patch_code>
<applied>2009-03-21 10:10:48</applied>
<htmlcode_id>37150</htmlcode_id>
<live_code>[%
  my @nodes = grep !/\D/, split ',', $query-&gt;param('nodes');
  return "&lt;error&gt;Error creatng fling object&lt;/error&gt;"
     unless htmlcode('new_xml_fling','',\my($xml,@data,%xmlstyle),"add_header");

  my $tag_info = $xmlstyle{clean} ? 'info' : 'INFO';
  my $tag_node = $xmlstyle{clean} ? 'node' : 'NODE';

  $xml-&gt;header("windows-1252")-&gt;
    start( $tag_info,
      site     =&gt; $HTMLVARS{site_url},
      sitename =&gt; $HTMLVARS{site_name},
      "Rendered by the Node query XML Generator"
    );

    foreach my $n ( grep ref $_, map getNodeById($_), @nodes ) {
      $n-&gt;{createtime} =~ s/\D//g;

      my @attrs = (
        node_id     =&gt; getId($n),
        author_user =&gt; $n-&gt;{author_user},
        createtime  =&gt; $n-&gt;{createtime},
        lastupdate  =&gt; $n-&gt;{lastupdate},
        nodetype    =&gt; $n-&gt;{type}{title}
      );

      my( $author_name )= $DB-&gt;sqlSelect('title', 'node', "node_id = $n-&gt;{author_user}");
      if (defined $author_name) {
       push @attrs, author_name =&gt; $author_name;
      }

      if ( $n-&gt;{type}{title} eq 'note'  ||  $n-&gt;{type}{title} eq 'categorized answer' ) {
        push @attrs,
          parent_node =&gt; $n-&gt;{parent_node},
          root_node =&gt; $n-&gt;{root_node},
          root_type =&gt; getNodeById( $n-&gt;{root_node} )-&gt;{type}{title};
      }

      $xml-&gt;element( $tag_node, @attrs, $n-&gt;{title} );
    }

  $xml-&gt;end;

  my $data = join "",@data;       
  htmlcode('postProcessXML','',\$data);
  return $data;
%]</live_code>
<reason>encoding in xml header</reason>
<field>doctext</field>
</record>
<record><htmlcode_id>676190</htmlcode_id>
<patch_code>[%
  return '' unless $q-&gt;param('displaytype') eq 'raw';
  my $common = htmlcode('htmlhead');
  qq[&lt;html id="privatemessages"&gt;
    &lt;head&gt;
     &lt;meta http-equiv="refresh" content="30;URL=?node_id=50772&amp;displaytype=raw" /&gt;
     &lt;base target="_new" /&gt;
     $common
    &lt;/head&gt;
    &lt;body&gt;\n] . htmlcode("userbody");
%]
[{openform:-target,_self}]
&lt;input type="hidden" name="op" value="message" /&gt;
[{showprivatemessages}]
[{closeform:delete}]
[% $q-&gt;param('displaytype') eq 'raw' ? "&lt;/body&gt;\n&lt;/html&gt;\n" : '' %]</patch_code>
<applied>2008-03-25 14:28:26</applied>
<htmlcode_id>50772</htmlcode_id>
<live_code>[%
    my $id= $NODE-&gt;{node_id};
    my $common= htmlcode('htmlhead');
    my $refresh= $q-&gt;param('refresh') || 60;
    $refresh= 30
        if  $refresh =~ /\D/  ||  $refresh &lt; 30;
    my $url= "?node_id=$id;refresh=$refresh";
    return join "\n",
        "&lt;html id='privatemessages'&gt;",
        "&lt;head&gt;",
        "&lt;meta http-equiv='refresh' content='$refresh;URL=$url' /&gt;",
        "&lt;base target='_new' /&gt;",
        $common,
        "&lt;/head&gt;",
        "&lt;body&gt;",
        htmlcode( 'openform','', -target =&gt; '_self' ),
        $q-&gt;hidden( -name=&gt;'op', -value=&gt;'message', -force=&gt;1 ),
        $q-&gt;hidden( -name=&gt;'refresh', -value=&gt;$refresh, -force=&gt;1 ),
        htmlcode( 'showprivatemessages' ),
        htmlcode( 'closeform','', 'delete' ),
        "&lt;/body&gt;\n&lt;/html&gt;\n";
%]</live_code>
<reason>numeric ID not valid CSS</reason>
<field>doctext</field>
</record>
<record><htmlcode_id>680609</htmlcode_id>
<patch_code>[%

my %id2class;
my %id2type;
my %auths;

my $parsetime=sub{""};
htmlcode('reusable_code','','parsetimeinstring',\$parsetime);

local *make_link= sub {
  my ( $id, $title, $tid, $fc )= @_;
  my $extra;
  if ( ref $id ) {
    $fc=$title;
    $auths{$id-&gt;{author_user}}||=$id-&gt;{author_user}&gt;0 
                                 ? getNodeById($id-&gt;{author_user})-&gt;{title}
                                 : $id-&gt;{author_user};
    my $updated=$parsetime-&gt;($id-&gt;{nodeupdated});
    $updated=~s/&lt;[^&gt;]+&gt;//g;
    $extra=$q-&gt;escapeHTML( join " - ",
            "by $auths{$id-&gt;{author_user}}",
            $id2type{$id-&gt;{type_nodetype}}{title},
            $id-&gt;{hits}." hits",
            "updated ".$updated,
    );
    ($id,$title,$tid)=@{$id}{qw(node_id title type_nodetype)};
    $tid= $id if $tid == 1;
  } else {
    $extra=$id2type{$tid}{title};
  }
  my @line=("");
  $title=$q-&gt;escapeHTML( $title );
  while ($title=~/\G(([a-z]{1,25})|(&amp;[a-z]+;|[^a-z\s]+)|(\s+))/gi) {
    if ( length($line[-1]) + length($1) &lt;= 25 ) {
      $line[-1].=$1;
    } elsif ($4) {
      push @line,"";
    } else {
      push @line,$1;
    }
  }
  sprintf "%s&lt;a href='?node_id=%s' title='%s' class='%s'&gt;%s&lt;/a&gt;",
           $fc, $id, $extra, $id2class{$tid}, join("&lt;br/&gt;",@line);
};


local *make_cols=sub {
  my ( $ary, $numcols )= @_;
  $numcols ||= 3;
  $numcols= @$ary if $numcols&gt;@$ary;

  my $depth= int( @$ary / $numcols + 0.5 );
  my @depths= (
                ($depth) x ($numcols-1),
                # If a column will be short it will
                # always be the last.
                @$ary- ($depth *  ($numcols-1))
              );
  my ( $lc, $cur, @cols )= ( "", 0, );

  foreach my $row (@$ary) {
    my $cell= "&amp;nbsp;";
    if (ref $row) {
      $cell= make_link($row,"&amp;bull;");
    } else {
      $cell= $row;
    }
    push @{$cols[$cur]}, $cell;
    $cur++ if ! --$depths[$cur];
  }
  return $q-&gt;table( join "",
    "&lt;colgroup span='$numcols' width='"
    . int(100/$numcols)
    . "%'&gt;&lt;/colgroup&gt;",
    map {
      my $y= $_;
      $q-&gt;Tr(
        $q-&gt;td(
          [ map { $cols[$_][$y] || "&amp;nbsp;" }
            (0..$numcols-1) ]
        )
      )
    } (0..$depth-1)
  );
};

my $dbh=$DB-&gt;getDatabaseHandle();


my %type_count;
{
  my $sth=$dbh-&gt;prepare(
    'select type_nodetype, count(node_id) num from node group by type_nodetype'
  );
  $sth-&gt;execute;
  while ( my @rec=$sth-&gt;fetchrow_array ) {
    $type_count{$rec[0]}=$rec[1];
  }
}

my $NN= getVars(getNode('Newest Nodes Setting','setting'));
my %ignore_type= map { $_ =&gt; !!1 }
                     qw(patch pmdevnote pmdevtopic zombie_user 
                        bug scratchpad rawdata),
                     split /,/,$NN-&gt;{nodetypes_all};


my %user_choice;
my $allbut;
my @sel;
my $numcols;

my $allbut_param= 'allbut';
my $seltype_param= 'sel-type';
my $cols_param= 'numcols';

if (  grep { $q-&gt;param($_) } 'sexisgood',
      $allbut_param, $seltype_param, $cols_param )
{
  ($numcols)= $q-&gt;param($cols_param)=~/^([1-9])$/;
  $allbut= $q-&gt;param($allbut_param);
  @sel= $q-&gt;param($seltype_param);
} else {
  $numcols=$VARS-&gt;{bpnl_numcols};
  $allbut=$VARS-&gt;{bpnl_allbut};
  @sel= ($VARS-&gt;{bpnl_types});
}
use Data::Dumper;
$numcols||=3;
foreach my $n ( grep { $type_count{$_} }
                map { split /,/, $_ }  @sel )
{
  $user_choice{$n}= !!1;
}
my @debug;#=("&lt;code&gt;".Dumper($allbut,\@sel,\%user_choice,\%type_count)."&lt;/code&gt;");
if ($numcols==3) {
  delete $VARS-&gt;{bpnl_numcols};
} else {
  $VARS-&gt;{bpnl_numcols}=$numcols;
}
if ($allbut) {
  $allbut=!!1;
  $VARS-&gt;{bpnl_allbut}=1;
} else {
  $allbut=!!0;
  delete $VARS-&gt;{bpnl_allbut};
}
if (%user_choice) {
  $VARS-&gt;{bpnl_types}=join ",", keys %user_choice;
} else {
  delete $VARS-&gt;{bpnl_types};
}

my @css;
my @typeid;
my @legal;
foreach my $type (
   sort { lc($a-&gt;{title}) cmp lc($b-&gt;{title}) }
   $DB-&gt;getAllTypes()
){
  my ($title,$id)=@{$type}{qw(title node_id)};
  next if $ignore_type{ $title } || ! $type_count{ $id };

  push @legal,$id;
  push @css, "nodetype-$id";
  $id2class {$id }= "nodetype-$id";
  $id2type{ $id }= $type;

  next if $allbut == !!$user_choice{ $id };

  push @typeid, $id;
}

@typeid=(4) if !@typeid;

my $intype= "type_nodetype in ("
          . join( ",", @typeid )
          . ")";

my ($lc,@ary,@anch)=("");
{
  my $sth= $dbh-&gt;prepare(
    "select * from node where $intype order by title",
  );
  $sth-&gt;execute();


  while (my $row= $sth-&gt;fetchrow_hashref) {
    my ( $fc )= lc($row-&gt;{title})=~/^([a-z])/;
    if ( $fc &amp;&amp; $fc ne $lc ) {
      $lc= $fc;
      push @anch,"&lt;a href='#listpos-$fc'&gt;\U$fc\E&lt;/a&gt;";
      push @ary, "&lt;table&gt;&lt;tr&gt;&lt;td align='center' width='70%'&gt;"
         . "&lt;big&gt;&lt;big&gt;&lt;b&gt;&lt;a name='listpos-$fc'&gt;\U$fc\E&lt;/a&gt;&lt;/b&gt;&lt;/big&gt;&lt;/big&gt;&lt;/td&gt;"
         . "&lt;td align='right'&gt;&lt;sub&gt;&lt;a href='#top'&gt;(top)&lt;/a&gt;&lt;/sub&gt;&lt;/td&gt;&lt;/tr&gt;"
         . "&lt;/table&gt;";
    }
    push @ary,{ %$row };
  }
}

join "\n",
  htmlcode( 'colorblend', '', 0 + @css,
               \my @colors, $THEME, \@css, q[] ),
  "&lt;p align='center'&gt;&lt;a name='top'&gt;&lt;/a&gt;"
  . join(" | ",@anch)
  . "&lt;br /&gt;&lt;small&gt;&lt;a href='#config'&gt;config&lt;/a&gt; - ("
  . ( 0+@ary )
  . " : "
  . ( join ", ",map { make_link($id2type{$_}) } @typeid )
  . ")&lt;/small&gt;&lt;/p&gt;&lt;hr/&gt;",
  "&lt;center&gt;",
  make_cols( \@ary, $numcols),
  "&lt;/center&gt;",
  "&lt;hr/&gt;&lt;a name='config'&gt;&lt;/a&gt;&lt;center&gt;&lt;small&gt;&lt;a href='#top'&gt;(top)&lt;/a&gt;&lt;br/&gt;",
  htmlcode('openform'),
  $q-&gt;checkbox(
        -name=&gt;$allbut_param,
        -checked=&gt;0,
        -value=&gt;1,
        -force=&gt;1,
        -label=&gt;'Show all but selected types?',
   ),
   "&lt;br /&gt;",
   $q-&gt;checkbox_group(
        -name =&gt; $seltype_param,
        -values =&gt; \@legal,
        -default =&gt; \@typeid,
        -force =&gt;1,
        -labels =&gt; { map {
                    $_ =&gt; make_link($id2type{$_})
                          . " (" . $type_count{$_} . ")"
                   } @legal },
        -cols =&gt; $numcols+1,
   ),
   "&lt;br/&gt;Number of columns to show:",
   $q-&gt;popup_menu(-name=&gt;$cols_param,
                  -values=&gt;[1..9],
                  -force=&gt;1,
                  -default=&gt;$numcols),
   "&lt;br/&gt;",
   htmlcode('closeform'),
   '&lt;/small&gt;&lt;/center&gt;',
  @debug
;

%]</patch_code>
<applied>2008-04-15 14:04:49</applied>
<htmlcode_id>56885</htmlcode_id>
<live_code>[%

my %id2class;
my %id2type;
my %auths;

my $parsetime=sub{""};
htmlcode('reusable_code','','parsetimeinstring',\$parsetime);

local *make_link= sub {
  my ( $id, $title, $tid, $fc )= @_;
  my $extra;
  if ( ref $id ) {
    $fc=$title;
    $auths{$id-&gt;{author_user}}||=$id-&gt;{author_user}&gt;0 
                                 ? getNodeById($id-&gt;{author_user})-&gt;{title}
                                 : $id-&gt;{author_user};
    my $updated=$parsetime-&gt;($id-&gt;{nodeupdated});
    $updated=~s/&lt;[^&gt;]+&gt;//g;
    $extra=$q-&gt;escapeHTML( join " - ",
            "by $auths{$id-&gt;{author_user}}",
            $id2type{$id-&gt;{type_nodetype}}{title},
            $id-&gt;{hits}." hits",
            "updated ".$updated,
    );
    ($id,$title,$tid)=@{$id}{qw(node_id title type_nodetype)};
    $tid= $id if $tid == 1;
  } else {
    $extra=$id2type{$tid}{title};
  }
  my @line=("");
  $title=$q-&gt;escapeHTML( $title );
  while ($title=~/\G(([a-z]{1,25})|(&amp;[a-z]+;|[^a-z\s]+)|(\s+))/gi) {
    if ( length($line[-1]) + length($1) &lt;= 25 ) {
      $line[-1].=$1;
    } elsif ($4) {
      push @line,"";
    } else {
      push @line,$1;
    }
  }
  sprintf "%s&lt;a href='?node_id=%s' title='%s' class='%s'&gt;%s&lt;/a&gt;",
           $fc, $id, $extra, $id2class{$tid}, join("&lt;br/&gt;",@line);
};


local *make_cols=sub {
  my ( $ary, $numcols )= @_;
  $numcols ||= 3;
  $numcols= @$ary if $numcols&gt;@$ary;

  my $depth= int( @$ary / $numcols + 0.5 );
  my @depths= (
                ($depth) x ($numcols-1),
                # If a column will be short it will
                # always be the last.
                @$ary- ($depth *  ($numcols-1))
              );
  my ( $lc, $cur, @cols )= ( "", 0, );

  foreach my $row (@$ary) {
    my $cell= "&amp;nbsp;";
    if (ref $row) {
      $cell= make_link($row,"&amp;bull;");
    } else {
      $cell= $row;
    }
    push @{$cols[$cur]}, $cell;
    $cur++ if ! --$depths[$cur];
  }
  return $q-&gt;table( join "",
    "&lt;colgroup span='$numcols' width='"
    . int(100/$numcols)
    . "%'&gt;&lt;/colgroup&gt;",
    map {
      my $y= $_;
      $q-&gt;Tr(
        $q-&gt;td(
          [ map { $cols[$_][$y] || "&amp;nbsp;" }
            (0..$numcols-1) ]
        )
      )
    } (0..$depth-1)
  );
};

my $dbh=$DB-&gt;getDatabaseHandle();


my %type_count;
{
  my $sth=$dbh-&gt;prepare(
    'select type_nodetype, count(node_id) num from node group by type_nodetype'
  );
  $sth-&gt;execute;
  while ( my @rec=$sth-&gt;fetchrow_array ) {
    $type_count{$rec[0]}=$rec[1];
  }
}

my $NN= getVars(getNode('Newest Nodes Setting','setting'));
my %ignore_type= map { $_ =&gt; !!1 }
                     qw(patch pmdevnote pmdevtopic zombie_user 
                        bug scratchpad rawdata),
                     split /,/,$NN-&gt;{nodetypes_all};


my %user_choice;
my $allbut;
my @sel;
my $numcols;

my $allbut_param= 'allbut';
my $seltype_param= 'sel-type';
my $cols_param= 'numcols';

if (  grep { $q-&gt;param($_) } 'sexisgood',
      $allbut_param, $seltype_param, $cols_param )
{
  ($numcols)= $q-&gt;param($cols_param)=~/^([1-9])$/;
  $allbut= $q-&gt;param($allbut_param);
  @sel= $q-&gt;param($seltype_param);
} else {
  $numcols=$VARS-&gt;{bpnl_numcols};
  $allbut=$VARS-&gt;{bpnl_allbut};
  @sel= ($VARS-&gt;{bpnl_types});
}
use Data::Dumper;
$numcols||=3;
foreach my $n ( grep { $type_count{$_} }
                map { split /,/, $_ }  @sel )
{
  $user_choice{$n}= !!1;
}
my @debug;#=("&lt;code&gt;".Dumper($allbut,\@sel,\%user_choice,\%type_count)."&lt;/code&gt;");
if ($numcols==3) {
  delete $VARS-&gt;{bpnl_numcols};
} else {
  $VARS-&gt;{bpnl_numcols}=$numcols;
}
if ($allbut) {
  $allbut=!!1;
  $VARS-&gt;{bpnl_allbut}=1;
} else {
  $allbut=!!0;
  delete $VARS-&gt;{bpnl_allbut};
}
if (%user_choice) {
  $VARS-&gt;{bpnl_types}=join ",", keys %user_choice;
} else {
  delete $VARS-&gt;{bpnl_types};
}

my @css;
my @typeid;
my @legal;
foreach my $type (
   sort { lc($a-&gt;{title}) cmp lc($b-&gt;{title}) }
   $DB-&gt;getAllTypes()
){
  my ($title,$id)=@{$type}{qw(title node_id)};
  next if $ignore_type{ $title } || ! $type_count{ $id };

  push @legal,$id;
  push @css, "nodetype-$id";
  $id2class {$id }= "nodetype-$id";
  $id2type{ $id }= $type;

  next if $allbut == !!$user_choice{ $id };

  push @typeid, $id;
}

@typeid=(4) if !@typeid;

my $intype= "type_nodetype in ("
          . join( ",", @typeid )
          . ")";

my ($lc,@ary,@anch)=("");
{
  my $sth= $dbh-&gt;prepare(
    "select * from node where $intype order by title",
  );
  $sth-&gt;execute();


  while (my $row= $sth-&gt;fetchrow_hashref) {
    my ( $fc )= lc($row-&gt;{title})=~/^([a-z])/;
    if ( $fc &amp;&amp; $fc ne $lc ) {
      $lc= $fc;
      push @anch,"&lt;a href='#listpos-$fc'&gt;\U$fc\E&lt;/a&gt;";
      push @ary, "&lt;table&gt;&lt;tr&gt;&lt;td align='center' width='70%'&gt;"
         . "&lt;big&gt;&lt;big&gt;&lt;b&gt;&lt;a name='listpos-$fc'&gt;\U$fc\E&lt;/a&gt;&lt;/b&gt;&lt;/big&gt;&lt;/big&gt;&lt;/td&gt;"
         . "&lt;td align='right'&gt;&lt;sub&gt;&lt;a href='#top'&gt;(top)&lt;/a&gt;&lt;/sub&gt;&lt;/td&gt;&lt;/tr&gt;"
         . "&lt;/table&gt;";
    }
    push @ary,{ %$row };
  }
}

join "\n",
  htmlcode( 'colorblend', '', 0 + @css,
               \my @colors, $THEME, \@css, q[] ),
  qq(&lt;p align="right"&gt;&lt;a href="?node_id=787964"&gt;&lt;b&gt;Help for this page&lt;/b&gt;&lt;/a&gt;&lt;/p&gt;),
  "&lt;p align='center'&gt;&lt;a name='top'&gt;&lt;/a&gt;"
  . join(" | ",@anch)
  . "&lt;br /&gt;&lt;small&gt;&lt;a href='#config'&gt;config&lt;/a&gt; - ("
  . ( 0+@ary )
  . " : "
  . ( join ", ",map { make_link($id2type{$_}) } @typeid )
  . ")&lt;/small&gt;&lt;/p&gt;&lt;hr/&gt;",
  "&lt;center&gt;",
  make_cols( \@ary, $numcols),
  "&lt;/center&gt;",
  "&lt;hr/&gt;&lt;a name='config'&gt;&lt;/a&gt;&lt;center&gt;&lt;small&gt;&lt;a href='#top'&gt;(top)&lt;/a&gt;&lt;br/&gt;",
  htmlcode('openform'),
  $q-&gt;checkbox(
        -name=&gt;$allbut_param,
        -checked=&gt;0,
        -value=&gt;1,
        -force=&gt;1,
        -label=&gt;'Show all but selected types?',
   ),
   "&lt;br /&gt;",
   $q-&gt;checkbox_group(
        -name =&gt; $seltype_param,
        -values =&gt; \@legal,
        -default =&gt; \@typeid,
        -force =&gt;1,
        -labels =&gt; { map {
                    $_ =&gt; make_link($id2type{$_})
                          . " (" . $type_count{$_} . ")"
                   } @legal },
        -cols =&gt; $numcols+1,
   ),
   "&lt;br/&gt;Number of columns to show:",
   $q-&gt;popup_menu(-name=&gt;$cols_param,
                  -values=&gt;[1..9],
                  -force=&gt;1,
                  -default=&gt;$numcols),
   "&lt;br/&gt;",
   htmlcode('closeform'),
   '&lt;/small&gt;&lt;/center&gt;',
  @debug
;

%]</live_code>
<reason>Clean up names to make them case sensitive</reason>
<field>doctext</field>
</record>
<record><htmlcode_id>702641</htmlcode_id>
<patch_code>[%
  my @quips = (
    "You going to leave quietly, or do I have to call the cops?",
    "You aren't on my list.",
    "You see nothing but your own reflection.",
    "Wait, who is that behind you?",
    "Nice teeth.",
    "Didn't you used to be shorter?",
    "Go away!",
    "Tough beans!",
    "Um, are you &lt;em&gt;supposed&lt;/em&gt; to be here?",
    "Don't look now!",
    "Thanks.  We'll take it from here.",
    "Get a haircut.",
    "Please remain where you are; I'm almost done...",
    "Where nothing can go wrong.... go wrong... go wrong....",
    "Another trouble maker, I see.",
    "Quick, before they spot you!!",
    "Look out!!",
    "Oops...",
    "They went that way --&gt;",
    '&lt;small&gt;Whatever you do, don\'t "view source"&lt;/small&gt;',
    "Uh... no.",
    "I have half a mind to... um...",
    "Server error: no random text found",
    "So, you think you are funny, eh?",
    "No, this is the hall.  You wanted the third door on your left.",
    "Don't touch that!!!",
    "Great, now you broke a mirror.  Well, seven years isn't &lt;b&gt;that&lt;/b&gt; long...",
    "Checking [editors]...  What did you say your names was?",
    "Yeah, right.",
    "Deleting node ID $$USER{user_id}...&lt;br&gt;Server error: Permission denied",
    "To-do items:&lt;ul&gt;&lt;li&gt;Check security on this node&lt;/li&gt;&lt;li&gt;Keep an eye on $$USER{title}&lt;/li&gt;&lt;/ul&gt;",
    "nya nya, you can't use this.",
    "... rrrrr ... bip ... PING",
    "No, they don't make any sense. Why do you ask?",
    "Hey, where did &lt;b&gt;that&lt;/b&gt; come from??",
    "&lt;p&gt;Let's see... This goes over there... That goes right here... Throw that one away..."
     ." Shift those to the left... Make a copy of that one... More CODE tags there and there..."
     ." Approve this... Purge all of those... Move that READMORE up a couple of paragraphs..."
     ." Consider both of those... Close that TABLE tag...&lt;/p&gt;"
     ."&lt;p&gt;Oh, sorry; I didn't see you there.  Can I help you?&lt;/p&gt;",
    "Next, please!",
    "We already tried that. It didn't work.",
    "1) Add [$$USER{title}] to the list.&lt;br&gt;&lt;br&gt;Check!",
    "It's only a model.",
    "Nothing to see here.  Move along.",
    '&lt;h1&gt;&lt;div style="font-size: 500%"&gt;Boo!&lt;/div&gt;&lt;/h1&gt;',
    "Made ya look!",
    "That's okay; I think I've got it.",
    "No really, I'm fine.",
    "Who left this here?",
    "Too bad it doesn't work...",
    '&lt;form&gt;&lt;input type="hidden" name="node_id" value="60309"&gt;User: &lt;input type="text" name="user" size="16" /&gt;'
     .' &amp;nbsp; Operation: &lt;select name="tmode"&gt;&lt;option selected value="upd"&gt;Update&lt;/option&gt;&lt;option value="ren"&gt;'
     .'Rename&lt;/option&gt;&lt;option value="del"&gt;Delete&lt;/option&gt;&lt;option value="pro"&gt;Promote&lt;/option&gt;&lt;/select&gt; &amp;nbsp; '
     .'&lt;input type="submit" name="etrick" value="Do it!" /&gt;&lt;/form&gt;',
  );
  return $quips[rand @quips]
  unless Everything::isApproved($USER, getNode('editors', 'usergroup'));

  my $mnode   = $query-&gt;param('mnode')   || 0;
  my $mparent = $query-&gt;param('mparent') || 0;
  foreach ($mnode, $mparent) {
    /^\d+$/ or $_ = 0;
  }
  my $approve = $query-&gt;param('approve');

  # These types should be:
  # Createable by normal users.
  # Shouldn't have extra tables,
  # we may leave cruft in the DB, and probably won't
  # display properly as a note.
  my @toplevel = qw/monkdiscuss perlmeditation perlquestion perltutorial CUFP poem obfuscated perlnews /;
  push @toplevel, 'user'   if  isGod($USER);

  if ( $mnode  &amp;&amp;  $mparent  &amp;&amp;  $approve ne 'No' ) {
    my $again = urlGen({node_id =&gt; getId($NODE)}, -1);

    my $node = getNodeById($mnode)
      or return sprintf q|Couldn't find node %d. &lt;a href="%s"&gt;Try again&lt;/a&gt;|,
      $mnode, $again;

    my $parent = getNodeById($mparent)
      or return sprintf q|Couldn't find parent node %d. &lt;a href="%s"&gt;Try again&lt;/a&gt;|,
      $mparent, $again;

    grep {$parent-&gt;{type}{title} eq $_ } @toplevel, qw(bookreview modulereview note snippet sourcecode)
      or return sprintf q|Can't reparent to %s type nodes! &lt;a href="%s"&gt;Try again&lt;/a&gt;|,
      $parent-&gt;{type}{title}, $again;

    $mnode == $mparent
      and return sprintf q|Nooooooo! No infinite loops please! &lt;a href="%s"&gt;Try again&lt;/a&gt;|,
      $again;

    if ( $approve eq 'Yes' ) {

      my $msg = sprintf q|I have reparented your node [id://%d] to [id://%d].|, getId($node), getId($parent);

      if ( grep $node-&gt;{type}{title} eq $_, @toplevel ) {

        $DB-&gt;sqlUpdate(
         'note',
         {
           root_node =&gt; $parent-&gt;{type}{title} eq 'note' ? $parent-&gt;{root_node} : getId($parent)
         },
         sprintf 'root_node = %d', getId($node)
        );

        $DB-&gt;sqlInsert(
         'note',
         {
           note_id      =&gt; getId($node),
           parent_node  =&gt; getId($parent),
           root_node    =&gt; $parent-&gt;{type}{title} eq 'note' ? $parent-&gt;{root_node} : getId($parent),
           position     =&gt; 0
         }
        );

        $DB-&gt;sqlUpdate('node', { type_nodetype =&gt; getId(getType('note')) }, sprintf 'node_id = %d', getId($node));

        return q|Done. &lt;a href="| . $again . q|"&gt;Start over&lt;/a&gt;| . htmlcode('msguser', $node-&gt;{author_user}, $msg);
      } elsif ( $node-&gt;{type}{title} eq 'note' ) {

        my $new_root = $parent-&gt;{type}{title} eq 'note' ? $parent-&gt;{root_node} : getId($parent);
        my $to_new_thread = $new_root != $node-&gt;{root_node};

        if ($to_new_thread) {
            $node-&gt;{root_node} = $new_root;
            my @descendants;
            htmlcode('replies_in_tree', '', $node, \@descendants);
            foreach my $d (@descendants) {
                $d-&gt;{root_node} = $new_root;
                updateNode($d, -1);
            }
        }
        $node-&gt;{parent_node} = getId($parent);
        updateNode($node, -1);

        return q|Done. &lt;a href="| . $again . q|"&gt;Start over&lt;/a&gt;| . htmlcode('msguser', $node-&gt;{author_user}, $msg);
      }

    } else {
      return htmlcode('openform') .
        $query-&gt;hidden('node_id' =&gt; getId($NODE)) .
        $query-&gt;hidden('mnode'   =&gt; $mnode) .
        $query-&gt;hidden('mparent' =&gt; $mparent) . q[
      Does this look correct?
      &lt;br /&gt;
      &lt;table&gt;
        &lt;tr&gt;
          &lt;td&gt;
            ] . linkNode($parent) . q[
          &lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;
            &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;bull;&amp;nbsp;] . linkNode($node) . q[
          &lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;
            &lt;br /&gt;] . $query-&gt;submit('approve' =&gt; 'Yes') . ' '. $query-&gt;submit('approve' =&gt; 'No') . q[
          &lt;/td&gt;
        &lt;/tr&gt;
      &lt;/table&gt;] . $query-&gt;end_form;
    }
  } else {
    return
      htmlcode('openform') .
      $query-&gt;hidden('node_id' =&gt; getId($NODE)) . q[
      &lt;table&gt;
        &lt;tr&gt;
          &lt;td&gt;
            Node to move:

          &lt;/td&gt;
          &lt;td&gt;
            ] . $query-&gt;textfield('mnode', '', 6, 10) . q[
          &lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;
            New parent:
          &lt;/td&gt;
          &lt;td&gt;
            ] . $query-&gt;textfield('mparent', '', 6, 10) . q[
          &lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;
          &lt;/td&gt;
          &lt;td&gt;
            ] . $query-&gt;submit('sexisgood' =&gt; 'Move') . q[
          &lt;/td&gt;
        &lt;/tr&gt;
      &lt;/table&gt;] .
      $query-&gt;end_form;
  }
%]</patch_code>
<applied>2008-08-06 20:04:42</applied>
<htmlcode_id>60309</htmlcode_id>
<live_code>[%
  my @quips = (
    "You going to leave quietly, or do I have to call the cops?",
    "You aren't on my list.",
    "You see nothing but your own reflection.",
    "Wait, who is that behind you?",
    "Nice teeth.",
    "Didn't you used to be shorter?",
    "Go away!",
    "Tough beans!",
    "Um, are you &lt;em&gt;supposed&lt;/em&gt; to be here?",
    "Don't look now!",
    "Thanks.  We'll take it from here.",
    "Get a haircut.",
    "Please remain where you are; I'm almost done...",
    "Where nothing can go wrong.... go wrong... go wrong....",
    "Another trouble maker, I see.",
    "Quick, before they spot you!!",
    "Look out!!",
    "Oops...",
    "They went that way --&gt;",
    '&lt;small&gt;Whatever you do, don\'t "view source"&lt;/small&gt;',
    "Uh... no.",
    "I have half a mind to... um...",
    "Server error: no random text found",
    "So, you think you are funny, eh?",
    "No, this is the hall.  You wanted the third door on your left.",
    "Don't touch that!!!",
    "Great, now you broke a mirror.  Well, seven years isn't &lt;b&gt;that&lt;/b&gt; long...",
    "Checking [editors]...  What did you say your names was?",
    "Yeah, right.",
    "Deleting node ID $$USER{user_id}...&lt;br&gt;Server error: Permission denied",
    "To-do items:&lt;ul&gt;&lt;li&gt;Check security on this node&lt;/li&gt;&lt;li&gt;Keep an eye on $$USER{title}&lt;/li&gt;&lt;/ul&gt;",
    "nya nya, you can't use this.",
    "... rrrrr ... bip ... PING",
    "No, they don't make any sense. Why do you ask?",
    "Hey, where did &lt;b&gt;that&lt;/b&gt; come from??",
    "&lt;p&gt;Let's see... This goes over there... That goes right here... Throw that one away..."
     ." Shift those to the left... Make a copy of that one... More CODE tags there and there..."
     ." Approve this... Purge all of those... Move that READMORE up a couple of paragraphs..."
     ." Consider both of those... Close that TABLE tag...&lt;/p&gt;"
     ."&lt;p&gt;Oh, sorry; I didn't see you there.  Can I help you?&lt;/p&gt;",
    "Next, please!",
    "We already tried that. It didn't work.",
    "1) Add [$$USER{title}] to the list.&lt;br&gt;&lt;br&gt;Check!",
    "It's only a model.",
    "Nothing to see here.  Move along.",
    '&lt;h1&gt;&lt;div style="font-size: 500%"&gt;Boo!&lt;/div&gt;&lt;/h1&gt;',
    "Made ya look!",
    "That's okay; I think I've got it.",
    "No really, I'm fine.",
    "Who left this here?",
    "Too bad it doesn't work...",
    '&lt;form&gt;&lt;input type="hidden" name="node_id" value="60309"&gt;User: &lt;input type="text" name="user" size="16" /&gt;'
     .' &amp;nbsp; Operation: &lt;select name="tmode"&gt;&lt;option selected value="upd"&gt;Update&lt;/option&gt;&lt;option value="ren"&gt;'
     .'Rename&lt;/option&gt;&lt;option value="del"&gt;Delete&lt;/option&gt;&lt;option value="pro"&gt;Promote&lt;/option&gt;&lt;/select&gt; &amp;nbsp; '
     .'&lt;input type="submit" name="etrick" value="Do it!" /&gt;&lt;/form&gt;',
  );
  return qq(&lt;div class="tough-beans"&gt;$quips[rand @quips]&lt;/div&gt;)
  unless Everything::isApproved($USER, getNode('editors', 'usergroup'));

  my $mnode   = $query-&gt;param('mnode')   || 0;
  my $mparent = $query-&gt;param('mparent') || 0;
  foreach ($mnode, $mparent) {
    /^\d+$/ or $_ = 0;
  }
  my $approve = $query-&gt;param('approve');

  # These types should be:
  # Createable by normal users.
  # Shouldn't have extra tables,
  # we may leave cruft in the DB, and probably won't
  # display properly as a note.
  my @toplevel = qw/monkdiscuss perlmeditation perlquestion perltutorial CUFP poem obfuscated perlnews /;
  push @toplevel, 'user'   if  isGod($USER);

  if ( $mnode  &amp;&amp;  $mparent  &amp;&amp;  $approve ne 'No' ) {
    my $again = urlGen({node_id =&gt; getId($NODE)}, -1);

    my $node = getNodeById($mnode)
      or return sprintf q|Couldn't find node %d. &lt;a href="%s"&gt;Try again&lt;/a&gt;|,
      $mnode, $again;

    my $parent = getNodeById($mparent)
      or return sprintf q|Couldn't find parent node %d. &lt;a href="%s"&gt;Try again&lt;/a&gt;|,
      $mparent, $again;

    grep {$parent-&gt;{type}{title} eq $_ } @toplevel, qw(bookreview modulereview note quest snippet sourcecode)
      or return sprintf q|Can't reparent to %s type nodes! &lt;a href="%s"&gt;Try again&lt;/a&gt;|,
      $parent-&gt;{type}{title}, $again;

    $mnode == $mparent
      and return sprintf q|Nooooooo! No infinite loops please! &lt;a href="%s"&gt;Try again&lt;/a&gt;|,
      $again;

    if ( $approve eq 'Yes' ) {

      my $msg = sprintf q|I have reparented your node [id://%d] to [id://%d].|, getId($node), getId($parent);

      if ( grep $node-&gt;{type}{title} eq $_, @toplevel ) {

        $DB-&gt;sqlUpdate(
         'note',
         {
           root_node =&gt; $parent-&gt;{type}{title} eq 'note' ? $parent-&gt;{root_node} : getId($parent)
         },
         sprintf 'root_node = %d', getId($node)
        );

        $DB-&gt;sqlInsert(
         'note',
         {
           note_id      =&gt; getId($node),
           parent_node  =&gt; getId($parent),
           root_node    =&gt; $parent-&gt;{type}{title} eq 'note' ? $parent-&gt;{root_node} : getId($parent),
           position     =&gt; 0
         }
        );

        $DB-&gt;sqlUpdate('node', { type_nodetype =&gt; getId(getType('note')) }, sprintf 'node_id = %d', getId($node));

        return q|Done. &lt;a href="| . $again . q|"&gt;Start over&lt;/a&gt;| . htmlcode('msguser', $node-&gt;{author_user}, $msg);
      } elsif ( $node-&gt;{type}{title} eq 'note' ) {

        my $new_root = $parent-&gt;{type}{title} eq 'note' ? $parent-&gt;{root_node} : getId($parent);
        my $to_new_thread = $new_root != $node-&gt;{root_node};

        if ($to_new_thread) {
            $node-&gt;{root_node} = $new_root;
            my @descendants;
            htmlcode('replies_in_tree', '', $node, \@descendants);
            foreach my $d (@descendants) {
                $d-&gt;{root_node} = $new_root;
                updateNode($d, -1);
            }
        }
        $node-&gt;{parent_node} = getId($parent);
        updateNode($node, -1);

        return q|Done. &lt;a href="| . $again . q|"&gt;Start over&lt;/a&gt;| . htmlcode('msguser', $node-&gt;{author_user}, $msg);
      }

    } else {
      return htmlcode('openform') .
        $query-&gt;hidden('node_id' =&gt; getId($NODE)) .
        $query-&gt;hidden('mnode'   =&gt; $mnode) .
        $query-&gt;hidden('mparent' =&gt; $mparent) . q[
      Does this look correct?
      &lt;br /&gt;
      &lt;table&gt;
        &lt;tr&gt;
          &lt;td&gt;
            ] . linkNode($parent) . q[
          &lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;
            &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;bull;&amp;nbsp;] . linkNode($node) . q[
          &lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;
            &lt;br /&gt;] . $query-&gt;submit('approve' =&gt; 'Yes') . ' '. $query-&gt;submit('approve' =&gt; 'No') . q[
          &lt;/td&gt;
        &lt;/tr&gt;
      &lt;/table&gt;] . $query-&gt;end_form;
    }
  } else {
    return
      htmlcode('openform') .
      $query-&gt;hidden('node_id' =&gt; getId($NODE)) . q[
      &lt;table&gt;
        &lt;tr&gt;
          &lt;td&gt;
            Node to move:

          &lt;/td&gt;
          &lt;td&gt;
            ] . $query-&gt;textfield('mnode', '', 6, 10) . q[
          &lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;
            New parent:
          &lt;/td&gt;
          &lt;td&gt;
            ] . $query-&gt;textfield('mparent', '', 6, 10) . q[
          &lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;
          &lt;/td&gt;
          &lt;td&gt;
            ] . $query-&gt;submit('sexisgood' =&gt; 'Move') . q[
          &lt;/td&gt;
        &lt;/tr&gt;
      &lt;/table&gt;] .
      $query-&gt;end_form;
  }
%]</live_code>
<reason>Allow reparenting within more sections</reason>
<field>doctext</field>
</record>
<record><htmlcode_id>759938</htmlcode_id>
<patch_code>What would a monastery be without an offering plate?  If you find this
place helpful and would like to show your appreciation by helping to
guarantee there will be money to keep this site running for years and
generations of little Perl programmers to come click below.
&lt;P&gt;
The donations are for [http://www.perlfoundation.org|The
Perl Foundation] and any contributions are tax
deductible. &lt;b&gt;Click
[http://donate.perlfoundation.org/index.pl?node=Contribution%20Info&amp;selfund=1|
here] to donate!&lt;/b&gt; (PayPal, Visa, MasterCard, and Discover accepted)
&lt;P&gt;If you can't/don't use a credit card you can send checks to:&lt;br /&gt;
The Perl Foundation&lt;br /&gt;
6832 Mulderstraat&lt;br /&gt;
Grand Ledge, MI 48837&lt;br /&gt;
&lt;font size="-1"&gt;&lt;b&gt;(Be sure to include a note or memo on the check saying
the money is supposed to be put towards PerlMonks Donation Fund.  See also
[https://donate.perlfoundation.org/index.pl?node=Contribution+FAQ].)&lt;/b&gt;&lt;/font&gt;
&lt;p&gt;
&lt;p&gt;For information on how much we've raised, see
[http://donate.perlfoundation.org/index.pl?node=Fund+Drive+Details&amp;selfund=1|
TPF's details page].&lt;/p&gt;
&lt;/center&gt;
&lt;p&gt;
Thanks Everybody!&lt;br /&gt;
&lt;a href="http://www.perlfoundation.org"&gt;The Perl Foundation&lt;/a&gt;
</patch_code>
<applied>2009-04-24 20:30:05</applied>
<htmlcode_id>71130</htmlcode_id>
<live_code>&lt;p&gt;
What would a monastery be without an offering plate?  If you find this
place helpful and would like to show your appreciation by helping to
guarantee there will be money to keep this site running for years and
generations of little Perl programmers to come click below.
&lt;P&gt;
The donations are for [http://www.perlfoundation.org|The
Perl Foundation] and any contributions are tax
deductible. &lt;b&gt;Click
[http://donate.perlfoundation.org/index.pl?node=Contribution%20Info&amp;selfund=1|
here] to donate!&lt;/b&gt; (PayPal, Visa, MasterCard, and Discover accepted)
&lt;P&gt;
If you can't/don't use a credit card, you can send checks.  
You can find the postal address at 
[https://donate.perlfoundation.org/index.pl?node=Contribution+FAQ]. 
(Be sure to include a note or memo on the check saying
the money is supposed to be put towards PerlMonks Donation Fund.)
&lt;p&gt;
For information on how much we've raised, see
[http://donate.perlfoundation.org/index.pl?node=Fund+Drive+Details&amp;selfund=1
|TPF's details page].&lt;/p&gt;
&lt;p&gt;
Thanks Everybody!&lt;br /&gt;
&lt;a href="http://www.perlfoundation.org"&gt;The Perl Foundation&lt;/a&gt;
</live_code>
<reason>Wrap the code</reason>
<field>doctext</field>
</record>
<record><htmlcode_id>538613</htmlcode_id>
<patch_code>[%

require POSIX;
require List::Util;
require Time::HiRes;

return "&lt;error error='ENOTPMDEV'&gt;Restricted to PMDEV members for now&lt;/error&gt;"
  unless Everything::isApproved($USER,'pmdev') or $USER-&gt;{title}=~/^(bobf|planetscape|davido)$/;

htmlcode('log_ticker','GRUNT');

local *split_args= sub {
    my $param=shift;
    my @param=map { /^(\d+)$/ ? $1 : () }
           map { split /,/,$_; }
           $q-&gt;param($param);
    splice @param,20;
    @param;
};

local *and_from_list= sub {
    my ( $param, $list )= @_;
    $list||=[];
    local $"=', '; #"
    if (@$list&gt;1) {
        return qq[ and $param in ( @$list ) ]
    } elsif (@$list) {
        return qq[ and $param = @$list ];
    } else {
        return ""
    }
};
my $no_strip = $q-&gt;param('no_strip');
my $wrote_records=0;
local *records_as_xml=do {
    my @default_fields= qw(
        node_id title author_user author
        type_nodetype type createdepoch createdgmtime
        updatedepoch updatedgmtime
        lastvisitedepoch lastvisitedgmtime
        root_node parent_node
        experience user_scratchpad
    );

    sub {
        my ($sth,$xml,$accept)=@_;
        while ( my $node=$sth-&gt;fetchrow_hashref ) {
            # check if we are doing a threaded node
            if ($accept) {
                if ($accept-&gt;{$node-&gt;{node_id}} ||
                    $accept-&gt;{$node-&gt;{parent_node}}
                ){
                    $accept-&gt;{$node-&gt;{node_id}}= 1;
                } else {
                    next;
                }
            }

            # First we prep the record. Unfortunately this stuff isn't
            # that easily done in the sql directly.
            # Make sure there is a human readable timestamp
            foreach my $key (qw(created updated lastvisited)) {
                if ( my $time= $node-&gt;{$key."epoch"} ) {
                    $node-&gt;{$key."gmtime"}=POSIX::strftime('%Y-%m-%d %H:%M:%S',gmtime($time));
                }
            }
            # Now handle stuff that is dependent on who is looking
            # and who is being looked at. Ie, votes, what the used
            # voted on and user private data like voteleft and nick.
            my @xtra;
            my $unick= $USER-&gt;{nick} || $USER-&gt;{title}; # user nick
            my $anick= $node-&gt;{nick} || $node-&gt;{author}; # author nick
            my $isowner=($USER-&gt;{node_id} == $node-&gt;{author_user}
                         || $USER-&gt;{title} eq $anick
                         || $unick eq $node-&gt;{title}
                         || $unick eq $anick );
            if ( $node-&gt;{vote_id} || $isowner )
            {
                push @xtra,qw(reputation voted);
                push @xtra,qw(votesleft nick) if $isowner;
            }
            # and finally we build the xml for the node
            $xml-&gt;start('node');
            foreach my $key ( @default_fields, @xtra ){
                if ( $node-&gt;{$key} ) {
                    $node-&gt;{$key} =~ tr/\x00-\x1f\x7F//d
                      unless $no_strip;
                    $xml-&gt;element( $key, $node-&gt;{$key} );
                }
            }
            $xml-&gt;end('node');
            $wrote_records++;
        } # end per record processing
    };
};


my $explain= ( $q-&gt;param('explain') &amp;&amp; Everything::isApproved($USER,'pmdev') ) || isGod($USER);
my $showquery= $q-&gt;param('showquery') || $explain;

# run_query - executes a query, with explain, and feeds the output through
# an $xml object in a standard format. returns an error xml string if
# an error occurs, otherwise returns nothing.
# Takes a query and an XML::Fling object as parameters.

local *run_query= do {
    my $queries= 0;

    my @explain= qw(table type possible_keys key key_len ref rows Extra);
    sub {
        my ( $clean_query, $xml, $accept ) = @_;

        my $query_num= ++$queries;

        # remove extraneous whitespace from the query
        s/^\s+//g, s/\s+$//g, s/\s+/ /g
            for $clean_query;

        my $starttime= Time::HiRes::time();
        if ($showquery) {
            $xml-&gt;start('query', which =&gt; $query_num);
            $xml-&gt;element( 'sql', $clean_query);

            if ($explain) {

                my $sth=$DB-&gt;getDatabaseHandle
                           -&gt;prepare( "explain $clean_query" )
                    or return qq[&lt;error error="ESQLPREPARE"&gt;].
                              qq[SQL Prepare (Explain) failed!&lt;/error&gt;];

                $sth-&gt;execute()
                    or return qq[&lt;error error="ESQLEXEC"&gt;].
                              qq[SQL Exec (Explain) failed!&lt;/error&gt;];

                $xml-&gt;start('explain');

                my $row= 1;
                while (my $node=$sth-&gt;fetchrow_arrayref) {
                   $xml-&gt;start('row', rownum=&gt; $row++);
                   foreach my $idx (0..$#$node) {
                      $xml-&gt;element($explain[$idx],$node-&gt;[$idx])
                        if $node-&gt;[$idx];
                   }
                   $xml-&gt;end('row');
                }
                $xml-&gt;end('explain');
            }
            $xml-&gt;end('query');
        }
        my $sth=$DB-&gt;getDatabaseHandle-&gt;prepare( $clean_query )
                    or return qq[&lt;error error="ESQLPREPARE"&gt;].
                              qq[SQL Prepare failed!&lt;/error&gt;];

        $sth-&gt;execute()
            or return qq[&lt;error error="ESQLEXEC"&gt;].
                      qq[SQL Exec failed!&lt;/error&gt;];

        records_as_xml($sth,$xml,$accept);

        if ($showquery) {
            $xml-&gt;element('elapsed', which=&gt;$query_num,
                Time::HiRes::time()-$starttime )
        }
        return; # presumably no errors occured
    };
};

local *make_query= sub {
    my ( $user_id, $from_id, $nodes, $types, $authors,
         $roots, $parents, $special, $offset, $limit, $must_order)= @_;

    my $query= qq[
        select
            n.node_id,       n.title,
            n.author_user,   a.title as author,
            n.type_nodetype, t.title as type,
            n.reputation,
            UNIX_TIMESTAMP(n.createtime) as createdepoch,
            UNIX_TIMESTAMP(n.nodeupdated) as updatedepoch,
            note.root_node,
            note.parent_node,
            u.experience,
            u.votesleft,
            au.nick,
            UNIX_TIMESTAMP(u.lasttime) as lastvisitedepoch,
            vote_id, vote.weight as voted,
            u.user_scratchpad
        from node a, node t, node n
        left join note on note_id = n.node_id
        left join vote on (vote_id=n.node_id and voter_user=$user_id)
        left join user u on u.user_id=n.node_id
        left join user au on au.user_id=n.author_user
        where a.node_id=n.author_user
        and t.node_id=n.type_nodetype
    ];
    $query .= qq[ and n.node_id &gt;= $from_id ] if $from_id;
    $query .= and_from_list('n.node_id', $nodes);
    $query .= and_from_list('n.author_user', $authors);
    $query .= and_from_list('n.type_nodetype', $types);
    $query .= and_from_list('note.parent_node',$parents);
    $query .= and_from_list('note.root_node',$roots);
    $query = join " and ",$query,@{$special||[]};
    $query .= qq[ order by node_id asc ]
        if $offset || $limit || $must_order;
    $query .= qq[ limit $offset, $limit ]
        if $offset || $limit;
    return $query;
};

#======================
# and it begins here... first we get the arguments from the user
# (there are a few 'special' arguments used above)

my @types;
if (isGod($USER)) {
  @types=split_args('type_nodetype');
}
if (!@types) {
  htmlcode( 'handle_nn_settings', '', (my $nn = {}) );
  @types= map getType( $_ )-&gt;{node_id}, @{ $nn-&gt;{types} };
}
my @nodes= split_args('nodes');
my @authors= split_args('authors');
my @roots= split_args('roots');
my @parents= split_args('parents');

my ($from_id)= $q-&gt;param('from_id')=~/^(\d+)$/;

my ($limit)= $q-&gt;param('limit')=~/^(\d+)$/;
my ($offset)= $q-&gt;param('offset')=~/^(\d+)$/;
my $def_limit= 100;
my $max_limit= 500;
$limit ||= $def_limit;
$limit= $max_limit unless $limit &lt;= $max_limit;
$offset ||= 0;

my ($mode)= $q-&gt;param('mode')=~/^(detail|new|user|thread)$/;
my $must_order= 0; # order the result even if no limit/offset
my $accept; # accept nodes whos parents are in this hash
my $first; # dump this node first

if ($mode eq 'thread') {
    return "&lt;error error='ENONODE'&gt;Must specify a node id to retreive ".
           "thread for using 'node' parameter&lt;/error&gt;"
           if !@nodes;
    @nodes=($nodes[0]);
    $limit = $offset = 0;
} elsif ($mode eq 'user') {
  @authors= ( $USER-&gt;{node_id} );
  $mode = 'detail';
}
if (!@nodes &amp;&amp; !@authors &amp;&amp; !@roots &amp;&amp; !@parents) {
  $mode ||= 'new';
} else {
  $mode ||= 'detail';
}

my $when; # maybe we use this later.

my ($hours)= $q-&gt;param('hours')=~/^(\d+)$/;
$hours||=24 if $mode eq 'new';
$hours=72 if $hours&gt;72;

my @special;
if ($mode eq 'new' and !$from_id) {
  push @special,"n.createtime &gt;= ".(
    $when
      ? "FROM_UNIXTIME($when)"
      : "DATE_ADD(now(),INTERVAL -$hours HOUR)"
  );
}

my %info=(
           nodes  =&gt; join(',',@nodes),
           authors=&gt; join(',',@authors),
           roots  =&gt; join(',',@roots),
           parents=&gt; join(',',@parents),
           from_id=&gt; $from_id,
           limit  =&gt; $limit,
           offset =&gt; $offset,
           hours  =&gt; $hours,
         );

my %xmlstyle= ( clean=&gt;1 );

# ========================
# ok so now we start making the xml and the main loop

htmlcode( 'new_xml_fling', '', \my( $xml, @data ), \%xmlstyle, "add_header")
    or return qq[&lt;error error="EXMLCREATE"&gt;Error creating fling object&lt;/error&gt;];

htmlcode('xml_info_tag', '', $xml, \%xmlstyle, 'nodes',
    min_poll_seconds =&gt; 30,
    mode=&gt;$mode,
    (map { $info{$_} ? ($_=&gt;$info{$_}) : ()  }  keys %info),
);

if ($mode eq 'thread') {
    my $node=getNodeById(shift @nodes);
    if ( !$node-&gt;{root_node} ) {
        @roots= ($node-&gt;{node_id}||0);
        $first= $node-&gt;{node_id}||0;
    } else {
        # no limit in this mode as some of the filtering
        # is client side.
        @parents= @authors= ();
        @roots= ($node-&gt;{root_node});
        $from_id= $node-&gt;{node_id};
        $must_order= 1;
        $accept={ $node-&gt;{node_id}=&gt;1 };

    }
}

my $start= Time::HiRes::time();
if ($first) {
    # get the root of the thread
    my $query= make_query( $USER-&gt;{node_id}, 0, [$first], \@types);
    my $error=run_query($query,$xml,undef);
    return $error if $error;
}

# and get the rest
my $query= make_query( $USER-&gt;{node_id}, $from_id, \@nodes, \@types,
         \@authors,\@roots, \@parents, \@special,
         $offset, $limit, $must_order );
my $error=run_query($query,$xml,$accept);
return $error if $error;


$xml-&gt;element('elapsed', which=&gt;'all', Time::HiRes::time() - $start );
$xml-&gt;element('recordcount', $wrote_records );
$xml-&gt;end('nodes');

return join "",@data;


%]</patch_code>
<applied>2006-03-22 16:47:28</applied>
<htmlcode_id>145597</htmlcode_id>
<live_code>Nothing to see here (this used to be some test code).</live_code>
<reason>log_fetches.</reason>
<field>doctext</field>
</record>
<record><htmlcode_id>741381</htmlcode_id>
<patch_code>[%  linkNode( $NODE, "Count 'em", {reroot=&gt;'count'} )  %] -
[%  linkNode( $NODE, "List 'em",  {reroot=&gt;'list'} )  %] -
[%  linkNode( $NODE, "Fix 'em",   {reroot=&gt;'fix'} )  %]
&lt;p&gt;
[%
   my $do= $q-&gt;param("reroot");
   return   if  ! $do;
   return   "Do what? ($do)"
      if  "count" ne $do  &amp;&amp;  "list" ne $do  &amp;&amp;  "fix" ne $do;
   my $st= $DB-&gt;sqlSelectMany(
      "count" eq $do ? "count(*)" : "note.*,p.root_node 'p.root'",
      "note,note p",
      "note.parent_node=p.note_id
         and note.root_node!=p.root_node
         and p.root_node!=0",
   );
   return   $st-&gt;fetchrow_arrayref()-&gt;[0]
      . " notes with incorrect root linkage found"
      if  "count" eq $do;
   my( $rec, @rec );
   push @rec, $rec   while  $rec= $st-&gt;fetchrow_hashref();
   if(  "list" eq $do  ) {
      return "None found"   if  ! @rec;
      return
         $q-&gt;table(
            $q-&gt;Tr(
               map $q-&gt;th( $_ ), @{$st-&gt;{NAME}},
            ),
            map $q-&gt;Tr(
               do {
                  $rec= $_,
                  map $q-&gt;td(
                     !$_ ? "0" : linkNode( {
                        node_id=&gt;$_,
                        title=&gt;$_,
                     } )
                  ), map $rec-&gt;{$_}, @{$st-&gt;{NAME}},
               },
            ), @rec,
         );
   }
   return 'You fix them with your intent stare, but they are unphased.'
       if  ! isGod($USER);
   my $st= $DB-&gt;getDatabaseHandle()-&gt;prepare(
      "update note set root_node=? where note_id=?"
   );
   my $count= 0;
   for $rec (  @rec  ) {
      $count += $st-&gt;execute( $rec-&gt;{'p.root'}, $rec-&gt;{note_id} );
   }
   return "$count notes updated.";
%]
&lt;/p&gt;
</patch_code>
<applied>2009-02-04 13:26:22</applied>
<htmlcode_id>150940</htmlcode_id>
<live_code>&lt;p&gt;
This situation tends to arise when Categorized Questions are SoPWified.
&lt;/p&gt;
[%  linkNode( $NODE, "Count 'em", {reroot=&gt;'count'} )  %] -
[%  linkNode( $NODE, "List 'em",  {reroot=&gt;'list'} )  %] -
[%  linkNode( $NODE, "Fix 'em",   {reroot=&gt;'fix'} )  %]
&lt;p&gt;
[%
   my $do= $q-&gt;param("reroot");
   return   if  ! $do;
   return   "Do what? ($do)"
      if  "count" ne $do  &amp;&amp;  "list" ne $do  &amp;&amp;  "fix" ne $do;
   my $st= $DB-&gt;sqlSelectMany(
      "count" eq $do ? "count(*)" : "note.*,p.root_node 'p.root'",
      "note,note p",
      "note.parent_node=p.note_id
         and note.root_node!=p.root_node
         and p.root_node!=0",
   );
   return   $st-&gt;fetchrow_arrayref()-&gt;[0]
      . " notes with incorrect root linkage found"
      if  "count" eq $do;
   my( $rec, @rec );
   push @rec, $rec   while  $rec= $st-&gt;fetchrow_hashref();
   if(  "list" eq $do  ) {
      return "None found"   if  ! @rec;
      return
         $q-&gt;table(
            $q-&gt;Tr(
               map $q-&gt;th( $_ ), @{$st-&gt;{NAME}},
            ),
            map $q-&gt;Tr(
               do {
                  $rec= $_,
                  map $q-&gt;td(
                     !$_ ? "0" : linkNode( {
                        node_id=&gt;$_,
                        title=&gt;$_,
                     } )
                  ), map $rec-&gt;{$_}, @{$st-&gt;{NAME}},
               },
            ), @rec,
         );
   }
   return 'You fix them with your intent stare, but they are unphased.'
       if  ! isGod($USER);
   my $st= $DB-&gt;getDatabaseHandle()-&gt;prepare(
      "update note set root_node=? where note_id=?"
   );
   my $count= 0;
   for $rec (  @rec  ) {
      $count += $st-&gt;execute( $rec-&gt;{'p.root'}, $rec-&gt;{note_id} );
   }
   return "$count notes updated.";
%]
&lt;/p&gt;
</live_code>
<reason>Facilitate allowing pmdev to use this code</reason>
<field>doctext</field>
</record>
<record><htmlcode_id>402176</htmlcode_id>
<patch_code>&lt;form type="post"&gt;
&lt;input type="hidden" name="node_id" value="["$$NODE{node_id}"]"&gt;
Node ID: &lt;input type="text" name="dumpid" size="9"&gt;&lt;br&gt;
 &amp;nbsp; - or -&lt;br&gt;
Title: &lt;input type="text" name="dumptitle" size="40"&gt;&lt;br&gt;
Type: &lt;input type="text" name="dumptype" size="20" 
 maxsize="40"&gt;&lt;br&gt;
&lt;input type="submit" name="dump_it" value="Dump It"&gt;
&lt;/form&gt;
[%
my $WHAT = { Nothing =&gt; "Here" };

if(  "" ne $q-&gt;param("dumpid")  ) {
    $WHAT = getNodeById($q-&gt;param("dumpid"))
         or return "ID " . $q-&gt;param("dumpid") . " not found.";
}
elsif(  "" ne $q-&gt;param("dumptitle")  ) {
    if(  "" ne $q-&gt;param("dumptype")  ) {
        $WHAT = getNode( $q-&gt;param("dumptitle"),
                $q-&gt;param("dumptype") )
             or return "Node (" . $q-&gt;param("dumptitle")
                     . ") of type " . $q-&gt;param("dumptype")
                     . " not found.";
    }
    else {
        my @list = getNodeWhere(
                    {title =&gt; $q-&gt;param("dumptitle")} )
                or return "Node (" . $q-&gt;param("dumptitle") . ") not found.";

        return join ", ", map {
            my $id= $_-&gt;{node_id};
            qq(&lt;a href="/?node_id=$NODE-&gt;{node_id}&amp;dumpid=$id"&gt;$id&lt;/a&gt;)
        } @list  if  1 &lt; @list;
        $WHAT = getNodeById($list[0]);
    }
}
else {
    return '';
}

return "Dump permission denied."
    if !isGod($USER) &amp;&amp; !canUpdateNode($USER,$WHAT);

return join $/,
    qq|&lt;table border cellspacing="0"&gt;&lt;tr&gt;&lt;th&gt;Field&lt;/th&gt;&lt;th&gt;Value&lt;/th&gt;&lt;/tr&gt;,
       &lt;tr&gt;&lt;td&gt;node type&lt;/td&gt;&lt;td&gt;$WHAT-&gt;{type}{title}&lt;/td&gt;&lt;tr&gt;|,
    map(
        {
            my( $x, $y ) = ( $_, $WHAT-&gt;{$_} );
            if ($x eq "passwd") {
               $y = "&lt;em&gt;hidden&lt;/em&gt;";
            } elsif ($x eq 'vars') {
               $y = htmlcode('displayvars','','vars',undef,$WHAT,'safe')
            } else {
               $y= $q-&gt;escapeHTML($y);       
            }
            $x= $q-&gt;escapeHTML($x);
            "&lt;tr&gt;&lt;td&gt;$x&lt;/td&gt;&lt;td&gt;$y&lt;/td&gt;&lt;/tr&gt;"
        } sort keys %$WHAT
    ), '&lt;/table&gt;';
%]</patch_code>
<applied>2004-10-25 05:31:01</applied>
<htmlcode_id>153451</htmlcode_id>
<live_code>&lt;form type="post"&gt;
&lt;input type="hidden" name="node_id" value="["$$NODE{node_id}"]"&gt;
Node ID: &lt;input type="text" name="dumpid" size="9"&gt;&lt;br&gt;
 &amp;nbsp; - or -&lt;br&gt;
Title: &lt;input type="text" name="dumptitle" size="40"&gt;&lt;br&gt;
Type: &lt;input type="text" name="dumptype" size="20" 
 maxsize="40"&gt;&lt;br&gt;
&lt;input type="submit" name="dump_it" value="Dump It"&gt;
&lt;/form&gt;
[%
my $WHAT = { Nothing =&gt; "Here" };

if(  "" ne $q-&gt;param("dumpid")  ) {
    $WHAT = getNodeById($q-&gt;param("dumpid"))
         or return "ID " . $q-&gt;param("dumpid") . " not found.";
}
elsif(  "" ne $q-&gt;param("dumptitle")  ) {
    if(  "" ne $q-&gt;param("dumptype")  ) {
        $WHAT = getNode( $q-&gt;param("dumptitle"),
                $q-&gt;param("dumptype") )
             or return "Node (" . $q-&gt;param("dumptitle")
                     . ") of type " . $q-&gt;param("dumptype")
                     . " not found.";
    }
    else {
        my @list = getNodeWhere(
                    {title =&gt; $q-&gt;param("dumptitle")} )
                or return "Node (" . $q-&gt;param("dumptitle") . ") not found.";

        return join ", ", map {
            my $id= $_-&gt;{node_id};
            qq(&lt;a href="/?node_id=$NODE-&gt;{node_id}&amp;dumpid=$id"&gt;$id&lt;/a&gt;)
        } @list  if  1 &lt; @list;
        $WHAT = getNodeById($list[0]);
    }
}
else {
    return '';
}

return qq(&lt;div class="tough-beans"&gt;Dump permission denied.&lt;/div&gt;)
    if !isGod($USER) &amp;&amp; !canUpdateNode($USER,$WHAT);

return join $/,
    qq|&lt;table border cellspacing="0"&gt;&lt;tr&gt;&lt;th&gt;Field&lt;/th&gt;&lt;th&gt;Value&lt;/th&gt;&lt;/tr&gt;,
       &lt;tr&gt;&lt;td&gt;node type&lt;/td&gt;&lt;td&gt;$WHAT-&gt;{type}{title}&lt;/td&gt;&lt;tr&gt;|,
    map(
        {
            my( $x, $y ) = ( $_, $WHAT-&gt;{$_} );
            if ($x eq "passwd") {
               $y = "&lt;em&gt;hidden&lt;/em&gt;";
            } elsif ($x eq 'vars') {
               $y = htmlcode('displayvars','','vars',undef,$WHAT,'safe')
            } elsif ($x eq 'type' &amp;&amp; ref $y) {
               $y = qq(&lt;a href="?node_id=$y-&gt;{node_id}"&gt;$y-&gt;{title}&lt;/a&gt;)
            } else {
               $y= $q-&gt;escapeHTML($y);       
            }
            $x= $q-&gt;escapeHTML($x);
            "&lt;tr&gt;&lt;td&gt;$x&lt;/td&gt;&lt;td&gt;$y&lt;/td&gt;&lt;/tr&gt;"
        } sort keys %$WHAT
    ), '&lt;/table&gt;';
%]</live_code>
<reason>support vars better</reason>
<field>doctext</field>
</record>
<record><htmlcode_id>760293</htmlcode_id>
<patch_code>&lt;h2&gt;Useful links for the divine&lt;/h2&gt;
&lt;h3&gt;Wikis&lt;/h3&gt;
[%
  return $q-&gt;ul(
    map {
      $q-&gt;li( htmlcode( 'linkWiki', $_ ) )
    } (
      q/gods' wiki/,
      q/editors' wiki/,
      q/QandAEditors' wiki/,
      q/pmdev wiki/,
      q/pmdev to-do wiki/,
      q/pm-port wiki/,
      q/SDC wiki/,
      q/sdc to-do wiki/,
      q/pollsters' wiki/,
      q/cabalists' wiki/
    )
  );
%]
&lt;h3&gt;Coding&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;[search internal code]&lt;/li&gt;
  &lt;li&gt;[patch lister]&lt;/li&gt;
  &lt;li&gt;[node lister]&lt;/li&gt;
  &lt;li&gt;[module version report]&lt;/li&gt;
  &lt;li&gt;[tail trace log]&lt;/li&gt;
  &lt;li&gt;[id://524816]&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Meddling&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;[dump node fields]&lt;/li&gt;
  &lt;li&gt;[edit user group] (or other groups)&lt;/li&gt;
  &lt;li&gt;[edit user vars]&lt;/li&gt;
  &lt;li&gt;[user image browser]&lt;/li&gt;
  &lt;li&gt;[A hazy shade of winter]&lt;/li&gt;
  &lt;li&gt;[If it quacks like a duck...]&lt;/li&gt;
  &lt;li&gt;[New users]&lt;/li&gt;
  &lt;li&gt;[Operating System Logs]&lt;/li&gt;
  &lt;li&gt;[SQL Prompt]&lt;/li&gt;
  &lt;li&gt;[Raise Anything] - restore nodes from the [tomb]&lt;/li&gt;
  &lt;li&gt;[map secondary account to master account]&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Fixup&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;[id://17186]&lt;/li&gt;
  &lt;li&gt;[re-root notes]&lt;/li&gt;
  &lt;li&gt;[Call for a Recount] - recalculate node rep/votes en masse&lt;/li&gt;
  &lt;li&gt;[fix repliesinfo directreplies]&lt;/li&gt;
  &lt;li&gt;[fix repliesinfo repliesbelow]&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Inboxes&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;[{toInbox:root,[root's inbox](%d),root's inbox}]
  &lt;/li&gt;&lt;li&gt;[{toInbox:NodeReaper,[NodeReaper's inbox](%d),NodeReaper's inbox}]
  &lt;/li&gt;&lt;li&gt;[{toInbox:gods,[gods' inbox](%d),gods' inbox}]
  &lt;/li&gt;&lt;li&gt;[{toInbox:janitors,[janitors' inbox](%d),janitors' inbox}]
  &lt;/li&gt;&lt;li&gt;[{toInbox:pmdev,[pmdev's inbox](%d),pmdev's inbox}]
  &lt;/li&gt;&lt;li&gt;[{toInbox:QandAEditors,[QandAEditors' inbox](%d),QandAEditors' inbox}]
  &lt;/li&gt;&lt;li&gt;[{toInbox:power users,[power users' inbox](%d),power users' inbox}]
  &lt;/li&gt;&lt;li&gt;[{toInbox:sitedocclan,[sitedocclan's inbox](%d),sitedocclan's inbox}]
  &lt;/li&gt;&lt;li&gt;[{toInbox:pollsters,[pollsters' inbox](%d),pollsters' inbox}]
  &lt;/li&gt;&lt;li&gt;[{toInbox:sitedocmanagers,[sitedocmanagers' inbox](%d),sitedocmanagers' inbox}]
  &lt;/li&gt;&lt;li&gt;[{toInbox:developers,[developers' inbox](%d),developers' inbox}]
&lt;/li&gt;&lt;/ul&gt;</patch_code>
<applied>2009-04-27 03:34:09</applied>
<htmlcode_id>154972</htmlcode_id>
<live_code>&lt;h2&gt;Useful links for the divine&lt;/h2&gt;
&lt;h3&gt;Wikis&lt;/h3&gt;
[%
  return $q-&gt;ul(
    map {
      $q-&gt;li( htmlcode( 'linkWiki', $_ ) )
    } (
      q/gods' wiki/,
      q/editors' wiki/,
      q/QandAEditors' wiki/,
      q/pmdev wiki/,
      q/pmdev to-do wiki/,
      q/pm-port wiki/,
      q/SDC wiki/,
      q/sdc to-do wiki/,
      q/pollsters' wiki/,
      q/cabalists' wiki/
    )
  );
%]
&lt;h3&gt;Coding&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;[search internal code]&lt;/li&gt;
  &lt;li&gt;[patch lister]&lt;/li&gt;
  &lt;li&gt;[node lister]&lt;/li&gt;
  &lt;li&gt;[module version report]&lt;/li&gt;
  &lt;li&gt;[tail trace log]&lt;/li&gt;
  &lt;li&gt;[id://524816]&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Meddling&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;[dump node fields]&lt;/li&gt;
  &lt;li&gt;[edit user group] (or other groups)&lt;/li&gt;
  &lt;li&gt;[edit user vars]&lt;/li&gt;
  &lt;li&gt;[user image browser]&lt;/li&gt;
  &lt;li&gt;[A hazy shade of winter]&lt;/li&gt;
  &lt;li&gt;[If it quacks like a duck...]&lt;/li&gt;
  &lt;li&gt;[New users]&lt;/li&gt;
  &lt;li&gt;[Operating System Logs]&lt;/li&gt;
  &lt;li&gt;[SQL Prompt]&lt;/li&gt;
  &lt;li&gt;[Raise Anything] - restore nodes from the [tomb]&lt;/li&gt;
  &lt;li&gt;[map secondary account to master account]&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Fixup&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;[id://17186]&lt;/li&gt;
  &lt;li&gt;[re-root notes]&lt;/li&gt;
  &lt;li&gt;[Call for a Recount] - recalculate node rep/votes en masse&lt;/li&gt;
  &lt;li&gt;[fix repliesinfo directreplies]&lt;/li&gt;
  &lt;li&gt;[fix repliesinfo repliesbelow]&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Inboxes&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;[inbox://root|root's inbox]&lt;/li&gt;
  &lt;li&gt;[inbox://NodeReaper|NodeReaper's inbox]&lt;/li&gt;
  &lt;li&gt;[inbox://gods|gods' inbox]&lt;/li&gt;
  &lt;li&gt;[inbox://janitors|janitors' inbox]&lt;/li&gt;
  &lt;li&gt;[inbox://pmdev|pmdev's inbox]&lt;/li&gt;
  &lt;li&gt;[inbox://QandAEditors|QandAEditors' inbox]&lt;/li&gt;
  &lt;li&gt;[inbox://power users|power users' inbox]&lt;/li&gt;
  &lt;li&gt;[inbox://sitedocclan|sitedocclan's inbox]&lt;/li&gt;
  &lt;li&gt;[inbox://pollsters|pollsters' inbox]&lt;/li&gt;
  &lt;li&gt;[inbox://sitedocmanagers|sitedocmanagers' inbox]&lt;/li&gt;
  &lt;li&gt;[inbox://developers|developers' inbox]&lt;/li&gt;
&lt;/li&gt;&lt;/ul&gt;</live_code>
<reason>'cause stuff was missing?</reason>
<field>doctext</field>
</record>
<record><htmlcode_id>485867</htmlcode_id>
<patch_code>[{openform}]
Search terms:
[% $q-&gt;textfield('searchterms', '', 80); %]

&lt;br /&gt;
( separate terms with ; )

&lt;br /&gt;
[{checkvar:sic_dogrep,Grep?,1}]
[{checkvar:sic_or_terms,Any Terms?,1}]
[% 
#$q-&gt;checkbox('dogrep',1,1,'Grep?')."&lt;br /&gt;".$q-&gt;checkbox('or_terms',1,1,'Any Terms?') 
%]
&lt;br /&gt;
[{closeform}]
[{search_internal_code}]</patch_code>
<applied>2005-08-26 04:13:43</applied>
<htmlcode_id>157620</htmlcode_id>
<live_code>[{openform}]
Search terms:
[% $q-&gt;textfield('searchterms', '', 80); %]

&lt;br /&gt;
( separate terms with ; )

&lt;br /&gt;
[{checkvar:sic_dogrep,Grep?,1}]
[{checkvar:sic_or_terms,Any Terms?,1}]
&lt;br /&gt;
[{closeform}]
[{search_internal_code}]</live_code>
<reason>any and grep should be default.</reason>
<field>doctext</field>
</record>
<record><htmlcode_id>685529</htmlcode_id>
<patch_code>[%
  my $str;

  local *generateLogin = sub
  {
    return &lt;&lt;"END";
    &lt;form action="?" method="post"&gt;
      &lt;input type="hidden" name="node_id" value="@{[ getId($NODE) ]}" /&gt;
      &lt;input type="hidden" name="op" value="newuser" /&gt;

      &lt;table&gt;
        &lt;tr&gt;
          &lt;td&gt;Preferred username:&lt;/td&gt;
          &lt;td&gt;&lt;input type="text" name="nu_name" size="20" maxlength="20" /&gt;&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;Real&amp;#153; Name:&lt;/td&gt;
          &lt;td&gt;&lt;input type="text" name="nu_realname" size="20" maxlength="40" /&gt;&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;Email Address&lt;/td&gt;
          &lt;td&gt;&lt;input type="text" name="nu_email" size="20" maxlength="255" /&gt;&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;&lt;/td&gt;
          &lt;td&gt;&lt;input type="submit" name="sexisgood" value="submit" /&gt;&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/table&gt;

    &lt;/form&gt;
END
  };

  unless ( $query-&gt;param('op') eq 'newuser' ) {
    return &lt;&lt;"END";
    &lt;p&gt;
      To create a new user on PerlMonks, we need a smattering of information:
    &lt;/p&gt;
    @{[ generateLogin() ]}
    &lt;p&gt;
      &lt;b&gt;Please note:&lt;/b&gt;
    &lt;/p&gt;
    &lt;p&gt;
      We are not going to send you junk email "member updates", sell your
      address to spammers, or display your email address for people to see.
      This email exists so that you can recieve your password, and/or retrieve
      it if you forget.  There may be future email functionality, which
      you will have the option to turn on from your user settings page.
    &lt;/p&gt;
END
  }

  my $realname  = $query-&gt;param("nu_realname");
  my $email     = $query-&gt;param("nu_email");
  my $name      = $query-&gt;param("nu_name");


  if ( my ($olduser) = $DB-&gt;getNodeWhere({ title =&gt; $name }, $DB-&gt;getType('user')) ) {
    return sprintf &lt;&lt;'END',
    &lt;p&gt;
      Sorry, %s already exists.  Try another name...
    &lt;/p&gt;
    %s
END

    linkNode($olduser), generateLogin();
  }

  # Check if we have any '_' vs ' ' clashing
  # that could lead to chatterbox conflicts.

  my $match = lc($name);
  $match=~s/([a-zA-Z])/'['.$1.uc($1).']'/eg;
  $match=~s/[_ ]/[_ ]/g;
  $match="^$match\$";

  my ($closeuser) = $DB-&gt;sqlSelect(
                    "node_id,title",
                    "node", "title regexp \"$match\" and type_nodetype in(".getId(getType('user')).",".getId(getType('usergroup')).")");
  if($closeuser) {
    return "Sorry, your username clashes with ".linkNode($closeuser)
    ." which already exists.  Pick a variation, or try another name...&lt;p&gt;\n".generateLogin();
  }

  # Deny people the power of _ and ' ' at the beginning of usernames
  if ( $name =~ /^[_ ]/ ) {

    return &lt;&lt;"END";
    &lt;p&gt;
      Sorry, ' ' and '_' are not allowed at the beginning of usernames.
      Try again, do not pass Go, and do not collect \$200.
    &lt;/p&gt;
    @{[ generateLogin() ]}
END

  }

  if( $name =~ /[\[\]&lt;&gt;]/ ) {

    return &lt;&lt;"END";
    &lt;p&gt;
      Sorry &amp;lt;, &amp;gt;, &amp;#091; and &amp;#093; are not allowed in usernames.  Try again.
    &lt;/p&gt;
    @{[ generateLogin() ]}
END

  }

  if( getNode($name,'superdoc') || getNode($name,'perlman') || getNode($name,'perlfunc')  || getNode($name,'usergroup') ) {

    return &lt;&lt;"END";
    &lt;p&gt;
      Sorry there is already a system document or usergroup with that name.
      Pick a name that doesn't clash with important system documents.
    &lt;/p&gt;
    @{[ generateLogin() ]}
END

  }


  # Generate the passwd and send it out on email.
  my @chars = ( 'A'..'Z', 'a'..'k', 2..9 );
  my $passwd = join('', @chars[ map { rand @chars } 1 .. 8 ]);


  my $NEWUSER = {
                  realname  =&gt; $realname,
                  email     =&gt; $email,
                  passwd    =&gt; $passwd,
                  title     =&gt; $name,
                  lastupdate =&gt; undef,
  };

  $DB-&gt;sqlInsert('newuser', $NEWUSER );

  # Send some email;
  my $msg = getNode('New User Mail', 'mail');

  $msg-&gt;{doctext} =~ s/&lt;name&gt;/$NEWUSER-&gt;{realname}/;
  $msg-&gt;{doctext} =~ s/&lt;user&gt;/$NEWUSER-&gt;{title}/;
  $msg-&gt;{doctext} =~ s/&lt;passwd&gt;/$NEWUSER-&gt;{passwd}/;
  $msg-&gt;{doctext} =~ s/&lt;site_name&gt;/$HTMLVARS{site_name}/;
  $msg-&gt;{doctext} =~ s/&lt;homenode&gt;/$HTMLVARS{site_url}index\.pl\?node=$NEWUSER-&gt;{title}\&amp;type=user/;
  $msg-&gt;{doctext} =~ s/&lt;site_url&gt;/$HTMLVARS{site_url}/;
  $msg-&gt;{doctext} =~ s/&lt;login&gt;/$HTMLVARS{site_url}index\.pl\?node_id=$HTMLVARS{login_node}/;

  use Everything::MAIL;
  node2mail($NEWUSER-&gt;{email}, $msg);
  $HTMLVARS{mailsent} = 1;

  # Record sign-up information for later reference.
  # $DB-&gt;sqlInsert('emailpwd', { user_id =&gt; getId($NEWUSER), ip =&gt; $ENV{REMOTE_ADDR}, email =&gt; $email, reason =&gt; 'New user' });


  return sprintf &lt;&lt;'END',
  &lt;p&gt;
    Your new user account (%s) has been created.  You (%s)
    should be getting an email soon telling you your generated
    password.
  &lt;/p&gt;
END

  $NEWUSER-&gt;{title}, $NEWUSER-&gt;{email};
%]
[%
  return unless exists $HTMLVARS{newuser}
          and not exists $HTMLVARS{mailsent};

  my $NU = getNodeById $HTMLVARS{newuser};

  return "Our mail server isn't working right now.  Sorry.  You get your password now: $NU-&gt;{passwd}";
%]
</patch_code>
<applied>2008-05-08 15:25:57</applied>
<htmlcode_id>158182</htmlcode_id>
<live_code>[%
  my $str;

  local *generateLogin = sub
  {
    return &lt;&lt;"END";
    &lt;form action="?" method="post"&gt;
      &lt;input type="hidden" name="node_id" value="@{[ getId($NODE) ]}" /&gt;
      &lt;input type="hidden" name="op" value="newuser" /&gt;

      &lt;table&gt;
        &lt;tr&gt;
          &lt;td&gt;Preferred username:&lt;/td&gt;
          &lt;td&gt;&lt;input type="text" name="nu_name" size="20" maxlength="20" /&gt;&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;Real&amp;#153; Name:&lt;/td&gt;
          &lt;td&gt;&lt;input type="text" name="nu_realname" size="20" maxlength="40" /&gt;&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;Email Address&lt;/td&gt;
          &lt;td&gt;&lt;input type="text" name="nu_email" size="20" maxlength="255" /&gt;&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;&lt;/td&gt;
          &lt;td&gt;&lt;input type="submit" name="sexisgood" value="submit" /&gt;&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/table&gt;

    &lt;/form&gt;
END
  };

  unless ( $query-&gt;param('op') eq 'newuser' ) {
    return &lt;&lt;"END";
    &lt;p&gt;
      To create a new user on PerlMonks, we need a smattering of information:
    &lt;/p&gt;
    @{[ generateLogin() ]}
    &lt;p&gt;
      &lt;b&gt;Please note:&lt;/b&gt;
    &lt;/p&gt;
    &lt;p&gt;
      We are not going to send you junk email "member updates", sell your
      address to spammers, or display your email address for people to see.
      This email exists so that you can recieve your password, and/or retrieve
      it if you forget.  There may be future email functionality, which
      you will have the option to turn on from your user settings page.
    &lt;/p&gt;
END
  }

  my $realname  = $query-&gt;param("nu_realname");
  my $email     = $query-&gt;param("nu_email");
  my $name      = $query-&gt;param("nu_name");


  if ( my ($olduser) = $DB-&gt;getNodeWhere({ title =&gt; $name }, $DB-&gt;getType('user')) ) {
    return sprintf &lt;&lt;'END',
    &lt;p&gt;
      Sorry, %s already exists.  Try another name...
    &lt;/p&gt;
    %s
END

    linkNode($olduser), generateLogin();
  }

  # Check if we have any '_' vs ' ' clashing
  # that could lead to chatterbox conflicts.

  my $match = lc($name);
  $match=~s/([a-zA-Z])/'['.$1.uc($1).']'/eg;
  $match=~s/[_ ]/[_ ]/g;
  $match="^$match\$";

  my ($closeuser) = $DB-&gt;sqlSelect(
                    "node_id,title",
                    "node", "title regexp \"$match\" and type_nodetype in(".getId(getType('user')).",".getId(getType('usergroup')).")");
  if($closeuser) {
    return "Sorry, your username clashes with ".linkNode($closeuser)
    ." which already exists.  Pick a variation, or try another name...&lt;p&gt;\n".generateLogin();
  }

  # Deny people the power of _ and ' ' at the beginning of usernames
  if ( $name =~ /^[_ ]/ ) {

    return &lt;&lt;"END";
    &lt;p&gt;
      Sorry, ' ' and '_' are not allowed at the beginning of usernames.
      Try again, do not pass Go, and do not collect \$200.
    &lt;/p&gt;
    @{[ generateLogin() ]}
END

  }

  if( $name =~ /[\[\]&lt;&gt;]/ ) {

    return &lt;&lt;"END";
    &lt;p&gt;
      Sorry &amp;lt;, &amp;gt;, &amp;#091; and &amp;#093; are not allowed in usernames.  Try again.
    &lt;/p&gt;
    @{[ generateLogin() ]}
END

  }

  if( getNode($name,'superdoc') || getNode($name,'perlman') || getNode($name,'perlfunc')  || getNode($name,'usergroup') ) {

    return &lt;&lt;"END";
    &lt;p&gt;
      Sorry there is already a system document or usergroup with that name.
      Pick a name that doesn't clash with important system documents.
    &lt;/p&gt;
    @{[ generateLogin() ]}
END

  }


  # Generate the passwd and send it out on email.
  my @chars = ( 'A'..'Z', 'a'..'k', 2..9 );
  my $passwd = join('', @chars[ map { rand @chars } 1 .. 8 ]);


  my $NEWUSER = {
                  realname  =&gt; $realname,
                  email     =&gt; $email,
                  passwd    =&gt; $passwd,
                  title     =&gt; $name,
                  lastupdate =&gt; undef,
  };

  $DB-&gt;sqlInsert('newuser', $NEWUSER );

  # Send some email;
  my $msg = getNode('New User Mail', 'mail');
  local $msg-&gt;{doctext} = $msg-&gt;{doctext};
  $msg-&gt;{doctext} =~ s/&lt;name&gt;/$NEWUSER-&gt;{realname}/;
  $msg-&gt;{doctext} =~ s/&lt;user&gt;/$NEWUSER-&gt;{title}/;
  $msg-&gt;{doctext} =~ s/&lt;passwd&gt;/$NEWUSER-&gt;{passwd}/;
  $msg-&gt;{doctext} =~ s/&lt;site_name&gt;/$HTMLVARS{site_name}/;
  $msg-&gt;{doctext} =~ s/&lt;homenode&gt;/$HTMLVARS{site_url}index\.pl\?node=$NEWUSER-&gt;{title}\&amp;type=user/;
  $msg-&gt;{doctext} =~ s/&lt;site_url&gt;/$HTMLVARS{site_url}/;
  $msg-&gt;{doctext} =~ s/&lt;login&gt;/$HTMLVARS{site_url}index\.pl\?node_id=$HTMLVARS{login_node}/;

  use Everything::MAIL;
  node2mail($NEWUSER-&gt;{email}, $msg);
  $HTMLVARS{mailsent} = 1;

  # Record sign-up information for later reference.
  # $DB-&gt;sqlInsert('emailpwd', { user_id =&gt; getId($NEWUSER), ip =&gt; $ENV{REMOTE_ADDR}, email =&gt; $email, reason =&gt; 'New user' });


  return sprintf &lt;&lt;'END',
  &lt;p&gt;
    Your new user account (%s) has been created.  You (%s)
    should be getting an email soon telling you your generated
    password.
  &lt;/p&gt;
END

  $NEWUSER-&gt;{title}, $NEWUSER-&gt;{email};
%]
[%
  return unless exists $HTMLVARS{newuser}
          and not exists $HTMLVARS{mailsent};

  my $NU = getNodeById $HTMLVARS{newuser};

  return "Our mail server isn't working right now.  Sorry.  You get your password now: $NU-&gt;{passwd}";
%]
</live_code>
<reason>New user creation scheme via table 'newuser'</reason>
<field>doctext</field>
</record>
<record><htmlcode_id>525024</htmlcode_id>
<patch_code>&lt;form action="[% $ENV{SCRIPT_NAME} %]" method="get"
 enctype="application/x-www-form-urlencoded"&gt;
  &lt;input type="hidden" name="node_id" value="[% getId($NODE) %]" /&gt;
  Edit group
  &lt;select name="group"&gt;
    &lt;option value="gods"[% ' selected="selected"'
      if $query-&gt;param('group') eq 'gods' %]&gt;gods&lt;/option&gt;
    &lt;option value="janitors"[% ' selected="selected"'
      if $query-&gt;param('group') eq 'janitors' %]&gt;janitors&lt;/option&gt;
    &lt;option value="pmdev"[% return ' selected="selected"'
      if $query-&gt;param('group') eq 'pmdev'; %]&gt;pmdev&lt;/option&gt;
    &lt;option value="power users"[% return ' selected="selected"'
      if $query-&gt;param('group') eq 'power users'; %]&gt;power users&lt;/option&gt;
    &lt;option value="QandAEditors"[% ' selected="selected"'
      if $query-&gt;param('group') eq 'QandAEditors' %]&gt;QandAEditors&lt;/option&gt;
    &lt;option value="SiteDocClan"[% ' selected="selected"'
      if $query-&gt;param('group') eq 'SiteDocClan'
    %]&gt;SiteDocClan&lt;/option&gt;
    &lt;option value="pmtesters"[% ' selected="selected"'
      if $query-&gt;param('group') eq 'pmtesters'
    %]&gt;PerlMonks Testers&lt;/option&gt;
    &lt;option value="cabal"[% ' selected="selected"'
      if $query-&gt;param('group') eq 'cabal' %]&gt;cabal&lt;/option&gt;
    &lt;option value="pedagogues"[% ' selected="selected"'
      if $query-&gt;param('group') eq 'pedagogues' %]&gt;pedagogues&lt;/option&gt;
  &lt;/select&gt;
  &lt;input type="submit" name="NaRF" value="Go" /&gt;
&lt;/form&gt;

[%
  if(  my $u= $query-&gt;param('user')
  and  my $g= $query-&gt;param('group')  ) {

    my $group = $g !~ /\D/
      ? getNodeById($g)
      : getNode( $g, 'usergroup' );
    return 'No such group!'
      unless $group;

    my $user  = $u !~ /\D/
      ? getNodeById($u)
      : getNode( $u, 'user' ) || getNode( $u, 'usergroup' );
    return 'No such user!'
      unless $user;

    $_=getNodeById(getId($_),'force') 
        for $user,$group;

    my $return;

    unless(
      $DB-&gt;sqlSelect(
        'node_id', 'nodegroup',
        sprintf( 'nodegroup_id = %d AND node_id = %d',
          getId($group), getId($user) )
      )
    ) {
      my $rank = $DB-&gt;sqlSelect(
        'rank + 1',
        'nodegroup',
        sprintf( 'nodegroup_id = %d', getId($group) ),
        'ORDER BY rank DESC LIMIT 1'
      );

      my $orderby = $rank;

      $DB-&gt;sqlInsert(
        'nodegroup',
        {
          nodegroup_id =&gt; getId($group),
          node_id      =&gt; getId($user),
          rank         =&gt; $rank,
          orderby      =&gt; $orderby
        }
      );

      $return=
        sprintf 'Added %s to %s',
          linkNode($user), linkNode($group);
    } else {
      $return=
        sprintf '%s already is in group %s',
          linkNode($user), linkNode($group);
    }

    # force an update
    updateNode($group,-1);

    return $return;

  } else {

    return sprintf &lt;&lt;'END',
    &lt;p&gt;
      &lt;form action="%s" method="post"
       enctype="application/x-www-form-urlencoded"&gt;
        &lt;input type="hidden" name="node_id" value="%d" /&gt;
        Add user &lt;input type="text" name="user" size="10" /&gt;
        to group &lt;input type="text" name="group" value="%s" size="10" /&gt;
        &lt;input type="submit" name="NaRF" value="Poit!" /&gt;
      &lt;/form&gt;
    &lt;/p&gt;
END
    $ENV{SCRIPT_NAME}, getId($NODE),
    $query-&gt;param('group') || '';

  }
%]
&lt;br /&gt;
[%
  if ( my $g = $query-&gt;param('group') ) {
    my $group = $g !~ /\D/ ? getNodeById($g) : getNode( $g, 'usergroup' );

    return 'No such group!' unless $group;

    if ( my @users = $query-&gt;param('delete') ) {
      foreach my $id (@users) {
        $DB-&gt;sqlDelete(
          'nodegroup',
          sprintf('nodegroup_id = %d AND node_id = %d', getId($group), $id)
        );
      }

      $group = getNodeById( getId($group), 'force' );
    }

    my $row = &lt;&lt;'END';
        &lt;tr&gt;
          &lt;td&gt;
            &lt;input type="checkbox" name="delete" value="%d" /&gt;
          &lt;/td&gt;
          &lt;td&gt;
            %s
          &lt;/td&gt;
        &lt;/tr&gt;
END

    return sprintf &lt;&lt;'END',
    &lt;form action="%s" method="post"
     enctype="application/x-www-form-urlencoded"&gt;
      &lt;input type="hidden" name="node_id" value="%d" /&gt;
      &lt;input type="hidden" name="group"   value="%s" /&gt;

      Members of %s:

      &lt;table&gt;
%s
      &lt;/table&gt;
      &lt;input type="submit" name="NaRF" value="Remove" /&gt;
    &lt;/form&gt;
END
    $ENV{SCRIPT_NAME},
    getId($NODE),
    $group-&gt;{title},
    linkNode($group),
    join '',
      map { sprintf $row, $_, linkNode($_) }
        @{$group-&gt;{group}};
  }
%]
</patch_code>
<applied>2006-01-23 14:19:05</applied>
<htmlcode_id>160900</htmlcode_id>
<live_code>&lt;form action="[% $ENV{SCRIPT_NAME} %]" method="get"
 enctype="application/x-www-form-urlencoded"&gt;
  &lt;input type="hidden" name="node_id" value="[% getId($NODE) %]" /&gt;
  Edit group
[%
    my @groups=
        sort { $a cmp $b }
        map { $_-&gt;{title} }
        getNodeWhere( {}, "usergroup" );
    return $query-&gt;popup_menu(
        -name =&gt; "group",
        -values =&gt; \@groups,
        -default =&gt; 'gods',
    );
%]
  &lt;input type="submit" name="NaRF" value="Go" /&gt;
&lt;/form&gt;

[%
  if(  my $u= $query-&gt;param('user')
  and  my $g= $query-&gt;param('group')  ) {

    my $group = $g !~ /\D/
      ? getNodeById($g)
      : getNode( $g, 'usergroup' );
    return 'No such group!'
      unless $group;

    my $user  = $u !~ /\D/
      ? getNodeById($u)
      : getNode( $u, 'user' ) || getNode( $u, 'usergroup' );
    return 'No such user!'
      unless $user;

    $_=getNodeById(getId($_),'force') 
        for $user,$group;

    my $return;

    unless(
      $DB-&gt;sqlSelect(
        'node_id', 'nodegroup',
        sprintf( 'nodegroup_id = %d AND node_id = %d',
          getId($group), getId($user) )
      )
    ) {
      my $rank = $DB-&gt;sqlSelect(
        'rank + 1',
        'nodegroup',
        sprintf( 'nodegroup_id = %d', getId($group) ),
        'ORDER BY rank DESC LIMIT 1'
      );

      my $orderby = $rank;

      $DB-&gt;sqlInsert(
        'nodegroup',
        {
          nodegroup_id =&gt; getId($group),
          node_id      =&gt; getId($user),
          rank         =&gt; $rank,
          orderby      =&gt; $orderby
        }
      );

      $return=
        sprintf 'Added %s to %s',
          linkNode($user), linkNode($group);
    } else {
      $return=
        sprintf '%s already is in group %s',
          linkNode($user), linkNode($group);
    }

    # force an update
    updateNode($group,-1);

    return $return;

  } else {

    return sprintf &lt;&lt;'END',
    &lt;p&gt;
      &lt;form action="%s" method="post"
       enctype="application/x-www-form-urlencoded"&gt;
        &lt;input type="hidden" name="node_id" value="%d" /&gt;
        Add user &lt;input type="text" name="user" size="10" /&gt;
        to group &lt;input type="text" name="group" value="%s" size="10" /&gt;
        &lt;input type="submit" name="NaRF" value="Poit!" /&gt;
      &lt;/form&gt;
    &lt;/p&gt;
END
    $ENV{SCRIPT_NAME}, getId($NODE),
    $query-&gt;param('group') || '';

  }
%]
&lt;br /&gt;
[%
  if ( my $g = $query-&gt;param('group') ) {
    my $group = $g !~ /\D/ ? getNodeById($g) : getNode( $g, 'usergroup' );

    return 'No such group!' unless $group;

    if ( my @users = $query-&gt;param('delete') ) {
      foreach my $id (@users) {
        $DB-&gt;sqlDelete(
          'nodegroup',
          sprintf('nodegroup_id = %d AND node_id = %d', getId($group), $id)
        );
      }

      $group = getNodeById( getId($group), 'force' );
    }

    my $row = &lt;&lt;'END';
        &lt;tr&gt;
          &lt;td&gt;
            &lt;input type="checkbox" name="delete" value="%d" /&gt;
          &lt;/td&gt;
          &lt;td&gt;
            %s
          &lt;/td&gt;
        &lt;/tr&gt;
END

    return sprintf &lt;&lt;'END',
    &lt;form action="%s" method="post"
     enctype="application/x-www-form-urlencoded"&gt;
      &lt;input type="hidden" name="node_id" value="%d" /&gt;
      &lt;input type="hidden" name="group"   value="%s" /&gt;

      Members of %s:

      &lt;table&gt;
%s
      &lt;/table&gt;
      &lt;input type="submit" name="NaRF" value="Remove" /&gt;
    &lt;/form&gt;
END
    $ENV{SCRIPT_NAME},
    getId($NODE),
    $group-&gt;{title},
    linkNode($group),
    join '',
      map { sprintf $row, $_, linkNode($_) }
        @{$group-&gt;{group}};
  }
%]
</live_code>
<reason>pedagogues -- why isnt the group list dynamically generated?!</reason>
<field>doctext</field>
</record>
<record><htmlcode_id>506108</htmlcode_id>
<patch_code>[%
  return "&lt;error&gt;Error creatng fling object&lt;/error&gt;"
     unless htmlcode('new_xml_fling','',\my($xml,@data,%xmlstyle),"addheader");

  local *kids = sub
  {
    my $parent = shift;
    
    $parent = ref $parent ? $parent-&gt;{node_id} : $parent;

    my $dbh = $DB-&gt;getDatabaseHandle;

    my $sth = $dbh-&gt;prepare_cached('
      SELECT node_id, title, author_user, parent_node, root_node
      FROM   note, node
      WHERE  parent_node = ?
      AND    note_id = node_id
    ');

    $sth-&gt;execute($parent);

    return @{ $sth-&gt;fetchall_arrayref({}) || [] }
  };
  
  local *flattree = sub 
  {
    my ($parent) = @_;
    
    my @these=kids($parent);
    foreach my $kid (@these) {
        my $title=delete $kid-&gt;{title};
        $xml-&gt;element('node',%$kid,$title);
        flattree($kid);
    }
  };
  
  local *tree = sub
  {
    my $parent = shift;

    my @kids = kids($parent);
    return unless @kids;

    my @tree;

    foreach my $kid ( @kids ) {
      push @tree, [ $kid, tree($kid-&gt;{node_id}) ];
    }

    return @tree;
  };

  local *thread= sub
  {
    my $t = shift;
    my $x = shift;

    foreach my $n ( @$t ) {
      my $i = shift @$n;

      $x-&gt;start('node', id =&gt; $i-&gt;{node_id});
      thread($n, $x);
      $x-&gt;end('node');
    }
  };
  
  
  my $id = $q-&gt;param('id') || 0;
  $xml-&gt;start('thread', id =&gt; $id);
  htmlcode('xml_info_tag','',$xml,\%xmlstyle);
  if ( $q-&gt;param('flattree') &amp;&amp; ( my $node = getNodeById($id) ) ) {
    $xml-&gt;element('node',
         ( map { $node-&gt;{$_} ? ($_ =&gt; $node-&gt;{$_}) : () } 
          qw(node_id author_user parent_node root_node)),
          $node-&gt;{title}
    );
    flattree( $id );
  } else {
    my @replies = tree($id);
    thread( \@replies, $xml ) if $id;
  }
  $xml-&gt;end('thread');
  return join '', @data;
%]</patch_code>
<applied>2005-11-06 09:35:40</applied>
<htmlcode_id>180684</htmlcode_id>
<live_code>[%
  return "&lt;error&gt;Error creatng fling object&lt;/error&gt;"
     unless htmlcode('new_xml_fling','',\my($xml,@data,%xmlstyle),"addheader");

  local *kids = sub
  {
    my $parent = shift;
    
    $parent = ref $parent ? $parent-&gt;{node_id} : $parent;

    my $dbh = $DB-&gt;getDatabaseHandle;

    my $sth = $dbh-&gt;prepare_cached('
      SELECT node_id, title, author_user, parent_node, root_node
      FROM   note, node
      WHERE  parent_node = ?
      AND    note_id = node_id
    ');

    $sth-&gt;execute($parent);

    return @{ $sth-&gt;fetchall_arrayref({}) || [] }
  };
  
  local *flattree = sub 
  {
    my ($parent) = @_;
    
    my @these=kids($parent);
    foreach my $kid (@these) {
        my $title=delete $kid-&gt;{title};
        $xml-&gt;element('node',%$kid,$title);
        flattree($kid);
    }
  };
  
  local *tree = sub
  {
    my $parent = shift;

    my @kids = kids($parent);
    return unless @kids;

    my @tree;

    foreach my $kid ( @kids ) {
      push @tree, [ $kid, tree($kid-&gt;{node_id}) ];
    }

    return @tree;
  };

  local *thread= sub
  {
    my $t = shift;
    my $x = shift;

    foreach my $n ( @$t ) {
      my $i = shift @$n;

      $x-&gt;start('node', id =&gt; $i-&gt;{node_id});
      thread($n, $x);
      $x-&gt;end('node');
    }
  };
  
  
  my $id = $q-&gt;param('id') || 0;
  $xml-&gt;start('thread', id =&gt; $id);
  htmlcode('xml_info_tag','',$xml,\%xmlstyle);
  if ( $q-&gt;param('flattree') &amp;&amp; ( my $node = getNodeById($id) ) ) {
    $xml-&gt;element('node',
         ( map { $node-&gt;{$_} ? ($_ =&gt; $node-&gt;{$_}) : () } 
          qw(node_id author_user parent_node root_node)),
          $node-&gt;{title}
    );
    flattree( $id );
  } else {
    my @replies = tree($id);
    thread( \@replies, $xml ) if $id;
  }
  $xml-&gt;end('thread');
  my $data = join "",@data;       
  htmlcode('postProcessXML','',\$data);
  return $data;
%]</live_code>
<reason>support a flattree</reason>
<field>doctext</field>
</record>
<record><htmlcode_id>585567</htmlcode_id>
<patch_code>[{get_sitedoclet}]
&lt;p&gt;[{see_also:Settings Nodes;faqlist}]&lt;/p&gt;
&lt;hr /&gt;
[%
my @anchors;
my $html= '';

for my $line (  split /\s*\n/, &lt;&lt;'END'
Pacific
   Samoa                Pacific/Apia           -11:00   WST
   Hawaii               Pacific/Honolulu       -10:00   HST
   French Polynesia     Pacific/Tahiti         -10:00   TAHT
   Cook Island          Pacific/Rarotonga      -10:00   CK*T
   Aleutian Islands     America/Adak           -10:00   HA*T
   French Polynesia     Pacific/Marquesas       -9:30   MART
   French Polynesia     Pacific/Gambier         -9:00   GAMT
   Pitcairn             Pacific/Pitcairn        -8:00   PST

North America
   Alaska               America/Anchorage       -9:00   AK*T
   Pacific w/ DST       America/Los_Angeles     -8:00   P*T
   Mountain Standard    MST                     -7:00   MST
   Mountain w/ DST      America/Denver          -7:00   M*T
   Central Standard     SystemV/CST6            -6:00   CST
   Central w/ DST       America/Chicago         -6:00   C*T
   Eastern Standard     EST                     -5:00   EST
   Eastern w/ DST       America/New_York        -5:00   E*T
   Cuba                 America/Havana          -5:00   C*T
   Atlantic Standard    SystemV/AST4            -4:00   AST
   Atlantic w/ DST      America/Halifax         -4:00   A*T
   Newfoundland         America/St_Johns        -3:30   N*T
   St. Pierre / Miquelon  America/Miquelon        -3:00   PM*T
   West Greenland       America/Godthab         -3:00   WG*T
   Scoresbysund         America/Scoresbysund    -1:00   EG*T
   NE Greenland         America/Danmarkshavn    0:00    GMT

South America
   Easter Island        Pacific/Easter          -6:00   EAS*T
   Ecuador / Galapagos  Pacific/Galapagos       -6:00   GALT
   Ecuador              America/Guayaquil       -5:00   ECT
   Colombia             America/Bogota          -5:00   CO*T
   Peru                 America/Lima            -5:00   PE*T
   Chile                America/Santiago        -4:00   CL*T
   Falklands            Atlantic/Stanley        -4:00   FK*T
   Paraguay             America/Asuncion        -4:00   PY*T
   Venezuela            America/Caracas         -4:00   VET
   Argentina            America/Buenos_Aires    -3:00   ART
   Uruguay              America/Montevideo      -3:00   UY*T
   South Georgia        Atlantic/South_Georgia  -2:00   GST

   Brazil / W Amazonas  America/Eirunepe        -5:00   ACT
   Brazil / W Para      America/Porto_Velho     -4:00   AMT
   Brazil / Mato Grosso America/Cuiaba          -4:00   AM*T
   Brazil               America/Sao_Paulo       -3:00   BR*T
   Brazil / E Para      America/Belem           -3:00   BRT
   Brazil / Atlantic    America/Noronha         -2:00   FNT

Europe
   Portugal             Atlantic/Azores         -1:00   AZO*T
   Universal Time       GMT                      0:00   GMT
   United Kingdom       Europe/London            0:00   GMT/BST
   Central Europe       Europe/Rome              1:00   CE*T
   Lithuania            Europe/Vilnius           2:00   EET
   Eastern Europe       Europe/Istanbul          2:00   EE*T

Africa
   Cape Verde           Atlantic/Cape_Verde     -1:00   CVT
   Canary Island        Atlantic/Canary          0:00   WE*T
   Tunisia              Africa/Tunis             1:00   CE*T
   Namibia              Africa/Windhoek          1:00   WA*T
   Western Africa       Africa/Lagos             1:00   WAT
   South Africa         Africa/Johannesburg      2:00   SAST
   Central Africa       Africa/Harare            2:00   CAT
   Eastern Africa       Africa/Nairobi           3:00   EAT
   Egypt                Africa/Cairo             2:00   EE*T

Middle East
   Israel               Asia/Jerusalem           2:00   I*T
   Syria                Asia/Damascus            2:00   EE*T
   Iran                 Asia/Tehran              3:30   IR*T
   Iraq                 Asia/Baghdad             3:00   A*T
   Saudi Arabia         Asia/Riyadh              3:00   AST
   Oman                 Asia/Muscat              4:00   GST

Asia
   Afghanistan          Asia/Kabul               4:30   AFT
   Pakistan             Asia/Karachi             5:00   PK*T
   Uzbekistan           Asia/Tashkent            5:00   UZT
   India                Asia/Calcutta            5:30   IST
   Nepal                Asia/Katmandu            5:45   NPT
   Bangladesh           Asia/Dhaka               6:00   BDT
   Burma                Asia/Rangoon             6:30   MMT
   Vietnam              Asia/Saigon              7:00   ICT
   Western Indonesia    Asia/Jakarta             7:00   WIT
   Central Indonesia    Asia/Makassar            8:00   CIT
   Eastern Indonesia    Asia/Jayapura            9:00   EIT
   Philippines          Asia/Manila              8:00   PH*T
   China                Asia/Shanghai            8:00   C*T
   Hong Kong/Xianggang  Asia/Hong_Kong           8:00   HK*T
   Japan                Asia/Tokyo               9:00   JST
   Korea                Asia/Seoul               9:00   KST

Russia
   Russia               Europe/Minsk             2:00   EE*T
   Russia               Europe/Moscow            3:00   MSK/MSD
   Russia               Europe/Samara            4:00   SAM*T
   Russia               Asia/Yekaterinburg       5:00   YEK*T
   Russia               Asia/Omsk                6:00   OMS*T
   Russia               Asia/Novosibirsk         6:00   NOV*T
   Russia               Asia/Krasnoyarsk         7:00   KRA*T
   Russia               Asia/Irkutsk             8:00   IRK*T
   Russia               Asia/Yakutsk             9:00   YAK*T
   Russia               Asia/Vladivostok        10:00   VLA*T
   Russia               Asia/Sakhalin           10:00   SAK*T
   Russia               Asia/Magadan            11:00   MAG*T
   Russia               Asia/Kamchatka          12:00   PET*T
   Russia               Asia/Anadyr             12:00   ANA*T

Australia / Pacific
   Western Australia    Australia/Perth          8:00   WST
   Northern Australia   Australia/Darwin         9:30   CST
   Southern Australia   Australia/Adelaide       9:30   C*T
   Eastern Australia    Australia/Brisbane      10:00   EST
   S.E. Australia       Australia/Sydney        10:00   E*T
   Tasmania             Australia/Hobart        10:00   E*T
   Lord Howe Island     Australia/Lord_Howe     10:30   LH*T

   Guam                 Pacific/Guam            10:00   ChST
   Solomon Is           Pacific/Guadalcanal     11:00   SBT
   Norfolk              Pacific/Norfolk         11:30   NFT
   Fiji                 Pacific/Fiji            12:00   FJT
   New Zealand          Pacific/Auckland        12:00   NZ*T
   New Z./Chatham Is    Pacific/Chatham         12:45   CHA*T
   Kiribati / Gilbert   Pacific/Tarawa          12:00   GILT
   Kiribati / Phoenix   Pacific/Enderbury       13:00   PHOT
   Kiribati / Line Is   Pacific/Kiritimati      14:00   LINT
END
) {
   if(  $line !~ /\S/  ) {
      $html .= qq[&lt;tr&gt;&lt;td colspan="4"&gt;&amp;nbsp;&lt;/td&gt;&lt;/tr&gt;\n];
   } elsif(  $line =~ /^\S/  ) {
      $html .= "&lt;/table&gt;"   if  @anchors;
      push @anchors, $line;
      my( $name )= split ' ', $line;
      $html .= qq[&lt;h3&gt;&lt;a name="$name"&gt;$line&lt;/a&gt;&lt;/h3&gt;\n]
         . qq[&lt;table width="100%"&gt;\n];
   } else {
      my @w= split ' ', $line;
      my $abbr= pop @w;
      my $off= pop @w;
      my $zone= pop @w;
      my $desc= "@w";
      $html .= qq[&lt;tr&gt;&lt;td&gt;$desc&lt;/td&gt;
         &lt;td&gt;] . linkNode( $NODE, $zone, { settimezone=&gt;$zone } ) . qq[&lt;/td&gt;
         &lt;td&gt;$abbr&lt;/td&gt;
         &lt;td&gt;] . htmlcode( 'parseTimeInString','', '', $zone ) . qq[&lt;/td&gt;
         &lt;/tr&gt;\n];
   }
}
$html .= qq[&lt;/table&gt;\n];

my $head= join " | ", map {
   my( $name )= split ' ', $_;
   s/ /&amp;nbsp;/g;
   qq[&lt;a href="#$name"&gt;$_&lt;/a&gt;];
} @anchors;

return join $/,
   $head,
   '&lt;p&gt;',
   '&lt;h2&gt;Click on a timezone below to start using it.&lt;/h2&gt;',
   '&lt;/p&gt;',
   $html,
   htmlcode('timezonechooser');
%]
</patch_code>
<applied>2006-11-22 11:35:00</applied>
<htmlcode_id>192270</htmlcode_id>
<live_code>&lt;p&gt;[{see_also:Settings Nodes;faqlist}]&lt;/p&gt;
[{get_sitedoclet}]
[%
my @anchors;
my $html= '';

for my $line (  split /\s*\n/, &lt;&lt;'END'
Pacific
   Samoa                Pacific/Apia           -11:00   WST
   Hawaii               Pacific/Honolulu       -10:00   HST
   French Polynesia     Pacific/Tahiti         -10:00   TAHT
   Cook Island          Pacific/Rarotonga      -10:00   CK*T
   Aleutian Islands     America/Adak           -10:00   HA*T
   French Polynesia     Pacific/Marquesas       -9:30   MART
   French Polynesia     Pacific/Gambier         -9:00   GAMT
   Pitcairn             Pacific/Pitcairn        -8:00   PST

North America
   Alaska               America/Anchorage       -9:00   AK*T
   Pacific w/ DST       America/Los_Angeles     -8:00   P*T
   Mountain Standard    MST                     -7:00   MST
   Mountain w/ DST      America/Denver          -7:00   M*T
   Central Standard     SystemV/CST6            -6:00   CST
   Central w/ DST       America/Chicago         -6:00   C*T
   Eastern Standard     EST                     -5:00   EST
   Eastern w/ DST       America/New_York        -5:00   E*T
   Cuba                 America/Havana          -5:00   C*T
   Atlantic Standard    SystemV/AST4            -4:00   AST
   Atlantic w/ DST      America/Halifax         -4:00   A*T
   Newfoundland         America/St_Johns        -3:30   N*T
   St. Pierre / Miquelon  America/Miquelon        -3:00   PM*T
   West Greenland       America/Godthab         -3:00   WG*T
   Scoresbysund         America/Scoresbysund    -1:00   EG*T
   NE Greenland         America/Danmarkshavn    0:00    GMT

South America
   Easter Island        Pacific/Easter          -6:00   EAS*T
   Ecuador / Galapagos  Pacific/Galapagos       -6:00   GALT
   Ecuador              America/Guayaquil       -5:00   ECT
   Colombia             America/Bogota          -5:00   CO*T
   Peru                 America/Lima            -5:00   PE*T
   Chile                America/Santiago        -4:00   CL*T
   Falklands            Atlantic/Stanley        -4:00   FK*T
   Paraguay             America/Asuncion        -4:00   PY*T
   Venezuela            America/Caracas         -4:00   VET
   Argentina            America/Buenos_Aires    -3:00   ART
   Uruguay              America/Montevideo      -3:00   UY*T
   South Georgia        Atlantic/South_Georgia  -2:00   GST

   Brazil / W Amazonas  America/Eirunepe        -5:00   ACT
   Brazil / W Para      America/Porto_Velho     -4:00   AMT
   Brazil / Mato Grosso America/Cuiaba          -4:00   AM*T
   Brazil               America/Sao_Paulo       -3:00   BR*T
   Brazil / E Para      America/Belem           -3:00   BRT
   Brazil / Atlantic    America/Noronha         -2:00   FNT

Europe
   Portugal             Atlantic/Azores         -1:00   AZO*T
   Universal Time       GMT                      0:00   GMT
   United Kingdom       Europe/London            0:00   GMT/BST
   Central Europe       Europe/Rome              1:00   CE*T
   Lithuania            Europe/Vilnius           2:00   EET
   Eastern Europe       Europe/Istanbul          2:00   EE*T

Africa
   Cape Verde           Atlantic/Cape_Verde     -1:00   CVT
   Canary Island        Atlantic/Canary          0:00   WE*T
   Tunisia              Africa/Tunis             1:00   CE*T
   Namibia              Africa/Windhoek          1:00   WA*T
   Western Africa       Africa/Lagos             1:00   WAT
   South Africa         Africa/Johannesburg      2:00   SAST
   Central Africa       Africa/Harare            2:00   CAT
   Eastern Africa       Africa/Nairobi           3:00   EAT
   Egypt                Africa/Cairo             2:00   EE*T

Middle East
   Israel               Asia/Jerusalem           2:00   I*T
   Syria                Asia/Damascus            2:00   EE*T
   Iran                 Asia/Tehran              3:30   IR*T
   Iraq                 Asia/Baghdad             3:00   A*T
   Saudi Arabia         Asia/Riyadh              3:00   AST
   Oman                 Asia/Muscat              4:00   GST

Asia
   Afghanistan          Asia/Kabul               4:30   AFT
   Pakistan             Asia/Karachi             5:00   PK*T
   Uzbekistan           Asia/Tashkent            5:00   UZT
   India                Asia/Calcutta            5:30   IST
   Nepal                Asia/Katmandu            5:45   NPT
   Bangladesh           Asia/Dhaka               6:00   BDT
   Burma                Asia/Rangoon             6:30   MMT
   Vietnam              Asia/Saigon              7:00   ICT
   Western Indonesia    Asia/Jakarta             7:00   WIT
   Central Indonesia    Asia/Makassar            8:00   CIT
   Eastern Indonesia    Asia/Jayapura            9:00   EIT
   Philippines          Asia/Manila              8:00   PH*T
   China                Asia/Shanghai            8:00   C*T
   Hong Kong/Xianggang  Asia/Hong_Kong           8:00   HK*T
   Japan                Asia/Tokyo               9:00   JST
   Korea                Asia/Seoul               9:00   KST

Russia
   Russia               Europe/Minsk             2:00   EE*T
   Russia               Europe/Moscow            3:00   MSK/MSD
   Russia               Europe/Samara            4:00   SAM*T
   Russia               Asia/Yekaterinburg       5:00   YEK*T
   Russia               Asia/Omsk                6:00   OMS*T
   Russia               Asia/Novosibirsk         6:00   NOV*T
   Russia               Asia/Krasnoyarsk         7:00   KRA*T
   Russia               Asia/Irkutsk             8:00   IRK*T
   Russia               Asia/Yakutsk             9:00   YAK*T
   Russia               Asia/Vladivostok        10:00   VLA*T
   Russia               Asia/Sakhalin           10:00   SAK*T
   Russia               Asia/Magadan            11:00   MAG*T
   Russia               Asia/Kamchatka          12:00   PET*T
   Russia               Asia/Anadyr             12:00   ANA*T

Australia / Pacific
   Western Australia    Australia/Perth          8:00   WST
   Northern Australia   Australia/Darwin         9:30   CST
   Southern Australia   Australia/Adelaide       9:30   C*T
   Eastern Australia    Australia/Brisbane      10:00   EST
   S.E. Australia       Australia/Sydney        10:00   E*T
   Tasmania             Australia/Hobart        10:00   E*T
   Lord Howe Island     Australia/Lord_Howe     10:30   LH*T

   Guam                 Pacific/Guam            10:00   ChST
   Solomon Is           Pacific/Guadalcanal     11:00   SBT
   Norfolk              Pacific/Norfolk         11:30   NFT
   Fiji                 Pacific/Fiji            12:00   FJT
   New Zealand          Pacific/Auckland        12:00   NZ*T
   New Z./Chatham Is    Pacific/Chatham         12:45   CHA*T
   Kiribati / Gilbert   Pacific/Tarawa          12:00   GILT
   Kiribati / Phoenix   Pacific/Enderbury       13:00   PHOT
   Kiribati / Line Is   Pacific/Kiritimati      14:00   LINT
END
) {
   if(  $line !~ /\S/  ) {
      $html .= qq[&lt;tr&gt;&lt;td colspan="4"&gt;&amp;nbsp;&lt;/td&gt;&lt;/tr&gt;\n];
   } elsif(  $line =~ /^\S/  ) {
      $html .= "&lt;/table&gt;"   if  @anchors;
      push @anchors, $line;
      my( $name )= split ' ', $line;
      $html .= qq[&lt;h3&gt;&lt;a name="$name"&gt;$line&lt;/a&gt;&lt;/h3&gt;\n]
         . qq[&lt;table width="100%"&gt;\n];
   } else {
      my @w= split ' ', $line;
      my $abbr= pop @w;
      my $off= pop @w;
      my $zone= pop @w;
      my $desc= "@w";
      $html .= qq[&lt;tr&gt;&lt;td&gt;$desc&lt;/td&gt;
         &lt;td&gt;] . linkNode( $NODE, $zone, { settimezone=&gt;$zone } ) . qq[&lt;/td&gt;
         &lt;td&gt;$abbr&lt;/td&gt;
         &lt;td&gt;] . htmlcode( 'parseTimeInString','', '', $zone ) . qq[&lt;/td&gt;
         &lt;/tr&gt;\n];
   }
}
$html .= qq[&lt;/table&gt;\n];

my $head= join " | ", map {
   my( $name )= split ' ', $_;
   s/ /&amp;nbsp;/g;
   qq[&lt;a href="#$name"&gt;$_&lt;/a&gt;];
} @anchors;

return join $/,
   $head,
   '&lt;p&gt;',
   '&lt;h2&gt;Click on a timezone below to start using it.&lt;/h2&gt;',
   '&lt;/p&gt;',
   $html,
   htmlcode('timezonechooser');
%]
</live_code>
<reason>fix spelling</reason>
<field>doctext</field>
</record>
<record><htmlcode_id>775725</htmlcode_id>
<patch_code>/* This CSS controls the Blue Web-Safe theme. */

body {
  color:            #000;
  background-color: #FFF;
}
td { color: #000; }
tr.titlebar { background-color: #006; }
tr.section_title {
  color:            #FFF;
  background-color: #006;
}
td.section_title {
  color:            #FFF;
  background-color: #006;
}
tr.post_head, tr.ntc-head { background-color: #CCC; }
.highlight { background-color: #CCC; }
td.titlebar { color: #FFF; }
table.nodelet_container { background-color: #006; }
a:link    { color: #006  }
a:visited { color: #339 }
a.titlebar:link, a.titlebar:visited { color:  #FFF; }
tbody.nodelet td, td.nodebody { background-color: #FFF; }
tbody.nodelet th, th.nodehead {
  color:             #FFF;
  background-color:  #006;
}
tbody.nodelet th a:link, tbody.nodelet th a:visited { color: #FFF; }
.chatsubmit {
	color: #FFF;
	border-width: 0;
	font-size: large;
	font-family: Times,serif;
	background-color: #006; 
}
.comment-on { background-color: #006; }
</patch_code>
<applied>2009-06-29 12:40:12</applied>
<htmlcode_id>204962</htmlcode_id>
<live_code>/* This CSS controls the Blue Web-Safe theme. */

body {
  color:            #000;
  background-color: #FFF;
}
td { color: #000; }
tr.titlebar, h2.titlebar,
tr.titlebar td,
tr.section_title {
  color:            #FFF;
  background-color: #006;
}
td.section_title {
  color:            #FFF;
  background-color: #006;
}
tr.post_head, tr.ntc-head { background-color: #CCC; }
.highlight { background-color: #CCC; }
td.titlebar { color: #FFF; }
table.nodelet_container { background-color: #006; }
a:link    { color: #006  }
a:visited { color: #339 }
a.titlebar:link, a.titlebar:visited { color:  #FFF; }
tbody.nodelet td, td.nodebody { background-color: #FFF; }
tbody.nodelet th, th.nodehead {
  color:             #FFF;
  background-color:  #006;
}
tbody.nodelet th a:link, tbody.nodelet th a:visited { color: #FFF; }
.chatsubmit {
	color: #FFF;
	border-width: 0;
	font-size: large;
	font-family: Times,serif;
	background-color: #006; 
}
.comment-on { background-color: #006; }
table#replies_table { background-color: #006; }
</live_code>
<reason>replace 'highlight' in ntc</reason>
<field>doctext</field>
</record>
<record><htmlcode_id>752269</htmlcode_id>
<patch_code>[%
  unless ($q-&gt;param('oldcache')) {
    return htmlcode('get_cached_xml_chatter','new');
  }
  htmlcode('log_ticker','','new-oldcache') or
    Everything::printLog( "CB - new - oldcache - " .
       "$USER-&gt;{title} ($ENV{REMOTE_ADDR}) - $ENV{'HTTP_USER_AGENT'}" );

  my $code_id= $$NODE{node_id};
  use vars qw( %cachehits );
  $cachehits{$code_id}++;
  my $hd = getHttpHeader("text/xml");
  my $updateInterval = 9;
  my $dbh = $DB-&gt;getDatabaseHandle();
  my $geth= $dbh-&gt;prepare_cached(
      "select updateinterval,cachekey,cachedata"
      ." from cachedinfo where code_id=? and"
      ." lastupdate between subdate(now(),interval ? second) and now()"
      ." order by cachekey" );
  $geth-&gt;execute( $code_id, $updateInterval );
  my $CACHE= $geth-&gt;fetchrow_hashref();
  if(   $CACHE  and  "" eq $$CACHE{cachekey}  ) {
    $geth-&gt;finish();
    return $hd . $$CACHE{cachedata};
  }

  use vars qw( $hostname );
  chomp( $hostname= `hostname` )   if  ! defined $hostname;
  my $mykey= "$$/$hostname";
  Everything::printLog( "node=$code_id; me=$mykey
hits=$cachehits{$code_id}"
    ." waitfor=".($CACHE?$$CACHE{cachekey}:"")." user=$$USER{title}" );
  $cachehits{$code_id}= 0;
  {
    my $NEXT= $CACHE;
    while(  $NEXT  &amp;&amp;  "" eq $$NEXT{cachekey}  ) {
      $NEXT= $geth-&gt;fetchrow_hashref();
    }
    $geth-&gt;finish();
    if(  $NEXT  &amp;&amp;  "" ne $$NEXT{cachekey}  ) {
      select(undef,undef,undef,2.0);
      $geth-&gt;execute( $code_id, $updateInterval );
      $CACHE= $geth-&gt;fetchrow_hashref();
      $geth-&gt;finish();
      return $hd . $$CACHE{cachedata}
        if  $CACHE  and  "" eq $$CACHE{cachekey};
      Everything::printLog( "node=$code_id; me=$mykey"
        ." waitedfor=$$NEXT{cachekey} user=$$USER{title}" );
    }
    $CACHE= $NEXT;
  }

  my $insertTime= time();
  $dbh-&gt;do( "insert into cachedinfo "
    ."(code_id,cachedata,updateinterval,lastupdate,cachekey) "
    ."values (?,?,?,now(),?)", undef,
    $code_id, "", $updateInterval, $mykey );
  my $data;
  {
    my $sth= $DB-&gt;sqlSelectMany(
      'message_id,msgtext as text,author_user as user_id,'   .
      'UNIX_TIMESTAMP(tstamp) as epoch,' .
      q&lt;DATE_FORMAT(tstamp, '%Y-%m-%d') as date,&gt; .
      q&lt;DATE_FORMAT(tstamp, '%T') as time&gt;,
      "message", "(for_user = 0) AND"
      ." (UNIX_TIMESTAMP(NOW()) - UNIX_TIMESTAMP(tstamp) &lt; 600)",
      "ORDER BY message_id DESC LIMIT 10"
    );
    my @msg;
    unshift @msg, $_ while $_ = $sth-&gt;fetchrow_hashref;
    require XML::Fling;
    my @data;
    my $xml= XML::Fling-&gt;new( \@data );
    $xml-&gt;header("Windows-1252");
    push @data, "\n";
    $xml-&gt;start('chatter');
    push @data, "\n";

    $xml-&gt;element(
      'info',
      site     =&gt; $HTMLVARS{site_url},
      sitename =&gt; $HTMLVARS{site_name},
      'Rendered by the New Chatterbox XML Ticker'
    );
    push @data, "\n";
    for my $msg (@msg) {
      $msg-&gt;{author} = getNodeById( $msg-&gt;{user_id} )-&gt;{title};
      $xml-&gt;start('message');
      push @data, "\n";
      for( @{$msg}{qw. author text .} ){
        tr/\x00-\x1f//d;
        tr/\x7F//d;
        s/&amp;/&amp;amp;/g;
        s/&lt;/&amp;lt;/g;
        s/&gt;/&amp;gt;/g;
      }
      for( qw. author user_id date time epoch message_id text. ) {
        $xml-&gt;start($_);
        push @data, $msg-&gt;{$_};
        $xml-&gt;end();
        push @data, "\n";
      }
      $xml-&gt;end();
      push @data, "\n";
    }
    $xml-&gt;end();
    $data = join '', @data;
  }

  my $sth= $dbh-&gt;prepare(
      "select cachekey,lastupdate"
      ." from cachedinfo where code_id=? and cachekey &lt;&gt; '' and"
      ." lastupdate between subdate(now(),interval ? second) and now()"
      ." order by lastupdate,cachekey" );
  $sth-&gt;execute( $code_id, $updateInterval + time() - $insertTime );
  my $WINNER= $sth-&gt;fetchrow_hashref();

  if(  ! $WINNER  ||  $mykey ne $$WINNER{cachekey}  ) {
    $dbh-&gt;do(
      'delete from cachedinfo where code_id=? and cachekey=?',
      undef,
      $code_id,
      $mykey
    );
    Everything::printLog(
      "node=$code_id; me=$mykey winner="
      .($WINNER?$$WINNER{cachekey}:"(none)")." user=$$USER{title}" );
    return $hd . $data;
  }

  my $updates= $dbh-&gt;do( "update cachedinfo set"
    ." lastupdate=now(), cachedata=?, updateinterval=?, cachekey=''"
    ." where code_id=? and cachekey=?", undef,
    $data, $updateInterval, $code_id, $mykey );
  my $deletes= "-";
  if(  0 &lt; $updates  ) {
    $deletes= $dbh-&gt;do( "delete from cachedinfo where code_id=? and ("
      ." cachekey &lt;&gt; '' or lastupdate not between"
      ." subdate( now(), interval ? second ) and now() )", undef,
      $code_id, $updateInterval );
  }
  Everything::printLog( "node=$code_id; me=$mykey updated=$updates"
    ." deleted=$deletes user=$$USER{title}" );
  $hd . $data;
%]</patch_code>
<applied>2009-03-21 13:35:33</applied>
<htmlcode_id>207304</htmlcode_id>
<live_code>[%
  unless ($q-&gt;param('oldcache')) {
    return htmlcode('get_cached_xml_chatter','new');
  }
  htmlcode('log_ticker','','new-oldcache') or
    Everything::printLog( "CB - new - oldcache - " .
       "$USER-&gt;{title} ($ENV{REMOTE_ADDR}) - $ENV{'HTTP_USER_AGENT'}" );

  my $code_id= $$NODE{node_id};
  use vars qw( %cachehits );
  $cachehits{$code_id}++;
  my $hd = getHttpHeader("text/xml");
  my $updateInterval = 9;
  my $dbh = $DB-&gt;getDatabaseHandle();
  my $geth= $dbh-&gt;prepare_cached(
      "select updateinterval,cachekey,cachedata"
      ." from cachedinfo where code_id=? and"
      ." lastupdate between subdate(now(),interval ? second) and now()"
      ." order by cachekey" );
  $geth-&gt;execute( $code_id, $updateInterval );
  my $CACHE= $geth-&gt;fetchrow_hashref();
  if(   $CACHE  and  "" eq $$CACHE{cachekey}  ) {
    $geth-&gt;finish();
    return $hd . $$CACHE{cachedata};
  }

  use vars qw( $hostname );
  chomp( $hostname= `hostname` )   if  ! defined $hostname;
  my $mykey= "$$/$hostname";
  Everything::printLog( "node=$code_id; me=$mykey
hits=$cachehits{$code_id}"
    ." waitfor=".($CACHE?$$CACHE{cachekey}:"")." user=$$USER{title}" );
  $cachehits{$code_id}= 0;
  {
    my $NEXT= $CACHE;
    while(  $NEXT  &amp;&amp;  "" eq $$NEXT{cachekey}  ) {
      $NEXT= $geth-&gt;fetchrow_hashref();
    }
    $geth-&gt;finish();
    if(  $NEXT  &amp;&amp;  "" ne $$NEXT{cachekey}  ) {
      select(undef,undef,undef,2.0);
      $geth-&gt;execute( $code_id, $updateInterval );
      $CACHE= $geth-&gt;fetchrow_hashref();
      $geth-&gt;finish();
      return $hd . $$CACHE{cachedata}
        if  $CACHE  and  "" eq $$CACHE{cachekey};
      Everything::printLog( "node=$code_id; me=$mykey"
        ." waitedfor=$$NEXT{cachekey} user=$$USER{title}" );
    }
    $CACHE= $NEXT;
  }

  my $insertTime= time();
  $dbh-&gt;do( "insert into cachedinfo "
    ."(code_id,cachedata,updateinterval,lastupdate,cachekey) "
    ."values (?,?,?,now(),?)", undef,
    $code_id, "", $updateInterval, $mykey );
  my $data;
  {
    my $sth= $DB-&gt;sqlSelectMany(
      'message_id,msgtext as text,author_user as user_id,'   .
      'UNIX_TIMESTAMP(tstamp) as epoch,' .
      q&lt;DATE_FORMAT(tstamp, '%Y-%m-%d') as date,&gt; .
      q&lt;DATE_FORMAT(tstamp, '%T') as time&gt;,
      "message", "(for_user = 0) AND"
      ." (UNIX_TIMESTAMP(NOW()) - UNIX_TIMESTAMP(tstamp) &lt; 600)",
      "ORDER BY message_id DESC LIMIT 10"
    );
    my @msg;
    unshift @msg, $_ while $_ = $sth-&gt;fetchrow_hashref;
    require XML::Fling;
    my @data;
    my $xml= XML::Fling-&gt;new( \@data );
    $xml-&gt;header("Windows-1252");
    push @data, "\n";
    $xml-&gt;start('chatter');
    push @data, "\n";

    $xml-&gt;element(
      'info',
      site     =&gt; $HTMLVARS{site_url},
      sitename =&gt; $HTMLVARS{site_name},
      'Rendered by the New Chatterbox XML Ticker'
    );
    push @data, "\n";
    for my $msg (@msg) {
      $msg-&gt;{author} = getNodeById( $msg-&gt;{user_id} )-&gt;{title};
      $xml-&gt;start('message');
      push @data, "\n";
      for( @{$msg}{qw. author text .} ){
        s/&amp;/&amp;amp;/g;
        s/&lt;/&amp;lt;/g;
        s/&gt;/&amp;gt;/g;
      }
      for( qw. author user_id date time epoch message_id text. ) {
        $xml-&gt;start($_);
        push @data, $msg-&gt;{$_};
        $xml-&gt;end();
        push @data, "\n";
      }
      $xml-&gt;end();
      push @data, "\n";
    }
    $xml-&gt;end();
    $data = join '', @data;
    htmlcode('postProcessXML','',\$data);
  }

  my $sth= $dbh-&gt;prepare(
      "select cachekey,lastupdate"
      ." from cachedinfo where code_id=? and cachekey &lt;&gt; '' and"
      ." lastupdate between subdate(now(),interval ? second) and now()"
      ." order by lastupdate,cachekey" );
  $sth-&gt;execute( $code_id, $updateInterval + time() - $insertTime );
  my $WINNER= $sth-&gt;fetchrow_hashref();

  if(  ! $WINNER  ||  $mykey ne $$WINNER{cachekey}  ) {
    $dbh-&gt;do(
      'delete from cachedinfo where code_id=? and cachekey=?',
      undef,
      $code_id,
      $mykey
    );
    Everything::printLog(
      "node=$code_id; me=$mykey winner="
      .($WINNER?$$WINNER{cachekey}:"(none)")." user=$$USER{title}" );
    return $hd . $data;
  }

  my $updates= $dbh-&gt;do( "update cachedinfo set"
    ." lastupdate=now(), cachedata=?, updateinterval=?, cachekey=''"
    ." where code_id=? and cachekey=?", undef,
    $data, $updateInterval, $code_id, $mykey );
  my $deletes= "-";
  if(  0 &lt; $updates  ) {
    $deletes= $dbh-&gt;do( "delete from cachedinfo where code_id=? and ("
      ." cachekey &lt;&gt; '' or lastupdate not between"
      ." subdate( now(), interval ? second ) and now() )", undef,
      $code_id, $updateInterval );
  }
  Everything::printLog( "node=$code_id; me=$mykey updated=$updates"
    ." deleted=$deletes user=$$USER{title}" );
  $hd . $data;
%]</live_code>
<reason>Capitalize correctly</reason>
<field>doctext</field>
</record>
<record><htmlcode_id>775724</htmlcode_id>
<patch_code>/* This CSS controls the Dark theme. */

.reply-new-body, .reply-body,
body {
  color: #CCC;
  background-color: #000;
}
td { color: #CCC; }
tr.titlebar { background-color: #666; }
tr.section_title {
  color:            #000;
  background-color: #CCC;
}
td.section_title {
  color:            #000;
  background-color: #CCC;
}
tr.post_head, tr.ntc-head { background-color: #666; }
.highlight { background-color: #333; }
td.titlebar  { color: #FFF; }
table.nodelet_container { background-color: #666; }
tbody.nodelet td { background-color: #333; }
a:link    { color: #CFF  }
a:visited { color: #FFC }
a.titlebar:link, a.titlebar:visited { color: #FFF; }

tbody.nodelet td, td.nodebody { background-color: #333; }
tbody.nodelet th, th.nodehead {
  color:             black;
  background-color:  #CCC;
}



tbody.nodelet th a:link, tbody.nodelet th a:visited { color: #555; }

.spoiler {
  color: #FFF;
  background-color: #FFF;
}

div.readmore {background-color: #222;}
.chatsubmit { background-color: #666; }
.comment-on { background-color: #666; }
</patch_code>
<applied>2009-06-29 12:40:14</applied>
<htmlcode_id>227261</htmlcode_id>
<live_code>/* This CSS controls the Dark theme. */

.reply-new-body, .reply-body,
body {
  color: #CCC;
  background-color: #000;
}
td { color: #CCC; }
tr.titlebar, h2.titlebar { background-color: #666; }
tr.section_title {
  color:            #000;
  background-color: #CCC;
}
td.section_title {
  color:            #000;
  background-color: #CCC;
}
tr.post_head, tr.ntc-head { background-color: #666; }
.highlight { background-color: #333; }
td.titlebar  { color: #FFF; }
table.nodelet_container { background-color: #666; }
tbody.nodelet td { background-color: #333; }
a:link    { color: #CFF  }
a:visited { color: #FFC }
a.titlebar:link, a.titlebar:visited { color: #FFF; }

tbody.nodelet td, td.nodebody { background-color: #333; }
tbody.nodelet th, th.nodehead {
  color:             black;
  background-color:  #CCC;
}



tbody.nodelet th a:link, tbody.nodelet th a:visited { color: #555; }

.spoiler {
  color: #FFF;
  background-color: #FFF;
}

div.readmore {background-color: #222;}
.chatsubmit { background-color: #666; }
.comment-on { background-color: #666; }
table#replies_table { background-color: #666; }
</live_code>
<reason>replace 'highlight' in ntc</reason>
<field>doctext</field>
</record>
<record><htmlcode_id>722689</htmlcode_id>
<patch_code>/* This CSS controls presentation details common to all six original themes. */

/* This CSS has been moved to a regular file on the server(s), for
   performance reasons. If it needs to be altered, chat with a god.
   If it doesn't, chat with a god anyway. Gods are people, too. */

.reply-new-body, .reply-body,
body {
  color: #000;
  background-color: #FFF;
}

h3.superdoc {
   font-size:  28px;
  font-family: "Old English Text MT", linotext, rudelsburg, goodcitymodern, 
               arnoldboecklin, agate, lucidabright, becker, Palatino,
               "Palatino Linotype", Harrington, serif;
}
span.attribution, span.addlinks { font-size: smaller; }
.attribution-title { display: none; }

input.titlebar {
  background-color: inherit; 
  color: inherit; 
  font-size: inherit; 
  font-family: inherit; 
  font-weight: inherit;
  border-width:     0;
}
tr.titlebar {
  height:           55px;
  font-size:        24px;
  font-weight:      bold;
  font-family:      lucidabright, agate, goudyoldstyle, goodcitymodern, linotext, 
                    rudelsberg, becker, arnoldboecklin, caligula, serif;
}
a.titlebar:link, a.titlebar:visited {
  text-decoration: none;
}
tbody.nodelet td { font-size: 12px; }
tbody.nodelet th { font-weight: bold; }
tbody.nodelet th a { text-decoration: none; }
form { display: inline }
span.title    { float: left  }
span.controls { float: right }
div.notetext { font-size: small }
font.htmlignored { text-decoration: line-through; }

div.showcontainer { border: 1px solid #0f0 }
div.containername { background-color: #afa; border-bottom: 1px solid #0f0 }
p.nnt-p { display: inline; }
p.nnt-p-title { /* width: 70%; */   }
p.nnt-author  { /* width: 28%; */ }
tr.this-patch td { font-weight: bold; }
tr.other-patch td { font-style: italic; }
a.nnt-Steaming, 
a.nnt-Hot, 
a.nnt-Fresh
{ font-weight: bold; }

.nnt-noderep,
.nnt-nodeattribs,
.time-text { font-size: smaller; }

#nodethreads {
  padding-right: 1em;
  white-space:normal;
}
#nodethreads ul {
  list-style: none;

  margin-left: 0;
  padding-left: 1em;
  text-indent: 0em;
  white-space:normal;
}

#nodethreads li {width: 100%;}

#nodethreads ul.expanded {
  display: block;
}

#nodethreads ul.collapsed {
  display: none;
}

.spoiler {
  color: black;
  background-color: #000000;
}

.faqlist-itemtype { font-size: smaller; }
.faqlist-faqlist { font-weight: bold; }
.faqlist-faqseen { font-style: italic; }
.faqlist-thislist { font-size: smaller; }


div.readmore {background-color: #eee;}

.embed-code-dl { 
  text-align: left;   
  display: block; 
  padding: 0px; 
  margin: 0px;
}
.embed-code-dl a { font-size: smaller; }
span.see_also { font-size:smaller; font-style:italic; }
span.see_also a { font-size: smaller; }
.chatsubmit {
	background-color: #777;
	color: #FFF;
	border-width: 0;
	font-size: large;
	font-family: Times,serif;
}
.paneled { border-style: groove; padding: 1em; }

.mailhead { background-color: #CCCCCC; }

div#footer { font-size: smaller; text-align: center; }

/* used in Everything/HTML.pm sub htmlScreen */
font.htmlattrib,
font.htmlignored,
font.htmlinserted { color: #808080; }

.add-text, .add-title { font-weight: bold; font-size: larger; }

td.settings_key { background-color: #ccccff; color: #000000 }
td.settings_val { background-color: #dedeff; color: #000000 }

tr.titlebar,
.comment-on, .comment-on u { color: #FFF; }
.comment-on { background-color: #777; }
</patch_code>
<applied>2008-11-12 12:07:46</applied>
<htmlcode_id>234493</htmlcode_id>
<live_code>/* This CSS controls presentation details common to all six original themes. */

/* This CSS has been moved to a regular file on the server(s), for
   performance reasons. If it needs to be altered, chat with a god.
   If it doesn't, chat with a god anyway. Gods are people, too. */

.reply-new-body, .reply-body,
body {
  color: #000;
  background-color: #FFF;
}

h3.superdoc {
   font-size:  28px;
  font-family: "Old English Text MT", linotext, rudelsburg, goodcitymodern, 
               arnoldboecklin, agate, lucidabright, becker, Palatino,
               "Palatino Linotype", Harrington, serif;
}
span.attribution, span.addlinks { font-size: smaller; }
.attribution-title { display: none; }

input.titlebar {
  background-color: inherit; 
  color: inherit; 
  font-size: inherit; 
  font-family: inherit; 
  font-weight: inherit;
  border-width:     0;
}
h2.titlebar,
tr.titlebar {
  height:           55px;
  font-size:        24px;
  font-weight:      bold;
  font-family:      lucidabright, agate, goudyoldstyle, goodcitymodern, linotext, 
                    rudelsberg, becker, arnoldboecklin, caligula, serif;
}
a.titlebar:link, a.titlebar:visited {
  text-decoration: none;
}
tbody.nodelet td { font-size: 12px; }
tbody.nodelet th { font-weight: bold; }
tbody.nodelet th a { text-decoration: none; }
form { display: inline }
span.title    { float: left  }
span.controls { float: right }
/* div.notetext { font-size: small } */
div.reputation { font-size: smaller }
font.htmlignored { text-decoration: line-through; }

div.showcontainer { border: 1px solid #0f0 }
div.containername { background-color: #afa; border-bottom: 1px solid #0f0 }
p.nnt-p { display: inline; }
p.nnt-p-title { /* width: 70%; */   }
p.nnt-author  { /* width: 28%; */ }
tr.this-patch td { font-weight: bold; }
tr.other-patch td { font-style: italic; }
a.nnt-Steaming, 
a.nnt-Hot, 
a.nnt-Fresh
{ font-weight: bold; }

.nnt-noderep,
.nnt-nodeattribs,
.time-text { font-size: smaller; }

li.inline,
.inline-list li { display: inline; margin-left: 3pt; }
li.inline:before,
.inline-list li:before { content:" |\A0" }
ul.word-list,
ul.inline-list { display: inline; margin: 0; padding: 0; list-style: none; }
.word-list li { display: inline; }
.word-list li:before { content:" " }

ul.spacey-list { margin: 0; padding: 0; list-style: none; }

#nodethreads {
  padding-right: 1em;
  white-space:normal;
}
#nodethreads ul {
  list-style: none;

  margin-left: 0;
  padding-left: 1em;
  text-indent: 0em;
  white-space:normal;
}

#nodethreads li {width: 100%;}

#nodethreads ul.expanded {
  display: block;
}

#nodethreads ul.collapsed {
  display: none;
}

.spoiler {
  color: black;
  background-color: #000000;
}

.faqlist-itemtype { font-size: smaller; }
.faqlist-faqlist { font-weight: bold; }
.faqlist-faqseen { font-style: italic; }
.faqlist-thislist { font-size: smaller; }


pre { white-space: pre-wrap; }
div.readmore {background-color: #eee;}

.embed-code-dl { 
  text-align: left;   
  display: block; 
  padding: 0px; 
  margin: 0px;
}
.embed-code-dl a { font-size: smaller; }
span.see_also { font-size:smaller; font-style:italic; }
span.see_also a { font-size: smaller; }
.chatsubmit {
	background-color: #777;
	color: #FFF;
	border-width: 0;
	font-size: large;
	font-family: Times,serif;
}
.paneled { border-style: groove; padding: 1em; }

.mailhead { background-color: #CCCCCC; }

div#footer { font-size: smaller; text-align: center; }

/* used in Everything/HTML.pm sub htmlScreen */
font.htmlattrib,
font.htmlignored,
font.htmlinserted { color: #808080; }

.add-text, .add-title { font-weight: bold; font-size: larger; }

td.settings_key { background-color: #ccccff; color: #000000 }
td.settings_val { background-color: #dedeff; color: #000000 }

h2.titlebar,
tr.titlebar,
.comment-on, .comment-on u { color: #FFF; }
.comment-on { background-color: #777; }

td.adjunct-links { font-size: smaller }
td.monkquip,
span.topnavmenu { font-size: smaller }
div.link-back { text-align: center; }
a.nodelethead-annot { display:none; }

.pmsig { border-top: 1px solid gray; }
.pmsig &gt; div:first-child &gt; hr:first-child { display: none; }

span.inboxupdate,
span.rjeupdate,
span.wikiupdate
{ font-weight: bold }
</live_code>
<reason>add common body fg/bg colors</reason>
<field>doctext</field>
</record>
<record><htmlcode_id>595944</htmlcode_id>
<patch_code>&lt;p align="right"&gt;&lt;a href="/?node_id=17642#personal_nodelet"&gt;Help for this page&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;[{see_also:Settings Nodes;faqlist}]&lt;/p&gt;
&lt;hr /&gt;
[{openform}]
[{personalnodelethandler:show_form,1}]
[{closeform}]</patch_code>
<applied>2007-01-22 12:23:56</applied>
<htmlcode_id>366609</htmlcode_id>
<live_code>&lt;p align="right"&gt;&lt;a href="?node_id=786931"&gt;Help for this page&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;[{see_also:Settings Nodes;faqlist}]&lt;/p&gt;
&lt;hr /&gt;
[{openform}]
[{personalnodelethandler:show_form,1}]
[{closeform}]</live_code>
<reason>right-align the help link</reason>
<field>doctext</field>
</record>
<record><htmlcode_id>583634</htmlcode_id>
<patch_code>[{get_sitedoclet}]
[{votehead}]
[{newlistapproved:pmdevtopic,perlquestion approved linktype,Inner Scriptorium,10,navbaron,showall}]
[{votefoot}]
[{addnewform:pmdevtopic,Start a new manuscript,New Manuscript,,cabal}]
[{showhints:cabal}]
</patch_code>
<applied>2006-11-13 00:49:04</applied>
<htmlcode_id>389873</htmlcode_id>
<live_code>[{get_sitedoclet}]
[{votehead}]
[{newlistapproved:pmdevtopic,perlquestion approved linktype,Inner Scriptorium,10,navbaron,showall}]
[{votefoot}]
[{addnewform:pmdevtopic,Start a new manuscript,New Manuscript,,cabal}]
</live_code>
<reason>link to sitedoclet</reason>
<field>doctext</field>
</record>
<record><htmlcode_id>775723</htmlcode_id>
<patch_code>/* This CSS controls the Blue Web-Safe theme. */

body {
  color:            #000;
  background-color: #FFF;
}
td { color: #000; }
tr.titlebar { background-color: #006; }
tr.section_title {
  color:            #FFF;
  background-color: #005;
}
td.section_title {
  color:            #FFF;
  background-color: #005;
}
tr.post_head, tr.ntc-head, .highlight { background-color: #CCC; }
td.titlebar { color: #FFF; }
table.nodelet_container { background-color: #006; }
a:link    { color: #006  }
a:visited { color: #339 }
a.titlebar:link, a.titlebar:visited { color:  #FFF; }
tbody.nodelet td, td.nodebody { background-color: #FFF; }
tbody.nodelet th, th.nodehead {
  color:             #FFF;
  background-color:  #006;
}
tbody.nodelet th a:link, tbody.nodelet th a:visited { color: #FFF; }

/* Perl-blue theme CSS */
 body {
	color: #000;
	background-color: #eee;
	font-size: smaller;
	font-family: "Bitstream Vera Sans", Verdana, Arial, Lucida, Helvetica, sans-serif;
}
td, th {
	color: #000;
	font-size: smaller;
	font-family: "Bitstream Vera Sans", Verdana, Arial, Lucida, Helvetica, sans-serif;
}
a:link {
	color: #036;
}
a:visited {
	color: #06c;
}
h3.other, h3.superdoc, h3.categorized_answer, h3.categorized_question {
	font-size: 42px;
	font-style: italic;
	font-family: Georgia, serif;
	padding: 10px;
}
pre, tt {
	font-family: "Bitstream Vera Sans Mono", monospace;
}
tt {
	font-size: 14px;
}
textarea {
	height: 25em;
}
input, select {
	margin: 3px;
	font-size: 9pt;
	font-family: "Bitstream Vera Sans", Verdana, Arial, Lucida, Helvetica, sans-serif;
}
table[bgcolor="#000066"] {
	border: solid 1px black;
	background-color: #069;
}
.code {
	display: block;
	border: 1px solid #666;
	color: #000;
	padding: 1em;
}
td.section_title {
	color: #fff;
	background-color: #069;
	font-size: 26px;
	font-family: Georgia, serif;
	font-weight: bold;
}
tr.titlebar, td.titlebar, table.titlebar {
	background-color: #069;
	font-size: 26px;
	font-family: Georgia, serif;
}
table.nodelet_container {
	background-color: #069;
}
tbody.nodelet th, th.nodehead {
	color: #fff;
	background-color: #069;
	padding-right: 0.5em;
	text-align: right;
}
tbody.nodelet td, td.nodebody {
	background-color: #eee;
}
#approval_nodelet input[type="text"] {
	background: #fcc;
}
textarea[name="note_doctext"], input[name="note_title"] {
	font-family: monospace;
	width: 80%;
}
.spacer[height~="75"], a[href="http://pair.com"] {
	display: none;
}
div.readmore {background-color: #fff;}
.chatsubmit {
	color: #FFF;
	border-width: 0;
	font-size: large;
	font-family: Times,serif;
	background-color: #069; 
}
.comment-on { background-color: #006; }
</patch_code>
<applied>2009-06-29 12:40:15</applied>
<htmlcode_id>404267</htmlcode_id>
<live_code>/* This CSS controls the Blue Web-Safe theme. */

body {
  color:            #000;
  background-color: #FFF;
}
td { color: #000; }
tr.titlebar, h2.titlebar { background-color: #006; }
tr.section_title {
  color:            #FFF;
  background-color: #005;
}
td.section_title {
  color:            #FFF;
  background-color: #005;
}
tr.post_head, tr.ntc-head, .highlight { background-color: #CCC; }
td.titlebar { color: #FFF; }
table.nodelet_container { background-color: #006; }
a:link    { color: #006  }
a:visited { color: #339 }
a.titlebar:link, a.titlebar:visited { color:  #FFF; }
tbody.nodelet td, td.nodebody { background-color: #FFF; }
tbody.nodelet th, th.nodehead {
  color:             #FFF;
  background-color:  #006;
}
tbody.nodelet th a:link, tbody.nodelet th a:visited { color: #FFF; }

/* Perl-blue theme CSS */
 body {
	color: #000;
	background-color: #eee;
	font-size: smaller;
	font-family: "Bitstream Vera Sans", Verdana, Arial, Lucida, Helvetica, sans-serif;
}
td, th {
	color: #000;
	font-size: smaller;
	font-family: "Bitstream Vera Sans", Verdana, Arial, Lucida, Helvetica, sans-serif;
}
a:link {
	color: #036;
}
a:visited {
	color: #06c;
}
h3.other, h3.superdoc, h3.categorized_answer, h3.categorized_question {
	font-size: 42px;
	font-style: italic;
	font-family: Georgia, serif;
	padding: 10px;
}
pre, tt {
	font-family: "Bitstream Vera Sans Mono", monospace;
}
tt {
	font-size: 14px;
}
textarea {
	height: 25em;
}
input, select {
	margin: 3px;
	font-size: 9pt;
	font-family: "Bitstream Vera Sans", Verdana, Arial, Lucida, Helvetica, sans-serif;
}
table[bgcolor="#000066"] {
	border: solid 1px black;
	background-color: #069;
}
.code {
	display: block;
	border: 1px solid #666;
	color: #000;
	padding: 1em;
}
td.section_title {
	color: #fff;
	background-color: #069;
	font-size: 26px;
	font-family: Georgia, serif;
	font-weight: bold;
}
tr.titlebar, td.titlebar, table.titlebar, h2.titlebar {
	background-color: #069;
	font-size: 26px;
	font-family: Georgia, serif;
}
table.nodelet_container {
	background-color: #069;
}
tbody.nodelet th, th.nodehead {
	color: #fff;
	background-color: #069;
	padding-right: 0.5em;
	text-align: right;
}
tbody.nodelet td, td.nodebody {
	background-color: #eee;
}
#approval_nodelet input[type="text"] {
	background: #fcc;
}
textarea[name="note_doctext"], input[name="note_title"] {
	font-family: monospace;
	width: 80%;
}
.spacer[height~="75"], a[href="http://pair.com"] {
	display: none;
}
div.readmore {background-color: #fff;}
.chatsubmit {
	color: #FFF;
	border-width: 0;
	font-size: large;
	font-family: Times,serif;
	background-color: #069; 
}
.comment-on { background-color: #006; }
table#replies_table { background-color: #006; }
</live_code>
<reason>replace 'highlight' in ntc</reason>
<field>doctext</field>
</record>
<record><htmlcode_id>784041</htmlcode_id>
<patch_code>[%
    my @history;

    my( @wheres, @bindvars );
    if(  my $user = $q-&gt;param('editor_user')  ) {
        push @wheres, 'AND editor_user = ?';
        push @bindvars, $user;
    }
    my $sth = $DB-&gt;getDatabaseHandle-&gt;prepare( join ' ',
        'SELECT rowid, edithistory_id, editor_user, fieldname, edittime',
        'FROM edithistory',
        'WHERE starttext != endtext',
        @wheres,
        'ORDER BY rowid DESC LIMIT 100',
    );

    my $lastchecked= $VARS-&gt;{'rje_lastchecked'};
    $sth-&gt;execute( @bindvars );
    my $sdc = { sitefaqlet=&gt;1, sitedoclet=&gt;1, faqlist=&gt;1, alphafaqlet=&gt;1 };
    my $tut = { tutstring=&gt;1, tutlist=&gt;1, perltutorial=&gt;1 };
    my $all_but = 'all but' eq ( $q-&gt;param('filter') || 'all but' );
    while (  my $edit = $sth-&gt;fetchrow_hashref()  ) {
        my $type = getNodeById( $edit-&gt;{edithistory_id} )-&gt;{type}{title};
        if(     $q-&gt;param('Wi')   &amp;&amp;  $type eq 'wiki'
            ||  $q-&gt;param('SDC')  &amp;&amp;  $sdc-&gt;{$type}
            ||  $q-&gt;param('Ped')  &amp;&amp;  $tut-&gt;{$type}
        ) {
            next
                if $all_but;
        } else {
            next
                if ! $all_but;
        }
        next
            if  ! canReadNode( $USER, $edit-&gt;{edithistory_id} )
            ||  (   $type eq 'wiki'
                &amp;&amp;  ! htmlcode( 'hasWikiPermission','',
                        'read',
                        $edit-&gt;{edithistory_id},
                    )
                );
        my @tr = map $q-&gt;td($_), (
            linkNode( $edit-&gt;{edithistory_id} ),
            linkNode(
                $edit-&gt;{edithistory_id},
                $edit-&gt;{rowid},
                {
                    displaytype =&gt; 'edithistory',
                    rowid =&gt; $edit-&gt;{rowid},
                },
            ),
            linkNode( $edit-&gt;{editor_user} ),
            $type,
            $edit-&gt;{fieldname},
            htmlcode( 'parseTimeInString','',
                $edit-&gt;{edittime}, '', '', 'short',
            ),
        );
        unshift @tr, { class =&gt; 'highlight' }
            if  $lastchecked
            &amp;&amp;  $lastchecked lt $edit-&gt;{edittime};
        push @history, \@tr;
    }
    $sth-&gt;finish();

    # filtering form
    my $form = join( "\n",
        htmlcode('openform'),
        $q-&gt;p( $q-&gt;submit(-value=&gt;'Filter') ),
        $q-&gt;radio_group(
            -name=&gt;'filter',
            -values=&gt;[ "all but", "only" ],
        ),
        $q-&gt;hidden( -name=&gt;'node_id', -default=&gt;getId($NODE) ),
        $q-&gt;blockquote(
            $q-&gt;checkbox( -name=&gt;'Wi',  -value=&gt;'1', -label=&gt;'Wikis' ),
            $q-&gt;checkbox( -name=&gt;'SDC', -value=&gt;'1', -label=&gt;'SDC nodes' ),
            $q-&gt;checkbox( -name=&gt;'Ped', -value=&gt;'1', -label=&gt;'Tut nodes' ),
        ),
        '&lt;/form&gt;&lt;hr /&gt;',
    );

    return join( "\n",
        $form,
        $q-&gt;p('No edits found (strange).'),
    )
        if ! @history;

    $VARS-&gt;{'rje_lastchecked'}= $DB-&gt;sqlSelect( 'now()' );
    return join( "\n",
        "&lt;!-- rje_lastchecked($VARS-&gt;{'rje_lastchecked'}) --&gt;",
        $form,
        $q-&gt;p( join ' ',
            'Last', 0+@history, 'edits, most recent first.',
        ),
        $q-&gt;table(
            { width =&gt; '100%' },
            $q-&gt;Tr(
                map {
                    $q-&gt;th( { align =&gt; 'left' }, $_ )
                } qw( Node EditNum Janitor Type Field Time ),
            ),
            map { $q-&gt;Tr(@$_)  } @history,
        ),
    );
%]
</patch_code>
<applied>2009-07-28 17:28:33</applied>
<htmlcode_id>434853</htmlcode_id>
<live_code>[%
    my @history;

    my( @wheres, @bindvars );
    if(  my $user = $q-&gt;param('editor_user')  ) {
        push @wheres, 'AND editor_user = ?';
        push @bindvars, $user;
    }
    my $sth = $DB-&gt;getDatabaseHandle-&gt;prepare( join ' ',
        'SELECT rowid, edithistory_id, editor_user, fieldname, edittime',
        'FROM edithistory',
        'WHERE starttext != endtext',
        @wheres,
        'ORDER BY rowid DESC LIMIT 100',
    );

    my $lastchecked= $VARS-&gt;{'rje_lastchecked'};
    $sth-&gt;execute( @bindvars );
    my $sdc = { sitefaqlet=&gt;1, sitedoclet=&gt;1, faqlist=&gt;1, alphafaqlet=&gt;1 };
    my $tut = { tutstring=&gt;1, tutlist=&gt;1, perltutorial=&gt;1 };
    my $all_but = 'all but' eq ( $q-&gt;param('filter') || 'all but' );
    while (  my $edit = $sth-&gt;fetchrow_hashref()  ) {
        my $type = ( getNodeById( $edit-&gt;{edithistory_id} ) or next )-&gt;{type}{title};
        if(     $q-&gt;param('Wi')   &amp;&amp;  $type eq 'wiki'
            ||  $q-&gt;param('SDC')  &amp;&amp;  $sdc-&gt;{$type}
            ||  $q-&gt;param('Ped')  &amp;&amp;  $tut-&gt;{$type}
        ) {
            next
                if $all_but;
        } else {
            next
                if ! $all_but;
        }
        next
            if  ! canReadNode( $USER, $edit-&gt;{edithistory_id} )
            ||  (   $type eq 'wiki'
                &amp;&amp;  ! htmlcode( 'hasWikiPermission','',
                        'read',
                        $edit-&gt;{edithistory_id},
                    )
                );
        my @tr = map $q-&gt;td($_), (
            linkNode( $edit-&gt;{edithistory_id} ),
            linkNode(
                $edit-&gt;{edithistory_id},
                $edit-&gt;{rowid},
                {
                    displaytype =&gt; 'edithistory',
                    rowid =&gt; $edit-&gt;{rowid},
                },
            ),
            linkNode( $edit-&gt;{editor_user} ),
            $type,
            $edit-&gt;{fieldname},
            htmlcode( 'parseTimeInString','',
                $edit-&gt;{edittime}, '', '', 'short',
            ),
        );
        unshift @tr, { class =&gt; 'highlight' }
            if  $lastchecked
            &amp;&amp;  $lastchecked lt $edit-&gt;{edittime};
        push @history, \@tr;
    }
    $sth-&gt;finish();

    # filtering form
    my $form = join( "\n",
        htmlcode('openform'),
        $q-&gt;p( $q-&gt;submit(-value=&gt;'Filter') ),
        $q-&gt;radio_group(
            -name=&gt;'filter',
            -values=&gt;[ "all but", "only" ],
            -default=&gt;'all but',
        ),
        $q-&gt;hidden( -name=&gt;'node_id', -default=&gt;getId($NODE) ),
        $q-&gt;blockquote(
            $q-&gt;checkbox( -name=&gt;'Wi',  -value=&gt;'1', -label=&gt;'Wikis' ),
            $q-&gt;checkbox( -name=&gt;'SDC', -value=&gt;'1', -label=&gt;'SDC nodes' ),
            $q-&gt;checkbox( -name=&gt;'Ped', -value=&gt;'1', -label=&gt;'Tut nodes' ),
        ),
        '&lt;/form&gt;&lt;hr /&gt;',
    );

    return join( "\n",
        $form,
        $q-&gt;p('No edits found (strange).'),
    )
        if ! @history;

    $VARS-&gt;{'rje_lastchecked'}= $DB-&gt;sqlSelect( 'now()' );
    return join( "\n",
        "&lt;!-- rje_lastchecked($VARS-&gt;{'rje_lastchecked'}) --&gt;",
        $form,
        $q-&gt;p( join ' ',
            'Last', 0+@history, 'edits, most recent first.',
        ),
        $q-&gt;table(
            { width =&gt; '100%' },
            $q-&gt;Tr(
                map {
                    $q-&gt;th( { align =&gt; 'left' }, $_ )
                } qw( Node EditNum Janitor Type Field Time ),
            ),
            map { $q-&gt;Tr(@$_)  } @history,
        ),
    );
%]
</live_code>
<reason>Debug</reason>
<field>doctext</field>
</record>
<record><htmlcode_id>745622</htmlcode_id>
<patch_code>&lt;div class="user-settings"&gt;
&lt;form method="post" action="?"
    enctype="application/x-www-form-urlencoded"
    style="display:block" &gt;
&lt;!-- Netscape makes everything "inline" when
       inside of an inline &lt;form&gt;. *sigh* --&gt;
[%
  $q-&gt;hidden( "displaytype" ) .
  $q-&gt;hidden( "node_id", getId($NODE) );
%]

&lt;p align="right"&gt;
    &lt;a target="_new" href="?node_id=17642#display"&gt;Help for this page&lt;/a&gt;
&lt;/p&gt;


&lt;p&gt;[{see_also:Settings Nodes;faqlist}]&lt;/p&gt;
 

&lt;br /&gt; &lt;!-- first table --&gt;

&lt;table border="1" class="user-settings" id="u-s-misc" &gt;
    &lt;col span=1 width="50%"&gt;
    &lt;col span=1 width="50%"&gt;
    &lt;tr&gt;&lt;th colspan="2"&gt;
        &lt;a name="u-s-special-tag-options"&gt;
            Special Tag Options
        &lt;/a&gt;
    &lt;/th&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;
        Override &amp;lt;readmore&amp;gt; tags
    &lt;/td&gt;&lt;td&gt;
        [{checkvar:readmoreoff}]
    &lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;
        Render &amp;lt;spoiler&amp;gt; tags as
    &lt;/td&gt;&lt;td&gt;
        [%
            $VARS-&gt;{spoiler_style} = 'link'
                unless $VARS-&gt;{spoiler_style};
            return htmlcode( "listVarMenu", "spoiler_style,link,div,span,table,reveal" );
        %]
    &lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;
        Customize CPAN link options:
    &lt;/td&gt;&lt;td&gt;
        [{setvar:cpan_link_args,30}]
    &lt;/td&gt;&lt;/tr&gt;
    
&lt;/table&gt;

&lt;br /&gt; &lt;!--  second table --&gt;

&lt;table border="1" class="user-settings" id="u-s-html-clean-opts-table" &gt;
    &lt;col span=1 width="50%"&gt;
    &lt;col span=1 width="50%"&gt;
    &lt;tr&gt;&lt;th colspan="2"&gt;
        &lt;a name="u-s-html-clean-opts"&gt;
            HTML Related Options
        &lt;/a&gt;
    &lt;/th&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;
        Enforce proper nesting of HTML
    &lt;/td&gt;&lt;td&gt;
        [{checkvar:htmlnest}]
    &lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;
        HTML error reporting level
    &lt;/td&gt;&lt;td&gt;
        [%
            $VARS-&gt;{htmlerror} = 0   unless $VARS-&gt;{htmlerror};
            return htmlcode( "listVarMenu", "htmlerror,0,1,2,3" );
        %]
    &lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;
        HTML error reporting during Preview
    &lt;/td&gt;&lt;td&gt;
        [%
            $VARS-&gt;{htmlpreview} = 3 unless $VARS-&gt;{htmlpreview};
            return htmlcode( "listVarMenu", "htmlpreview,3,4" );
        %]
    &lt;/td&gt;&lt;/tr&gt;
&lt;/table&gt;

&lt;br /&gt; &lt;!--  third table --&gt;


&lt;table border="1" class="user-settings" id="u-s-node-title"&gt;
    &lt;col span=1 width="50%"&gt;
    &lt;col span=1 width="50%"&gt;
    &lt;tr&gt;&lt;td colspan="2"&gt;
        &lt;a name="Custom-Node-Title"&gt;
            &lt;b&gt;Custom Node Title Definition:&lt;/b&gt;
        &lt;/a&gt;
        [{setvar:titledef,30}]&lt;br /&gt;
        &lt;small&gt;
            Available tokens are &lt;tt&gt;%T&lt;/tt&gt; (title),
            &lt;tt&gt;%D&lt;/tt&gt; (create date), &lt;tt&gt;%N&lt;/tt&gt;
            (node id), and &lt;tt&gt;%S&lt;/tt&gt; (section;
            e.g. SOPW, Q&amp;amp;A, but only for root nodes).
            Don't use &amp;#91; nor &amp;#93;; use
            &amp;amp;#91; and &amp;amp;#93; instead.
        &lt;/small&gt;&lt;br /&gt;
    &lt;/td&gt;&lt;/tr&gt;
&lt;/table&gt;

&lt;br /&gt; &lt;!--  fourth table --&gt;

&lt;table border="1" class="user-settings" id="u-s-code"&gt;
    &lt;col span=1 width="50%"&gt;
    &lt;col span=1 width="50%"&gt;
    &lt;tr&gt;&lt;th colspan="2"&gt;
        &lt;a name="Code-Listing-Settings"&gt;Code Listing Settings&lt;/a&gt;
    &lt;/th&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;
        [id://189399|Code Wrapping Off]
    &lt;/td&gt;&lt;td&gt;
        [{checkvar:codewrapoff}]
    &lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;
        Code Wrap Length
    &lt;/td&gt;&lt;td&gt;
        [{setvar:codewraplength}]
        &lt;small&gt;(default 70, max 32766)&lt;/small&gt;
    &lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;
        Auto Code Wrapping
    &lt;/td&gt;&lt;td&gt;
        [{checkvar:codeautowrap}]
    &lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;
        Code Prefix
    &lt;/td&gt;&lt;td&gt;
        [{setvar:codeprefix}]
    &lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;
        Large Code Font
    &lt;/td&gt;&lt;td&gt;
        [{checkvar:codebig}]
    &lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;
        Don't show embedded d/l links
    &lt;/td&gt;&lt;td&gt;
        [{checkvar:no_emded_code_dl}]
    &lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;
        Show download link on code N lines long or more:
    &lt;/td&gt;&lt;td&gt;
        [{setvar:dllink_lines}] 
    &lt;/td&gt;&lt;/tr&gt;
&lt;/table&gt;
  
&lt;br /&gt; &lt;!--  fifth table --&gt;

&lt;table border="1" class="user-settings" id="u-s-themes"&gt;
    &lt;col span=1 width="50%"&gt;
    &lt;col span=1 width="50%"&gt;
    &lt;tr&gt;&lt;th th colspan="2"&gt;
        &lt;a name="Theme-Configuration"&gt;
            Theme Configuration
        &lt;/a&gt;
    &lt;/th&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;
        Theme container:
    &lt;/td&gt;&lt;td&gt;
        [{varmenu:preferred_theme,theme}]
    &lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;
        Monk Pictures off:
    &lt;/td&gt;&lt;td&gt;
        [{checkvar:monkpicsoff}]
    &lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;
        Monk Quips off:
    &lt;/td&gt;&lt;td&gt;
        [{checkvar:monkquipsoff}]
    &lt;/td&gt;&lt;/tr&gt;
&lt;/table&gt;

&lt;br /&gt; &lt;!--  sixth table --&gt;      

&lt;table border="1" class="user-settings" id="u-s-css"&gt;
    &lt;col span=1 width="100%"&gt;
    &lt;tr&gt;&lt;th colspan="2"&gt;
        &lt;a name="Stylesheet-Settings"&gt;Stylesheet Settings&lt;/a&gt;
    &lt;/th&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;
        &lt;b&gt;&lt;a name="External-CSS"&gt;
            Link to External CSS stylesheet:
        &lt;/a&gt;&lt;/b&gt;
        [{setvar:css_link,50}]
    &lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;
        &lt;b&gt;&lt;a name="On-Site-CSS"&gt;On-Site CSS Markup:&lt;/a&gt;&lt;/b&gt;
        &lt;br /&gt;
        [{setvararea:style}]
    &lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;
        &lt;b&gt;&lt;a name="Print-CSS"&gt;
            Link to CSS stylesheet for &lt;tt&gt;print&lt;/tt&gt; display type:
        &lt;/a&gt;&lt;/b&gt;
        [{setvar:printcss,50}]
    &lt;/td&gt;&lt;/tr&gt;
&lt;/table&gt;

&lt;br /&gt; &lt;!-- table the seventh --&gt;

&lt;table border="1" class="user-settings" id="u-s-misdisp"&gt;
    &lt;col span=1 width="100%"&gt;
    &lt;tr&gt;&lt;th colspan="2"&gt;
        &lt;a name="Misc-Display-Settings"&gt;Misc Display Settings&lt;/a&gt;
    &lt;/th&gt;&lt;/tr&gt;
    &lt;tr&gt;&lt;td&gt;
        &lt;b&gt;&lt;a name="Show-ID-On-Notes"&gt;
            Show a ID tags on notes?
        &lt;/a&gt;&lt;/b&gt;
        [{checkvar:show_id_on_note}]
    &lt;/td&gt;&lt;/tr&gt;
    &lt;tr&gt;&lt;td&gt;
        &lt;b&gt;&lt;a name="wp-lang"&gt;
            Language preference for WikiMedia links
        &lt;/a&gt;&lt;/b&gt;
        [{setvar:wp_lang,4}]
        Two-letter language code
    &lt;/td&gt;&lt;/tr&gt;
    &lt;tr&gt;&lt;td&gt;
        &lt;b&gt;&lt;a name="Nodelets-as-div"&gt;
            Lay out nodelets as &lt;c&gt;&lt;div&gt;&lt;/c&gt; instead of &lt;c&gt;&lt;table&gt;&lt;/c&gt;?
        &lt;/a&gt;&lt;/b&gt;
        [{checkvar:nodelets_as_div}]
    &lt;/td&gt;&lt;/tr&gt;
    &lt;tr&gt;&lt;td&gt;
        &lt;b&gt;&lt;a name="Content-as-div"&gt;
            Lay out main content as &lt;c&gt;&lt;div&gt;&lt;/c&gt; instead of &lt;c&gt;&lt;table&gt;&lt;/c&gt;?
        &lt;/a&gt;&lt;/b&gt;
        [{checkvar:content_as_div}]
    &lt;/td&gt;&lt;/tr&gt;
&lt;/table&gt;
[{closeform}]
&lt;/div&gt;

    

</patch_code>
<applied>2009-02-22 06:01:09</applied>
<htmlcode_id>450961</htmlcode_id>
<live_code>&lt;div class="user-settings"&gt;
&lt;form method="post" action="?"
    enctype="application/x-www-form-urlencoded"
    style="display:block" &gt;
&lt;!-- Netscape makes everything "inline" when
       inside of an inline &lt;form&gt;. *sigh* --&gt;
[%
  $q-&gt;hidden( "displaytype" ) .
  $q-&gt;hidden( "node_id", getId($NODE) );
%]

&lt;p align="right"&gt;
    &lt;a target="_new" href="?node_id=786921"&gt;Help for this page&lt;/a&gt;
&lt;/p&gt;


&lt;p&gt;[{see_also:Settings Nodes;faqlist}]&lt;/p&gt;
 

&lt;br /&gt; &lt;!-- first table --&gt;

&lt;table border="1" class="user-settings" id="u-s-misc" &gt;
    &lt;col span=1 width="50%"&gt;
    &lt;col span=1 width="50%"&gt;
    &lt;tr&gt;&lt;th colspan="2"&gt;
        &lt;a name="u-s-special-tag-options"&gt;
            Special Tag Options
        &lt;/a&gt;
    &lt;/th&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;
        Override &amp;lt;readmore&amp;gt; tags
    &lt;/td&gt;&lt;td&gt;
        [{checkvar:readmoreoff}]
    &lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;
        Render &amp;lt;spoiler&amp;gt; tags as
    &lt;/td&gt;&lt;td&gt;
        [%
            $VARS-&gt;{spoiler_style} = 'link'
                unless $VARS-&gt;{spoiler_style};
            return htmlcode( "listVarMenu", "spoiler_style,link,div,span,table,reveal" );
        %]
    &lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;
        Customize CPAN link options:
    &lt;/td&gt;&lt;td&gt;
        [{setvar:cpan_link_args,30}]
    &lt;/td&gt;&lt;/tr&gt;
    
&lt;/table&gt;

&lt;br /&gt; &lt;!--  second table --&gt;

&lt;table border="1" class="user-settings" id="u-s-html-clean-opts-table" &gt;
    &lt;col span=1 width="50%"&gt;
    &lt;col span=1 width="50%"&gt;
    &lt;tr&gt;&lt;th colspan="2"&gt;
        &lt;a name="u-s-html-clean-opts"&gt;
            HTML Related Options
        &lt;/a&gt;
    &lt;/th&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;
        Enforce proper nesting of HTML
    &lt;/td&gt;&lt;td&gt;
        [{checkvar:htmlnest}]
    &lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;
        HTML error reporting level
    &lt;/td&gt;&lt;td&gt;
        [%
            $VARS-&gt;{htmlerror} = 0   unless $VARS-&gt;{htmlerror};
            return htmlcode( "listVarMenu", "htmlerror,0,1,2,3" );
        %]
    &lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;
        HTML error reporting during Preview
    &lt;/td&gt;&lt;td&gt;
        [%
            $VARS-&gt;{htmlpreview} = 3 unless $VARS-&gt;{htmlpreview};
            return htmlcode( "listVarMenu", "htmlpreview,3,4" );
        %]
    &lt;/td&gt;&lt;/tr&gt;
&lt;/table&gt;

&lt;br /&gt; &lt;!--  third table --&gt;


&lt;table border="1" class="user-settings" id="u-s-node-title"&gt;
    &lt;col span=1 width="50%"&gt;
    &lt;col span=1 width="50%"&gt;
    &lt;tr&gt;&lt;td colspan="2"&gt;
        &lt;a name="Custom-Node-Title"&gt;
            &lt;b&gt;Custom Node Title Definition:&lt;/b&gt;
        &lt;/a&gt;
        [{setvar:titledef,30}]&lt;br /&gt;
        &lt;small&gt;
            Available tokens are &lt;tt&gt;%T&lt;/tt&gt; (title),
            &lt;tt&gt;%D&lt;/tt&gt; (create date), &lt;tt&gt;%N&lt;/tt&gt;
            (node id), and &lt;tt&gt;%S&lt;/tt&gt; (section;
            e.g. SOPW, Q&amp;amp;A, but only for root nodes).
            Don't use &amp;#91; nor &amp;#93;; use
            &amp;amp;#91; and &amp;amp;#93; instead.
        &lt;/small&gt;&lt;br /&gt;
    &lt;/td&gt;&lt;/tr&gt;
&lt;/table&gt;

&lt;br /&gt; &lt;!--  fourth table --&gt;

&lt;table border="1" class="user-settings" id="u-s-code"&gt;
    &lt;col span=1 width="50%"&gt;
    &lt;col span=1 width="50%"&gt;
    &lt;tr&gt;&lt;th colspan="2"&gt;
        &lt;a name="Code-Listing-Settings"&gt;Code Listing Settings&lt;/a&gt;
    &lt;/th&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;
        [id://189399|Code Wrapping Off]
    &lt;/td&gt;&lt;td&gt;
        [{checkvar:codewrapoff}]
    &lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;
        Code Wrap Length
    &lt;/td&gt;&lt;td&gt;
        [{setvar:codewraplength}]
        &lt;small&gt;(default 70, max 32766)&lt;/small&gt;
    &lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;
        Auto Code Wrapping
    &lt;/td&gt;&lt;td&gt;
        [{checkvar:codeautowrap}]
    &lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;
        Code Prefix
    &lt;/td&gt;&lt;td&gt;
        [{setvar:codeprefix}]
    &lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;
        Large Code Font
    &lt;/td&gt;&lt;td&gt;
        [{checkvar:codebig}]
    &lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;
        Don't show embedded d/l links
    &lt;/td&gt;&lt;td&gt;
        [{checkvar:no_emded_code_dl}]
    &lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;
        Show download link on code N lines long or more:
    &lt;/td&gt;&lt;td&gt;
        [{setvar:dllink_lines}] 
    &lt;/td&gt;&lt;/tr&gt;
&lt;/table&gt;
  
&lt;br /&gt; &lt;!--  fifth table --&gt;

&lt;table border="1" class="user-settings" id="u-s-themes"&gt;
    &lt;col span=1 width="50%"&gt;
    &lt;col span=1 width="50%"&gt;
    &lt;tr&gt;&lt;th th colspan="2"&gt;
        &lt;a name="Theme-Configuration"&gt;
            Theme Configuration
        &lt;/a&gt;
    &lt;/th&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;
        Theme container:
    &lt;/td&gt;&lt;td&gt;
        [{varmenu:preferred_theme,theme}]
    &lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;
        Monk Pictures off:
    &lt;/td&gt;&lt;td&gt;
        [{checkvar:monkpicsoff}]
    &lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;
        Monk Quips off:
    &lt;/td&gt;&lt;td&gt;
        [{checkvar:monkquipsoff}]
    &lt;/td&gt;&lt;/tr&gt;
&lt;/table&gt;

&lt;br /&gt; &lt;!--  sixth table --&gt;      

&lt;table border="1" class="user-settings" id="u-s-css"&gt;
    &lt;col span=1 width="100%"&gt;
    &lt;tr&gt;&lt;th colspan="2"&gt;
        &lt;a name="Stylesheet-Settings"&gt;Stylesheet Settings&lt;/a&gt;
    &lt;/th&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;
        &lt;b&gt;&lt;a name="External-CSS"&gt;
            Link to External CSS stylesheet:
        &lt;/a&gt;&lt;/b&gt;
        [{setvar:css_link,50}]
    &lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;
        &lt;b&gt;&lt;a name="On-Site-CSS"&gt;On-Site CSS Markup:&lt;/a&gt;&lt;/b&gt;
        &lt;br /&gt;
        [{setvararea:style}]
    &lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;
        &lt;b&gt;&lt;a name="Print-CSS"&gt;
            Link to CSS stylesheet for &lt;tt&gt;print&lt;/tt&gt; display type:
        &lt;/a&gt;&lt;/b&gt;
        [{setvar:printcss,50}]
    &lt;/td&gt;&lt;/tr&gt;
&lt;/table&gt;

&lt;br /&gt; &lt;!-- table the seventh --&gt;

&lt;table border="1" class="user-settings" id="u-s-misdisp"&gt;
    &lt;col span=1 width="100%"&gt;
    &lt;tr&gt;&lt;th colspan="2"&gt;
        &lt;a name="Misc-Display-Settings"&gt;Misc Display Settings&lt;/a&gt;
    &lt;/th&gt;&lt;/tr&gt;
    &lt;tr&gt;&lt;td&gt;
        &lt;a name="Show-ID-On-Notes"&gt;
            Show a ID tags on notes?
        &lt;/a&gt;
        [{checkvar:show_id_on_note}]
    &lt;/td&gt;&lt;/tr&gt;
    &lt;tr&gt;&lt;td&gt;
        &lt;a name="wp-lang"&gt;
            Language preference for WikiMedia links
        &lt;/a&gt;
        [{setvar:wp_lang,4}]
        Two-letter language code
    &lt;/td&gt;&lt;/tr&gt;
    &lt;tr&gt;&lt;td&gt;
        &lt;a name="Nodelets-as-div"&gt;
            Lay out nodelets as &lt;c&gt;&lt;div&gt;&lt;/c&gt; instead of &lt;c&gt;&lt;table&gt;&lt;/c&gt;?
        &lt;/a&gt;
        [{checkvar:nodelets_as_div}]
    &lt;/td&gt;&lt;/tr&gt;
    &lt;tr&gt;&lt;td&gt;
        &lt;a name="Content-as-div"&gt;
            Lay out main content as &lt;c&gt;&lt;div&gt;&lt;/c&gt; instead of &lt;c&gt;&lt;table&gt;&lt;/c&gt;?
        &lt;/a&gt;
        [{checkvar:content_as_div}]
    &lt;/td&gt;&lt;/tr&gt;
    &lt;tr&gt;&lt;td&gt;
        &lt;a name="threads-as-div"&gt;
            Lay out threads as &lt;c&gt;&lt;div&gt;&lt;/c&gt; instead of &lt;c&gt;&lt;table&gt;&lt;/c&gt;?
        &lt;/a&gt;
        [{checkvar:threads_as_div}]
    &lt;/td&gt;&lt;/tr&gt;
&lt;/table&gt;
[{closeform}]
&lt;/div&gt;

    

</live_code>
<reason>add anchor</reason>
<field>doctext</field>
</record>
<record><htmlcode_id>518628</htmlcode_id>
<patch_code>&lt;html&gt;
 &lt;head&gt;
  &lt;title&gt;PM Chatterbox&lt;/title&gt;
  &lt;meta http-equiv="refresh" content="24;URL=?node_id=[%getId($NODE)%]#chatbottom" /&gt;

[{htmlhead}]
&lt;/head&gt;
&lt;body id="id-[%getId($NODE)%]"&gt;
[% 
  # In opera, links from the sidebar stay there.
  # In firefox, they open in the current tab (or new tab on middleclick).
  "&lt;base target='_new' /&gt;" if $ENV{HTTP_USER_AGENT}=~/opera/i 
%]
[{openform:-action,?node=chatterbox+sidebar,-target,_top}]
[%
  my $str= '';
  if( ! $q-&gt;param("noinbox") ) {
    $str .= htmlcode( 'showprivatemessages','', 2, 1 );
  } elsif( $USER-&gt;{node_id} != $HTMLVARS{guest_user} ) {
    $str .= htmlcode( 'toInbox','',
      $USER-&gt;{node_id}, '&lt;b&gt;%d&lt;/b&gt; [new msgs]', '[inbox]' );
  }
  $str .= "\n&lt;hr /&gt;\n"
    if  $str;
  # Don't blank out scratchpad when you hit "talk":

  $str .= $q-&gt;hidden( 'user', $_ )
    if  $q-&gt;param('user');
  $str .= htmlcode( 'showchatter', 500, 10, 1 )
    unless  $VARS-&gt;{publicchatteroff};
  $str .= "&lt;a name='chatbottom'&gt;&lt;/a&gt;\n";
  return  $str;
%]
[%
  my $e = $q-&gt;end_form();
  $e =~ s#&gt;&lt;#&gt;\n&lt;#g;
  return $e;
%]
&lt;/body&gt;
&lt;/html&gt;</patch_code>
<applied>2009-07-23 14:53:21</applied>
<htmlcode_id>481181</htmlcode_id>
<live_code>&lt;html&gt;
 &lt;head&gt;
  &lt;title&gt;PM Chatterbox&lt;/title&gt;
  &lt;meta http-equiv="refresh" content="24;URL=?node_id=[%getId($NODE)%]#chatbottom" /&gt;

[{htmlhead}]
&lt;/head&gt;
&lt;body id="id-[%getId($NODE)%]"&gt;
[% 
  # In opera, links from the sidebar stay there.
  # In firefox, they open in the current tab (or new tab on middleclick).
  "&lt;base target='_new' /&gt;" if $ENV{HTTP_USER_AGENT}=~/opera/i 
%]
[{openform:-action,?node=chatterbox+sidebar,-target,_top}]
[%
  my $str= '';
  if( ! $q-&gt;param("noinbox") ) {
    $str .= htmlcode( 'showprivatemessages','', 2, 1 );
  } elsif( $USER-&gt;{node_id} != $HTMLVARS{guest_user} ) {
    $str .= htmlcode( 'toInbox', $USER-&gt;{node_id}, 'inbox', '(%d)' );
  }
  $str .= "\n&lt;hr /&gt;\n"
    if  $str;
  # Don't blank out scratchpad when you hit "talk":

  $str .= $q-&gt;hidden( 'user', $_ )
    if  $q-&gt;param('user');
  $str .= htmlcode( 'showchatter', 500, 10, 1 )
    unless  $VARS-&gt;{publicchatteroff};
  $str .= "&lt;a name='chatbottom'&gt;&lt;/a&gt;\n";
  return  $str;
%]
[%
  my $e = $q-&gt;end_form();
  $e =~ s#&gt;&lt;#&gt;\n&lt;#g;
  return $e;
%]
&lt;/body&gt;
&lt;/html&gt;</live_code>
<reason>Add ability to drop the inbox off the top.</reason>
<field>doctext</field>
</record>
<record><htmlcode_id>591536</htmlcode_id>
<patch_code>[%
use HTML::Entities qw( encode_entities );
use POSIX qw(strftime);

local *form_getid = sub {
    return
      htmlcode('openform') .
      $query-&gt;hidden('node_id' =&gt; getId($NODE)) . qq[
      &lt;table&gt;
        &lt;tr&gt;
          &lt;td&gt;
            Node to retitle:
          &lt;/td&gt;
          &lt;td&gt;
             ${ \$query-&gt;textfield('node_tr', '', 6, 10) }
          &lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;
          &lt;/td&gt;
          &lt;td&gt;
             ${ \$query-&gt;submit('sexisgood' =&gt; 'Continue') }
          &lt;/td&gt;
        &lt;/tr&gt;
      &lt;/table&gt;] .
      $query-&gt;end_form;
};

local *form_get_title_opts = sub
{
    my ($parent, $node_tr) = shift;

    my $consideration = $DB-&gt;sqlSelect(
      'description', 
      'considernodes', 
      "considernodes_id = $parent-&gt;{node_id}" 
    );

    return
      htmlcode('openform') .
      $query-&gt;hidden('node_id' =&gt; getId($NODE)) .
      $query-&gt;hidden('node_tr' =&gt; $node_tr) . qq[
      &lt;table width="95%"&gt;
        &lt;tr&gt;
          &lt;td valign="top" colspan="2"&gt;
            Retitle (sub)thread ${ \linkNode($parent) } ?
            ${ $consideration
               ? \("&lt;br /&gt;\nConsidered: " . htmlcode('parseLinksInChatter', '', $consideration))
               : \"" }
          &lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td valign="top"&gt;
            New title:
          &lt;/td&gt;
          &lt;td valign="top"&gt;
            ${ \$query-&gt;textfield(-name=&gt;'new_ti', -size=&gt;60) }
          &lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td valign="top"&gt;
            Old title (optional)*:
          &lt;/td&gt;
          &lt;td valign="top"&gt;
            ${ \$query-&gt;textfield(-name=&gt;'old_ti', -size=&gt;60) }
          &lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td valign="top" colspan="2"&gt;
            ${ \$query-&gt;checkbox(-name=&gt;'mark_offtopic', -value=&gt;'1',
                                 -label=&gt;'Mark as off topic') }
            &lt;i&gt;(omit new title)&lt;/i&gt;
          &lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td valign="top"&gt;
            ${ \$query-&gt;checkbox(-name=&gt;'use_sig', -value=&gt;'1',
                                 -label=&gt;'Use signature') }
            &amp;dagger;
            &lt;br /&gt;
            ${ \$query-&gt;checkbox(-name=&gt;'add_old_ti', -value=&gt;'1',
                                 -label=&gt;'Add original title to signature',
                                 ) }
          &lt;/td&gt;
          &lt;td valign="top"&gt;
            ${ \$query-&gt;textarea(
                  -name    =&gt; 'sig',
                  -default =&gt; "Retitled by [$$USER{title}]".
                    ', as per Monastery [id://341118|guidelines]',
                  -rows =&gt; 2, -columns =&gt; 60
                ) }
          &lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;&amp;nbsp;&lt;/td&gt;
          &lt;td valign="top"&gt;
            ${ \$query-&gt;submit('retitle' =&gt; 'Retitle') }
          &lt;/td&gt;
        &lt;/tr&gt;
      &lt;/table&gt;
      &lt;p&gt;*  This is assumed to be the existing title if omitted.&lt;br /&gt;
            The old title is needed when
        &lt;ul&gt;&lt;li&gt;retitling a subthread;
               in this case omit the 'Re:(depth)' prefix.&lt;/li&gt;
            &lt;li&gt;retitling a thread where the author has subsequently
               fiddled with the title.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/p&gt;
      &lt;p&gt;&amp;dagger; Please avoid using this unless there is a really good
          reason (e.g. Anonymous author).
      &lt;/p&gt;
      ] .
      $query-&gt;end_form;
};

local *get_thread = sub
{
    my $parent = shift;
    my @thread;
    htmlcode('replies_in_tree', '', $parent, \@thread);
    unshift @thread, $parent;
    return \@thread;
};

local *retitle = sub
{
    my ($parent, $new_ti) = @_;

    my $thread = get_thread($parent);
    my $old_ti = $query-&gt;param('old_ti') || $parent-&gt;{title};
    $new_ti ||= "(OT) $old_ti";

    my $old_p = qr/\Q$old_ti\E/;
    my @skipped;
    my @retitled;
    my $node_count = 0;
    foreach my $node (@$thread)
    {
        $node_count++;

        if($node-&gt;{title} =~ /^(:?R[eE]\^?: \d*)*\Q$new_ti\E$/) {
            push @skipped, [$node, "New title identical to old title"];
            next;
        }
        if($node-&gt;{title} !~ m{$old_p}i) {
            push @skipped, [$node, "significant retitle by node author"];
            next;
        }
        unless(htmlcode('getOrRenewLock')) {
            push @skipped, [$node, "edit lock held by ".
                            linkNode($node-&gt;{lockedby_user})];
            $node_count == 1 ? last : next;
        }

        if ($node_count == 1 &amp;&amp; $query-&gt;param('use_sig'))
        {
            my $orig_ti = $query-&gt;param('add_old_ti')
                            ? sprintf("&lt;br /&gt;Original title: '%s'",
                                      encode_entities($old_ti))
                            : '';

            my $doctext = $node-&gt;{doctext};
            my $sig = sprintf "&lt;p&gt;&lt;small&gt;%s %s $orig_ti&lt;/small&gt;&lt;/p&gt;",
                        strftime('%Y-%m-%d',gmtime()),
                        ($query-&gt;param('sig') || '');
            $node-&gt;{doctext} = $doctext . $sig;
            $DB-&gt;sqlInsert('edithistory',{starttext=&gt;$doctext,
                                           endtext=&gt;$node-&gt;{doctext},
                                           editor_user=&gt;getId($USER),
                                           -edittime=&gt;"now()",
                                           fieldname=&gt;'doctext',
                                           edithistory_id=&gt;getId($node)});
        }
        my $title = $node-&gt;{title};
        $node-&gt;{title} = do {$_ = $title; s/$old_p/$new_ti/; $_};
        updateNode($node ,-1);
        $DB-&gt;sqlInsert('edithistory',{starttext=&gt;$title,
                                       endtext=&gt;$node-&gt;{title},
                                       editor_user=&gt;getId($USER),
                                       -edittime=&gt;"now()",
                                       fieldname=&gt;'title',
                                       edithistory_id=&gt;getId($node)});
        push @retitled, [$node, $title];
        # remove node from consideration
        $DB-&gt;sqlDelete("considernodes","considernodes_id=".getId($parent))
          if $node_count == 1;
    }
    return (\@retitled, \@skipped, $parent);
};

local *report = sub
{
    my($retitled, $skipped, $parent) = @_;

    return "No nodes were retitled : $skipped-&gt;[0][1]; node: " .
           linkNode($skipped-&gt;[0][0]) unless @$retitled;

    my $str = '';
    my $count = 1;
    foreach (@$retitled) {
        my ($node, $old_title) = @$_;
        $str .= qq[&lt;tr&gt;&lt;td&gt;$count&lt;/td&gt;
             &lt;td&gt;${\linkNode($node, $node-&gt;{node_id})}&lt;/td&gt;
             &lt;td&gt;$old_title&lt;/td&gt;
             &lt;td&gt;&amp;rarr;&lt;/td&gt;
             &lt;td&gt;$node-&gt;{title}&lt;/td&gt;&lt;/tr&gt;];
        $count++;
    }
    $str = qq[&lt;p&gt;The following nodes were retitled&lt;/p&gt;
              &lt;table border="0" cellspacing="5"&gt;$str&lt;/table&gt;];
    if (@$skipped) {
        $str .= qq[&lt;p&gt;The following nodes were &lt;b&gt;not&lt;/b&gt; retitled&lt;/p&gt;
                  &lt;table border="0" cellspacing="5"&gt;];
        $count = 1;
        foreach (@$skipped) {
            my ($node, $reason) = @$_;
            $str .= qq[&lt;tr&gt;
              &lt;td&gt;$count&lt;/td&gt;
              &lt;td&gt;${\linkNode($node, $node-&gt;{node_id})}&lt;/td&gt;
              &lt;td&gt;$node-&gt;{title}&lt;/td&gt;
              &lt;td&gt;&lt;i&gt;$reason&lt;/i&gt;&lt;/td&gt;
            ];
            $count++;
        }
        $str .= q[&lt;/table&gt;];
    }
    my $msg =
      sprintf
        q{I've retitled your node [id://%d]. Please read [id://%d].},
        getId($parent), 341118;
    $str .= '&lt;p&gt;'.htmlcode('msguser', $parent-&gt;{author_user}, $msg)
         .'&lt;/p&gt;';

};

# The fun begins here!

my $node_tr = $query-&gt;param('node_tr')
  or return form_getid();

my $again = sprintf q|&lt;a href="%s"&gt;Thank you. Come again!&lt;/a&gt;|,
              urlGen({node_id =&gt; getId($NODE)}, -1);
my $parent = getNodeById($node_tr)
  or return  qq[Couldn't find node $node_tr. $again];

htmlcode('isJanitorable', '', $parent)
    or return qq|Not an janitor editable type ($parent-&gt;{type}{title}). $again|;

my $new_ti = $query-&gt;param('new_ti');

if ($query-&gt;param('retitle') &amp;&amp;
        ($new_ti || $query-&gt;param('mark_offtopic')))
{
    return report( retitle($parent, $new_ti) ) . "&lt;p&gt;$again&lt;/p&gt;";
}
else
{
    return form_get_title_opts($parent, $node_tr);
}

%]</patch_code>
<applied>2006-12-24 16:38:46</applied>
<htmlcode_id>483915</htmlcode_id>
<live_code>[%
use HTML::Entities qw( encode_entities );
use POSIX ();

local *form_getid = sub {
    return
      htmlcode('openform') .
      $query-&gt;hidden('node_id' =&gt; getId($NODE)) . qq[
      &lt;table&gt;
        &lt;tr&gt;
          &lt;td&gt;
            Node to retitle:
          &lt;/td&gt;
          &lt;td&gt;
             ${ \$query-&gt;textfield('node_tr', '', 6, 10) }
          &lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;
          &lt;/td&gt;
          &lt;td&gt;
             ${ \$query-&gt;submit('sexisgood' =&gt; 'Continue') }
          &lt;/td&gt;
        &lt;/tr&gt;
      &lt;/table&gt;] .
      $query-&gt;end_form;
};

local *form_get_title_opts = sub
{
    my ($parent, $node_tr) = shift;

    my $consideration = $DB-&gt;sqlSelect(
      'description', 
      'considernodes', 
      "considernodes_id = $parent-&gt;{node_id}" 
    );

    return
      htmlcode('openform') .
      $query-&gt;hidden('node_id' =&gt; getId($NODE)) .
      $query-&gt;hidden('node_tr' =&gt; $node_tr) . qq[
      &lt;table width="95%"&gt;
        &lt;tr&gt;
          &lt;td valign="top" colspan="2"&gt;
            Retitle (sub)thread ${ \linkNode($parent) } ?
            ${ $consideration
               ? \("&lt;br /&gt;\nConsidered: " . htmlcode('parseLinksInChatter', '', $consideration))
               : \"" }
          &lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td valign="top"&gt;
            New title:
          &lt;/td&gt;
          &lt;td valign="top"&gt;
            ${ \$query-&gt;textfield(-name=&gt;'new_ti', -size=&gt;60) }
          &lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td valign="top"&gt;
            Old title (optional)*:
          &lt;/td&gt;
          &lt;td valign="top"&gt;
            ${ \$query-&gt;textfield(-name=&gt;'old_ti', -size=&gt;60) }
          &lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td valign="top" colspan="2"&gt;
            ${ \$query-&gt;checkbox(-name=&gt;'mark_offtopic', -value=&gt;'1',
                                 -label=&gt;'Mark as off topic') }
            &lt;i&gt;(omit new title)&lt;/i&gt;
          &lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td valign="top"&gt;
            ${ \$query-&gt;checkbox(-name=&gt;'use_sig', -value=&gt;'1',
                                 -label=&gt;'Use signature') }
            &amp;dagger;
            &lt;br /&gt;
            ${ \$query-&gt;checkbox(-name=&gt;'add_old_ti', -value=&gt;'1',
                                 -label=&gt;'Add original title to signature',
                                 ) }
          &lt;/td&gt;
          &lt;td valign="top"&gt;
            ${ \$query-&gt;textarea(
                  -name    =&gt; 'sig',
                  -default =&gt; "Retitled by [$$USER{title}]".
                    ', as per Monastery [id://341118|guidelines]',
                  -rows =&gt; 2, -columns =&gt; 60
                ) }
          &lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;&amp;nbsp;&lt;/td&gt;
          &lt;td valign="top"&gt;
            ${ \$query-&gt;submit('retitle' =&gt; 'Retitle') }
          &lt;/td&gt;
        &lt;/tr&gt;
      &lt;/table&gt;
      &lt;p&gt;*  This is assumed to be the existing title if omitted.&lt;br /&gt;
            The old title is needed when
        &lt;ul&gt;&lt;li&gt;retitling a subthread;
               in this case omit the 'Re:(depth)' prefix.&lt;/li&gt;
            &lt;li&gt;retitling a thread where the author has subsequently
               fiddled with the title.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/p&gt;
      &lt;p&gt;&amp;dagger; Please avoid using this unless there is a really good
          reason (e.g. Anonymous author).
      &lt;/p&gt;
      ] .
      $query-&gt;end_form;
};

local *get_thread = sub
{
    my $parent = shift;
    my @thread;
    htmlcode('replies_in_tree', '', $parent, \@thread);
    unshift @thread, $parent;
    return \@thread;
};

local *retitle = sub
{
    my ($parent, $new_ti) = @_;

    my $thread = get_thread($parent);
    my $old_ti = $query-&gt;param('old_ti') || $parent-&gt;{title};
    $new_ti ||= "(OT) $old_ti";

    my $old_p = qr/\Q$old_ti\E/;
    my @skipped;
    my @retitled;
    my $node_count = 0;
    foreach my $node (@$thread)
    {
        $node_count++;

        if($node-&gt;{title} =~ /^(:?R[eE]\^?: \d*)*\Q$new_ti\E$/) {
            push @skipped, [$node, "New title identical to old title"];
            next;
        }
        if($node-&gt;{title} !~ m{$old_p}i) {
            push @skipped, [$node, "significant retitle by node author"];
            next;
        }
        unless(htmlcode('getOrRenewLock')) {
            push @skipped, [$node, "edit lock held by ".
                            linkNode($node-&gt;{lockedby_user})];
            $node_count == 1 ? last : next;
        }

        if ($node_count == 1 &amp;&amp; $query-&gt;param('use_sig'))
        {
            my $orig_ti = $query-&gt;param('add_old_ti')
                            ? sprintf("&lt;br /&gt;Original title: '%s'",
                                      encode_entities($old_ti))
                            : '';

            my $doctext = $node-&gt;{doctext};
            my $sig = sprintf "&lt;p&gt;&lt;small&gt;%s %s $orig_ti&lt;/small&gt;&lt;/p&gt;",
                        POSIX::strftime('%Y-%m-%d',gmtime()),
                        ($query-&gt;param('sig') || '');
            $node-&gt;{doctext} = $doctext . $sig;
            $DB-&gt;sqlInsert('edithistory',{starttext=&gt;$doctext,
                                           endtext=&gt;$node-&gt;{doctext},
                                           editor_user=&gt;getId($USER),
                                           -edittime=&gt;"now()",
                                           fieldname=&gt;'doctext',
                                           edithistory_id=&gt;getId($node)});
        }
        my $title = $node-&gt;{title};
        $node-&gt;{title} = do {$_ = $title; s/$old_p/$new_ti/; $_};
        updateNode($node ,-1);
        $DB-&gt;sqlInsert('edithistory',{starttext=&gt;$title,
                                       endtext=&gt;$node-&gt;{title},
                                       editor_user=&gt;getId($USER),
                                       -edittime=&gt;"now()",
                                       fieldname=&gt;'title',
                                       edithistory_id=&gt;getId($node)});
        push @retitled, [$node, $title];
        # remove node from consideration
        $DB-&gt;sqlDelete("considernodes","considernodes_id=".getId($parent))
          if $node_count == 1;
    }
    return (\@retitled, \@skipped, $parent);
};

local *report = sub
{
    my($retitled, $skipped, $parent) = @_;

    return "No nodes were retitled : $skipped-&gt;[0][1]; node: " .
           linkNode($skipped-&gt;[0][0]) unless @$retitled;

    my $str = '';
    my $count = 1;
    foreach (@$retitled) {
        my ($node, $old_title) = @$_;
        $str .= qq[&lt;tr&gt;&lt;td&gt;$count&lt;/td&gt;
             &lt;td&gt;${\linkNode($node, $node-&gt;{node_id})}&lt;/td&gt;
             &lt;td&gt;$old_title&lt;/td&gt;
             &lt;td&gt;&amp;rarr;&lt;/td&gt;
             &lt;td&gt;$node-&gt;{title}&lt;/td&gt;&lt;/tr&gt;];
        $count++;
    }
    $str = qq[&lt;p&gt;The following nodes were retitled&lt;/p&gt;
              &lt;table border="0" cellspacing="5"&gt;$str&lt;/table&gt;];
    if (@$skipped) {
        $str .= qq[&lt;p&gt;The following nodes were &lt;b&gt;not&lt;/b&gt; retitled&lt;/p&gt;
                  &lt;table border="0" cellspacing="5"&gt;];
        $count = 1;
        foreach (@$skipped) {
            my ($node, $reason) = @$_;
            $str .= qq[&lt;tr&gt;
              &lt;td&gt;$count&lt;/td&gt;
              &lt;td&gt;${\linkNode($node, $node-&gt;{node_id})}&lt;/td&gt;
              &lt;td&gt;$node-&gt;{title}&lt;/td&gt;
              &lt;td&gt;&lt;i&gt;$reason&lt;/i&gt;&lt;/td&gt;
            ];
            $count++;
        }
        $str .= q[&lt;/table&gt;];
    }
    my $msg =
      sprintf
        q{I've retitled your node [id://%d]. Please read [id://%d].},
        getId($parent), 341118;
    $str .= '&lt;p&gt;'.htmlcode('msguser', $parent-&gt;{author_user}, $msg)
         .'&lt;/p&gt;';

};

# The fun begins here!

my $node_tr = $query-&gt;param('node_tr')
  or return form_getid();

my $again = sprintf q|&lt;a href="%s"&gt;Thank you. Come again!&lt;/a&gt;|,
              urlGen({node_id =&gt; getId($NODE)}, -1);
my $parent = getNodeById($node_tr)
  or return  qq[Couldn't find node $node_tr. $again];

htmlcode('isJanitorable', '', $parent)
    or return qq|Not an janitor editable type ($parent-&gt;{type}{title}). $again|;

my $new_ti = $query-&gt;param('new_ti');

if ($query-&gt;param('retitle') &amp;&amp;
        ($new_ti || $query-&gt;param('mark_offtopic')))
{
    return report( retitle($parent, $new_ti) ) . "&lt;p&gt;$again&lt;/p&gt;";
}
else
{
    return form_get_title_opts($parent, $node_tr);
}

%]</live_code>
<reason>show consideration</reason>
<field>doctext</field>
</record>
<record><htmlcode_id>486393</htmlcode_id>
<patch_code>Kind of pointless to run this unless you run [fix repliesinfo directreplies] first,
since it depends on that being correct.&lt;br /&gt;
May need to be run more than once.&lt;br /&gt;
[%  linkNode( $NODE, "List 'em",  {mode=&gt;'list'} )  %] -
[%  linkNode( $NODE, "Fix 'em",   {mode=&gt;'fix'} )  %]
&lt;p&gt;
[%
   my $do= $q-&gt;param("mode");
   return   if  ! $do;
   return   "Do what? ($do)"
      if  "fix" ne $do  &amp;&amp;  "list" ne $do;
   my $starttime = time();
   my $st= $DB-&gt;sqlSelectMany(
      join( ", ",
         "ri.parent as node_id",
         "( ri.directreplies + coalesce( sum( cri.repliesbelow ), 0 ) ) as descendants",
         "ri.repliesbelow as repliesbelow"
      ),
      join( " ",
         "repliesinfo as ri",
         "left join note on ri.parent = parent_node",
         "left join repliesinfo as cri on note_id = cri.parent"
      ),
      "",
      "group by node_id desc having descendants != repliesbelow"
   );

   my( $rec, @rec );
   push @rec, $rec while ( $rec= $st-&gt;fetchrow_hashref() );

   my $time = time()-$starttime;
   if(  "list" eq $do  ) {
      return "$time seconds.  None found"   if  ! @rec;
      return "$time seconds.  ".@rec." found.".
         $q-&gt;table(
            $q-&gt;Tr(
               map $q-&gt;th( $_ ), @{$st-&gt;{NAME}},
            ),
            map $q-&gt;Tr(
               do {
                  $rec= $_,
                  map $q-&gt;td(
                     /_/
                     ? ( !$rec-&gt;{$_} ? "0" : linkNode( {
                        node_id=&gt;$rec-&gt;{$_},
                        title=&gt;$rec-&gt;{$_},
                     } ) )
                     : ( !defined $rec-&gt;{$_} ? "NULL" : $rec-&gt;{$_} )
                  ), @{$st-&gt;{NAME}},
               },
            ), @rec,
         );
   }

   my $st= $DB-&gt;getDatabaseHandle()-&gt;prepare(
      "update repliesinfo set repliesbelow=? where parent=?"
   );

   my $count = 0;
   for $rec (  @rec  ) {
      $count += $st-&gt;execute( $rec-&gt;{descendants}, $rec-&gt;{node_id} );
   }
   return "$time seconds.  $count rows updated.";
%]
&lt;/p&gt;
</patch_code>
<applied>2005-08-24 21:06:39</applied>
<htmlcode_id>486391</htmlcode_id>
<live_code>Kind of pointless to run this unless you run [fix repliesinfo directreplies] first,
since it depends on that being correct.&lt;br /&gt;
May need to be run more than once.&lt;br /&gt;
[%  linkNode( $NODE, "List 'em",  {mode=&gt;'list'} )  %] -
[%  linkNode( $NODE, "Fix 'em",   {mode=&gt;'fix'} )  %]
&lt;p&gt;
[%
   my $do= $q-&gt;param("mode");
   return   if  ! $do;
   return   "Do what? ($do)"
      if  "fix" ne $do  &amp;&amp;  "list" ne $do;
   my $starttime = time();
   my $max = $q-&gt;param("to") || $DB-&gt;sqlSelect('MAX(parent)','repliesinfo');
   my $batch = $q-&gt;param("batch") || 100000;
   my @rec;
   my @names;

   for ( my $from = $q-&gt;param("from") || 1; $from &lt;= $max; $from += $batch ) {
      my $st= $DB-&gt;sqlSelectMany(
         join( ", ",
            "ri.parent as node_id",
            "( ri.directreplies + coalesce( sum( cri.repliesbelow ), 0 ) ) as descendants",
            "ri.repliesbelow as repliesbelow"
         ),
         join( " ",
            "repliesinfo as ri",
            "left join note on ri.parent = parent_node",
            "left join repliesinfo as cri on note_id = cri.parent"
         ),
         "ri.parent between $from and " . ( $from + $batch - 1 ),
         "group by node_id desc having descendants != repliesbelow"
      );

      my $rec;
      push @rec, $rec while ( $rec= $st-&gt;fetchrow_hashref() );
      @names = @{$st-&gt;{NAME}};
   }

   my $time = time()-$starttime;
   if(  "list" eq $do  ) {
      return "$time seconds.  None found"   if  ! @rec;
      return "$time seconds.  ".@rec." found.".
         $q-&gt;table(
            $q-&gt;Tr(
               map $q-&gt;th( $_ ), @names,
            ),
            map $q-&gt;Tr(
               do {
                  my $rec= $_;
                  map $q-&gt;td(
                     /_/
                     ? ( !$rec-&gt;{$_} ? "0" : linkNode( {
                        node_id=&gt;$rec-&gt;{$_},
                        title=&gt;$rec-&gt;{$_},
                     } ) )
                     : ( !defined $rec-&gt;{$_} ? "NULL" : $rec-&gt;{$_} )
                  ), @names,
               },
            ), @rec,
         );
   }

   my $st= $DB-&gt;getDatabaseHandle()-&gt;prepare(
      "update repliesinfo set repliesbelow=? where parent=?"
   );

   my $count = 0;
   for my $rec (  @rec  ) {
      $count += $st-&gt;execute( $rec-&gt;{descendants}, $rec-&gt;{node_id} );
   }
   return "$time seconds.  $count rows updated.";
%]
&lt;/p&gt;
</live_code>
<reason>create</reason>
<field>doctext</field>
</record>
<record><htmlcode_id>616297</htmlcode_id>
<patch_code>&lt;div class="user-settings"&gt;
&lt;form method="post" action="?"
    enctype="application/x-www-form-urlencoded"
    style="display:block" &gt;
&lt;!-- Netscape makes everything "inline" when
       inside of an inline &lt;form&gt;. *sigh* --&gt;
[%
  $q-&gt;hidden( "displaytype" ) .
  $q-&gt;hidden( "node_id", getId($NODE) );
%]

&lt;!--
&lt;p align="right"&gt;
    &lt;a target="_new" href="?node_id=17642"&gt;Help for this page&lt;/a&gt;
&lt;/p&gt;
--&gt;

&lt;p&gt;[{see_also:Settings Nodes;faqlist}]&lt;/p&gt;
 

&lt;table border="1" class="user-settings" id="u-s-colorstuff"&gt;
    &lt;col span=1 width="50%"&gt;
    &lt;col span=1 width="50%"&gt;
    &lt;tr&gt;&lt;td colspan="2"&gt;[Recently Active Threads] Styling&lt;/td&gt;&lt;/tr&gt;
    &lt;tr&gt;&lt;td&gt;
        Color Blends &lt;br /&gt;
        &lt;small&gt;";" separated list of 3- or 6-Digit Hex Colors&lt;/small&gt;
    &lt;/td&gt;&lt;td&gt;
        [{setvar:blend_colors,32}]
    &lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td colspan="2" align="left"&gt;
        &lt;a name="colorstuff"&gt;
            CSS to use instead of a color blend: 
        &lt;/a&gt;
    &lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td colspan="2"&gt;
        [{setvararea:nnt_color_style}]
    &lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td colspan="2" align="left"&gt;
        &lt;a name="colorstuff"&gt;
            Last autogenerated CSS for style&lt;br/&gt; 
            (setting this does nothing, here for reference only) 
        &lt;/a&gt;
    &lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td colspan="2"&gt;
        [{setvararea:__nnt_color_style}]
    &lt;/td&gt;&lt;/tr&gt;
&lt;/table&gt;
[{closeform}]
&lt;/div&gt;</patch_code>
<applied>2007-05-18 23:20:28</applied>
<htmlcode_id>492690</htmlcode_id>
<live_code>&lt;div class="user-settings"&gt;
&lt;form method="post" action="?"
    enctype="application/x-www-form-urlencoded"
    style="display:block" &gt;
&lt;!-- Netscape makes everything "inline" when
       inside of an inline &lt;form&gt;. *sigh* --&gt;
[%
  $q-&gt;hidden( "displaytype" ) .
  $q-&gt;hidden( "node_id", getId($NODE) );
%]

&lt;!--
&lt;p align="right"&gt;
    &lt;a target="_new" href="?node_id=786929"&gt;Help for this page&lt;/a&gt;
&lt;/p&gt;
--&gt;

&lt;p&gt;[{see_also:Settings Nodes;faqlist}]&lt;/p&gt;
 

&lt;table border="1" class="user-settings" id="u-s-colorstuff"&gt;
    &lt;col span=1 width="50%"&gt;
    &lt;col span=1 width="50%"&gt;
    &lt;tr&gt;&lt;td colspan="2"&gt;[Recently Active Threads] Styling&lt;/td&gt;&lt;/tr&gt;
    &lt;tr&gt;&lt;td&gt;
        Color Blends &lt;br /&gt;
        &lt;small&gt;";" separated list of 3- or 6-Digit Hex Colors&lt;/small&gt;
    &lt;/td&gt;&lt;td&gt;
        [{setvar:blend_colors,32}]
    &lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td colspan="2" align="left"&gt;
        &lt;a name="colorstuff"&gt;
            CSS to use instead of a color blend: 
        &lt;/a&gt;
    &lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td colspan="2"&gt;
        [{setvararea:nnt_color_style}]
    &lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td colspan="2" align="left"&gt;
        &lt;a name="colorstuff"&gt;
            Last autogenerated CSS for style&lt;br/&gt; 
            (setting this does nothing, here for reference only) 
        &lt;/a&gt;
    &lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td colspan="2"&gt;
        [{setvararea:__nnt_color_style}]
    &lt;/td&gt;&lt;/tr&gt;
&lt;/table&gt;
[{closeform}]
&lt;/div&gt;</live_code>
<reason>hyphens</reason>
<field>doctext</field>
</record>
<record><htmlcode_id>700405</htmlcode_id>
<patch_code>[{get_sitedoclet}]
&lt;div class="user-settings"&gt;
&lt;form method="post" action="?"
    enctype="application/x-www-form-urlencoded"
    style="display:block" &gt;
&lt;!-- Netscape makes everything "inline" when
       inside of an inline &lt;form&gt;. *sigh* --&gt;
[%
  $q-&gt;hidden( "displaytype" ) .
  $q-&gt;hidden( "node_id", getId($NODE) );
%]

&lt;p&gt;
    [{see_also:Settings Nodes;faqlist}]
&lt;/p&gt;

      &lt;table border="1" class="user-settings" id="u-s-freenodelet"&gt;
        &lt;tr&gt;&lt;td align="left"&gt;&lt;a name="freenodelet"&gt;
          HTML to show in Free Nodelet&lt;/a&gt;: [%
          if (!grep {$_ eq 399101} 
               split( /,/,$VARS-&gt;{fpnodelets}),
               split( /,/,$VARS-&gt;{nodelets}) 
          ){
             "(if enabled in [Nodelet Settings])"
          }
        %]
        &lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;
          [{setvararea:freenodelet,20,60}]
        &lt;/td&gt;&lt;/tr&gt;
      &lt;/table&gt;

[{closeform}]
&lt;p&gt;
Your Free Nodelet contains [% ' ' . length $VARS-&gt;{freenodelet} %] bytes.
Your encoded user settings require [% ' ' . length $USER-&gt;{vars} %] bytes or
[% sprintf "%.2f%%", length( $USER-&gt;{vars} )*100/64/1024 %]
of the 64kB available for user settings.  Exceeding the available space
will likely cause you to lose all of your settings, so be sure to leave
spare capacity as there are many things that make adjustments to your
user settings (and thus can increase the space required for them).
&lt;/p&gt;
&lt;/div&gt;</patch_code>
<applied>2008-07-28 00:45:07</applied>
<htmlcode_id>492700</htmlcode_id>
<live_code>&lt;div class="user-settings"&gt;
&lt;form method="post" action="?"
    enctype="application/x-www-form-urlencoded"
    style="display:block" &gt;
&lt;!-- Netscape makes everything "inline" when
       inside of an inline &lt;form&gt;. *sigh* --&gt;
[%
  $q-&gt;hidden( "displaytype" ) .
  $q-&gt;hidden( "node_id", getId($NODE) );
%]

&lt;p&gt;
    [{see_also:Settings Nodes;faqlist}]
&lt;/p&gt;
[{get_sitedoclet}]

      &lt;table border="1" class="user-settings" id="u-s-freenodelet"&gt;
        &lt;tr&gt;&lt;td align="left"&gt;&lt;a name="freenodelet"&gt;
          HTML to show in Free Nodelet&lt;/a&gt;: [%
          if (!grep {$_ eq 399101} 
               split( /,/,$VARS-&gt;{fpnodelets}),
               split( /,/,$VARS-&gt;{nodelets}) 
          ){
             "(if enabled in [Nodelet Settings])"
          }
        %]
        &lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;
          [{setvararea:freenodelet,20,60}]
        &lt;/td&gt;&lt;/tr&gt;
      &lt;/table&gt;

[{closeform}]
&lt;p&gt;
Your Free Nodelet contains [% ' ' . length $VARS-&gt;{freenodelet} %] bytes.
Your encoded user settings require [% ' ' . length $USER-&gt;{vars} %] bytes or
[% sprintf "%.2f%%", length( $USER-&gt;{vars} )*100/64/1024 %]
of the 64kB available for user settings.  Exceeding the available space
will likely cause you to lose all of your settings, so be sure to leave
spare capacity as there are many things that make adjustments to your
user settings (and thus can increase the space required for them).
&lt;/p&gt;
&lt;/div&gt;</live_code>
<reason>Report space used</reason>
<field>doctext</field>
</record>
<record><htmlcode_id>732091</htmlcode_id>
<patch_code>&lt;p align="right"&gt;&lt;a href="?node_id=17642#newest_nodes"&gt;Help for this page&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;[{see_also:Settings Nodes;faqlist}]&lt;/p&gt;
[{get_sitedoclet}]
&lt;hr/&gt;
[%
  return ''
    if $HTMLVARS{guest_user} == getId($USER);

  $VARS-&gt;{lastviewednewestnodes} = ''
    if $q-&gt;param('clearNNflag');

  if ( $VARS-&gt;{lastviewednewestnodes} ) {
    htmlcode("openform") .
     qq[Your 'last checked' time is set to show you nodes created since ] .
     htmlcode('convertEpochSecs',$VARS-&gt;{lastviewednewestnodes}) .
     qq[&lt;br/&gt;&lt;input type="submit" name="clearNNflag"
         value="Clear my 'last checked' time" /&gt;&lt;br/&gt;] .
     qq[When your 'last checked' time is cleared, Newest Nodes will show you nodes ] .
     qq[created during the preceding 24 hours.] .
     $q-&gt;endform();
  }
  else {
    qq[Your 'last checked' time is not set. Newest Nodes will show you ] .
    qq[nodes created during the preceding 24 hours.&lt;br/&gt;];
  }
%]
&lt;hr/&gt;
&lt;div class="user-settings"&gt;
&lt;form method="post" action="?"
    enctype="application/x-www-form-urlencoded"
    style="display:block" &gt;
&lt;!-- Netscape makes everything "inline" when
       inside of an inline &lt;form&gt;. *sigh* --&gt;
[%
  $q-&gt;hidden( "displaytype" ) .
  $q-&gt;hidden( "node_id", getId($NODE) );
%]

      &lt;table border="1" class="user-settings" id="u-s-nn"&gt;
      &lt;tr&gt;&lt;th colspan="2"&gt;Configure [id://3628]&lt;/th&gt;&lt;/tr&gt;
      &lt;tr&gt;&lt;th&gt;Sections&lt;br /&gt;to hide:&lt;/th&gt;[%
        my %nn;        
        if ($q-&gt;param('update_sections') &amp;&amp; $query-&gt;param("sexisgood") ) {
           $VARS-&gt;{'nn_hide_nodetypes'}=join ',',$q-&gt;param('set_nn_sections');
           $nn{set}='hide';
        }
        htmlcode('handle_nn_settings','',\%nn);
        $VARS-&gt;{nn_toc_style}||=($VARS-&gt;{no_nn_toc} ? 'none' : 'banner');
        $q-&gt;td($q-&gt;scrolling_list(
                                 -name=&gt;"set_nn_sections",
                                 -values=&gt;$nn{legal},
                                 -default=&gt;$nn{hidden},
                                 -force=&gt;1,
                                 -size=&gt;int(@{$nn{legal}}/2),
                                 -multiple=&gt;'true',
                                 -labels=&gt;$nn{descr},
                                 #-style=&gt;'width:100%',
                                )
               .$q-&gt;checkbox(-name=&gt;'update_sections',
                             -checked=&gt;0,

                             -value=&gt;'ON',
                             -label=&gt;'Update')
              )
      %]&lt;/tr&gt;
      &lt;tr&gt;
          &lt;th&gt;TOC Style:&lt;/th&gt;
          &lt;td&gt;[{listVarMenu:nn_toc_style,banner,counted_banner,long,none}]&lt;/td&gt;
      &lt;/tr&gt; 

      &lt;tr&gt;
          &lt;th rowspan=2&gt;Show reaped&lt;/th&gt;
          &lt;td&gt;root nodes: [{checkvar:showreaped}]&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;replies: [{checkvar:showreapednotes}]&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;!-- only use fields of node: --&gt;
           &lt;th&gt;Order nodes by:&lt;/th&gt;
           &lt;td&gt;[{listVarMenu:order_nn_by,createtime,author_user|author id,title}]&lt;/td&gt;
      &lt;/tr&gt;

      &lt;/table&gt;

[{closeform}]
&lt;/div&gt;</patch_code>
<applied>2008-12-24 08:13:48</applied>
<htmlcode_id>492848</htmlcode_id>
<live_code>&lt;p&gt;[{see_also:Settings Nodes;faqlist}]&lt;/p&gt;
[{get_sitedoclet}]
&lt;hr/&gt;
[%
  return ''
    if $HTMLVARS{guest_user} == getId($USER);

  $VARS-&gt;{lastviewednewestnodes} = ''
    if $q-&gt;param('clearNNflag');

  if ( $VARS-&gt;{lastviewednewestnodes} ) {
    htmlcode("openform") .
     qq[Your 'last checked' time is set to show you nodes created since ] .
     htmlcode('convertEpochSecs',$VARS-&gt;{lastviewednewestnodes}) .
     qq[&lt;br/&gt;&lt;input type="submit" name="clearNNflag"
         value="Clear my 'last checked' time" /&gt;&lt;br/&gt;] .
     qq[When your 'last checked' time is cleared, Newest Nodes will show you nodes ] .
     qq[created during the preceding 24 hours.] .
     $q-&gt;endform();
  }
  else {
    qq[Your 'last checked' time is not set. Newest Nodes will show you ] .
    qq[nodes created during the preceding 24 hours.&lt;br/&gt;];
  }
%]
&lt;hr/&gt;
&lt;div class="user-settings"&gt;
&lt;form method="post" action="?"
    enctype="application/x-www-form-urlencoded"
    style="display:block" &gt;
&lt;!-- Netscape makes everything "inline" when
       inside of an inline &lt;form&gt;. *sigh* --&gt;
[%
  $q-&gt;hidden( "displaytype" ) .
  $q-&gt;hidden( "node_id", getId($NODE) );
%]

      &lt;table border="1" class="user-settings" id="u-s-nn"&gt;
      &lt;tr&gt;&lt;th colspan="2"&gt;Configure [id://3628]&lt;/th&gt;&lt;/tr&gt;
      &lt;tr&gt;&lt;th&gt;Sections&lt;br /&gt;to hide:&lt;/th&gt;[%
        my %nn;        
        if ($q-&gt;param('update_sections') &amp;&amp; $query-&gt;param("sexisgood") ) {
           $VARS-&gt;{'nn_hide_nodetypes'}=join ',',$q-&gt;param('set_nn_sections');
           $nn{set}='hide';
        }
        htmlcode('handle_nn_settings','',\%nn);
        $VARS-&gt;{nn_toc_style}||=($VARS-&gt;{no_nn_toc} ? 'none' : 'banner');
        $q-&gt;td($q-&gt;scrolling_list(
                                 -name=&gt;"set_nn_sections",
                                 -values=&gt;$nn{legal},
                                 -default=&gt;$nn{hidden},
                                 -force=&gt;1,
                                 -size=&gt;int(@{$nn{legal}}/2),
                                 -multiple=&gt;'true',
                                 -labels=&gt;$nn{descr},
                                 #-style=&gt;'width:100%',
                                )
               .$q-&gt;checkbox(-name=&gt;'update_sections',
                             -checked=&gt;0,

                             -value=&gt;'ON',
                             -label=&gt;'Update')
              )
      %]&lt;/tr&gt;
      &lt;tr&gt;
          &lt;th&gt;TOC Style:&lt;/th&gt;
          &lt;td&gt;[{listVarMenu:nn_toc_style,banner,counted_banner,long,none}]&lt;/td&gt;
      &lt;/tr&gt; 

      &lt;tr&gt;
          &lt;th rowspan=2&gt;Show reaped&lt;/th&gt;
          &lt;td&gt;root nodes: [{checkvar:showreaped}]&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;replies: [{checkvar:showreapednotes}]&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;!-- only use fields of node: --&gt;
           &lt;th&gt;Order nodes by:&lt;/th&gt;
           &lt;td&gt;[{listVarMenu:order_nn_by,createtime,author_user|author id,title}]&lt;/td&gt;
      &lt;/tr&gt;

      &lt;/table&gt;

[{closeform}]
&lt;/div&gt;</live_code>
<reason>s/flag/time/</reason>
<field>doctext</field>
</record>
<record><htmlcode_id>595945</htmlcode_id>
<patch_code>&lt;p align="right"&gt;&lt;a href="/?node_id=17642#message"&gt;Help for this page&lt;/a&gt;&lt;/p&gt;
&lt;div class="user-settings"&gt;
&lt;form method="post" action="?"
    enctype="application/x-www-form-urlencoded"
    style="display:block" &gt;
&lt;!-- Netscape makes everything "inline" when
       inside of an inline &lt;form&gt;. *sigh* --&gt;
[%
 return join "\n",
    htmlcode('state_link','',48824,in_form=&gt;1),
    htmlcode('get_sitedoclet'),
    $q-&gt;hidden( "displaytype" ),
    $q-&gt;hidden( "node_id", getId($NODE) ),
    '&lt;p&gt;',
    htmlcode('see_also','Settings Nodes;faqlist,48824'),
    '&lt;/p&gt;',
%]
&lt;br /&gt;
&lt;table border="1" class="user-settings"&gt;
  &lt;tr&gt;&lt;th colspan='2'&gt;
     &lt;a name="Private-Message-Settings"&gt;Message Settings&lt;/a&gt;
  &lt;/th&gt;&lt;/tr&gt;
  &lt;tr&gt;&lt;td&gt;
      /msg me when there's a reply to one of my posts
    &lt;/td&gt;&lt;td&gt;
      [{checkvar:msgonreply}]
  &lt;/td&gt;&lt;/tr&gt;
  &lt;tr&gt;&lt;td&gt;
    Newest Messages First
    &lt;/td&gt;&lt;td&gt;
    [{checkvar:reverse_messages}]
  &lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;
    Max to display in [id://48824|Inbox] (hard limit 1000)
    &lt;/td&gt;&lt;td&gt;
    [{setvar:inboxmaxmsgs}]
  &lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;
    Max to display in Chatterbox (hard limit 50)
    &lt;/td&gt;&lt;td&gt;
    [{setvar:cbmaxmsgs}]
  &lt;/td&gt;&lt;/tr&gt;
&lt;/table&gt;

&lt;br /&gt;

&lt;table class="user-settings" id="u-s-archive" border="1"&gt;
&lt;tr&gt;&lt;th colspan='3'&gt;
  &lt;a name="Private-Message-Settings"&gt;Folder Settings&lt;/a&gt;
&lt;/th&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td colspan='3'&gt;
This is where you can configure how your archive folders for &lt;a href='?node=message+inbox'&gt;private 
messages&lt;/a&gt; will be named. Note that folders can be created 
and renamed but not deleted at this time.
&lt;/td&gt;&lt;/tr&gt;
[%
  return htmlcode('inbox_folder_settings', '', $USER, html =&gt; 'inline' );
%]
&lt;/table&gt;
[{closeform}]
&lt;/div&gt;</patch_code>
<applied>2007-01-22 12:23:47</applied>
<htmlcode_id>512013</htmlcode_id>
<live_code>&lt;p align="right"&gt;&lt;a href="?node_id=786932"&gt;Help for this page&lt;/a&gt;&lt;/p&gt;
&lt;div class="user-settings"&gt;
&lt;form method="post" action="?"
    enctype="application/x-www-form-urlencoded"
    style="display:block" &gt;
&lt;!-- Netscape makes everything "inline" when
       inside of an inline &lt;form&gt;. *sigh* --&gt;
[%
 return join "\n",
    htmlcode('state_link','',48824,in_form=&gt;1),
    htmlcode('get_sitedoclet'),
    $q-&gt;hidden( "displaytype" ),
    $q-&gt;hidden( "node_id", getId($NODE) ),
    '&lt;p&gt;',
    htmlcode('see_also','Settings Nodes;faqlist,48824'),
    '&lt;/p&gt;',
%]
&lt;br /&gt;
&lt;table border="1" class="user-settings"&gt;
  &lt;tr&gt;&lt;th colspan='2'&gt;
     &lt;a name="Private-Message-Settings"&gt;Message Settings&lt;/a&gt;
  &lt;/th&gt;&lt;/tr&gt;
  &lt;tr&gt;&lt;td&gt;
      /msg me when there's a reply to one of my posts
    &lt;/td&gt;&lt;td&gt;
      [{checkvar:msgonreply}]
  &lt;/td&gt;&lt;/tr&gt;
  &lt;tr&gt;&lt;td&gt;
    Newest Messages First
    &lt;/td&gt;&lt;td&gt;
    [{checkvar:reverse_messages}]
  &lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;
    Max to display in [id://48824|Inbox] (hard limit 1000)
    &lt;/td&gt;&lt;td&gt;
    [{setvar:inboxmaxmsgs}]
  &lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;
    Max to display in Chatterbox (hard limit 50)
    &lt;/td&gt;&lt;td&gt;
    [{setvar:cbmaxmsgs}]
  &lt;/td&gt;&lt;/tr&gt;
&lt;/table&gt;

&lt;br /&gt;

&lt;table class="user-settings" id="u-s-archive" border="1"&gt;
&lt;tr&gt;&lt;th colspan='3'&gt;
  &lt;a name="Private-Message-Settings"&gt;Folder Settings&lt;/a&gt;
&lt;/th&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td colspan='3'&gt;
This is where you can configure how your archive folders for &lt;a href='?node=message+inbox'&gt;private 
messages&lt;/a&gt; will be named. Note that folders can be created 
and renamed but not deleted at this time.
&lt;/td&gt;&lt;/tr&gt;
[%
  return htmlcode('inbox_folder_settings', '', $USER, html =&gt; 'inline' );
%]
&lt;/table&gt;
[{closeform}]
&lt;/div&gt;</live_code>
<reason>right-align the help link</reason>
<field>doctext</field>
</record>
<record><htmlcode_id>546826</htmlcode_id>
<patch_code>[%
   return "We have never heard of you and require a meet under the third lampost past the 
           remains of the Norfolk Arms to see your union card."
     if ! Everything::isApproved( $USER, getNode( 'pollsters', 'usergroup' ) );

   join "",
      htmlcode('openform'),
      $query-&gt;hidden("type", "testpoll"),
      qq[&lt;input type="hidden" name="op" value="new"&gt;\n],
      qq[Title: &lt;input type="text" name="node" value=""&gt;\n],
      qq[&lt;br /&gt;Choices&lt;br /&gt;\n],
      $q-&gt;textarea("testpoll_choices","",10,60),
      qq[&lt;br /&gt;Gimmick: &lt;input type="text" name="testpoll_gimmick" value="0"&gt; (1 = force choice)&lt;br /&gt;\n],
      qq[Gimmick choice: &lt;input type="text" name="testpoll_gimmickchoice" value="0"&gt;\n],
      "&lt;br /&gt;Change author to (optional): \n",
      qq[&lt;input type="text" name="change_poll_author"&gt;&lt;br /&gt;\n],
      htmlcode('closeform');
%]</patch_code>
<applied>2006-05-02 01:38:51</applied>
<htmlcode_id>517560</htmlcode_id>
<live_code>[%
   return "We have never heard of you and require a meet under the third lampost past the 
           remains of the Norfolk Arms to see your union card."
     if ! Everything::isApproved( $USER, getNode( 'pollsters', 'usergroup' ) );

   join "",
      htmlcode('openform'),
      $query-&gt;hidden("type", "testpoll"),
      qq[&lt;input type="hidden" name="op" value="new"&gt;\n],
      qq[Title: &lt;input type="text" name="node" value=""&gt;\n],
      qq[&lt;br /&gt;Choices&lt;br /&gt;\n],
      $q-&gt;textarea("testpoll_choices","",10,60),
      qq[&lt;br /&gt;Prologue (optional)&lt;br /&gt;\n],
      $q-&gt;textarea("testpoll_prologue","",5,60),
      qq[&lt;br /&gt;Gimmick: &lt;input type="text" name="testpoll_gimmick" value="0"&gt; (1 = force choice)&lt;br /&gt;\n],
      qq[Gimmick choice: &lt;input type="text" name="testpoll_gimmickchoice" value="0"&gt;\n],
      "&lt;br /&gt;Change author to (optional): \n",
      qq[&lt;input type="text" name="change_poll_author"&gt;&lt;br /&gt;\n],
      htmlcode('closeform');
%]</live_code>
<reason>gimmicks</reason>
<field>doctext</field>
</record>
<record><htmlcode_id>694357</htmlcode_id>
<patch_code>[%
my %xmlstyle= ( clean =&gt; 1 );

return "&lt;error&gt;Error creating fling object&lt;/error&gt;"
     unless htmlcode('new_xml_fling','',\my($xml,@data),\%xmlstyle,'add_http_header');

my $node_id= $q-&gt;param('id') || 847; $node_id+=0;

my $refnode= getNodeById( $node_id );

# api decision:
# if user specifies param explicitly, and it's invalid,
# DO NOT fall back on using the value from the ref node.

# the fields in the xml header are to reflect the user's inputs, as long as
# they're defined, even if they're invalid.
# the error code will report if any are invalid.

my @xml_header_fields = ( node_id =&gt; $node_id );
my @errors;

push @errors, "reference node does not exist"
   unless $refnode;

my $nodetype_id = 
   $q-&gt;param('nodetype') ? $q-&gt;param('nodetype') :
   ref $refnode ? $refnode-&gt;{type_nodetype} :
   undef;

my $author_id = 
   $q-&gt;param('author') ? $q-&gt;param('author') :
   ref $refnode ? $refnode-&gt;{author_user} :
   undef;

$nodetype_id+=0;
$author_id+=0;

if ( $nodetype_id ) {
   my $typenode = getNodeById( $nodetype_id );
   push @xml_header_fields,
      nodetype_id =&gt; $nodetype_id,
      nodetype_name =&gt; $typenode-&gt;{title};
   if ( $typenode-&gt;{type_nodetype} != 1 ) { # 1 = nodetype
      push @errors, "invalid nodetype id $nodetype_id";
      undef $nodetype_id;
   }
}
else {
   push @errors, "nodetype id undetermined/unspecified";
}

if ( $author_id ) {
   my $authnode = getNodeById( $author_id );
   push @xml_header_fields,
      author_id =&gt; $author_id,
      author_name =&gt; $authnode-&gt;{title};
   if ( $authnode-&gt;{type_nodetype} != 15
     &amp;&amp; $authnode-&gt;{type_nodetype} != 16 ) { # 15,16 = user,usergroup
      push @errors, "invalid author id $author_id";
      undef $author_id;
   }
}
else {
   push @errors, "author id undetermined/unspecified";
}

@errors and push @xml_header_fields,
   error =&gt; join ';', @errors;

htmlcode( 'xml_info_tag', '', $xml, \%xmlstyle, 'nodenav',
   @xml_header_fields,
);

my %tag = (
   type  =&gt; 'of_type',
   auth  =&gt; 'by_author',
);
my %att = (
   type =&gt; [ nodetype_id =&gt; $nodetype_id ],
   auth =&gt; [ author_id =&gt; $author_id ],
);
my %and = (
   type =&gt; " and type_nodetype=$nodetype_id",
   auth =&gt; " and author_user=$author_id",
);

my $empty = {
   tag =&gt; [], # use "deref to empty array" trick
   att =&gt; [],
   sql =&gt; [],
};
my @typevec = ($empty);
my @authvec = ($empty);
$nodetype_id and push @typevec, {
   tag =&gt; ['of_type'],
   att =&gt; [ nodetype_id =&gt; $nodetype_id ],
   sql =&gt; [" and type_nodetype=$nodetype_id"],
};
$author_id and push @authvec, {
   tag =&gt; ['by_author'],
   att =&gt; [ author_id =&gt; $author_id ],
   sql =&gt; [" and author_user=$author_id"],
};

for my $tv ( @typevec ) {
for my $av ( @authvec ) {

   my $tag = join '_', @{ $tv-&gt;{tag} }, @{ $av-&gt;{tag} };
   my @att =           @{ $tv-&gt;{att} }, @{ $av-&gt;{att} };
   my $and = join  '', @{ $tv-&gt;{sql} }, @{ $av-&gt;{sql} };

   $tag ||= 'all';

   my $pst= $DB-&gt;sqlSelect( "max(node_id)", "node", "node_id&lt;$node_id".$and );
   my $nst= $DB-&gt;sqlSelect( "min(node_id)", "node", "node_id&gt;$node_id".$and );

   $xml-&gt;start( $tag, @att );
   $xml-&gt;empty( 'prev', node_id =&gt; $pst ) if $pst;
   $xml-&gt;empty( 'next', node_id =&gt; $nst ) if $nst;
   $xml-&gt;end;
}
}

$xml-&gt;end;

return join '', @data;
%]
</patch_code>
<applied>2008-06-27 11:51:05</applied>
<htmlcode_id>693598</htmlcode_id>
<live_code>[%
my %xmlstyle= ( clean =&gt; 1 );

return "&lt;error&gt;Error creating fling object&lt;/error&gt;"
     unless htmlcode('new_xml_fling','',\my($xml,@data),\%xmlstyle,'add_http_header');

my $node_id= $q-&gt;param('id') || 847; $node_id+=0;

my $refnode= getNodeById( $node_id );

# api decision:
# if user specifies param explicitly, and it's invalid,
# DO NOT fall back on using the value from the ref node.

# the fields in the xml header are to reflect the user's inputs, as long as
# they're defined, even if they're invalid.
# the error code will report if any are invalid.

my @xml_header_fields = ( node_id =&gt; $node_id );
my @errors;

push @errors, "reference node does not exist"
   unless $refnode;

my $nodetype_id = 
   $q-&gt;param('nodetype') ? $q-&gt;param('nodetype') :
   ref $refnode ? $refnode-&gt;{type_nodetype} :
   undef;

my $author_id = 
   $q-&gt;param('author') ? $q-&gt;param('author') :
   ref $refnode ? $refnode-&gt;{author_user} :
   undef;

$nodetype_id+=0;
$author_id+=0;

if ( $nodetype_id ) {
   my $typenode = getNodeById( $nodetype_id );
   push @xml_header_fields,
      nodetype_id =&gt; $nodetype_id,
      nodetype_name =&gt; $typenode-&gt;{title};
   if ( $typenode-&gt;{type_nodetype} != 1 ) { # 1 = nodetype
      push @errors, "invalid nodetype id $nodetype_id";
      undef $nodetype_id;
   }
}
else {
   push @errors, "nodetype id undetermined/unspecified";
}

if ( $author_id ) {
   my $authnode = getNodeById( $author_id );
   push @xml_header_fields,
      author_id =&gt; $author_id,
      author_name =&gt; $authnode-&gt;{title};
   if ( $authnode-&gt;{type_nodetype} != 15
     &amp;&amp; $authnode-&gt;{type_nodetype} != 16 ) { # 15,16 = user,usergroup
      push @errors, "invalid author id $author_id";
      undef $author_id;
   }
}
else {
   push @errors, "author id undetermined/unspecified";
}

@errors and push @xml_header_fields,
   error =&gt; join ';', @errors;

htmlcode( 'xml_info_tag', '', $xml, \%xmlstyle, 'nodenav',
   @xml_header_fields,
);

my %tag = (
   type  =&gt; 'of_type',
   auth  =&gt; 'by_author',
);
my %att = (
   type =&gt; [ nodetype_id =&gt; $nodetype_id ],
   auth =&gt; [ author_id =&gt; $author_id ],
);
my %and = (
   type =&gt; " and type_nodetype=$nodetype_id",
   auth =&gt; " and author_user=$author_id",
);

my $empty = {
   tag =&gt; [], # use "deref to empty array" trick
   att =&gt; [],
   sql =&gt; [],
};
my @typevec = ($empty);
my @authvec = ($empty);
$nodetype_id and push @typevec, {
   tag =&gt; ['of_type'],
   att =&gt; [ nodetype_id =&gt; $nodetype_id ],
   sql =&gt; [" and type_nodetype=$nodetype_id"],
};
$author_id and push @authvec, {
   tag =&gt; ['by_author'],
   att =&gt; [ author_id =&gt; $author_id ],
   sql =&gt; [" and author_user=$author_id"],
};

for my $tv ( @typevec ) {
for my $av ( @authvec ) {

   my $tag = join '_', @{ $tv-&gt;{tag} }, @{ $av-&gt;{tag} };
   my @att =           @{ $tv-&gt;{att} }, @{ $av-&gt;{att} };
   my $and = join  '', @{ $tv-&gt;{sql} }, @{ $av-&gt;{sql} };

   $tag ||= 'all';

   my $pst= $DB-&gt;sqlSelect( "max(node_id)", "node", "node_id&lt;$node_id".$and );
   my $nst= $DB-&gt;sqlSelect( "min(node_id)", "node", "node_id&gt;$node_id".$and );

   $xml-&gt;start( $tag, @att );
   $xml-&gt;empty( 'prev', node_id =&gt; $pst ) if $pst;
   $xml-&gt;empty( 'next', node_id =&gt; $nst ) if $nst;
   $xml-&gt;end;
}
}

$xml-&gt;end;

my $data = join "",@data;       
htmlcode('postProcessXML','',\$data);
return $data;
%]
</live_code>
<reason>param name s/type/nodetype/. info += type.title, author.title</reason>
<field>doctext</field>
</record>
<record><htmlcode_id>774218</htmlcode_id>
<patch_code>[{get_sitedoclet}]
[%
    return "You aren't logged in."
        if  $HTMLVARS{guest_user} == getId($USER);
    my $textsize= $q-&gt;param("textsize") || 80;
    my $borged= time() &lt; getVars(
        getNode( 'borged users', 'setting' ) )-&gt;{ getId($USER) };

    my $notice = $q-&gt;param( "sentmessage" ) || '';
    if($notice) {
        $notice = $q-&gt;p($notice);
    }

    return  join $/,
        htmlcode('openform'),
        $q-&gt;hidden(
            -name=&gt;"op", -value=&gt;"message", -force=&gt;1,
        ),
        $q-&gt;hidden(
            -name=&gt;"replyto", -value=&gt;"user", -force=&gt;1,
        ),
        $q-&gt;hidden(
            -name  =&gt; "originallyto",
            -value =&gt; ''.$q-&gt;param('sendto'),
            -force =&gt; 1,
        ),
        $q-&gt;hidden(
            -name  =&gt; "originaltext",
            -value =&gt; ''.$q-&gt;param('replytotext'),
            -force =&gt; 1,
        ),
        $q-&gt;hidden( -name=&gt;"textsize" ),
        "&lt;tt&gt;Send&lt;/tt&gt;",
        "&lt;br /&gt;&lt;tt&gt;Message:&lt;/tt&gt;",
        $q-&gt;textfield(
            -name=&gt;"replytotext", -size=&gt;$textsize, -maxlength=&gt;240,
        ),
        "&lt;br /&gt;&lt;tt&gt;To User:&lt;/tt&gt;",
        $q-&gt;textfield(
            -name=&gt;"sendto", -size=&gt;40, -maxlength=&gt;240,
        ),
        "&lt;br /&gt;&lt;tt&gt;" . ( "&amp;nbsp;" x 8 ) . "&lt;/tt&gt;",
        $q-&gt;submit(
            -name =&gt; "stumbit",
            -value =&gt; $borged ? "Dally" : "Deliver",
        ),
        "&lt;/form&gt;&lt;br /&gt;",
        $notice;
%]
</patch_code>
<applied>2009-06-23 22:26:02</applied>
<htmlcode_id>762476</htmlcode_id>
<live_code>[%
    return "You aren't logged in."
        if  $HTMLVARS{guest_user} == getId($USER);
    my $textsize= $q-&gt;param("textsize") || 80;
    my $borged= time() &lt; getVars(
        getNode( 'borged users', 'setting' ) )-&gt;{ getId($USER) };

    my $notice = $q-&gt;param( "sentmessage" ) || '';
    if($notice) {
        $notice = $q-&gt;p($notice);
    }

    return  join $/,
        htmlcode('openform'),
        $q-&gt;hidden(
            -name=&gt;"op", -value=&gt;"message", -force=&gt;1,
        ),
        $q-&gt;hidden(
            -name=&gt;"replyto", -value=&gt;"user", -force=&gt;1,
        ),
        $q-&gt;hidden(
            -name  =&gt; "originallyto",
            -value =&gt; ''.$q-&gt;param('sendto'),
            -force =&gt; 1,
        ),
        $q-&gt;hidden(
            -name  =&gt; "originaltext",
            -value =&gt; ''.$q-&gt;param('replytotext'),
            -force =&gt; 1,
        ),
        $q-&gt;hidden( -name=&gt;"textsize" ),
        "&lt;tt&gt;Send&lt;/tt&gt;",
        "&lt;br /&gt;&lt;tt&gt;Message:&lt;/tt&gt;",
        $q-&gt;textfield(
            -name=&gt;"replytotext", -size=&gt;$textsize, -maxlength=&gt;240,
        ),
        "&lt;br /&gt;&lt;tt&gt;To User:&lt;/tt&gt;",
        $q-&gt;textfield(
            -name=&gt;"sendto", -size=&gt;40, -maxlength=&gt;240,
        ),
        "&lt;br /&gt;&lt;tt&gt;" . ( "&amp;nbsp;" x 8 ) . "&lt;/tt&gt;",
        $q-&gt;submit(
            -name =&gt; "stumbit",
            -value =&gt; $borged ? "Dally" : "Deliver",
        ),
        "&lt;/form&gt;&lt;br /&gt;",
        $notice;
%]
[{get_sitedoclet}]
</live_code>
<reason>Make the form flow better as English</reason>
<field>doctext</field>
</record>
<record><htmlcode_id>192227</htmlcode_id>
<patch_code>[% ''.localtime() %]&lt;br /&gt;
[{parseTimeInString}]</patch_code>
<applied>2002-08-22 20:42:54</applied>
<htmlcode_id>94</htmlcode_id>
<live_code>[%
    use POSIX ();
    localtime() . POSIX::strftime( ' %Z', localtime() );
%]&lt;br /&gt;
[{parseTimeInString}]&lt;br /&gt;
[% htmlcode( 'parseTimeInString','',
    '','GMT','','%Y-%m-%d %H:%M:%S Z' ) %]</live_code>
<reason>Include local (and server) time</reason>
<field>nlcode</field>
</record>
<record><htmlcode_id>536826</htmlcode_id>
<patch_code>[%
   my $str;
   my $temp;
   
   foreach(sort keys %{$HTMLVARS{perlfunc}}){
      my $pagetitle=$HTMLVARS{perlfunc}{$_};
      $pagetitle=~s/\s//g;
      my($N)=getNodeWhere({title=&gt;"$pagetitle"},getType "perlfunc");   
      my $linktitle=$$N{synopsis};
      undef $/;
      $linktitle=~s/\n//g;
      $linktitle=~s/^&lt;P&gt;(.*?)&lt;P&gt;.*/$1/;
      $linktitle=~s!&lt;font\s+size=-1&gt;(.*?)&lt;/font&gt;!&lt;small&gt;$1&lt;/small&gt;!gi;
      my $temp="doc://$_|$linktitle";
      $str.=linkNodeTitle($temp,$NODE)."&lt;BR&gt;";
 
      #my($N)=getNodeWhere({title=&gt;"$pagetitle"},getType "perlfunc");   
      #$str.=$$N{synopsis}
    }
   $str;
%]</patch_code>
<applied>2006-03-15 13:06:17</applied>
<htmlcode_id>496</htmlcode_id>
<live_code>[%
   my $str;
   my $temp;
   
   foreach(sort keys %{$HTMLVARS{perlfunc}}){
      my $pagetitle=$HTMLVARS{perlfunc}{$_};
      $pagetitle=~s/\s//g;
      my($N)=getNodeWhere({title=&gt;"$pagetitle"},getType "perlfunc");   
      my $linktitle=$$N{synopsis};
      undef $/;
      $linktitle=~s/\n//g;
      $linktitle=~s/^&lt;P&gt;(.*?)&lt;P&gt;.*/$1/;
      $linktitle=~s!&lt;font\s+size=-1&gt;(.*?)&lt;/font&gt;!&lt;small&gt;$1&lt;/small&gt;!gi;
      my $temp="doc://$_|$linktitle";
      $str.='&lt;li&gt;'.linkNodeTitle($temp,$NODE).'&lt;/li&gt;';
 
      #my($N)=getNodeWhere({title=&gt;"$pagetitle"},getType "perlfunc");   
      #$str.=$$N{synopsis}
    }
   '&lt;ul class="spacey-list"&gt;'.$str.'&lt;/ul&gt;'
%]
</live_code>
<reason>link to perldoc.perl.org instead of onsite docs</reason>
<field>nlcode</field>
</record>
<record><htmlcode_id>553057</htmlcode_id>
<patch_code>[%
  return join "&lt;br /&gt;\n",
    map linkNodeTitle( $_ ),
      'The Monastery Gates',
      'Seekers of Perl Wisdom',
      'Meditations',
      'Perl Monks Discussion|PerlMonks Discussion',
      'Categorized Questions and Answers|Categorized Q&amp;amp;A',
      'Tutorials',
      'Obfuscated Code',
      'Perl Poetry',
      'Cool Uses for Perl',
      'Snippets Section',
      'Code Catacombs',
      'Perl News',
%]</patch_code>
<applied>2006-06-05 08:12:52</applied>
<htmlcode_id>1052</htmlcode_id>
<live_code>[{get_sitedoclet:Sections}]
</live_code>
<reason>add Tutorials</reason>
<field>nlcode</field>
</record>
<record><htmlcode_id>547245</htmlcode_id>
<patch_code>[%
  return join "&lt;br /&gt;\n", 
    linkNode( 6364, "Nodes You Wrote",
      { user =&gt; $USER-&gt;{title} } ),
    map( linkNodeTitle( $_ ),
      'Super Search',
      'Perl Monks User Search|List Nodes By Users',
      'Newest Nodes',
      'Recently Active Threads',
      'Selected Best Nodes',
      'Best Nodes',
      'Worst Nodes',
      'Saints in our Book',
    ),
%]</patch_code>
<applied>2006-05-03 15:44:19</applied>
<htmlcode_id>1054</htmlcode_id>
<live_code>[%
  htmlcode( 'get_sitedoclet', 'Find Nodes sitedoclet',
    -USER =&gt; $USER-&gt;{node_id} )
%]</live_code>
<reason>better label for "User Search"</reason>
<field>nlcode</field>
</record>
<record><htmlcode_id>781759</htmlcode_id>
<patch_code>[%
  my $html= '';
  if( getId($USER) != $HTMLVARS{guest_user} ) {
    $html .= linkNode( $USER ) . "&lt;br /&gt;\n";
    $html .= linkNode( 109,
      "log " . $q-&gt;escapeHTML($USER-&gt;{title}) . " out",
      { op =&gt; 'logout' },
    ) . "&lt;br /&gt;\n";
  }
  $html .= join "&lt;br /&gt;\n",
    map( linkNodeTitle( $_ ),
      'The St. Larry Wall Shrine',
      'Offering Plate',
      'Awards',
      'Craft',
      'Quests',
      'Editor Requests',
      'Is there PerlMonks merchandise I can buy?|Buy PerlMonks Gear',
    ), '';
  $html .= qq[&lt;a href="http://shop.cafepress.com/perlmonks"&gt;PerlMonks Merchandise&lt;/a&gt;&lt;br /&gt;\n]
    . qq[&lt;a href="http://planet.perl.org/"&gt;Planet Perl&lt;/a&gt;&lt;br /&gt;\n] 
    . qq[&lt;a href="http://perlsphere.net/"&gt;Perlsphere&lt;/a&gt;&lt;br /&gt;\n]
    . qq[&lt;a href="http://use.perl.org/"&gt;Use Perl&lt;/a&gt;&lt;br /&gt;\n]
    . qq[&lt;a href="http://perl.com/"&gt;Perl.com&lt;/a&gt;&lt;br /&gt;\n]
    . qq[&lt;a href="http://www.perlfoundation.org/perl5/index.cgi"&gt;Perl 5 Wiki&lt;/a&gt;&lt;br /&gt;\n]   
    . qq[&lt;a href="http://jobs.perl.org/"&gt;Perl Jobs&lt;/a&gt;&lt;br /&gt;\n]   
    . qq[&lt;a href="http://www.pm.org/"&gt;Perl Mongers&lt;/a&gt;&lt;br /&gt;\n]      
    . qq[&lt;a href="http://www.perl.org/"&gt;Perl Directory&lt;/a&gt;&lt;br /&gt;\n]
    . qq[&lt;a href="http://perldoc.perl.org/"&gt;Perl documentation&lt;/a&gt;&lt;br /&gt;\n]
    . qq[&lt;a href="http://cpan.perl.org/"&gt;CPAN&lt;/a&gt;&lt;br /&gt;\n]
  ;
  $html .= qq[&lt;a href="?op=randomnode"&gt;Random Node&lt;/a&gt;&lt;br /&gt;\n];
  return $html;
%]</patch_code>
<applied>2009-07-20 16:56:46</applied>
<htmlcode_id>1055</htmlcode_id>
<live_code>[%
  htmlcode( 'get_sitedoclet', 'Leftovers sitedoclet',
    -USER_LINKS =&gt;
    getId($USER) == $HTMLVARS{guest_user} ? '' : join( '',
      '&lt;li&gt;', linkNode( $USER ), "&lt;/li&gt;\n&lt;li&gt;",
      linkNode( 109, "log&amp;nbsp;out", { op =&gt; 'logout' } ),
      "&lt;/li&gt;\n",
    ),
  )
%]
</live_code>
<reason>use the faqlet version of "Buy Stuff"</reason>
<field>nlcode</field>
</record>
<record><htmlcode_id>650215</htmlcode_id>
<patch_code>[%

# Note: when patching this, don't forget to synch with [poll vote page]

my $poll_type_id = getId( getType( 'poll' ) );

my $latest_poll = $DB-&gt;sqlSelect(
    "max( node_id )",
    "node",
    join " and ",
        "type_nodetype=$poll_type_id",
        "date_sub( curdate(), interval 30 day ) &lt; createtime",
);
return "&lt;p&gt;No recent polls found&lt;br /&gt;"
    if  ! $latest_poll;

my $N = getNodeById( $latest_poll );
my @choice = split( /\n/, $N-&gt;{choices} );
my @choice_votecount = split( /\n/, $N-&gt;{numbers} );

my %labels = map {
    $_ =&gt; htmlcode(
        'ParseLinksInContent','',
        $choice[ $_ ],
        simplecode =&gt; 1,
    )
} 0 .. $#choice;

my $total_votes = 0;
$total_votes += $_ foreach @choice_votecount;

'&lt;h4&gt;'
. htmlcode( 'ParseLinksInContent','', $N-&gt;{title}, simplecode =&gt; 1 )
. '&lt;/h4&gt;'
. ( $N-&gt;{prologue} &amp;&amp; htmlcode( 'ParseLinksInContent','', $N-&gt;{prologue} ) )
. htmlcode( 'openform','', -displaytype =&gt; 'display', -node_id =&gt; $N-&gt;{node_id} )
. "\n&lt;p&gt;\n"
. $query-&gt;radio_group(
    -name      =&gt; 'vote',
    -values    =&gt; [ 0 .. $#choice ],
    -labels    =&gt; \%labels,
    -linebreak =&gt;'true',
)
. &lt;&lt;'END_HTML'
&lt;input type="submit" value="Vote"&gt;
&lt;/p&gt;
&lt;/form&gt;

&lt;p&gt;
END_HTML
. linkNode($N, "Results ($total_votes votes)")
. ', '
%]
[%
linkNodeTitle("past polls|past polls")."&lt;/p&gt;"
%]</patch_code>
<applied>2007-11-12 00:12:47</applied>
<htmlcode_id>1448</htmlcode_id>
<live_code>[%

# Note: when patching this, don't forget to synch with [poll vote page]

my $poll_type_id = getId( getType( 'poll' ) );

my $latest_poll = $DB-&gt;sqlSelect(
    "max( node_id )",
    "node",
    join " and ",
        "type_nodetype=$poll_type_id",
        "date_sub( curdate(), interval 30 day ) &lt; createtime",
);
return "&lt;p&gt;No recent polls found&lt;br /&gt;"
    if  ! $latest_poll;

my $N = getNodeById( $latest_poll );
my @choice = split( /\n/, $N-&gt;{choices} );
my @choice_votecount = split( /\n/, $N-&gt;{numbers} );

my %labels = map {
    $_ =&gt; htmlcode(
        'ParseLinksInContent','',
        $choice[ $_ ],
        simplecode =&gt; 1,
    )
} 0 .. $#choice;

my $total_votes = 0;
$total_votes += $_ foreach @choice_votecount;

'&lt;h4&gt;'
. htmlcode( 'ParseLinksInContent','', $N-&gt;{title}, simplecode =&gt; 1 )
. '&lt;/h4&gt;'
. ( $N-&gt;{prologue} &amp;&amp; htmlcode( 'ParseLinksInContent','', $N-&gt;{prologue} ) )
. htmlcode( 'openform','', -displaytype =&gt; 'display', -node_id =&gt; $N-&gt;{node_id} )
. "\n&lt;p&gt;\n"
. $query-&gt;radio_group(
    -name      =&gt; 'vote',
    -values    =&gt; [ 0 .. $#choice ],
    -labels    =&gt; \%labels,
    -linebreak =&gt;'true',
    -default   =&gt; 'n/a',
)
. &lt;&lt;'END_HTML'
&lt;input type="submit" value="Vote"&gt;
&lt;/p&gt;
&lt;/form&gt;

&lt;p&gt;
END_HTML
. linkNode($N, "Results ($total_votes votes)")
. ', '
%]
[%
linkNodeTitle("past polls|past polls")."&lt;/p&gt;"
%]</live_code>
<reason>probably a more Everything way to do this, but...</reason>
<field>nlcode</field>
</record>
<record><htmlcode_id>528879</htmlcode_id>
<patch_code>[%
  my $str;
  my $NL;

  eval{
    use XML::RSS;
    use LWP::Simple;
    my $xml = LWP::Simple::get( 'http://search.cpan.org/uploads.rdf' );
    my $rss = XML::RSS-&gt;new;
    $rss-&gt;parse( $xml );
    my @items = @{ $rss-&gt;{items} };
    @items = @items[0..24]
      if @items &gt; 25;
    $str .= qq(&amp;bull;&lt;a href = "$_-&gt;{link}"&gt;$_-&gt;{title}&lt;/a&gt;&lt;br /&gt;\n)
      for @items;
    $str =~ s!search.cpan.org,\s+!!g;
    $str = htmlcode('split_html','',$str);
    $str .= &lt;&lt;'END';
      &lt;form method = get action="http://search.cpan.org/search"&gt;
        &lt;select name = "mode"&gt;
          &lt;option value = "module" &gt;Module        &lt;/option&gt;
          &lt;option value = "dist"   &gt;Distribution  &lt;/option&gt;
          &lt;option value = "author" &gt;Author        &lt;/option&gt;
          &lt;option value = "doc"    &gt;Documentation &lt;/option&gt;
        &lt;/select&gt;
        &lt;input type = "text"   name  = "query"  /&gt;&lt;br /&gt;
        &lt;input type = "submit" value = "Search" /&gt;
      &lt;/form&gt;
END
  };
  $@ ? "CPAN seems to be down; connection trouble&lt;br /&gt;\n" : $str;
%]</patch_code>
<applied>2006-02-08 13:12:30</applied>
<htmlcode_id>31304</htmlcode_id>
<live_code>[%
  my $str;
  my $NL;

  eval{
    use XML::RSS;
    use LWP::Simple;
    my $xml = LWP::Simple::get( 'http://search.cpan.org/uploads.rdf' );
    my $rss = XML::RSS-&gt;new;
    $rss-&gt;parse( $xml );
    my @items = @{ $rss-&gt;{items} };
    @items = @items[0..24]
      if @items &gt; 25;
    $str .= qq(&lt;li&gt;&lt;a href = "$_-&gt;{link}"&gt;$_-&gt;{title}&lt;/a&gt;&lt;/li&gt;\n)
      for @items;
    $str =~ s!search.cpan.org,\s+!!g;
    $str = htmlcode('split_html','',$str);
    $str = '&lt;ul class="spacey-list"&gt;'.$str.'&lt;/ul&gt;';
    $str .= &lt;&lt;'END';
      &lt;form method = get action="http://search.cpan.org/search"&gt;
        &lt;select name = "mode"&gt;
          &lt;option value = "module" &gt;Module        &lt;/option&gt;
          &lt;option value = "dist"   &gt;Distribution  &lt;/option&gt;
          &lt;option value = "author" &gt;Author        &lt;/option&gt;
          &lt;option value = "doc"    &gt;Documentation &lt;/option&gt;
        &lt;/select&gt;
        &lt;input type = "text"   name  = "query"  /&gt;&lt;br /&gt;
        &lt;input type = "submit" value = "Search" /&gt;
      &lt;/form&gt;
END
  };
  $@ ? "CPAN seems to be down; connection trouble&lt;br /&gt;\n" : $str;
%]
</live_code>
<reason>prevent the cpan nodelet from bloating the nodelet bar</reason>
<field>nlcode</field>
</record>
<record><htmlcode_id>774933</htmlcode_id>
<patch_code>[%
  my $nid = getId($NODE);
  my %converter = (
      snippet =&gt; sub {
          linkNode( getNode("Snippet Mover", 'superdoc'),
                            "resection",
                    { snippet_id =&gt; $nid , -title =&gt; 'Move snippet' } );
      },

      sourcecode =&gt; sub {
          linkNode( getNode("Sourcecode Mover", 'superdoc'),
                            "resection",
                    { sourcecode_id =&gt; $nid , -title =&gt; 'Move sourcecode' } );
      },

      modulereview =&gt; sub {
          linkNode( getNode("Review Mover", 'superdoc'),
                            "resection",
                    { review_id =&gt; $nid , -title =&gt; 'Move review' } );
      },

      note =&gt; sub {
          linkNode( getNode("Reply Promoter", 'superdoc'),
                            "promote",
                    { note_id =&gt; $nid , -title =&gt; 'Promote to root node' } )
      },
  );
  $converter{bookreview} = $converter{modulereview};

  my $is_janitorable = htmlcode('isJanitorable', '', $NODE);
  my $dt= $q-&gt;param("displaytype") || '';

  my $str = join( "\n",
    ( 'display' eq $dt ? "re" : "" ),
    linkNode( $nid, "display", { displaytype =&gt; 'display' } ),

    $is_janitorable
      ? ( 'editors' eq $dt ? "re" : "" )
        . linkNode( $nid, "edit", { displaytype =&gt; 'editors' } )
      : "edit",
    " | ",

    $is_janitorable
      ? linkNode( getNode('Thread Retitler','superdoc'), "retitle",
                  { node_tr =&gt; $nid , -title =&gt; 'Thread Retitler' } )
      : "retitle",

    htmlcode('isNoteWorthy', '', $NODE)
      ? linkNode( getNode("The editors' hall of mirrors and trickery",'superdoc'),
                  "reparent",
                  { mnode =&gt; $nid , -title =&gt; 'Reply Mover' } )
      : "reparent",

    exists $converter{ $NODE-&gt;{type}{title} }
      ? $converter{ $NODE-&gt;{type}{title} }-&gt;()
      : '',

    ' | ',
    htmlcode( 'linkWiki', "editors' wiki", 'wiki', '(*)' ),
    htmlcode( 'toInbox','', 'janitors', '[/msgs](&lt;b&gt;%d&lt;/b&gt;)', '/msgs' ),
    ' | ',
    linkNode(getNode('Nodes to consider','superdoc'),
             'ntc', {-title =&gt; 'Nodes to consider'}),
    linkNode(getNode('nodes requiring editing','superdoc'),
             'nre', {-title =&gt; 'Nodes requiring editing'}),
    linkNode(getNode('Editor Requests','superdoc'),
             'er',  {-title =&gt; 'Editor requests'}),
    htmlcode('linkRJE','rje'),
    ' | ',
    linkNode(getNode("Janitors' Guidelines",'sitefaqlet'),
             'guide', {-title =&gt; 'Janitorial guidelines'}),
    linkNode(getNode("Janitor Tools", 'sitefaqlet'),
             'tools', {-title =&gt; 'Janitor Tools'}),

  );

  require Everything::WebServerId;
  $str .= qq[
    &lt;!-- HTTPd PID = $$($Everything::WebServerId::short) --&gt;];

  my %move_types = map {$_ =&gt; 1} qw/perltutorial perlnews offtopicroot/;
  my $mover;
  if( $move_types{ $NODE-&gt;{type}{title} }
      and $mover = htmlcode('writeupmover')
  )
  {
    $str .= qq[
      ] . htmlcode('openform') . qq[
      Move to:&lt;br /&gt;
      $mover
      ] . htmlcode('closeform') . qq[&lt;br /&gt;
      ];
  }

  return join "&lt;br /&gt;\n", grep $_,
    $str,
    htmlcode('removelinks'),
    htmlcode( 'editor_vote','', getId($NODE), 'd', 'Delete' );
%]
</patch_code>
<applied>2009-06-26 02:15:28</applied>
<htmlcode_id>59490</htmlcode_id>
<live_code>[%
  my $nid = getId($NODE);
  my %converter = (
      snippet =&gt; sub {
          linkNode( getNode("Snippet Mover", 'superdoc'),
                            "resection",
                    { snippet_id =&gt; $nid , -title =&gt; 'Move snippet' } );
      },

      sourcecode =&gt; sub {
          linkNode( getNode("Sourcecode Mover", 'superdoc'),
                            "resection",
                    { sourcecode_id =&gt; $nid , -title =&gt; 'Move sourcecode' } );
      },

      modulereview =&gt; sub {
          linkNode( getNode("Review Mover", 'superdoc'),
                            "resection",
                    { review_id =&gt; $nid , -title =&gt; 'Move review' } );
      },

      note =&gt; sub {
          linkNode( getNode("Reply Promoter", 'superdoc'),
                            "promote",
                    { note_id =&gt; $nid , -title =&gt; 'Promote to root node' } )
      },
  );
  $converter{bookreview} = $converter{modulereview};

  my $is_janitorable = htmlcode('isJanitorable', '', $NODE);
  my $dt= $q-&gt;param("displaytype") || '';

  my $str = join( "\n",
    ( 'display' eq $dt ? "re" : "" ),
    linkNode( $nid, "display", { displaytype =&gt; 'display' } ),

    $is_janitorable
      ? ( 'editors' eq $dt ? "re" : "" )
        . linkNode( $nid, "edit", { displaytype =&gt; 'editors' } )
      : "edit",
    " | ",

    $is_janitorable
      ? linkNode( getNode('Thread Retitler','superdoc'), "retitle",
                  { node_tr =&gt; $nid , -title =&gt; 'Thread Retitler' } )
      : "retitle",

    htmlcode('isNoteWorthy', '', $NODE)
      ? linkNode( getNode("The editors' hall of mirrors and trickery",'superdoc'),
                  "reparent",
                  { mnode =&gt; $nid , -title =&gt; 'Reply Mover' } )
      : "reparent",

    exists $converter{ $NODE-&gt;{type}{title} }
      ? $converter{ $NODE-&gt;{type}{title} }-&gt;()
      : '',

    ' | ',
    htmlcode( 'linkWiki', "editors' wiki", 'wiki', '(*)' ),
    htmlcode( 'toInbox','', 'janitors', '/msgs', '(%d)' ),
    ' | ',
    linkNode(getNode('Nodes to consider','superdoc'),
             'ntc', {-title =&gt; 'Nodes to consider'}),
    linkNode(getNode('nodes requiring editing','superdoc'),
             'nre', {-title =&gt; 'Nodes requiring editing'}),
    linkNode(getNode('Editor Requests','superdoc'),
             'er',  {-title =&gt; 'Editor requests'}),
    htmlcode('linkRJE','rje'),
    ' | ',
    linkNode(getNode("Janitors' Guidelines",'sitefaqlet'),
             'guide', {-title =&gt; 'Janitorial guidelines'}),
    linkNode(getNode("Janitor Tools", 'sitefaqlet'),
             'tools', {-title =&gt; 'Janitor Tools'}),

  );

  require Everything::WebServerId;
  $str .= qq[
    &lt;!-- HTTPd PID = $$($Everything::WebServerId::short) --&gt;];

  my %move_types = map {$_ =&gt; 1} qw/perltutorial perlnews offtopicroot/;
  my $mover;
  if( $move_types{ $NODE-&gt;{type}{title} }
      and $mover = htmlcode('writeupmover')
  )
  {
    $str .= qq[
      ] . htmlcode('openform') . qq[
      Move to:&lt;br /&gt;
      $mover
      ] . htmlcode('closeform') . qq[&lt;br /&gt;
      ];
  }

  return join "&lt;br /&gt;\n", grep $_,
    $str,
    htmlcode('removelinks'),
    htmlcode( 'editor_vote','', getId($NODE), 'd', 'Delete' );
%]
</live_code>
<reason>Preserve prior (lower)case, wrap code</reason>
<field>nlcode</field>
</record>
<record><htmlcode_id>296133</htmlcode_id>
<patch_code>[{openform}]
&lt;input type="hidden" name="op" value="nodelet" /&gt;
[%
  my $which = getId($NODE) == 131 || $VARS-&gt;{fpeqnonfp} ? 'fpnodelets' : 'nodelets';
  $which = 'nodelets' if $ENV{HTTP_HOST} =~ /^ns4/; # this should change
  my $nodelets = $VARS-&gt;{$which};

  my @list = map {
    getNodeById( $_, 'light' )
  } grep {
    -1 == index( ",$nodelets,", ",$_," )
  } split /,/, htmlcode( 'allowed nodelets' );

  return $q-&gt;popup_menu(
    'add',
    [ map getId($_), grep ref, @list ],
    getId( $list[0] ),
    { map { getId($_) =&gt; $_-&gt;{title} } @list }
  );
%]
&lt;input type="submit" value="add" name="kthxbi" /&gt;
&lt;input type="radio" name="topside" VALUE="yes" /&gt;Top
&lt;input type="radio" name="topside" VALUE="no" checked /&gt;Bottom
&lt;/form&gt;</patch_code>
<applied>2003-10-02 20:21:52</applied>
<htmlcode_id>61383</htmlcode_id>
<live_code>[{openform}]
&lt;input type="hidden" name="op" value="nodelet" /&gt;
[%
  my $which = getId($NODE) == 131 || $VARS-&gt;{fpeqnonfp} ? 'fpnodelets' : 'nodelets';
  $which = 'nodelets' if $ENV{HTTP_HOST} =~ /^css/;
  my $nodelets = $VARS-&gt;{$which};

  my @list = map {
    getNodeById( $_, 'light' )
  } grep {
    -1 == index( ",$nodelets,", ",$_," )
  } split /,/, htmlcode( 'allowed nodelets' );

  return $q-&gt;popup_menu(
    'add',
    [ map getId($_), grep ref, @list ],
    getId( $list[0] ),
    { map { getId($_) =&gt; $_-&gt;{title} } @list }
  );
%]
&lt;input type="submit" value="add" name="kthxbi" /&gt;
&lt;br /&gt;
&lt;input type="radio" name="topside" VALUE="yes" /&gt;Top
&lt;input type="radio" name="topside" VALUE="no" checked /&gt;Bottom
&lt;/form&gt;</live_code>
<reason>Adding add to top functionality</reason>
<field>nlcode</field>
</record>
<record><htmlcode_id>525650</htmlcode_id>
<patch_code>[{adminbar}]&lt;br /&gt;

   &lt;form action="?" method="get" style="margin-bottom: 5px"&gt;
    &lt;input type="text" name="node" value=""
           maxlength="240" style="width: 60px" /&gt;
    &lt;input type="submit" name="" value="Node" style="width: 60px" /&gt;
   &lt;/form&gt;&lt;br /&gt;
   &lt;form action="?" method="get" style="margin-bottom: 5px"&gt;
    &lt;input type="text" name="node_id" value=""
           maxlength="240" style="width: 60px" /&gt;
    &lt;input type="submit" name="" value="ID" style="width: 60px" /&gt;
   &lt;/form&gt;&lt;br /&gt;
   &lt;form action="?" method="get" style="margin-bottom: 5px"&gt;
    &lt;input type="text" name="op" value=""
           maxlength="240" style="width: 60px" /&gt;
    &lt;input type="submit" name="" value="Op" style="width: 60px" /&gt;
    &lt;input type="hidden" name="node_id"
           value="[% $NODE-&gt;{node_id} %]" /&gt;
   &lt;/form&gt;&lt;br /&gt;
   &lt;form action="?" method="get" style="margin-bottom: 5px"&gt;
    &lt;input type="text" name="displaytype" value=""
           maxlength="240" style="width: 60px" /&gt;
    &lt;input type="submit" name="" value="Display" style="width: 60px" /&gt;
    &lt;input type="hidden" name="node_id"
           value="[% $NODE-&gt;{node_id} %]" /&gt;
   &lt;/form&gt;&lt;br /&gt;
   [% linkNodeTitle("gods' arcade|Gods' Arcade") %]
   [% htmlcode( 'linkWiki', q/gods' wiki/, 'gw', '(*)' ) %]
   [% htmlcode( 'toInbox', 'gods', '[inbox](&lt;b&gt;%d&lt;/b&gt;)', 'inbox' ) %]&lt;br /&gt;

[% linkNode(getNode('create node', 'superdoc'), 'Create new node') %]&lt;br /&gt;
</patch_code>
<applied>2006-01-26 02:02:43</applied>
<htmlcode_id>160711</htmlcode_id>
<live_code>[%
  return join '', map '&lt;ul class="word-list"&gt;'.$_.'&lt;/ul&gt;',
    join "\n",
      htmlcode('adminbar'),
      map '&lt;li&gt;'.$_.'&lt;/li&gt;',
        linkNode( getNode('create node','superdoc'), 'create' ),
        htmlcode( 'linkWiki', "gods' wiki", 'gw', '(*)' ),
        htmlcode( 'toInbox', 'gods', 'inbox', '(%d)' ),
        linkNodeTitle("gods' arcade|arcade"),
%]
</live_code>
<reason>Shorten URLs, spaces around = tickle browser bugs, 'cw' elsewhere, etc</reason>
<field>nlcode</field>
</record>
<record><htmlcode_id>773063</htmlcode_id>
<patch_code>[%
  my $nodeid = linkNode( $NODE, getId($NODE) );
  my $type = linkNode( $NODE-&gt;{type} );

  my $htmlpage = linkNode( getPageForType(
    $NODE-&gt;{type},
    $q-&gt;param('displaytype') || 'display' )
  );

  my @dump;
  @dump = ($q-&gt;a(
    {
      href =&gt; urlGen( {
        node   =&gt; "Dump node fields",
        type   =&gt; "superdoc",
        dumpid =&gt; getId($NODE)
      }, -1)
    },
    "Dump Fields"
  ))
  if isGod($USER) || canUpdateNode($USER,$NODE);

  my $code  = linkNode($NODE, 'View&amp;nbsp;Code', { displaytype =&gt; 'viewcode' })
    if htmlcode('lookup_patchable_field');
  $code   ||= 'View&amp;nbsp;Code';

  my $containers = sprintf qq(&lt;a href=%s&gt;Show&amp;nbsp;Containers&lt;/a&gt;\n),
    urlGen({ 
      node_id     =&gt; getId($NODE),
      displaytype =&gt; $query-&gt;param('displaytype') || 'display',
      containers  =&gt; 'show'
    });
  my $msgs   = htmlcode( 'toInbox','', 'pmdev',
      '&lt;b&gt;%d&lt;/b&gt;[/msgs]', '/msgs' ),
  my $wiki   = htmlcode( 'linkWiki', 'pmdev wiki', 'Dev&amp;nbsp;Wiki', '(*)');
  my $todo   = htmlcode( 'linkWiki', 'pmdev to-do wiki', 'Todo&amp;nbsp;Wiki', '(*)');
  my $cabal  = htmlcode( 'linkWiki', 322009, 'Cabal&amp;nbsp;Wiki', '(*)');
  my $howto  = htmlcode( 'linkWiki', 461491, 'HowTo&amp;nbsp;Wiki', '(*)');
  my $list   = linkNodeTitle('Node Lister|Nodes');
  my $patch  = linkNodeTitle('Patch Lister|Patches');
  my $tree   = linkNode( 386578,'Types' );
  if ( $DB-&gt;sqlSelect( 'MAX(patch_id)', 'patch' ) &gt; $VARS-&gt;{patchlisterlast} ) {
    $patch .= '(*)';
  }
  my $search = linkNodeTitle('Search internal code|Search&amp;nbsp;code');
  my $bible  = join '',
    '&lt;a href="http://web.archive.org/web/20080101111220/',
    'http://everydevel.com/index.pl?node=The+Everything+Bible"&gt;',
    'Everything&amp;nbsp;Bible&lt;/a&gt;';
  my $chrome = join '',
    '&lt;a href="http://web.archive.org/web/20050302045849/',
    'http://www.everydevel.com/index.pl?node=chromatic"&gt;',
    "chromatic's&amp;nbsp;Library&lt;/a&gt;";
  my $bpnl = linkNodeTitle('Big Pretty Nodelist|BPNL');

  return join( ' | ',
    qq(&lt;small&gt;#$nodeid = $type via $htmlpage&lt;/small&gt;),
    @dump,
    $code,
    $containers,
    $msgs,
    $wiki,
    $todo,
    $howto,
    $cabal,
    $tree,
    $list,
    $bpnl,
    $patch,
    $search,
    $bible,
    $chrome,
  );
%]
</patch_code>
<applied>2009-06-19 11:09:25</applied>
<htmlcode_id>160734</htmlcode_id>
<live_code>[%
  my $nodeid = linkNode( $NODE, getId($NODE) );
  my $type = linkNode( $NODE-&gt;{type} );

  my $htmlpage = linkNode( getPageForType(
    $NODE-&gt;{type},
    $q-&gt;param('displaytype') || 'display' )
  );

  my @dump;
  @dump = ($q-&gt;a(
    {
      href =&gt; urlGen( {
        node   =&gt; "Dump node fields",
        type   =&gt; "superdoc",
        dumpid =&gt; getId($NODE)
      }, -1)
    },
    "Dump Fields"
  ))
  if isGod($USER) || canUpdateNode($USER,$NODE);

  my $code  = linkNode($NODE, 'View&amp;nbsp;Code', { displaytype =&gt; 'viewcode' })
    if htmlcode('lookup_patchable_field');
  $code   ||= 'View&amp;nbsp;Code';

  my $containers = sprintf qq(&lt;a href=%s&gt;Show&amp;nbsp;Containers&lt;/a&gt;\n),
    urlGen({ 
      node_id     =&gt; getId($NODE),
      displaytype =&gt; $query-&gt;param('displaytype') || 'display',
      containers  =&gt; 'show'
    });
  my $msgs   = htmlcode( 'toInbox', 'pmdev', 'inbox', '(%d)' ),
  my $wiki   = htmlcode( 'linkWiki', 'pmdev wiki', 'Dev&amp;nbsp;Wiki', '(*)');
  my $todo   = htmlcode( 'linkWiki', 'pmdev to-do wiki', 'Todo&amp;nbsp;Wiki', '(*)');
  my $cabal  = htmlcode( 'linkWiki', 322009, 'Cabal&amp;nbsp;Wiki', '(*)');
  my $howto  = htmlcode( 'linkWiki', 461491, 'HowTo&amp;nbsp;Wiki', '(*)');
  my $list   = linkNodeTitle('Node Lister|Nodes');
  my $patch  = linkNodeTitle('Patch Lister|Patches');
  my $tree   = linkNode( 386578,'Types' );
  if ( $DB-&gt;sqlSelect( 'MAX(patch_id)', 'patch' ) &gt; $VARS-&gt;{patchlisterlast} ) {
    $patch .= '(*)';
  }
  my $search = linkNodeTitle('Search internal code|Search&amp;nbsp;code');
  my $bible  = join '',
    '&lt;a href="http://web.archive.org/web/20080101111220/',
    'http://everydevel.com/index.pl?node=The+Everything+Bible"&gt;',
    'Everything&amp;nbsp;Bible&lt;/a&gt;';
  my $chrome = join '',
    '&lt;a href="http://web.archive.org/web/20050302045849/',
    'http://www.everydevel.com/index.pl?node=chromatic"&gt;',
    "chromatic's&amp;nbsp;Library&lt;/a&gt;";
  my $bpnl = linkNodeTitle('Big Pretty Nodelist|BPNL');

  return '&lt;ul class="inline-list"&gt;' . join( '',
    map { '&lt;li&gt;'.$_.'&lt;/li&gt;' }
    qq(&lt;small&gt;#$nodeid = $type via $htmlpage&lt;/small&gt;),
    @dump,
    $code,
    $containers,
    $msgs,
    $wiki,
    $todo,
    $howto,
    $cabal,
    $tree,
    $list,
    $bpnl,
    $patch,
    $search,
    $bible,
    $chrome,
  ) . '&lt;/ul&gt;';
%]
</live_code>
<reason>wups - lost the first sep bar</reason>
<field>nlcode</field>
</record>
<record><htmlcode_id>191375</htmlcode_id>
<patch_code>&lt;center&gt;Navigate all nodes:&lt;/center&gt;
[%
   my $nid= getId($NODE);
   my $pst= $DB-&gt;sqlSelect( "max(node_id)", "node", "node_id&lt;$nid" );
   my $nst= $DB-&gt;sqlSelect( "min(node_id)", "node", "$nid&lt;node_id" );

   my $str= '';
   $str .= "&amp;lt;&amp;nbsp;" . linkNode( $pst )   if  $pst;
   $str .= " | ";
   $str .= linkNode( $nst ) . "&amp;nbsp;&amp;gt;"    if  $nst;

   return "&lt;center&gt;$str&lt;/center&gt;";
%]

   &lt;hr /&gt;
   &lt;center&gt;Navigate nodes of type [% $NODE-&gt;{type}{title} %]:&lt;/center&gt;
[%
   my $nid= getId($NODE);
   my $pst= $DB-&gt;sqlSelect( "max(node_id)", "node",
      "type_nodetype=$NODE-&gt;{type_nodetype} and node_id&lt;$nid" );
   my $nst= $DB-&gt;sqlSelect( "min(node_id)", "node",
      "type_nodetype=$NODE-&gt;{type_nodetype} and $nid&lt;node_id" );

   my $str= '';
   $str .= "&amp;lt;&amp;nbsp;" . linkNode( $pst )   if  $pst;
   $str .= " | ";
   $str .= linkNode( $nst ) . "&amp;nbsp;&amp;gt;"    if  $nst;

   return "&lt;center&gt;$str&lt;/center&gt;";
%]

   &lt;hr /&gt;
   &lt;center&gt;
      Navigate nodes authored by [% linkNode($NODE-&gt;{author_user}) %]:
   &lt;/center&gt;
[%
   my $nid= getId($NODE);
   my $pst= $DB-&gt;sqlSelect( "max(node_id)", "node",
      "author_user=$NODE-&gt;{author_user} and node_id&lt;$nid" );
   my $nst= $DB-&gt;sqlSelect( "min(node_id)", "node",
      "author_user=$NODE-&gt;{author_user} and $nid&lt;node_id" );

   my $str= '';
   $str .= "&amp;lt;&amp;nbsp;" . linkNode( $pst )   if  $pst;
   $str .= " | ";
   $str .= linkNode( $nst ) . "&amp;nbsp;&amp;gt;"    if  $nst;

   return "&lt;center&gt;$str&lt;/center&gt;";
%]
</patch_code>
<applied>2004-03-08 01:30:40</applied>
<htmlcode_id>183108</htmlcode_id>
<live_code>&lt;center&gt;Navigate all nodes:&lt;/center&gt;
[%
   my $nid= getId($NODE);
   my $pst= $DB-&gt;sqlSelect( "max(node_id)", "node", "node_id&lt;$nid" );
   my $nst= $DB-&gt;sqlSelect( "min(node_id)", "node", "$nid&lt;node_id" );

   my $str= '';
   $str .= "&amp;lt;&amp;nbsp;" . linkNode( $pst )   if  $pst;
   $str .= " | ";
   $str .= linkNode( $nst ) . "&amp;nbsp;&amp;gt;"    if  $nst;

   return htmlcode('split_html', '', "&lt;center&gt;$str&lt;/center&gt;");
%]

   &lt;hr /&gt;
   &lt;center&gt;Navigate nodes of type [% $NODE-&gt;{type}{title} %]:&lt;/center&gt;
[%
   my $nid= getId($NODE);
   my $pst= $DB-&gt;sqlSelect( "max(node_id)", "node",
      "type_nodetype=$NODE-&gt;{type_nodetype} and node_id&lt;$nid" );
   my $nst= $DB-&gt;sqlSelect( "min(node_id)", "node",
      "type_nodetype=$NODE-&gt;{type_nodetype} and $nid&lt;node_id" );

   my $str= '';
   $str .= "&amp;lt;&amp;nbsp;" . linkNode( $pst )   if  $pst;
   $str .= " | ";
   $str .= linkNode( $nst ) . "&amp;nbsp;&amp;gt;"    if  $nst;

   return htmlcode('split_html', '', "&lt;center&gt;$str&lt;/center&gt;");
%]

   &lt;hr /&gt;
   &lt;center&gt;
      Navigate nodes authored by [% linkNode($NODE-&gt;{author_user}) %]:
   &lt;/center&gt;
[%
   my $nid= getId($NODE);
   my $pst= $DB-&gt;sqlSelect( "max(node_id)", "node",
      "author_user=$NODE-&gt;{author_user} and node_id&lt;$nid" );
   my $nst= $DB-&gt;sqlSelect( "min(node_id)", "node",
      "author_user=$NODE-&gt;{author_user} and $nid&lt;node_id" );

   my $str= '';
   $str .= "&amp;lt;&amp;nbsp;" . linkNode( $pst )   if  $pst;
   $str .= " | ";
   $str .= linkNode( $nst ) . "&amp;nbsp;&amp;gt;"    if  $nst;

   return htmlcode('split_html', '', "&lt;center&gt;$str&lt;/center&gt;");
%]
</live_code>
<reason>Use indices! *yeah*</reason>
<field>nlcode</field>
</record>
<record><htmlcode_id>772722</htmlcode_id>
<patch_code>[%
  my ($history,$rebless)=('','');
  if ( htmlcode('CanSdcEdit') ) {
    $history= linkNode( getId($NODE), "Node history", 
                            { displaytype =&gt; 'edithistory' } );
    my %known=(sitedoclet =&gt; 'doc', sitefaqlet =&gt; 'faq', alphafaqlet =&gt; 'alpha' );
    if ( $known{$NODE-&gt;{type}{title}} &amp;&amp; Everything::isApproved($USER,'SiteDocClan') ) {
        my @links;
        foreach my $key (sort keys %known) {
            if ($key ne $NODE-&gt;{type}{title}) {
              push @links,linkNode( $NODE, $known{$key}, { op=&gt;'sdc_rebless', sdc_rebless_to =&gt; $key } );
            }
        }
        $rebless= join " ","Rebless as ",@links;
    }
  }

  my $sdl_text='';
  if ( $NODE-&gt;{type}{title} =~ /superdoc|setting|nodelet/ ) {
    my $sdl = getNode($NODE-&gt;{title}." sitedoclet", "sitedoclet");
    $sdl_text= $sdl ? linkNode( $sdl, "Edit SiteDoclet", { displaytype =&gt; 'edit' } ) : "";
  } elsif ( $NODE-&gt;{type}{title} eq 'sitedoclet') {
    (my $title= $NODE-&gt;{title})=~s/ sitedoclet$//i;
    my $sd = getNode($title, "superdoc");
    $sdl_text= $sd ? linkNode( $sd, "View Superdoc") : "";
  }

  return join ' | ', grep length($_),
    $sdl_text, $history, $rebless,
    htmlcode('get_sitedoclet','SiteDocClan Nodelet sitedoclet');

%]</patch_code>
<applied>2009-06-19 10:45:23</applied>
<htmlcode_id>245004</htmlcode_id>
<live_code>[%
  my ($history,$rebless)=('','');
  if ( htmlcode('CanSdcEdit') ) {
    $history= linkNode( getId($NODE), "Node history", 
                            { displaytype =&gt; 'edithistory' } );
    my %known=(sitedoclet =&gt; 'doc', sitefaqlet =&gt; 'faq', alphafaqlet =&gt; 'alpha' );
    if ( $known{$NODE-&gt;{type}{title}} &amp;&amp; Everything::isApproved($USER,'SiteDocClan') ) {
        my @links;
        foreach my $key (sort keys %known) {
            if ($key ne $NODE-&gt;{type}{title}) {
              push @links,linkNode( $NODE, $known{$key}, { op=&gt;'sdc_rebless', sdc_rebless_to =&gt; $key } );
            }
        }
        $rebless= join " ","Rebless as ",@links;
    }
  }

  my $sdl_text='';
  if ( $NODE-&gt;{type}{title} =~ /superdoc|setting|nodelet/ ) {
    my $sdl = getNode($NODE-&gt;{title}." sitedoclet", "sitedoclet");
    $sdl_text= linkNode( $sdl, "Edit SiteDoclet", { displaytype =&gt; 'edit' } ) if $sdl;
  } elsif ( $NODE-&gt;{type}{title} eq 'sitedoclet') {
    (my $title= $NODE-&gt;{title})=~s/ sitedoclet$//i;
    my $sd = getNode($title, "superdoc");
    $sdl_text= linkNode( $sd, "View Superdoc") if $sd;
  }

  htmlcode( 'get_sitedoclet', 'SiteDocClan Nodelet sitedoclet',
    ( -SDL     =&gt; $sdl_text ? '&lt;li&gt;'.$sdl_text : '' ),
    ( -HISTORY =&gt; $history  ? '&lt;li&gt;'.$history  : '' ),
    ( -REBLESS =&gt; $rebless  ? '&lt;li&gt;'.$rebless  : '' ),
  );
%]
</live_code>
<reason>show 'edit sitedoclet' link for other supported types</reason>
<field>nlcode</field>
</record>
<record><htmlcode_id>546962</htmlcode_id>
<patch_code>[%
return '' if $USER-&gt;{node_id} == $HTMLVARS{guest_user};
my $infolink = 'My info';
htmlcode('link_list',
  list=&gt; [ 
           ($NODE-&gt;{node_id} eq $USER-&gt;{node_id} &amp;&amp; $q-&gt;param('displaytype') eq 'edit')
             ? $infolink 
             : linkNode($USER,$infolink,{displaytype=&gt;'edit'}), 
           @{getNode('Settings Nodes','faqlist')-&gt;{group}},
         ], 
  tag=&gt;'div', 
  class=&gt;'setting-nodelet',
  titlesub=&gt; sub{ my $title= $_-&gt;{title}; $title =~ s/\s+Settings$//i; $title },
)
%]
</patch_code>
<applied>2006-05-04 16:50:42</applied>
<htmlcode_id>403577</htmlcode_id>
<live_code>[%
  $USER-&gt;{node_id} == $HTMLVARS{guest_user} ? '' :
  htmlcode( 'get_sitedoclet', 'Settings Nodelet sitedoclet',
    -USER_LINKS =&gt; map qq(&lt;li&gt;$_&lt;/li&gt;),
      $NODE-&gt;{node_id} eq $USER-&gt;{node_id} &amp;&amp; $q-&gt;param('displaytype') eq 'edit'
        ? 'My info'
        : linkNode( $USER, 'My info', { displaytype =&gt; 'edit' } )
  )
%]
</live_code>
<reason>harmonize with link on homenode, and disambiguate from Personal Nodelet</reason>
<field>nlcode</field>
</record>
<record><htmlcode_id>513566</htmlcode_id>
<patch_code>[%
   my @N;
   {
      # select nodes in danger of being reaped
      my $csr=$DB-&gt;sqlSelectMany(
         "*", "considernodes", "del&gt;0 and 2*keep+edit&lt;4", "order by considertime desc" );
      my $N;
      while(  $N= $csr-&gt;fetchrow_hashref()  ) {
         push @N, $N;
      }
      $csr-&gt;finish();
   }

   my $reaps = htmlcode( 'toInbox','', 'root', "&lt;b&gt;\%d&lt;/b&gt; [(un)reaps/borgs]&lt;br /&gt;\n", 'xyzzy' );
   $reaps =~ s/.*xyzzy.*//s;
   # remove s's if just one message
   $reaps =~ s!(\b1\b.*reap)s/borgs!$1/borg!;

   my $msgs = htmlcode( 'toInbox','', 'NodeReaper', "&lt;b&gt;\%d&lt;/b&gt; [msgs]&lt;br /&gt;\n", 'plugh' );
   $msgs =~ s/.*plugh.*//s;
   $msgs =~ s/\b(1\b.*msg)s/$1/;

   my $str = join "",
      $reaps,
      $msgs,
      map {
         sprintf "%s K/E/D:%d/%d/%d&lt;br /&gt;\n",
            linkNode( $_-&gt;{considernodes_id} ),
            @$_{ qw/keep edit del/ }
      } @N;

   $str;
%]</patch_code>
<applied>2005-12-02 06:42:55</applied>
<htmlcode_id>486752</htmlcode_id>
<live_code>[%
   my @N;
   {
      # select nodes in danger of being reaped
      my $csr=$DB-&gt;sqlSelectMany(
         "*", "considernodes", "del&gt;0 and 2*keep+edit&lt;4", "order by considertime desc" );
      my $N;
      while(  $N= $csr-&gt;fetchrow_hashref()  ) {
         push @N, $N;
      }
      $csr-&gt;finish();
   }

   my $reaps = htmlcode( 'toInbox', 'root', '(un)reaps/borgs:', '%d' );
   $reaps=''  unless $reaps =~ /inboxupdate/;
   $reaps .= "&lt;br/&gt;\n" if $reaps;

   my $msgs = htmlcode( 'toInbox', 'NodeReaper', 'msgs:', '%d' );
   $msgs=''  unless $msgs =~ /inboxupdate/;
   $msgs .= "&lt;br/&gt;\n" if $msgs;

   my $str = join "",
      $reaps,
      $msgs,
      map {
         sprintf "%s K/E/D:%d/%d/%d&lt;br /&gt;\n",
            linkNode( $_-&gt;{considernodes_id} ),
            @$_{ qw/keep edit del/ }
      } @N;

   $str;
%]</live_code>
<reason>root gets borg msgs now</reason>
<field>nlcode</field>
</record>
<record><htmlcode_id>725850</htmlcode_id>
<patch_code>&lt;!-- Nodelet Break --&gt;
[%
  # Code cleansed by Petruchio Tuesday March 26th 2002

  my $title = $NODELET-&gt;{title};
  my $name  = $title;
  $name   =~ s/ /_/g;
  $name   =~ s/'//g;

  my $var = "conceal.$NODELET-&gt;{node_id}";
  my $on  = '&amp;oplus;';
  my $off = '&amp;#8854;';

  my @display = ( displaytype =&gt; $q-&gt;param('displaytype') || 'display' );

  my $flip = linkNode(
    $NODE,
    ( $VARS-&gt;{$var} eq 'on' ? $on : $off ),
    { node_id =&gt; getId($NODE), op =&gt; 'changevar', "set$var" =&gt; $VARS-&gt;{$var} eq 'on' ? 'off' : 'on', @display },
    { title =&gt; $VARS-&gt;{$var} eq 'on' ? 'Show nodelet' : 'Conceal nodelet' }
  );

  my @args = ( node_id =&gt; getId($NODE), @display, op =&gt; 'nodelet' );
  my $nid  = getId($NODELET);

  my $up = linkNode(
    $NODE,
    '&amp;#8593;',
    { @args, direction =&gt; 'up', move =&gt; $nid, -title =&gt; 'Move nodelet up.'}
  );

  my $down = linkNode(
    $NODE,
    '&amp;#8595;',
    { @args, direction =&gt; 'down', move =&gt; $nid, -title =&gt; 'Move nodelet down.' }
  );

  my $remove = linkNode(
   $NODE,
   '&amp;otimes;',
   { @args, remove =&gt; $nid, -title =&gt; 'Remove this nodelet.' }
  );

  $title =
    qq(&lt;span class="title"&gt;$title&lt;/span&gt; &lt;span class="controls"&gt;$up $down $flip $remove&lt;/span&gt;)
      if grep { $USER-&gt;{title} eq $_ }
        qw/hiip ar0n Petruchio larsen Macphisto jcwren JayBonci boo_radley vroom/;

my $inner_open  = $VARS-&gt;{'nodelets_as_div'} ? 'div' : 'tr&gt;&lt;td';
my $inner_close = $VARS-&gt;{'nodelets_as_div'} ? 'div' : 'td&gt;&lt;/tr';

  my $body = $VARS-&gt;{$var} eq 'on' ? '' : &lt;&lt;BODY;
      &lt;$inner_open class="nodelet_body"&gt;
CONTAINED_STUFF
      &lt;/$inner_close&gt;
BODY

my $outer = $VARS-&gt;{'nodelets_as_div'} ? 'div' : 'tbody';
$inner_open  = $VARS-&gt;{'nodelets_as_div'} ? 'div' : 'tr&gt;&lt;th';
$inner_close = $VARS-&gt;{'nodelets_as_div'} ? 'div' : 'th&gt;&lt;/tr';

&lt;&lt;END;
    &lt;$outer class="nodelet" id="$name"&gt;
      &lt;$inner_open class="nodelet_head"&gt;
          $title
      &lt;/$inner_close&gt;
$body
    &lt;/$outer&gt;
END

%]</patch_code>
<applied>2009-02-03 11:23:56</applied>
<htmlcode_id>20</htmlcode_id>
<live_code>&lt;!-- Nodelet Break --&gt;
[%
  # Code cleansed by Petruchio Tuesday March 26th 2002

  my $title = $NODELET-&gt;{title};
  my $name  = $title;
  $name   =~ s/ /_/g;
  $name   =~ s/'//g;

  my $var = "conceal.$NODELET-&gt;{node_id}";

  my $inner_open  = $VARS-&gt;{'nodelets_as_div'} ? 'div' : 'tr&gt;&lt;td';
  my $inner_close = $VARS-&gt;{'nodelets_as_div'} ? 'div' : 'td&gt;&lt;/tr';

  my $body = $VARS-&gt;{$var} eq 'on' ? '' : &lt;&lt;BODY;
      &lt;$inner_open class="nodelet_body"&gt;
CONTAINED_STUFF
      &lt;/$inner_close&gt;
BODY

  my $outer = $VARS-&gt;{'nodelets_as_div'} ? 'div' : 'tbody';
  $inner_open  = $VARS-&gt;{'nodelets_as_div'} ? 'div' : 'tr&gt;&lt;th';
  $inner_close = $VARS-&gt;{'nodelets_as_div'} ? 'div' : 'th&gt;&lt;/tr';
  my $about = qq(&lt;a href="?node=About the $title" class="nodelethead-annot"&gt;&lt;sup&gt;?&lt;/sup&gt;&lt;/a&gt;);

  &lt;&lt;END;
    &lt;$outer class="nodelet" id="$name"&gt;
      &lt;$inner_open class="nodelet_head"&gt;
          &lt;span class="title"&gt;$title&lt;/span&gt;$about
      &lt;/$inner_close&gt;
$body
    &lt;/$outer&gt;
END

%]
</live_code>
<reason>fix bug: "Cabalists'_Nodelet" doesn't work as an element id value</reason>
<field>context</field>
</record>
<record><htmlcode_id>294620</htmlcode_id>
<patch_code>[%
  my %style= ( bare =&gt; 233637, css =&gt; 233637, normal =&gt; 20 );
  $CURRENTNODE-&gt;{parent_container} = $ENV{HTTP_HOST} =~ /^ns4/ ? $style{css} : 20;
  return '';
%]
CONTAINED_STUFF</patch_code>
<applied>2003-09-27 05:13:40</applied>
<htmlcode_id>1058</htmlcode_id>
<live_code>[%
  my %style= ( bare =&gt; 233637, css =&gt; 233637, normal =&gt; 20 );
  $CURRENTNODE-&gt;{parent_container} = $ENV{HTTP_HOST} =~ /^css/ ? $style{css} : 20;
  return '';
%]
CONTAINED_STUFF</live_code>
<reason>Cleaning unneeded test code</reason>
<field>context</field>
</record>
<record><htmlcode_id>670155</htmlcode_id>
<patch_code>&lt;table width = 100% cellpadding = "0" cellspacing = "0"&gt;

  &lt;tr class = "section_title" width = "100%" border = "1"&gt;
    &lt;td class = "section_title" width = "100%"&gt;
      [%
  my $url      = $HTMLVARS{listapproved}{title};
  my $linkto   = $HTMLVARS{listapproved}{linkto_node_id};
  return $url unless $linkto;
    $_ = urlGen( { node_id =&gt; $url, displaytype =&gt; 'display', lastnode_id =&gt; getId($NODE) } );
  return &lt;&lt;END;
      &lt;h3&gt;
        &lt;a href="$_"&gt;
          $url
        &lt;/a&gt;
      &lt;/h3&gt;
END
%]
    &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td&gt;
      &lt;table width = "100%" border = "0" cellpadding = "2" cellspacing = "0" &gt;
CONTAINED_STUFF
      &lt;/table&gt;
    &lt;/td&gt;
  &lt;/tr&gt;
&lt;/table&gt;
</patch_code>
<applied>2008-03-17 13:20:24</applied>
<htmlcode_id>5393</htmlcode_id>
<live_code>&lt;table width="100%" cellpadding="0" cellspacing="0"&gt;

  &lt;tr class="section_title" width="100%" border="1"&gt;
    &lt;td class="section_title" width="100%"&gt;
[%
    my $title   = $HTMLVARS{listapproved}{title};
    my $linkto  = $HTMLVARS{listapproved}{linkto_node_id};
    return $title
        if  ! $linkto;
    return genLink( $title, { node_id =&gt; $linkto } );
%]
    &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td&gt;
      &lt;table width="100%" border="0" cellpadding="2" cellspacing="0"&gt;
CONTAINED_STUFF
      &lt;/table&gt;
    &lt;/td&gt;
  &lt;/tr&gt;
&lt;/table&gt;
</live_code>
<reason>fontattr not used</reason>
<field>context</field>
</record>
<record><htmlcode_id>489117</htmlcode_id>
<patch_code>&lt;TABLE&gt;
&lt;TR width=100% BGCOLOR=[% return $$THEME{clr_highlight} if($$THEME{clr_highlight}); return "EEDDDD"; %]&gt;&lt;TD&gt;[[% return linkNode($HTMLVARS{embed_node}) %]]
&lt;BR&gt; on [%
      my $str;
      $str.=htmlcode('parsetimestamp',$HTMLVARS{embed_node}{createtime});
      $str;
%]
&lt;/TD&gt;
&lt;TD valign=top&gt;
[%
   my $str;
   my $replytag;
   $replytag=$HTMLVARS{embed_node}{numreplies}." replies" if($HTMLVARS{embed_node}{numreplies}&gt;1);
   $replytag="0 replies" if(!$HTMLVARS{embed_node}{numreplies});
   $replytag="1 reply" if($HTMLVARS{embed_node}{numreplies}==1);
   $str.=linkNode($HTMLVARS{embed_node},"$replytag");
   $str;
%]
&lt;/TD&gt;
&lt;TD valign=top&gt;
by [% if($HTMLVARS{embed_node}{author_user}!=-1 and exists $HTMLVARS{embed_node}{author_user}){
             return linkNode($HTMLVARS{embed_node}{author_user})
          }
          return;
       %]


&lt;/TD&gt;
&lt;/TR&gt;
&lt;TR&gt;&lt;TD COLSPAN=2&gt;
CONTAINED_STUFF
&lt;/TD&gt;&lt;TD&gt;&lt;BR&gt;
&lt;A HREF=[%urlGen ({node =&gt; "Comment on", parent=&gt;getId($HTMLVARS{embed_node}) });%]&gt;&lt;font size=2&gt;&amp;#091;Offer your reply&amp;#093&lt;/font&gt;&lt;/a&gt;
&lt;/TD&gt;&lt;/TR&gt;
&lt;/TABLE&gt;</patch_code>
<applied>2005-09-04 23:13:21</applied>
<htmlcode_id>5491</htmlcode_id>
<live_code>[embed node container2] is not used!</live_code>
<reason>use [Comment on]</reason>
<field>context</field>
</record>
<record><htmlcode_id>775144</htmlcode_id>
<patch_code>&lt;!-- Begin Post --&gt;
&lt;!-- embed node with vote container --&gt;
&lt;tr class="["$HTMLVARS{embed_node}{classprefix}"]post-head post_head"&gt;
  &lt;td&gt;
    &lt;a id  ="post-head-id[% $HTMLVARS{embed_node}{node_id} %]" 
       name="post-head-id[% $HTMLVARS{embed_node}{node_id} %]" 
       href="?node_id=[% $HTMLVARS{embed_node}{node_id} %]"
    &gt;[% $q-&gt;escapeHTML($HTMLVARS{embed_node}{title}) %]&lt;/a&gt;&lt;br /&gt; 
    on [% htmlcode( 'parsetimestamp', $HTMLVARS{embed_node}{createtime} ) %]
  &lt;/td&gt;
  &lt;td valign = "top"&gt;
    [%
       my $n = $HTMLVARS{embed_node}{numreplies};
       my $reply = join '', $n,
         ( $n &gt; 0 &amp;&amp; $VARS-&gt;{repliesdisplay} eq 'repliesbelow' ? ' ' : ' direct ' ),
         ( $n != 1 ? 'replies' : 'reply' );
       linkNode( $HTMLVARS{embed_node}, $reply );
    %]
  &lt;/td&gt;
  &lt;td valign = "top"&gt;
    by [% 
         my $x = $HTMLVARS{embed_node}{author_user} || -1;
         -1 == $x ? '' : linkNode( $x );
       %]
  &lt;/td&gt;
&lt;/tr&gt;
&lt;tr class="["$HTMLVARS{embed_node}{classprefix}"]post-voterep"&gt;
  &lt;td colspan="3" class="voterep"&gt;
  [% htmlcode( 'voteit', getId( $HTMLVARS{embed_node} ) ) %]
  &lt;/td&gt;
&lt;/tr&gt;
&lt;tr class="["$HTMLVARS{embed_node}{classprefix}"]post-body post_body"&gt;
  &lt;td colspan = "2"&gt;
CONTAINED_STUFF
  &lt;/td&gt;
  &lt;td&gt;&lt;br /&gt;
    &lt;a href= [%
      my $x = $HTMLVARS{embed_node};
      my $g = getId( $x );
        urlGen ( 
          {
            node        =&gt; 'Comment on',
            parent      =&gt; $g
          }
        );
        %]&gt;&lt;font size = "2"&gt;&amp;#091;Offer your reply&amp;#093;&lt;/font&gt;&lt;/a&gt;
  &lt;/td&gt;
&lt;/tr&gt;

&lt;!--  End Post  --&gt;
</patch_code>
<applied>2009-06-26 14:48:53</applied>
<htmlcode_id>5917</htmlcode_id>
<live_code>&lt;!-- Begin Post --&gt;
&lt;!-- embed node with vote container --&gt;
&lt;tr class="["$HTMLVARS{embed_node}{classprefix}"]post-head post_head"&gt;
  &lt;td valign="top" style="padding-left:.2em"&gt;
&lt;!-- TITLE --&gt;
    &lt;a id  ="post-head-id[% $HTMLVARS{embed_node}{node_id} %]" 
       name="post-head-id[% $HTMLVARS{embed_node}{node_id} %]" 
       href="?node_id=[% $HTMLVARS{embed_node}{node_id} %]"
    &gt;[% $q-&gt;escapeHTML($HTMLVARS{embed_node}{title}) %]&lt;/a&gt;
&lt;br/&gt;
&lt;!-- REPLIES --&gt;
    [%
       my $n = $HTMLVARS{embed_node}{numreplies};
       if ( $n == 0 ) {
         return join '',
           'No replies &amp;mdash; ',
           linkNode( $HTMLVARS{embed_node}, 'Read more' ),
           ' | ',
           linkNode( 3333, 'Post response', { parent =&gt; getId($HTMLVARS{embed_node}) } );
       }
       return join '', $n,
         ( $VARS-&gt;{repliesdisplay} eq 'repliesbelow' ? ' ' : ' direct ' ),
         ( $n != 1 ? 'replies' : 'reply' ),
         ' &amp;mdash; ',
         linkNode( $HTMLVARS{embed_node}, 'Read more / Contribute' );
    %]
  &lt;/td&gt;
  &lt;td valign="top" align="right" style="padding-right:.2em"&gt;
&lt;!-- AUTHOR --&gt;
    by [% 
         my $x = $HTMLVARS{embed_node}{author_user} || -1;
         -1 == $x ? '' : linkNode( $x );
       %]
&lt;br/&gt;
&lt;!-- DATE --&gt;
    on [% htmlcode( 'parsetimestamp', $HTMLVARS{embed_node}{createtime} ) %]
  &lt;/td&gt;
&lt;/tr&gt;
&lt;tr class="["$HTMLVARS{embed_node}{classprefix}"]post-voterep"&gt;
  &lt;td colspan="2" class="voterep"&gt;
  [% htmlcode( 'voteit', getId( $HTMLVARS{embed_node} ) ) %]
  &lt;/td&gt;
&lt;/tr&gt;
&lt;tr class="["$HTMLVARS{embed_node}{classprefix}"]post-body post_body"&gt;
  &lt;td colspan="2"&gt;
CONTAINED_STUFF
  &lt;/td&gt;
&lt;/tr&gt;

&lt;!--  End Post  --&gt;
</live_code>
<reason>add class to rows; see [id://775140]</reason>
<field>context</field>
</record>
<record><htmlcode_id>222904</htmlcode_id>
<patch_code>parent container:
[%
   return linkNode($NODE-&gt;{parent_container})
      if  $NODE-&gt;{parent_container};
   return "&lt;i&gt;none&lt;/i&gt;";
%]&lt;p&gt;
children containers:
[%
   my $st= $DB-&gt;sqlSelectMany(
      "container_id as id",
      "container",
      "parent_container = " . getId($NODE),
      "order by container_id" );
   my $html= '';
   my $row;
   while(  $row= $st-&gt;fetchrow_hashref()  ) {
      $html .= "&lt;li&gt;" . linkNode($row-&gt;{id}) . "&lt;/li&gt;\n";
   }
   return ''   if  ! $html;
   return "&lt;br /&gt;$html";
%]&lt;/p&gt;&lt;p&gt;
[{listcode:context}]
&lt;br /&gt;
&lt;hr /&gt;
&lt;br /&gt;
[{listpatches}]
&lt;/p&gt;</patch_code>
<applied>2002-12-29 05:29:32</applied>
<htmlcode_id>59</htmlcode_id>
<live_code>parent container:
[%
   return linkNode($NODE-&gt;{parent_container})
      if  $NODE-&gt;{parent_container};
   return "&lt;i&gt;none&lt;/i&gt;";
%]&lt;p&gt;
children:
[%
   my @html;
   for my $tbl (qw( container htmlpage nodelet )) {
     my $st= $DB-&gt;sqlSelectMany(
       "${tbl}_id as id",
       $tbl,
       "parent_container = " . getId($NODE),
       "order by ${tbl}_id limit 11" );
     my @subhtml;
     my $row;
     while(  $row= $st-&gt;fetchrow_hashref()  ) {
       push @subhtml, linkNode($row-&gt;{id});
     }
     if ( @subhtml &gt; 10 ) {
       splice @subhtml, 10;
       push @subhtml, "&lt;i&gt;Not all &lt;u&gt;$tbl&lt;/u&gt; results shown.&lt;/i&gt;";
     }
     push @html, @subhtml;
   }
   return '&lt;i&gt;none&lt;/i&gt;'   if  ! @html;
   return join '',
     '&lt;ul class="inline-list"&gt;',
     map( '&lt;li&gt;'.$_.'&lt;/li&gt;', @html ),
     '&lt;/ul&gt;';
%]&lt;/p&gt;&lt;p&gt;
[{listcode:context}]
&lt;br /&gt;
[{showsitedoclet}]
&lt;hr /&gt;
&lt;br /&gt;
[{listpatches}]
&lt;/p&gt;</live_code>
<reason>List patches.</reason>
<field>page</field>
</record>
<record><htmlcode_id>222887</htmlcode_id>
<patch_code>[{listcode:code}]
&lt;br /&gt;
&lt;hr /&gt;
&lt;br /&gt;
[{listpatches}]</patch_code>
<applied>2002-12-29 03:49:06</applied>
<htmlcode_id>63</htmlcode_id>
<live_code>[{listcode:code}]
&lt;hr /&gt;
[{showsitedoclet}]
[{listpatches}]</live_code>
<reason>List patches for node</reason>
<field>page</field>
</record>
<record><htmlcode_id>399050</htmlcode_id>
<patch_code>&lt;b&gt;pagetype&lt;/b&gt;: 
[%
	my $N = $DB-&gt;getNodeById($$NODE{pagetype_nodetype}, 'light');
	linkNode $N;
%]&lt;br&gt;
&lt;b&gt;parent container&lt;/b&gt;:
[% return linkNode ($$NODE{parent_container}) if $$NODE{parent_container};
"&lt;i&gt;none&lt;/i&gt;";
%]
&lt;br&gt;
&lt;b&gt;displaytype&lt;/b&gt;:
["$$NODE{displaytype}"]
&lt;br&gt;
&lt;b&gt;theme&lt;/b&gt;:
[%
unless ($$NODE{ownedby_theme}) {
  return "&lt;i&gt;this htmlpage does not belong to a theme&lt;/i&gt;";
}
my $THEME = getNode $$NODE{ownedby_theme};
linkNode($THEME);

%]
&lt;br&gt;
&lt;b&gt;mimetype&lt;/b&gt;:
[%
unless ($$NODE{mimetype}) {
  return "&lt;i&gt;none&lt;/i&gt;";
}
$$NODE{mimetype};
%]
&lt;p&gt;[{listcode:page}]
&lt;br /&gt;
&lt;hr /&gt;
&lt;br /&gt;
[{listpatches}]
</patch_code>
<applied>2004-11-07 07:46:17</applied>
<htmlcode_id>65</htmlcode_id>
<live_code>&lt;b&gt;pagetype&lt;/b&gt;: 
[%
	my $N = $DB-&gt;getNodeById($$NODE{pagetype_nodetype}, 'light');
	linkNode $N;
%]&lt;br&gt;
&lt;b&gt;parent container&lt;/b&gt;:
[% return linkNode ($$NODE{parent_container}) if $$NODE{parent_container};
"&lt;i&gt;none&lt;/i&gt;";
%]
&lt;br&gt;
&lt;b&gt;displaytype&lt;/b&gt;:
["$$NODE{displaytype}"]
&lt;br&gt;
&lt;b&gt;theme&lt;/b&gt;:
[%
unless ($$NODE{ownedby_theme}) {
  return "&lt;i&gt;this htmlpage does not belong to a theme&lt;/i&gt;";
}
my $THEME = getNode $$NODE{ownedby_theme};
linkNode($THEME);

%]
&lt;br&gt;
&lt;b&gt;mimetype&lt;/b&gt;:
[%
unless ($$NODE{mimetype}) {
  return "&lt;i&gt;none&lt;/i&gt;";
}
$$NODE{mimetype};
%]
&lt;p&gt;[{listcode:page}]
&lt;br /&gt;
[{showsitedoclet}]
&lt;hr /&gt;
&lt;br /&gt;
[{listpatches}]
</live_code>
<reason>mimetype</reason>
<field>page</field>
</record>
<record><htmlcode_id>250345</htmlcode_id>
<patch_code>&lt;p&gt;
Update interval: ["$NODE-&gt;{updateinterval}"] seconds&lt;br /&gt;
Parent container: [%linkNode($NODE-&gt;{parent_container})%]
&lt;/p&gt;&lt;p&gt;
[{listcode:nlcode}]
&lt;/p&gt;&lt;hr /&gt;
[{listpatches}]</patch_code>
<applied>2003-04-14 13:25:20</applied>
<htmlcode_id>73</htmlcode_id>
<live_code>&lt;p&gt;
Update interval: ["$NODE-&gt;{updateinterval}"] seconds&lt;br /&gt;
Parent container: [%linkNode($NODE-&gt;{parent_container})%]
&lt;/p&gt;&lt;p&gt;
[{listcode:nlcode}]
&lt;/p&gt;
[{showsitedoclet}]
&lt;hr /&gt;
[{listpatches}]</live_code>
<reason>Just show updateinterval</reason>
<field>page</field>
</record>
<record><htmlcode_id>605958</htmlcode_id>
<patch_code>&lt;p&gt;&lt;b&gt;Authorized Readers&lt;/b&gt;:
  [{listgroup:readers_user}]
  [{displayInherited:readers_user}]

&lt;p&gt;&lt;b&gt;Authorized Creators&lt;/b&gt;:
  [{listgroup:writers_user}]
  [{displayInherited:writers_user}]

&lt;p&gt;&lt;b&gt;Authorized Updaters&lt;/b&gt;:
  [{listgroup:updaters_user}]
  [{displayInherited:updaters_user}]

&lt;p&gt;&lt;b&gt;Authorized Deleters&lt;/b&gt;:
  [{listgroup:deleters_user}]
  [{displayInherited:deleters_user}]

&lt;p&gt;&lt;b&gt;Restrict Duplicates&lt;/b&gt; (identical titles):
[%
  if(  $$NODE{restrictdupes} == -1  ) {
    "parent";
  } else {
    $$NODE{restrictdupes} ? "Yes" : "No";
  }
%]
  [{displayInherited:restrictdups}]

&lt;p&gt;&lt;b&gt;SQL Table&lt;/b&gt;:
[%
  return "&lt;i&gt;none&lt;/i&gt;"   if  ! exists $$NODE{sqltable};
  my $tab = $NODE-&gt;{sqltable};
  my $inh = '';
  if(  0 &lt; $NODE-&gt;{extends_nodetype}  ) {
    my $TYPE = $DB-&gt;getType( $NODE-&gt;{extends_nodetype} );
    $inh = $TYPE-&gt;{sqltablelist}   if  $TYPE;
  }
  for my $str (  $tab, $inh  ) {
    my @tables= split /,/, $str;
    $str = '';
    for my $table (  @tables  ) {
      my $TABLE = getNode( $table, 'dbtable' );
      $str .= ','   if  '' ne $str;
      $str .= $TABLE ? linkNode( $TABLE ) : $table;
    }
  }
  $inh = " ( Inherited: $inh )"   if  $inh;
  return $tab . $inh;
%]

&lt;p&gt;&lt;b&gt;Extends Nodetype&lt;/b&gt;:
  [% linkNode ($$NODE{extends_nodetype})
       if $$NODE{extends_nodetype}; %]

&lt;p&gt;&lt;b&gt;Group Table&lt;/b&gt;:
[%
  my $table = $NODE-&gt;{grouptable};
  return "none" unless $table;
  my $TABLE = getNode( $table, 'dbtable' );
  $TABLE ? linkNode( $TABLE ) : $table;
%]
[{displayInherited:grouptable}]

[%
  return "&lt;p&gt;" . linkNode(
    getNode( "Node Lister", "superdoc" ),
    "List $NODE-&gt;{title} nodes", {
      'whichtype' =&gt; $NODE-&gt;{node_id}
    }
  ) . ", &lt;a href='?node=Type%20Tree&amp;#nodetype_$NODE-&gt;{node_id}'&gt;"
    . "View in class heirarchy&lt;/a&gt;&lt;/p&gt;";
%]

&lt;p&gt;&lt;b&gt;Relevant pages&lt;/b&gt;:&lt;br&gt;
[{get_display_types}]

&lt;p&gt;&lt;b&gt;Active Maintenances&lt;/b&gt;:&lt;br /&gt;
[%
  my $str;
  my %maints;

  my $type = $NODE;
  do {
    my( @maints )= getNodeWhere(
     {maintain_nodetype=&gt;getId($type)},
      getType('maintenance')
    );
    $maints{$_-&gt;{maintaintype}} ||= $_ for @maints;
  } while ( getRef( $type = $type-&gt;{extends_nodetype} ) );

  return "&lt;i&gt;no maintenance functions&lt;/i&gt;"
    unless  keys %maints;

  foreach(  values %maints  ) {
    $str .= "&lt;li&gt;" . linkNode($_) . "&lt;/li&gt;";
  }
  return $str;
%]
&lt;/p&gt;&lt;p&gt;
[%
my $type=$DB-&gt;deriveType($NODE);
my $out = '&lt;table border="1"&gt;';
$out .= '
&lt;tr&gt;
 &lt;th&gt;field&lt;/th&gt;
 &lt;th&gt;type&lt;/th&gt;
 &lt;th&gt;extra&lt;/th&gt;
 &lt;th&gt;default&lt;/th&gt;
 &lt;th&gt;key&lt;/th&gt;
&lt;/tr&gt;';
foreach my $table (reverse('node', @{$type-&gt;{tableArray}})) {
  $out .= '&lt;tr&gt;&lt;td colspan="5"&gt;&lt;center&gt;&lt;b&gt;';
  $out .= $table;
  $out .= '&lt;/b&gt;&lt;/center&gt;&lt;/td&gt;&lt;/tr&gt;';
  foreach my $field ($DB-&gt;getFieldsHash($table)) {
    next if $field eq $table.'_id';
    $out .= '&lt;tr&gt;';
    $out .= '&lt;td&gt;'. $field-&gt;{Field} .'&lt;/td&gt;';
    $out .= '&lt;td&gt;'. $field-&gt;{Type}  .'&lt;/td&gt;';
    $out .= '&lt;td&gt;'. $field-&gt;{Extra} . 
            ($field-&gt;{Null} ? '&amp;nbsp;' : ' not null') .'&lt;/td&gt;';
    $out .= '&lt;td&gt;' 
            . ( 
               defined($field-&gt;{Default})
               ? "'$field-&gt;{Default}'" 
               : 'null'
              ) 
            . '&lt;/td&gt;';
    $out .= '&lt;td&gt;'. ($field-&gt;{Key}||'&amp;nbsp;') .'&lt;/td&gt;';
    $out .= "&lt;/tr&gt;\n";
  }
}
$out .= '&lt;/table&gt;';

$out;
%]
&lt;/p&gt;</patch_code>
<applied>2007-03-22 01:40:31</applied>
<htmlcode_id>75</htmlcode_id>
<live_code>&lt;p&gt;&lt;b&gt;Authorized Readers&lt;/b&gt;:
  [{listgroup:readers_user}]
  [{displayInherited:readers_user}]

&lt;p&gt;&lt;b&gt;Authorized Creators&lt;/b&gt;:
  [{listgroup:writers_user}]
  [{displayInherited:writers_user}]

&lt;p&gt;&lt;b&gt;Authorized Updaters&lt;/b&gt;:
  [{listgroup:updaters_user}]
  [{displayInherited:updaters_user}]

&lt;p&gt;&lt;b&gt;Authorized Deleters&lt;/b&gt;:
  [{listgroup:deleters_user}]
  [{displayInherited:deleters_user}]

&lt;p&gt;&lt;b&gt;Restrict Duplicates&lt;/b&gt; (identical titles):
[%
  if(  $$NODE{restrictdupes} == -1  ) {
    "parent";
  } else {
    $$NODE{restrictdupes} ? "Yes" : "No";
  }
%]
  [{displayInherited:restrictdups}]

&lt;p&gt;&lt;b&gt;SQL Table&lt;/b&gt;:
[%
  return "&lt;i&gt;none&lt;/i&gt;"   if  ! exists $$NODE{sqltable};
  my $tab = $NODE-&gt;{sqltable};
  my $inh = '';
  if(  0 &lt; $NODE-&gt;{extends_nodetype}  ) {
    my $TYPE = $DB-&gt;getType( $NODE-&gt;{extends_nodetype} );
    $inh = $TYPE-&gt;{sqltablelist}   if  $TYPE;
  }
  for my $str (  $tab, $inh  ) {
    my @tables= split /,/, $str;
    $str = '';
    for my $table (  @tables  ) {
      my $TABLE = getNode( $table, 'dbtable' );
      $str .= ','   if  '' ne $str;
      $str .= $TABLE ? linkNode( $TABLE ) : $table;
    }
  }
  $inh = " ( Inherited: $inh )"   if  $inh;
  return $tab . $inh;
%]

&lt;p&gt;&lt;b&gt;Extends Nodetype&lt;/b&gt;:
  [% linkNode ($$NODE{extends_nodetype})
       if $$NODE{extends_nodetype}; %]

&lt;p&gt;&lt;b&gt;Group Table&lt;/b&gt;:
[%
  my $table = $NODE-&gt;{grouptable};
  return "none" unless $table;
  my $TABLE = getNode( $table, 'dbtable' );
  $TABLE ? linkNode( $TABLE ) : $table;
%]
[{displayInherited:grouptable}]

[%
  return "&lt;p&gt;" . linkNode(
    getNode( "Node Lister", "superdoc" ),
    "List $NODE-&gt;{title} nodes", {
      'whichtype' =&gt; $NODE-&gt;{node_id}
    }
  ) . ", &lt;a href='?node=Type%20Tree&amp;#nodetype_$NODE-&gt;{node_id}'&gt;"
    . "View in class heirarchy&lt;/a&gt;&lt;/p&gt;";
%]

&lt;p&gt;&lt;b&gt;Relevant pages&lt;/b&gt;:&lt;br&gt;
[{get_display_types}]

&lt;p&gt;&lt;b&gt;Active Maintenances&lt;/b&gt;:&lt;br /&gt;
[%
  my $str;
  my %maints;

  my $type = $NODE;
  do {
    my( @maints )= getNodeWhere(
     {maintain_nodetype=&gt;getId($type)},
      getType('maintenance')
    );
    $maints{$_-&gt;{maintaintype}} ||= $_ for @maints;
  } while ( getRef( $type = $type-&gt;{extends_nodetype} ) );

  return "&lt;i&gt;no maintenance functions&lt;/i&gt;"
    unless  keys %maints;

  foreach(  values %maints  ) {
    $str .= "&lt;li&gt;" . linkNode($_) . "&lt;/li&gt;";
  }
  return $str;
%]
&lt;/p&gt;&lt;p&gt;
[%
my $type=$DB-&gt;deriveType($NODE);
my $out = '&lt;table border="1"&gt;';
$out .= '
&lt;tr&gt;
 &lt;th&gt;field&lt;/th&gt;
 &lt;th&gt;type&lt;/th&gt;
 &lt;th&gt;extra&lt;/th&gt;
 &lt;th&gt;default&lt;/th&gt;
 &lt;th&gt;key&lt;/th&gt;
&lt;/tr&gt;';
foreach my $table (reverse('node', @{$type-&gt;{tableArray}})) {
  $out .= '&lt;tr&gt;&lt;td colspan="5"&gt;&lt;center&gt;&lt;b&gt;';
  $out .= $table;
  $out .= '&lt;/b&gt;&lt;/center&gt;&lt;/td&gt;&lt;/tr&gt;';
  foreach my $field ($DB-&gt;getFieldsHash($table)) {
    next if $field eq $table.'_id';
    $out .= '&lt;tr&gt;';
    $out .= '&lt;td&gt;'. $field-&gt;{Field} .'&lt;/td&gt;';
    $out .= '&lt;td&gt;'. $field-&gt;{Type}  .'&lt;/td&gt;';
    $out .= '&lt;td&gt;'. $field-&gt;{Extra} . 
            ($field-&gt;{Null} ? '&amp;nbsp;' : ' not null') .'&lt;/td&gt;';
    $out .= '&lt;td&gt;' 
            . ( 
               defined($field-&gt;{Default})
               ? "'$field-&gt;{Default}'" 
               : 'null'
              ) 
            . '&lt;/td&gt;';
    $out .= '&lt;td&gt;'. ($field-&gt;{Key}||'&amp;nbsp;') .'&lt;/td&gt;';
    $out .= "&lt;/tr&gt;\n";
  }
}
$out .= '&lt;/table&gt;';

$out;
%]
&lt;/p&gt;
[{showsitedoclet}]</live_code>
<reason>"short things before long things"++, drop itemless label</reason>
<field>page</field>
</record>
<record><htmlcode_id>697820</htmlcode_id>
<patch_code>[{votehead}]
[%
  if(  $NODE-&gt;{parent_node}  ) {
    my $PARENT = selectNode( $NODE-&gt;{parent_node} );
    my $root_node = htmlcode('get_root_node');
    return qq[&lt;div class="notetext auth-$NODE-&gt;{author_user}"&gt;&lt;p align='right'&gt;in reply to ]
      . linkNode($PARENT)
      . ( $PARENT-&gt;{node_id} != $root_node
          &amp;&amp; qq[&lt;br /&gt;in thread ] . linkNode($root_node) )
      . qq[&lt;/p&gt;];
  }
%]
[{voteit}]
&lt;p&gt;
[{parselinks:doctext}]
&lt;/p&gt;
&lt;/div&gt;
[{editinvote:Text}]
&lt;br /&gt;
&lt;!-- don't [ {showhints} ] (unless is _your_ note) --&gt;
[{shownote}]
[{votefoot}]</patch_code>
<applied>2008-07-16 10:56:52</applied>
<htmlcode_id>77</htmlcode_id>
<live_code>[{votehead}]
[%
    my $PARENT = selectNode( $NODE-&gt;{parent_node} )
        or  return '';
    my $root_node = htmlcode('get_root_node');

    return join "\n",
        "&lt;div class='notetext auth-$NODE-&gt;{author_user}'&gt;",
        "&lt;p align='right'&gt;",
        "&lt;br /&gt;in reply to",
        linkNode($PARENT),
        $PARENT-&gt;{node_id} == $root_node ? () :
            "&lt;br /&gt;in thread " . linkNode($root_node),
        '&lt;/p&gt;',
    '';
%]
[{voteit}]
&lt;p&gt;
[{parselinks:doctext}]
&lt;/p&gt;
&lt;/div&gt;
[{editinvote:Text}]
&lt;br /&gt;
[{shownote}]
[{votefoot}]
[%
    htmlcode(
        'linkToSection','',
        selectNode($NODE-&gt;{root_node}),
        'In Section',
        'section',
    );
%]
</live_code>
<reason>previous patch broke voting: div needs to be entirely inside form</reason>
<field>page</field>
</record>
<record><htmlcode_id>776081</htmlcode_id>
<patch_code>[%
    return join '',
        "&lt;p&gt;&lt;b&gt;If this is your usernode and you want it ",
        "back please read &lt;a href='?node_id=523120'&gt;",
        "Unused accounts zombified&lt;/a&gt;&lt;/b&gt;&lt;/p&gt;&lt;hr /&gt;\n"
        if(  'zombie_user' eq $NODE-&gt;{type}{title}  );
%]


&lt;table class="pm-user-info"&gt;&lt;tr&gt;
[%
    # User Image
    my $src= $NODE-&gt;{imgsrc};
    return ''
        if  ! $src
        ||  ! Everything::isApproved( $NODE, 'CanHaveImage' );

    my $upd= join '', $NODE-&gt;{lastupdate} =~ /(\d+)/g;
    my $alt= "$NODE-&gt;{title}'s user image";

    if(  $src =~ /\D/  ) {
        $src= "/$src?updated=$upd";
    } else {
        $src= urlGen(
            { node_id =&gt; $src, updated =&gt; $upd },
            -1,
        );
    }
    return $q-&gt;td(
        $q-&gt;img( {
            src =&gt; $src,
            alt =&gt; $alt,
            title =&gt; $alt,
        } )
    );
%]
    &lt;td valign="top"&gt;
[%
    return linkNodeTitle('I want my picture back|*')
        if  ! Everything::isApproved( $NODE, 'CanHaveImage' )
        &amp;&amp;  $NODE-&gt;{imgsrc};
%]
      &lt;table&gt;
[%
    # Edit links
    return ''
        if  getId($USER) != getId($NODE)
        ||  getId($USER) == $HTMLVARS{default_user};

    my $eup= genLink(
        'Profile',
        { node_id =&gt; getId($NODE), displaytype =&gt; 'edit' },
    );
    my $eus= genLink(
        'Settings',
        { node =&gt; 'User Settings' },
    );
    return join '',
        '&lt;tr id="user-edit-links"&gt;&lt;td&gt;Edit your:&lt;/td&gt;&lt;td&gt;',
        "$eup, $eus&lt;/td&gt;&lt;/tr&gt;\n";
%]
        &lt;tr&gt;
          &lt;td&gt;User since:&lt;/td&gt;
          &lt;td&gt;[{parsetime:createtime}]&lt;/td&gt;
        &lt;/tr&gt;&lt;tr&gt;
          &lt;td&gt;Last here:&lt;/td&gt;
          &lt;td&gt;[{parsetime:lasttime}]
            &lt;i&gt;([{timesince:$NODE-&gt;{lasttime}}])&lt;/i&gt;&lt;/td&gt;
        &lt;/tr&gt;&lt;tr&gt;
          &lt;td&gt;Experience:&lt;/td&gt;
          &lt;td&gt;&lt;b&gt;
[%
    my $xp= $NODE-&gt;{experience};
    (  $xp &lt; -950000  ||  0 &lt; $xp  )
        ?   $xp :
    (  $xp &lt; 0  )
        ? 'requires penance'
        : 'none earned'
%]
          &lt;/b&gt;&lt;/td&gt;
        &lt;/tr&gt;&lt;tr&gt;
          &lt;td&gt;Level:&lt;/td&gt;&lt;td&gt;&lt;b&gt;
[%
    use Everything::Experience qw( getLevel );

    my $level= getLevel($NODE); # can't accessrule
    my $title= getVars(
        getNode( 'level titles', 'setting' )
    )-&gt;{$level};

    return "$title ($level)";
%]
          &lt;/b&gt;&lt;/td&gt;
        &lt;/tr&gt;&lt;tr&gt;
          &lt;td&gt;Writeups:&lt;/td&gt;
          &lt;td&gt;&lt;b&gt;
[%
    my $count= htmlcode( 'displaySingleVar', 'numwriteups' );

    $count= "none"
        if  ! $count  ||  $count =~ /\D/;

    return linkNode(
        6364,
        $count,
        { user =&gt; $NODE-&gt;{title} },
    );
%]
          &lt;/b&gt;&lt;/td&gt;
        &lt;/tr&gt;
[%
    htmlcode(
        'displaySingleVar','',
        'location',
        (   isGod($USER)  ||  $q-&gt;param('scrub')
        ||  ! $VARS-&gt;{unfilterhtml}  )
            ? 1 : 0,
        '&lt;tr&gt;&lt;td&gt;Location:&lt;/td&gt;&lt;td&gt;',
        '&lt;/td&gt;&lt;/tr&gt;',
    )
%]
        &lt;tr&gt;
          &lt;td&gt;User's localtime:&lt;/td&gt;&lt;td&gt;
[%
    my $tz= getVars($NODE)-&gt;{timezone};
    $tz= " "
        if  $tz !~ /\S/;
    return htmlcode( 'parseTimeInString','', '', $tz );
%]
          &lt;/td&gt;
        &lt;/tr&gt;&lt;tr&gt;
          &lt;td&gt;Scratchpad:&lt;/td&gt;&lt;td&gt;
[%
    my $has_pad= $NODE-&gt;{user_scratchpad};

    my $view= $has_pad
        ?   htmlcode( 'scratchpad_link','', $NODE, 'View' )
        :   'None.';

    my @links= $view;

    if(  $NODE-&gt;{author_user} == $USER-&gt;{node_id}  ) {
        push @links, htmlcode( 'scratchpad_link','',
            $NODE,
            $has_pad ? 'Edit' : 'Create',
            { displaytype=&gt;'edit', viewmode=&gt;'public' },
        );
        if( $has_pad ) {
            push @links, sprintf "%s (%s)",
                htmlcode( 'scratchpad_link','',
                    $NODE,
                    'Private',
                    { viewmode=&gt;'private' },
                ),
                htmlcode( 'scratchpad_link','',
                    $NODE,
                    'Edit',
                    { displaytype=&gt;'edit', viewmode=&gt;'private' },
                );
        }
    }
    return join ", ", @links;
%]
          &lt;/td&gt;
        &lt;/tr&gt;
[%
    my $and_where= isGod($USER) ? "" : "AND n.type_nodetype=16";
    my $sth= $DB-&gt;getDatabaseHandle-&gt;prepare_cached( join ' ',
        'SELECT n.node_id AS node_id, n.title AS title',
        'FROM nodegroup AS g, node AS n',
        'WHERE g.nodegroup_id = n.node_id AND g.node_id = ?',
        $and_where,
        'ORDER BY n.title ASC',
    );
    $sth-&gt;execute( getId($NODE) );

    my @groups;
    while(  my $group= $sth-&gt;fetchrow_hashref()  ) {
        push @groups, $group;
    }
    return ''
        if  ! @groups;
    return join '',
        "&lt;tr&gt;&lt;td&gt;Member of:&lt;/td&gt;&lt;td&gt;\n",
        join( ', ', map { linkNode($_) } @groups ),
    "\n";
%]
          &lt;/td&gt;
        &lt;/tr&gt;
[%
    return ''
        if  $HTMLVARS{guest_user} == getId($USER);

    my $msg_link= '';
    if(  $HTMLVARS{guest_user} != getId($NODE)  ) {
        $msg_link= linkNode(
            762476,
            "Send private /msg",
            {   sendto =&gt; $NODE-&gt;{title},
                replytotext =&gt; "",
            },
            {   trusted =&gt; 'yes' },
        ) . ", ";
    }

    return join "\n",
        '&lt;tr class="msg_user"&gt;&lt;td&gt;For this user:&lt;/td&gt;&lt;td&gt;',
        $msg_link,
        genLink(
            isGod($USER) ? 'Their votes' : 'Your votes',
            { node_id =&gt; getId($NODE), displaytype =&gt; 'voteview' },
        ),
        isGod($USER) ? qq{&lt;a href="?node=lock+user;user_id=} . $NODE-&gt;{node_id} . qq{"&gt;Lock&lt;/a&gt;} : '',
        '&lt;/td&gt;&lt;/tr&gt;',
    '';
%]
      &lt;/table&gt;
    &lt;/td&gt;
  &lt;/tr&gt;
&lt;/table&gt;

&lt;p&gt;
[%
    if(  '[NodeReaper]' eq $NODE-&gt;{nick}  ) {
        return join '',
            q{&lt;p&gt;Account locked&lt;/p&gt;},
            q{&lt;p&gt;Please &lt;a href="?node_id=491035"&gt;contact the site administrators&lt;/a&gt;},
              q{ if you feel your account should be made available again.&lt;/p&gt;},
    };

    my @type;
    my $scrub=  isGod($USER)
            ||  $q-&gt;param('scrub')
            ||  ! $VARS-&gt;{unfilterhtml};

    if ($scrub) {
        @type= (
            'doctext',
            {
                # img =&gt; 'alt,border,height,src,width',
                select =&gt; 'name',
                option =&gt; 'selected,value',
                form =&gt; 'method',
                input =&gt;'name,type,value,/'
            },
        );
    } else {
        @type= qw&lt; doctext override &gt;;
    }

    my $nofollow = ! Everything::isApproved( $NODE, 'CanHaveImage' ) or $q-&gt;param('nofollow');

    my $str= htmlcode( 'parselinks','', @type );

    # prevent images even if viewer doesn't filter HTML
    $str =~ s/&lt;\s*(?:img|image)[^&gt;]*&gt;//gis
        if  ! Everything::isApproved( $NODE, 'CanHaveImage' );

    $str =~ s{&lt;(\s*script[^&gt;]*&gt;.*?&lt;\s*/\s*script[^&gt;]*)&gt;}{
        "&lt;!-- PM Stripped: ($1) --&gt;";
    }gise
        if  $VARS-&gt;{jsoff}  &amp;&amp;  ! $scrub;

    $str =~ s/(s)(crip)(t)/$1&amp;#x200E;$2&amp;#x200E;$3/gi
        if  $scrub;

    $str =~ s/(&lt;\s*a)\b/$1 rel="nofollow"/gi
        if  $nofollow;

    return $str;
%]
&lt;/p&gt;
</patch_code>
<applied>2009-06-30 17:37:47</applied>
<htmlcode_id>81</htmlcode_id>
<live_code>[%
    return join '',
        "&lt;p&gt;&lt;b&gt;If this is your usernode and you want it ",
        "back please read &lt;a href='?node_id=523120'&gt;",
        "Unused accounts zombified&lt;/a&gt;&lt;/b&gt;&lt;/p&gt;&lt;hr /&gt;\n"
        if(  'zombie_user' eq $NODE-&gt;{type}{title}  );
%]


&lt;table class="pm-user-info"&gt;&lt;tr&gt;
[%
    # User Image
    my $src= $NODE-&gt;{imgsrc};
    return ''
        if  ! $src
        ||  ! Everything::isApproved( $NODE, 'CanHaveImage' );

    my $upd= join '', $NODE-&gt;{lastupdate} =~ /(\d+)/g;
    my $alt= "$NODE-&gt;{title}'s user image";

    if(  $src =~ /\D/  ) {
        $src= "/$src?updated=$upd";
    } else {
        $src= urlGen(
            { node_id =&gt; $src, updated =&gt; $upd },
            -1,
        );
    }
    return $q-&gt;td(
        $q-&gt;img( {
            src =&gt; $src,
            alt =&gt; $alt,
            title =&gt; $alt,
        } )
    );
%]
    &lt;td valign="top"&gt;
[%
    return linkNodeTitle('I want my picture back|*')
        if  ! Everything::isApproved( $NODE, 'CanHaveImage' )
        &amp;&amp;  $NODE-&gt;{imgsrc};
%]
      &lt;table&gt;
[%
    # Edit links
    return ''
        if  getId($USER) != getId($NODE)
        ||  getId($USER) == $HTMLVARS{default_user};

    my $eup= genLink(
        'Profile',
        { node_id =&gt; getId($NODE), displaytype =&gt; 'edit' },
    );
    my $eus= genLink(
        'Settings',
        { node =&gt; 'User Settings' },
    );
    return join '',
        '&lt;tr id="user-edit-links"&gt;&lt;td&gt;Edit your:&lt;/td&gt;&lt;td&gt;',
        "$eup, $eus&lt;/td&gt;&lt;/tr&gt;\n";
%]
        &lt;tr&gt;
          &lt;td&gt;User since:&lt;/td&gt;
          &lt;td&gt;[{parsetime:createtime}]
          [%  return q{&amp;#91;Account disabled&amp;#93;}
                if  ! $NODE-&gt;{passwd};
          %]&lt;/td&gt;
        &lt;/tr&gt;&lt;tr&gt;
          &lt;td&gt;Last here:&lt;/td&gt;
          &lt;td&gt;[{parsetime:lasttime}]
            &lt;i&gt;([{timesince:$NODE-&gt;{lasttime}}])&lt;/i&gt;&lt;/td&gt;
        &lt;/tr&gt;&lt;tr&gt;
          &lt;td&gt;Experience:&lt;/td&gt;
          &lt;td&gt;&lt;b&gt;
[%
    my $xp= $NODE-&gt;{experience};
    (  $xp &lt; -950000  ||  0 &lt; $xp  )
        ?   $xp :
    (  $xp &lt; 0  )
        ? 'requires penance'
        : 'none earned'
%]
          &lt;/b&gt;&lt;/td&gt;
        &lt;/tr&gt;&lt;tr&gt;
          &lt;td&gt;Level:&lt;/td&gt;&lt;td&gt;&lt;b&gt;
[%
    use Everything::Experience qw( getLevel );

    my $level= getLevel($NODE); # can't accessrule
    my $title= getVars(
        getNode( 'level titles', 'setting' )
    )-&gt;{$level};

    return "$title ($level)";
%]
          &lt;/b&gt;&lt;/td&gt;
        &lt;/tr&gt;&lt;tr&gt;
          &lt;td&gt;Writeups:&lt;/td&gt;
          &lt;td&gt;&lt;b&gt;
[%
    my $count= getVars($NODE)-&gt;{numwriteups};

    $count= "none"
        if  ! $count  ||  $count =~ /\D/;

    return linkNode(
        6364,
        $count,
        { user =&gt; $NODE-&gt;{title} },
    );
%]
          &lt;/b&gt;&lt;/td&gt;
        &lt;/tr&gt;
[%
    return ''   # Don't show 'location' for locked users
        if  '[NodeReaper]' eq $NODE-&gt;{nick};
    return htmlcode(
        'displaySingleVar','',
        'location',
        (   isGod($USER)
        ||  $q-&gt;param('scrub')
        ||  ! $VARS-&gt;{unfilterhtml}  )
            ? 1 : 0,
        '&lt;tr&gt;&lt;td&gt;Location:&lt;/td&gt;&lt;td&gt;',
        '&lt;/td&gt;&lt;/tr&gt;',
    );
%]
        &lt;tr&gt;
          &lt;td&gt;User's localtime:&lt;/td&gt;&lt;td&gt;
[%
    my $tz= getVars($NODE)-&gt;{timezone};
    $tz= " "
        if  $tz !~ /\S/;
    return htmlcode( 'parseTimeInString','', '', $tz );
%]
          &lt;/td&gt;
        &lt;/tr&gt;&lt;tr&gt;
          &lt;td&gt;Scratchpad:&lt;/td&gt;&lt;td&gt;
[%
    my $has_pad= $NODE-&gt;{user_scratchpad};

    my $view= $has_pad
        ?   htmlcode( 'scratchpad_link','', $NODE, 'View' )
        :   'None.';

    my @links= $view;

    if(  $NODE-&gt;{author_user} == $USER-&gt;{node_id}  ) {
        push @links, scalar htmlcode( 'scratchpad_link','',
            $NODE,
            $has_pad ? 'Edit' : 'Create',
            { displaytype=&gt;'edit', viewmode=&gt;'public' },
        );
        if( $has_pad ) {
            push @links, sprintf "%s (%s)",
                scalar htmlcode( 'scratchpad_link','',
                    $NODE,
                    'Private',
                    { viewmode=&gt;'private' },
                ),
                scalar htmlcode( 'scratchpad_link','',
                    $NODE,
                    'Edit',
                    { displaytype=&gt;'edit', viewmode=&gt;'private' },
                );
        }
    }
    return join ", ", @links;
%]
          &lt;/td&gt;
        &lt;/tr&gt;
[%
    my $and_where= isGod($USER) ? "" : "AND n.type_nodetype=16";
    my $sth= $DB-&gt;getDatabaseHandle-&gt;prepare_cached( join ' ',
        'SELECT n.node_id AS node_id, n.title AS title',
        'FROM nodegroup AS g, node AS n',
        'WHERE g.nodegroup_id = n.node_id AND g.node_id = ?',
        $and_where,
        'ORDER BY n.title ASC',
    );
    $sth-&gt;execute( getId($NODE) );

    my @groups;
    while(  my $group= $sth-&gt;fetchrow_hashref()  ) {
        push @groups, $group;
    }
    return ''
        if  ! @groups;
    return join '',
        "&lt;tr&gt;&lt;td&gt;Member of:&lt;/td&gt;&lt;td&gt;\n",
        join( ', ', map { linkNode($_) } @groups ),
    "\n";
%]
          &lt;/td&gt;
        &lt;/tr&gt;
[%
    return ''
        if  $HTMLVARS{guest_user} == getId($USER);

    my $msg_link= '';
    if(  $HTMLVARS{guest_user} != getId($NODE)  ) {
        $msg_link= linkNode(
            762476,
            "Send private /msg",
            {   sendto =&gt; $NODE-&gt;{title},
                replytotext =&gt; "",
            },
            {   trusted =&gt; 'yes' },
        ) . ", ";
    }

    return join "\n",
        '&lt;tr class="msg_user"&gt;&lt;td&gt;For this user:&lt;/td&gt;&lt;td&gt;',
        $msg_link,
        genLink(
            isGod($USER) ? 'Their votes' : 'Your votes',
            { node_id =&gt; getId($NODE), displaytype =&gt; 'voteview' },
        ),
        ! isGod($USER) ? '' : genLink( 'Lock', {
            node =&gt; 'lock user',
            type =&gt; 'superdoc',
            user_id =&gt; $NODE-&gt;{node_id},
        } ),
        '&lt;/td&gt;&lt;/tr&gt;',
    '';
%]
      &lt;/table&gt;
    &lt;/td&gt;
  &lt;/tr&gt;
&lt;/table&gt;

&lt;p&gt;
[%
    if(  '[NodeReaper]' eq $NODE-&gt;{nick}  ) {
        return join $/,
            q{&lt;p&gt;Account locked.&lt;/p&gt;},
            q{&lt;p&gt;Please &lt;a href="?node_id=491035"&gt;},
            q{contact the site administrators&lt;/a&gt; if you feel},
            q{your account should be made available again.&lt;/p&gt;},
        '';
    }

    my @type;
    my $scrub=  isGod($USER)
            ||  $q-&gt;param('scrub')
            ||  ! $VARS-&gt;{unfilterhtml};

    if ($scrub) {
        @type= (
            'doctext',
            {
                # img =&gt; 'alt,border,height,src,width',
                select =&gt; 'name',
                option =&gt; 'selected,value',
                form =&gt; 'method',
                input =&gt;'name,type,value,/'
            },
        );
    } else {
        @type= qw&lt; doctext override &gt;;
    }

    my $nofollow =
            ! Everything::isApproved( $NODE, 'CanHaveImage' )
        ||  $q-&gt;param('nofollow');

    my $str= htmlcode( 'parselinks','', @type );

    # prevent images even if viewer doesn't filter HTML
    $str =~ s/&lt;\s*(?:img|image)[^&gt;]*&gt;//gis
        if  ! Everything::isApproved( $NODE, 'CanHaveImage' );

    $str =~ s{&lt;(\s*script[^&gt;]*&gt;.*?&lt;\s*/\s*script[^&gt;]*)&gt;}{
        "&lt;!-- PM Stripped: ($1) --&gt;";
    }gise
        if  $VARS-&gt;{jsoff}  &amp;&amp;  ! $scrub;

    $str =~ s/(s)(crip)(t)/$1&amp;#x200E;$2&amp;#x200E;$3/gi
        if  $scrub;

    $str =~ s/(&lt;\s*a)\b/$1 rel="nofollow"/gi
        if  $nofollow;

    return $str;
%]
&lt;/p&gt;</live_code>
<reason>Don't display locked users' content</reason>
<field>page</field>
</record>
<record><htmlcode_id>560153</htmlcode_id>
<patch_code>&lt;p align="right"&gt;&lt;a target="_new" href="?node_id=17639"&gt;
  Help for this page&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;
  Last significant update: [%
    return $NODE-&gt;{lastupdate} unless(canUpdateNode($USER, $NODE));

    if ( $query-&gt;param('significantupdate') ) {
      my ($sec, $min, $hour, $mday, $mon, $year) = localtime();

      $NODE-&gt;{lastupdate} = sprintf "%04d-%02d-%02d %02d:%02d:%02d",
        $year + 1900, $mon + 1, $mday, $hour, $min, $sec;

      updateNode($NODE, $USER);
    }

    return $NODE-&gt;{lastupdate}; %]
&lt;/p&gt;
[%
  return "" unless(canUpdateNode($USER, $NODE));

  return "&lt;p&gt;No picture for you yet,"
    . " you need to reach a higher level to gain this power&lt;/p&gt;"
    unless Everything::isApproved( $USER, 'CanHaveImage' );
  
  return &lt;&lt;"END";
&lt;p&gt;
  Your coveted user image
&lt;/p&gt;
  
&lt;p&gt;
  @{[ htmlcode('uploaduserimage', 'imgsrc') ]} &lt;br /&gt;
  &lt;input type="checkbox" name="deluserimg" value="yes" /&gt;
    Remove image &lt;br /&gt;
&lt;/p&gt;
END

%]

&lt;br /&gt;&lt;b&gt;Real Name&lt;/b&gt;: ["$$NODE{realname}"]&lt;br /&gt;
[{textfield:realname}]
&lt;p&gt;Change password:&lt;br /&gt;[{password_field:passwd}]

&lt;p&gt;&lt;b&gt;Email Address&lt;/b&gt;: ["$$NODE{email}"]&lt;br /&gt;[{textfield:email,40}]
&lt;p&gt;[{editSingleVar:location}]
&lt;p&gt;&lt;b&gt;User's Bio&lt;/B&gt;:
&lt;p&gt;[{textarea:doctext}]
[%
  my $spad = '&lt;p&gt;' .
   htmlcode('scratchpad_link', '', getId($USER), 'Edit Scratchpad',{'displaytype' =&gt; 'edit'});

  $spad;
%]
&lt;!-- &lt;p&gt;[{checkvar:scratchpublic,Make scratch pad public}]&lt;br /&gt; --&gt;
&lt;p&gt;[% $query-&gt;checkbox( -name =&gt; 'significantupdate',
        -label =&gt; 'This is a significant update &lt;sup&gt;'
          . '&lt;a href="?node_id=17639#significant"&gt;?&lt;/a&gt;&lt;/sup&gt;'
      ); %]&lt;br /&gt;
</patch_code>
<applied>2006-07-10 12:02:35</applied>
<htmlcode_id>82</htmlcode_id>
<live_code>&lt;p align="right"&gt;&lt;a target="_new" href="?node_id=17639"&gt;
  Help for this page&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;
  Last significant update: [%
    return $NODE-&gt;{lastupdate} unless(canUpdateNode($USER, $NODE));

    if ( $query-&gt;param('significantupdate') ) {
      my ($sec, $min, $hour, $mday, $mon, $year) = localtime();

      $NODE-&gt;{lastupdate} = sprintf "%04d-%02d-%02d %02d:%02d:%02d",
        $year + 1900, $mon + 1, $mday, $hour, $min, $sec;

      updateNode($NODE, $USER);
    }

    return $NODE-&gt;{lastupdate}; %]
&lt;/p&gt;
[%
  return "" unless(canUpdateNode($USER, $NODE));

  return "&lt;p&gt;No picture for you yet,"
    . " you need to reach a higher level to gain this power&lt;/p&gt;"
    unless Everything::isApproved( $USER, 'CanHaveImage' );
  
  return &lt;&lt;"END";
&lt;p&gt;
  Your coveted user image
&lt;/p&gt;
  
&lt;p&gt;
  @{[ htmlcode('uploaduserimage', 'imgsrc') ]} &lt;br /&gt;
  &lt;input type="checkbox" name="deluserimg" value="yes" /&gt;
    Remove image &lt;br /&gt;
&lt;/p&gt;
END

%]

&lt;br /&gt;&lt;b&gt;Real Name&lt;/b&gt;: ["$$NODE{realname}"]&lt;br /&gt;
[{textfield:realname}]
&lt;p&gt;Change password:&lt;br /&gt;[{password_field:passwd}] &lt;i&gt;Note: Eight (8) characters max!&lt;/i&gt;

&lt;p&gt;&lt;b&gt;Email Address&lt;/b&gt;: ["$$NODE{email}"]&lt;br /&gt;[{textfield:email,40}]
&lt;p&gt;[{editSingleVar:location}]
&lt;p&gt;&lt;b&gt;User's Bio&lt;/B&gt;:
&lt;p&gt;[{textarea:doctext}]
[%
  my $spad = '&lt;p&gt;' .
   htmlcode('scratchpad_link', '', getId($USER), 'Edit Scratchpad',{'displaytype' =&gt; 'edit'});

  $spad;
%]
&lt;!-- &lt;p&gt;[{checkvar:scratchpublic,Make scratch pad public}]&lt;br /&gt; --&gt;
&lt;p&gt;[% $query-&gt;checkbox( -name =&gt; 'significantupdate',
        -label =&gt; 'This is a significant update &lt;sup&gt;'
          . '&lt;a href="?node_id=17639#significant"&gt;?&lt;/a&gt;&lt;/sup&gt;'
      ); %]&lt;br /&gt;
</live_code>
<reason>label tweak, per [id://359284]</reason>
<field>page</field>
</record>
<record><htmlcode_id>404006</htmlcode_id>
<patch_code>[{stdheader}]
[{searchform}]
&lt;h3&gt;["$$NODE{title}"]&lt;/h3&gt;
&lt;p&gt;the String:
&lt;p&gt;["$$NODE{text}"]
&lt;p&gt;&lt;FONT size=2&gt;&lt;b&gt;Edit yer string:&lt;/b&gt;&lt;/FONT&gt;
&lt;p&gt;[% 
	htmlcode('openform') .
	$query-&gt;hidden("displaytype", "edit") .
	$query-&gt;hidden("node_id", getId $NODE) .
	$query-&gt;textfield("string_text", $$NODE{text}, 50, 255) .
	$query-&gt;submit("sexisgood", "blusmut") .
	$query-&gt;end_form;
%]
&lt;p align=right&gt;[{adminbar}]
[{stdfooter}]
</patch_code>
<applied>2004-10-30 05:45:31</applied>
<htmlcode_id>136</htmlcode_id>
<live_code>&lt;p align="right"&gt;&lt;small&gt;&lt;b&gt;[%
 linkNode($NODE,"Display view");
%]&lt;/b&gt;&lt;/small&gt;&lt;/p&gt;

&lt;h3&gt;Edit yer string:&lt;/h3&gt;
&lt;p&gt;[% 
	htmlcode('openform') .
	$query-&gt;hidden("displaytype", "edit") .
	$query-&gt;hidden("node_id", getId $NODE) .
	$query-&gt;textfield("string_text", $$NODE{text}, 50, 255) .
	$query-&gt;submit("sexisgood", "blusmut") .
	$query-&gt;end_form;
%]&lt;/p&gt;

&lt;p&gt;
Hint: Use the &lt;i&gt;clone&lt;/i&gt; function in the Admin Nodelet to make a new [string] node.
&lt;/p&gt;
</live_code>
<reason>use openform</reason>
<field>page</field>
</record>
<record><htmlcode_id>642981</htmlcode_id>
<patch_code>[%
  my( $type, $page ) = split ':', $NODE-&gt;{title}, 2;
  my $site = 'perldoc.perl.org';
  # my $tail = "perlfaq.html";  # perlfaq
  # my $tail= "$page.html";  # perlman
  my $tail = "functions/$page.html";
  if ( $page =~ s/^lib:// || $page =~ /::/  ) {
    ( $tail= $page ) =~ s#::#/#g;
    $tail= "lib/$tail.html";
  }
  return qq[
    &lt;h1&gt;$page&lt;/h1&gt;
    &lt;p&gt;
      Current Perl documentation can be found at 
      &lt;a href="http://$site/$tail"&gt;$site&lt;/a&gt;.
    &lt;/p&gt;&lt;p&gt;
      Here is our local, out-dated (pre-5.6) version:
    &lt;/p&gt;
  ];
%]

[%
  local( $HTMLVARS{codereplaceoff} )= 1;
  return qq[
    &lt;img src="/images/nametitle.gif"&gt;&lt;br /&gt;
    ] . htmlcode('parsecode','','name') . qq[
    &lt;img src="/images/synopsistitle.gif"&gt;&lt;br /&gt;
    ] . htmlcode('parsecode','','synopsis') . qq[
    &lt;img src="/images/descriptiontitle.gif"&gt;&lt;br /&gt;
    ] . htmlcode('parsecode','','description');
%]</patch_code>
<applied>2007-10-05 16:45:24</applied>
<htmlcode_id>157</htmlcode_id>
<live_code>[%
  my( $type, $page ) = split ':', $NODE-&gt;{title}, 2;
  my $doclink = htmlcode('convert_links_to_html','',"[doc://$page]");
  return qq[
    &lt;h1&gt;$page&lt;/h1&gt;
    &lt;p&gt;
      See the current Perl documentation for $doclink.
    &lt;/p&gt;&lt;p&gt;
      Here is our local, out-dated (pre-5.6) version:
    &lt;/p&gt;
  ];
%]

[%
  local( $HTMLVARS{codereplaceoff} )= 1;
  return qq[
    &lt;img src="/images/nametitle.gif"&gt;&lt;br /&gt;
    ] . htmlcode('parsecode','','name') . qq[
    &lt;img src="/images/synopsistitle.gif"&gt;&lt;br /&gt;
    ] . htmlcode('parsecode','','synopsis') . qq[
    &lt;img src="/images/descriptiontitle.gif"&gt;&lt;br /&gt;
    ] . htmlcode('parsecode','','description');
%]</live_code>
<reason>Bad version number reporting</reason>
<field>page</field>
</record>
<record><htmlcode_id>297749</htmlcode_id>
<patch_code>&lt;i&gt;
[% linkNode $$NODE{author_user}; %] has asked for the
wisdom of the Perl Monks concerning the following question:
&lt;/i&gt;
[{votehead}]
[{voteit}]
&lt;p&gt;
[{parselinks:doctext}]
&lt;/p&gt;&lt;p&gt;
[{editinvote:Your Question}]
[{shownote}]
[{votefoot}]
&lt;/p&gt;
[%
  #addnewform:note,Offer an answer,Your answer,$$NODE{title},getId($NODE)
%]
&lt;p&gt;&lt;center&gt;
  Back to
  [% linkNodeTitle('Seekers of Perl Wisdom',$NODE); %]
&lt;/center&gt;&lt;/p&gt;&lt;br /&gt;
</patch_code>
<applied>2003-10-08 17:43:22</applied>
<htmlcode_id>372</htmlcode_id>
<live_code>&lt;i&gt;
[% linkNode $$NODE{author_user}; %] has asked for the
wisdom of the Perl Monks concerning the following question:
&lt;/i&gt;
[{votehead}]
[{voteit}]
&lt;p&gt;&lt;div class="doctext"&gt;
[{parselinks:doctext}]
&lt;/div&gt;&lt;/p&gt;
[{editinvote:Your Question}]
[{shownote}]
[{votefoot}]
[{linkToSection}]
</live_code>
<reason>Allow edit of root SoPW nodes</reason>
<field>page</field>
</record>
<record><htmlcode_id>560418</htmlcode_id>
<patch_code>[{votehead}]
[{voteit}]
&lt;p&gt;
[%
   my $str= '';
   my $NR= $HTMLVARS{NodeReaperID};
   if(  $$NODE{author_user} == $NR  ){
      $str .= htmlcode('parselinks','doctext');
   } else{
      $str .= htmlcode('listcodeold','doctext');
   }
   return $str;
%]
&lt;/p&gt;
[{editinvote:Your craft}]
[{shownote}]
[{votefoot}]
&lt;p&gt;&lt;center&gt;
  Back to [% linkNodeTitle('Craft',$NODE); %]
&lt;/center&gt;&lt;/p&gt;&lt;br /&gt;
</patch_code>
<applied>2006-07-11 11:53:28</applied>
<htmlcode_id>469</htmlcode_id>
<live_code>[{votehead}]
[{voteit}]
&lt;p&gt;&lt;div class="doctext"&gt;
[%
   my $str= '';
   my $NR= $HTMLVARS{NodeReaperID};
   if(  $$NODE{author_user} == $NR  ){
      $str .= htmlcode('parselinks','doctext');
   } else{
      $str .= htmlcode('listcodeold','doctext');
   }
   return $str;
%]
&lt;/div&gt;&lt;/p&gt;
[{editinvote:Your craft}]
[{shownote}]
[{votefoot}]
[{linkToSection}]</live_code>
<reason>Eliminate DB-request for "NodeReaper" in favour of $HTMLVARS{NodeReaperID}</reason>
<field>page</field>
</record>
<record><htmlcode_id>597392</htmlcode_id>
<patch_code>[% unless ($$NODE{group}) {
	"&lt;i&gt;This nodeball is empty&lt;/i&gt;";
} else {
	my $GROUP = $$NODE{group};
	my $str;
	foreach my $N  (@$GROUP) {
		$N = $DB-&gt;getNodeById($N, 'light');
		$str .= "&lt;li&gt;" . linkNode ($N) . "($$N{type}{title})";
	}
	$str;
}
%]
&lt;p&gt;[%
  htmlcode('windowview','editor,launch editor')
    if canUpdateNode( $USER, $NODE );
%]
&lt;hr /&gt;
&lt;p&gt;[{displayvars}]

[{open_new_patch_form:vars,edit}]
[%
   return $q-&gt;hidden( -name=&gt;"patch_code", -value=&gt;$NODE-&gt;{vars}, -force=&gt;1 );
%]
[{closeform:Create Patch}]
&lt;br /&gt;
&lt;hr /&gt;
&lt;br /&gt;
[{listpatches}]
</patch_code>
<applied>2007-01-30 11:56:08</applied>
<htmlcode_id>909</htmlcode_id>
<live_code>[% unless ($$NODE{group}) {
	"&lt;i&gt;This nodeball is empty&lt;/i&gt;";
} else {
	my $GROUP = $$NODE{group};
	my $str;
	foreach my $N  (@$GROUP) {
		$N = $DB-&gt;getNodeById($N, 'light');
		$str .= "&lt;li&gt;" . linkNode ($N) . "($$N{type}{title})";
	}
	$str;
}
%]
&lt;p&gt;[%
  htmlcode('windowview','editor,launch editor')
    if canUpdateNode( $USER, $NODE );
%]
&lt;hr /&gt;
&lt;p&gt;[{displayvars}]

[{open_new_patch_form:vars,edit}]
[%
   return $q-&gt;hidden( -name=&gt;"patch_code", -value=&gt;$NODE-&gt;{vars}, -force=&gt;1 );
%]
[{closeform:Create Patch}]
&lt;br /&gt;
[{showsitedoclet}]
&lt;hr /&gt;
&lt;br /&gt;
[{listpatches}]
</live_code>
<reason>only show the "launch editor" link if it makes sense for this user</reason>
<field>page</field>
</record>
<record><htmlcode_id>676403</htmlcode_id>
<patch_code>&lt;TABLE width="100%" cellpadding=0 cellspacing=1 border=0&gt;
&lt;TR class="mailhead"&gt;&lt;TH&gt;To:&lt;/TH&gt;&lt;TD width="100%"&gt;[%
linkNode($$NODE{author_user})
%]&lt;TD&gt;&lt;/TR&gt;
&lt;TR class="mailhead"&gt;&lt;TH&gt;From:&lt;/TH&gt;&lt;TD width="100%"&gt;[%
if (not $$NODE{from_address}) {
  return "&lt;i&gt;nobody&lt;/i&gt;";
} else {
  return $$NODE{from_address};
}
#eventually this will have links to an addressbook
#as well as a home node if a person exists within the 
#system
%]&lt;/TD&gt;&lt;/TR&gt;
&lt;/TABLE&gt;
[{parseLinks:doctext}]
</patch_code>
<applied>2008-03-26 13:26:45</applied>
<htmlcode_id>913</htmlcode_id>
<live_code>&lt;TABLE width="100%" cellpadding=0 cellspacing=1 border=0&gt;
&lt;TR class="mailhead"&gt;&lt;TH&gt;To:&lt;/TH&gt;&lt;TD width="100%"&gt;[%
linkNode($$NODE{author_user})
%]&lt;TD&gt;&lt;/TR&gt;
&lt;TR class="mailhead"&gt;&lt;TH&gt;From:&lt;/TH&gt;&lt;TD width="100%"&gt;[%
if (not $$NODE{from_address}) {
  return "&lt;i&gt;nobody&lt;/i&gt;";
} else {
  return $$NODE{from_address};
}
#eventually this will have links to an addressbook
#as well as a home node if a person exists within the 
#system
%]&lt;/TD&gt;&lt;/TR&gt;
&lt;/TABLE&gt;
&lt;pre&gt;
[{parseLinks:doctext}]
&lt;/pre&gt;</live_code>
<reason>replace mailhead_color bgcolor with css class mailhead</reason>
<field>page</field>
</record>
<record><htmlcode_id>297751</htmlcode_id>
<patch_code>[{votehead}]
[{voteit}]
&lt;p&gt;
[{parselinks:doctext}]
&lt;/p&gt;&lt;p&gt;
[{editinvote:Your Discussion}]
[{shownote}]
[{votefoot}]
&lt;/p&gt;&lt;p&gt;
  &lt;center&gt;
    Back to [% linkNodeTitle('Perl Monks Discussion') %]
  &lt;/center&gt;&lt;br /&gt;
&lt;/p&gt;</patch_code>
<applied>2003-10-08 17:45:24</applied>
<htmlcode_id>1421</htmlcode_id>
<live_code>[{votehead}]
[{voteit}]
&lt;p&gt;&lt;div class="doctext"&gt;
[{parselinks:doctext}]
&lt;/div&gt;&lt;/p&gt;
[{editinvote:Your Discussion}]
[{shownote}]
[{votefoot}]
[{linkToSection}]</live_code>
<reason>Allow edit of root PMD nodes</reason>
<field>page</field>
</record>
<record><htmlcode_id>721759</htmlcode_id>
<patch_code>&lt;font size="2"&gt;
  Contributed by [% linkNode($$NODE{original_author}) %]
  on [% htmlcode( 'parseTimeInString','', $NODE-&gt;{createtime}) %]
&lt;/font&gt;&lt;br /&gt;
[%
  $DB-&gt;isApproved( $USER, getNode('QandAEditors','usergroup') )
    ?  htmlcode('Q&amp;Adelete')
    :  "";
%]
[%
  my $isEditor= $DB-&gt;isApproved($USER,getNode('QandAEditors','usergroup'));
  my $nodeid= getId($NODE);
  my $votestr= '';
  my $PARENT= selectNode( $NODE-&gt;{parent_node} );
  my $str= qq[
    &lt;font size="2"&gt;
      ] . linkNodeTitle("Categorized Questions and Answers|Q&amp;A") . qq[
      &amp;nbsp;&amp;gt; ] . linkNode($PARENT) . qq[
    &lt;/font&gt;
    &lt;p&gt;
      ] . htmlcode('votehead') . qq[
      ] . htmlcode('voteit',$nodeid) . qq[
      &lt;br /&gt;];
  $str .= qq[
      &lt;script language="javascript"&gt;
        function confirmDelete(){
          if(  confirm("Delete '$$NODE{title}'?")  ) {
            parent.location= ]
              . urlGen({node_id=&gt;getId($NODE),op=&gt;"nuke"}) . qq[;
          }
        }
      &lt;/script&gt;
      &lt;font size="1"&gt;
        &lt;a href="javascript: confirmDelete();"&gt;delete&lt;/a&gt;
      &lt;/font&gt;]
    if  canDeleteNode($USER,$NODE);
  ## $str .= htmlcode('approveQ&amp;A',$nodeid)   if $isEditor;
  if(  0 &lt; length $$NODE{doctext}  ) {
    $str .= qq[
      &lt;h4&gt;Description:&lt;/h4&gt;
      &lt;ul&gt;
        ] . htmlcode('parselinks','doctext') . qq[
      &lt;/ul&gt;&lt;br /&gt;];
  }
  ## $str .= htmlcode('editinvote');
  ####editinvotestuff
  $str .= qq[
    &lt;a href=] . urlGen({ node_id=&gt;getId($NODE), op=&gt;'sopwify' }) . qq[&gt;
    SOPWify!&lt;/a&gt;&lt;br /&gt;
    ] . htmlcode('placequestionincategory')
    if  $isEditor;
  if(  canUpdateNode($USER,$NODE)
  and  getId($USER) != $HTMLVARS{default_user}  ) {
    $str .= qq[
      &lt;br /&gt;&lt;br /&gt;&lt;b&gt;Title:&lt;/b&gt;&lt;br /&gt;
      ] . htmlcode('textfield','title') . qq[
      &lt;br /&gt;&lt;br /&gt;
      &lt;b&gt;Further Description:&lt;/b&gt; (try to avoid using... keep it short and in the title)&lt;br /&gt;
      ] . htmlcode('textarea','doctext') . qq[
      &lt;br /&gt;
      ] . $query-&gt;submit("sexisgood","submit");
  }
  ####
  my( @nodes )= getNodeWhere(
    {parent_node=&gt;getId($NODE)},
    'categorized answer',
    'reputation desc'
  );
  my @unapproved;
  if(  @nodes  ) {
    $str .= qq[&lt;table class="paneled" width="100%"&gt;];
    foreach my $TEMP (  @nodes  ) {
      $HTMLVARS{embed_node}{doctext}= $$TEMP{doctext};
      $votestr= htmlcode( 'voteit', getId($TEMP) );
      $votestr .= htmlcode( 'approveQ&amp;A', getId($TEMP) )
        if $isEditor;
      $str .= qq[&lt;tr&gt;&lt;td&gt;]
           . linkNode($TEMP)
           . "&lt;br /&gt;"
           . $q-&gt;span(
                { class =&gt; 'attribution' },
                join '',
                    "contributed by ",
                    linkNode( $TEMP-&gt;{original_author} ),
                    $isEditor ? ' on '. htmlcode( 'parseTimeInString','', $TEMP-&gt;{createtime}) : '',
           );

      $str .= $votestr
             #. htmlcode('approveanswer',getId($TEMP))
             . qq[ &lt;p&gt;]
             . htmlcode('parseLinksInString')
             . qq[&lt;/td&gt;&lt;/tr&gt;];
    }
    $str .= qq[&lt;/table&gt;];
  }
  $str .= htmlcode('votefoot') . qq[
    &lt;p&gt;&lt;/p&gt;
    ] . htmlcode('addnewanswer') . qq[
    &lt;br /&gt;] . htmlcode('showhints');
  return $str;
%]
</patch_code>
<applied>2008-11-07 18:14:37</applied>
<htmlcode_id>1887</htmlcode_id>
<live_code>&lt;font size="2"&gt;
  Contributed by [% linkNode($$NODE{original_author}) %]
  on [% htmlcode( 'parseTimeInString','', $NODE-&gt;{createtime}) %]
&lt;/font&gt;&lt;br /&gt;
[%
  $DB-&gt;isApproved( $USER, getNode('QandAEditors','usergroup') )
    ?  htmlcode('Q&amp;Adelete')
    :  "";
%]
[%
  my $isEditor= $DB-&gt;isApproved($USER,getNode('QandAEditors','usergroup'));
  my $nodeid= getId($NODE);
  my $votestr= '';
  my $PARENT= selectNode( $NODE-&gt;{parent_node} );
  my $str= qq[
    &lt;font size="2"&gt;
      ] . linkNodeTitle("Categorized Questions and Answers|Q&amp;A") . qq[
      &amp;nbsp;&amp;gt; ] . linkNode($PARENT) . qq[
    &lt;/font&gt;
    &lt;p&gt;
      ] . htmlcode('votehead') . qq[
      ] . htmlcode('voteit',$nodeid) . qq[
      &lt;br /&gt;];

  if ( $isEditor or canDeleteNode($USER,$NODE) ) {
    $str .= qq[&lt;div class="catqa-commandbox"&gt;];

    $str .= qq[
      &lt;script language="javascript"&gt;
        function confirmDelete(){
          if(  confirm("Delete '$$NODE{title}'?")  ) {
            parent.location= ]
              . urlGen({node_id=&gt;getId($NODE),op=&gt;"nuke"}) . qq[;
          }
        }
      &lt;/script&gt;
      &lt;a href="javascript: confirmDelete();"&gt;Delete this question...&lt;/a&gt; ]
    if  canDeleteNode($USER,$NODE);

    $str .= qq[ &amp;mdash; &lt;a href=]
        . urlGen({ node_id=&gt;getId($NODE), op=&gt;'sopwify' })
        . qq[&gt;SOPWify!&lt;/a&gt; &amp;mdash; Change category: ]
        . htmlcode('placequestionincategory')
    if  $isEditor;

    $str .= qq[&lt;/div&gt;];
  }

  if(  0 &lt; length $$NODE{doctext}  ) {
    $str .= qq[&lt;div class="catq-description"&gt;&lt;p&gt;&lt;h4&gt;Description:&lt;/h4&gt; ]
          . htmlcode('parselinks','doctext')
          . qq[&lt;/p&gt;&lt;/div&gt;];
  }
  ## $str .= htmlcode('editinvote');

  if(  $isEditor || canUpdateNode($USER,$NODE)
  and  getId($USER) != $HTMLVARS{default_user}  ) {
    $str .= qq[
      &lt;br /&gt;&lt;br /&gt;&lt;b&gt;Title:&lt;/b&gt;&lt;br /&gt;
      ] . htmlcode('textfield','title') . qq[
      &lt;br /&gt;&lt;br /&gt;
      &lt;b&gt;Further Description:&lt;/b&gt; (try to avoid using... keep it short and in the title)&lt;br /&gt;
      ] . htmlcode('textarea','doctext') . qq[
      &lt;br /&gt;
      ] . $query-&gt;submit("sexisgood","submit");
  }
  ####
  my( @nodes )= getNodeWhere(
    {parent_node=&gt;getId($NODE)},
    'categorized answer',
    'reputation desc'
  );
  my @unapproved;
  if(  @nodes  ) {
    $str .= qq[&lt;table class="paneled" width="100%"&gt;];
    foreach my $TEMP (  @nodes  ) {
      $votestr= htmlcode( 'voteit', getId($TEMP) );
      $votestr .= htmlcode( 'approveQ&amp;A', getId($TEMP) )
        if $isEditor;
      $str .= qq[&lt;tr&gt;&lt;td&gt;]
           . linkNode($TEMP)
           . "&lt;br /&gt;"
           . $q-&gt;span(
                { class =&gt; 'attribution' },
                join '',
                    "contributed by ",
                    linkNode( $TEMP-&gt;{original_author} ),
                    $isEditor ? ' on '. htmlcode( 'parseTimeInString','', $TEMP-&gt;{createtime}) : '',
           );

      $str .= $votestr
             . qq[ &lt;p&gt;]
             . htmlcode('parseLinksInString',0,getId($TEMP),$TEMP-&gt;{doctext})
             . qq[&lt;/td&gt;&lt;/tr&gt;];
    }
    $str .= qq[&lt;/table&gt;];
  }
  $str .= htmlcode('votefoot') . qq[
    &lt;p&gt;&lt;/p&gt;
    ] . htmlcode('addnewanswer') . qq[
    &lt;br /&gt;] . htmlcode('showhints');
  return $str;
%]
</live_code>
<reason>format timestrings the modern way; add classy attribution span</reason>
<field>page</field>
</record>
<record><htmlcode_id>711321</htmlcode_id>
<patch_code>&lt;table border=0&gt;
&lt;tr&gt;&lt;td&gt;Quest starts at:&lt;/td&gt;&lt;td class="quest-time"&gt;[{parsetime:starttime}]&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;Quest ends   at:&lt;/td&gt;&lt;td class="quest-time"&gt;[{parsetime:endtime}]&lt;/td&gt;&lt;/tr&gt;
&lt;/table&gt;

&lt;p&gt;
[%
  local* getEpochSeconds = sub {
     my ( $date, $time )     = split / /, shift;
     my ( $hrs, $min, $sec ) = split /:/, $time;
     my ( $yy, $mm, $dd )    = split /-/, $date;
     use Time::Local;
     timelocal( $sec, $min, $hrs, $dd, --$mm, $yy );
  };
  my $start = getEpochSeconds( $NODE-&gt;{starttime} );
  my $end   = getEpochSeconds( $NODE-&gt;{endtime}   );
  my $now   = time;
  '  ' . $now &lt; $start ? 'This quest has yet to begin' :
         $now &gt; $end   ? 'This quest has ended'        :
                         'This quest is still active!' ;
%]
&lt;/p&gt;
[{parselinks:doctext}]
[{votehead}]
[{shownote}]
[{votefoot}]
&lt;/p&gt;&lt;p&gt;&lt;center&gt;
Back to [% linkNodeTitle('Quests',$NODE); %]
&lt;/center&gt;&lt;/p&gt;&lt;br /&gt;
</patch_code>
<applied>2008-09-14 21:37:48</applied>
<htmlcode_id>7495</htmlcode_id>
<live_code>&lt;table border=0&gt;
&lt;tr&gt;&lt;td&gt;Quest starts at:&lt;/td&gt;&lt;td class="quest-time"&gt;[{parsetime:starttime}]&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;Quest ends   at:&lt;/td&gt;&lt;td class="quest-time"&gt;[{parsetime:endtime}]&lt;/td&gt;&lt;/tr&gt;
&lt;/table&gt;

&lt;p&gt;
[%
  local* getEpochSeconds = sub {
     my ( $date, $time )     = split / /, shift;
     my ( $hrs, $min, $sec ) = split /:/, $time;
     my ( $yy, $mm, $dd )    = split /-/, $date;
     use Time::Local;
     timelocal( $sec, $min, $hrs, $dd, --$mm, $yy );
  };
  my $start = getEpochSeconds( $NODE-&gt;{starttime} );
  my $end   = getEpochSeconds( $NODE-&gt;{endtime}   );
  my $now   = time;
  '  ' . $now &lt; $start ? 'This quest has yet to begin' :
         $now &gt; $end   ? 'This quest has ended'        :
                         'This quest is still active!' ;
%]
&lt;/p&gt;
&lt;p&gt;&lt;div class="doctext"&gt;
[{parselinks:doctext}]
&lt;/div&gt;&lt;/p&gt;
[{votehead}]
[{shownote}]
[{votefoot}]
[{linkToSection}]
</live_code>
<reason>add link to Quests section</reason>
<field>page</field>
</record>
<record><htmlcode_id>698626</htmlcode_id>
<patch_code>[%
  if(  "new" eq $query-&gt;param("op")  ) {
    $$NODE{parent_node}=
      $query-&gt;param("categorized answer_parent_node");
    updateNode( $NODE, -1 );
  }
  if(  $$NODE{parent_node}  ) {
    my $PARENT= selectNode( $NODE-&gt;{parent_node} );
    my $GPARENT= selectNode( $PARENT-&gt;{parent_node} );
    my $QA= getNode( 'Categorized Questions and Answers', 'superdoc' );
    return qq[&lt;p align="left"&gt;&lt;font size="2"&gt;]
        . linkNode($QA,"Q&amp;A") . " &amp;gt; "
        . linkNode($GPARENT) . " &amp;gt; "
        . linkNode($PARENT)
        . qq[ contributed by ]
        . linkNode($NODE-&gt;{original_author})
        . qq[&lt;/font&gt;&lt;p&gt;];
  }
  return "";
%]
[%
  my $url = urlGen({ node_id=&gt;getId($NODE), op=&gt;'sopwify' });
  $DB-&gt;isApproved($USER,getNode('QandAEditors','usergroup'))
    ? qq[&lt;p&gt;&lt;b&gt;&lt;a href=$url&gt;SOPWify!&lt;/a&gt;&lt;/b&gt;&lt;/p&gt;] : ''
%]
[{votehead}]
[{voteit}]&lt;br /&gt;
[{parselinks:doctext}]
[{editinvote:Text}]
&lt;br /&gt;
&lt;!-- don't [ {showhints} ] unless is _your_ answer --&gt;
[{shownote}]
[{votefoot}]
</patch_code>
<applied>2008-07-18 13:24:24</applied>
<htmlcode_id>9818</htmlcode_id>
<live_code>[%
  if(  "new" eq $query-&gt;param("op")  ) {
    $$NODE{parent_node}=
      $query-&gt;param("categorized answer_parent_node");
    updateNode( $NODE, -1 );
  }
  if(  $$NODE{parent_node}  ) {
    my $PARENT= selectNode( $NODE-&gt;{parent_node} );
    my $GPARENT= selectNode( $PARENT-&gt;{parent_node} );
    my $QA= getNode( 'Categorized Questions and Answers', 'superdoc' );
    return qq[&lt;p align="left"&gt;&lt;font size="2"&gt;]
        . linkNode($QA,"Q&amp;A") . " &amp;gt; "
        . linkNode($GPARENT) . " &amp;gt; "
        . linkNode($PARENT)
        . qq[ contributed by ]
        . linkNode($NODE-&gt;{original_author})
        . qq[&lt;/font&gt;&lt;p&gt;];
  }
  return "";
%]
[%
  my $url = urlGen({ node_id=&gt;getId($NODE), op=&gt;'sopwify' });
  $DB-&gt;isApproved($USER,getNode('QandAEditors','usergroup'))
    ? qq[&lt;p&gt;&lt;b&gt;&lt;a href=$url&gt;SOPWify!&lt;/a&gt;&lt;/b&gt;&lt;/p&gt;] : ''
%]
[{votehead}]
[{voteit}]
&lt;p&gt;&lt;div class="doctext"&gt;
[{parselinks:doctext}]
&lt;/div&gt;&lt;/p&gt;
[{editinvote:Text}]
[{shownote}]
[{votefoot}]
</live_code>
<reason>allow to SOPWify a CatA</reason>
<field>page</field>
</record>
<record><htmlcode_id>546323</htmlcode_id>
<patch_code>[{votehead}]
[{voteit}]
&lt;p&gt;
[%
  my $str= '';
  if(  $$NODE{type}{title} eq "bookreview"
  and  $$NODE{identifier}  ) {
    my $ISBN= $$NODE{identifier};
    $str .= htmlcode( 'parselinksinstring', '', 0, '',
      "Order [isbn://$ISBN|$NODE-&gt;{title}]&lt;br /&gt;\n" );
    #$str .= "&lt;A HREF=http://www1.fatbrain.com/asp/BookInfo/
    #BookInfo.asp?theisbn=$ISBN&amp;from=MDZ411&gt;&lt;IMG SRC=
    #http://www1.fatbrain.com/asp/coverimage/coverimage.asp
    #?isbn=$ISBN WIDTH=91 HEIGHT=120 ALIGN=left BORDER=1 HSPACE=4&gt;
    #&lt;/a&gt;&amp;nbsp;&amp;nbsp;&lt;A HREF=http://www1.fatbrain.com/basket/
    #ChooseBook.cl?isbn=$ISBN&amp;from=MDZ411&amp;addbasket=
    #Add+Item+to+Basket&gt;Buy Me&lt;/A&gt;&lt;BR&gt;&lt;BR&gt;"
  }
  return $str;
%]
&lt;/p&gt;
&lt;p&gt;Item Description: [{parselinks:itemdescription}]&lt;/p&gt;
&lt;p&gt;Review Synopsis: [{parselinks:usercomment}]&lt;/p&gt;
&lt;p&gt;
[{parselinks:doctext}]
&lt;/p&gt;
[%
  return   unless  canUpdateNode($USER,$NODE)
    and  getId($USER) != $HTMLVARS{default_user};
  my $str= qq[
    Item Description:] . htmlcode('textfield','itemdescription,50')
      . qq[&lt;br /&gt;
    Review Synopsis:] . htmlcode('textfield','usercomment,50')
      . qq[&lt;br /&gt;];
  $str .= qq[
    ISBN:] . htmlcode('textfield','identifier,50')
      . qq[&lt;br /&gt;]
    if  $$NODE{type}{title} eq "bookreview";
  return $str;
%]
[{editinvote:Your review}]

[{shownote}]
[{votefoot}]
&lt;p&gt;
  &lt;center&gt;
    Back to [% linkNodeTitle('Reviews') %]
  &lt;/center&gt;
&lt;/p&gt;</patch_code>
<applied>2006-04-28 14:35:27</applied>
<htmlcode_id>21151</htmlcode_id>
<live_code>[{votehead}]
[{voteit}]
&lt;p&gt;
[%
  my $str= '';
  if(  $$NODE{type}{title} eq "bookreview"
  and  $$NODE{identifier}  ) {
    my $ISBN= $$NODE{identifier};
    $str .= htmlcode( 'parselinksinstring', '', 0, '',
      "Order [isbn://$ISBN|$NODE-&gt;{title}]&lt;br /&gt;\n" );
    #$str .= "&lt;A HREF=http://www1.fatbrain.com/asp/BookInfo/
    #BookInfo.asp?theisbn=$ISBN&amp;from=MDZ411&gt;&lt;IMG SRC=
    #http://www1.fatbrain.com/asp/coverimage/coverimage.asp
    #?isbn=$ISBN WIDTH=91 HEIGHT=120 ALIGN=left BORDER=1 HSPACE=4&gt;
    #&lt;/a&gt;&amp;nbsp;&amp;nbsp;&lt;A HREF=http://www1.fatbrain.com/basket/
    #ChooseBook.cl?isbn=$ISBN&amp;from=MDZ411&amp;addbasket=
    #Add+Item+to+Basket&gt;Buy Me&lt;/A&gt;&lt;BR&gt;&lt;BR&gt;"
  }
  return $str;
%]
&lt;/p&gt;
&lt;p&gt;Item Description: [{parselinks:itemdescription}]&lt;/p&gt;
&lt;p&gt;Review Synopsis: [{parselinks:usercomment}]&lt;/p&gt;
&lt;p&gt;
[{parselinks:doctext}]
&lt;/p&gt;
[%
  return   unless  canUpdateNode($USER,$NODE);
  my $str= qq[
    Item Description:] . htmlcode('textfield','itemdescription,50')
      . qq[&lt;br /&gt;
    Review Synopsis:] . htmlcode('textfield','usercomment,50')
      . qq[&lt;br /&gt;];
  $str .= qq[
    ISBN:] . htmlcode('textfield','identifier,50')
      . qq[&lt;br /&gt;]
    if  $$NODE{type}{title} eq "bookreview";
  return $str;
%]
[{editinvote:Your review}]

[{shownote}]
[{votefoot}]
&lt;p&gt;
  &lt;center&gt;
    Back to [% linkNodeTitle('Reviews') %]
  &lt;/center&gt;
&lt;/p&gt;</live_code>
<reason>DEV Update Fri Apr 28 17:40:26 2006</reason>
<field>page</field>
</record>
<record><htmlcode_id>433978</htmlcode_id>
<patch_code>[{votehead}]
[{voteit}]
&lt;p&gt;
[{parselinks:doctext}]
&lt;/p&gt;&lt;p&gt;
[{editinvote:Your News}]
[{shownote}]
[{votefoot}]
&lt;/p&gt;&lt;p&gt;
  &lt;center&gt;
    Back to [% linkNodeTitle('Perl News') %]
  &lt;/center&gt;&lt;br /&gt;
&lt;/p&gt;</patch_code>
<applied>2005-02-24 03:26:34</applied>
<htmlcode_id>23789</htmlcode_id>
<live_code>[{votehead}]
[{voteit}]
&lt;p&gt;&lt;div class="doctext"&gt;
[{parselinks:doctext}]
&lt;/div&gt;&lt;/p&gt;
[{editinvote:Your News}]
[{shownote}]
[{votefoot}]
[{linkToSection}]</live_code>
<reason>Allow author to edit own nodes</reason>
<field>page</field>
</record>
<record><htmlcode_id>494133</htmlcode_id>
<patch_code>[%
    return $q-&gt;p(
      { align =&gt; 'right' },
      $q-&gt;small(
        (htmlcode( 'hasWikiPermission', 'writers' ) ? 
        linkNode(
          $NODE,
          'Edit Wiki',
          { displaytype =&gt; 'editpage' }
        )."&lt;br /&gt;(Size:".length($NODE-&gt;{doctext}).")"
         . "&lt;br /&gt; " : "").
        linkNode(
          $NODE,
          'View Recent Edits',
          { displaytype =&gt; 'edithistory', limit =&gt; 25 }
        )
      ) 
    );
%]
[%
  if (  htmlcode( 'hasWikiPermission', 'readers' )  ) {
    $VARS-&gt;{ 'wiki' . getId($NODE) } = $NODE-&gt;{lastedit};

    return htmlcode( 'parselinks', 'doctext' );
  } else {
    return "You don't have sufficient permission to view this node";
  }
%]</patch_code>
<applied>2005-09-22 10:23:33</applied>
<htmlcode_id>68051</htmlcode_id>
<live_code>[%
    return $q-&gt;p(
      { align =&gt; 'right' },
      $q-&gt;small(
        (htmlcode( 'hasWikiPermission', 'writers' ) ? 
        linkNode(
          $NODE,
          'Edit Wiki',
          { displaytype =&gt; 'editpage' }
        )."&lt;br /&gt;(Size:".length($NODE-&gt;{doctext}).")"
         . "&lt;br /&gt; " : "").
        linkNode(
          $NODE,
          'View Recent Edits',
          { displaytype =&gt; 'edithistory', limit =&gt; 25 }
        )
      ) 
    );
%]
[%
  if (  htmlcode( 'hasWikiPermission', 'readers' )  ) {
    $VARS-&gt;{ 'wiki' . getId($NODE) } = $NODE-&gt;{lastedit};

    return htmlcode( 'parselinks', 'doctext' );
  } else {
    return "&lt;div class='tough-beans'&gt;You don't have "
          ."sufficient permission to view this node.&lt;/div&gt;";
  }
%]</live_code>
<reason>let anybody see the edithistory link</reason>
<field>page</field>
</record>
<record><htmlcode_id>570827</htmlcode_id>
<patch_code>&lt;h4&gt;[% htmlcode( 'ParseLinksInContent', $NODE-&gt;{title}, simplecode =&gt; 1 ) %]&lt;/h4&gt;
[%

# Note: when patch this, don't forget to synch [Voting Booth]

my @choice = split( /\n/, $NODE-&gt;{choices} );
my @choice_votecount = split( /\n/, $NODE-&gt;{numbers} );

my %labels = map {
    $_ =&gt; htmlcode(
        'ParseLinksInContent', '',
        $choice[ $_ ],
        simplecode =&gt; 1,
    )
} 0 .. $#choice;

my $total_votes = 0;
$total_votes += $_ foreach @choice_votecount;

( $NODE-&gt;{prologue} &amp;&amp; htmlcode( 'ParseLinksInContent', '', $NODE-&gt;{prologue} ) )
. htmlcode('openform', -displaytype =&gt; 'display')
. "\n&lt;p&gt;\n"
. $query-&gt;radio_group(
    -name      =&gt; 'vote',
    -values    =&gt; [ 0 .. $#choice ],
    -labels    =&gt; \%labels,
    -linebreak =&gt;'true',
)
. &lt;&lt;'END_HTML'
&lt;input type="submit" value="Vote"&gt;
&lt;/p&gt;
&lt;/form&gt;

&lt;p&gt;
END_HTML
. linkNode($NODE, "Results ($total_votes votes)")
. ', '
. linkNodeTitle("past polls|past polls")
. '&lt;/p&gt;'
%]</patch_code>
<applied>2006-09-01 16:50:31</applied>
<htmlcode_id>97831</htmlcode_id>
<live_code>&lt;h4&gt;[% htmlcode( 'ParseLinksInContent', $NODE-&gt;{title}, simplecode =&gt; 1 ) %]&lt;/h4&gt;
[%

# Note: when patch this, don't forget to synch [Voting Booth]

my @choice = split( /\n/, $NODE-&gt;{choices} );
my @choice_votecount = split( /\n/, $NODE-&gt;{numbers} );

my %labels = map {
    $_ =&gt; htmlcode(
        'ParseLinksInContent', '',
        $choice[ $_ ],
        simplecode =&gt; 1,
    )
} 0 .. $#choice;

my $total_votes = 0;
$total_votes += $_ foreach @choice_votecount;

( $NODE-&gt;{prologue} &amp;&amp; htmlcode( 'ParseLinksInContent', '', $NODE-&gt;{prologue} ) )
. htmlcode('openform', -displaytype =&gt; 'display')
. "\n&lt;p&gt;\n"
. $query-&gt;radio_group(
    -name      =&gt; 'vote',
    -values    =&gt; [ 0 .. $#choice ],
    -labels    =&gt; \%labels,
    -linebreak =&gt;'true',
    -default   =&gt; 'n/a',
)
. &lt;&lt;'END_HTML'
&lt;input type="submit" value="Vote"&gt;
&lt;/p&gt;
&lt;/form&gt;

&lt;p&gt;
END_HTML
. linkNode($NODE, "Results ($total_votes votes)")
. ', '
. linkNodeTitle("past polls|past polls")
. '&lt;/p&gt;'
%]</live_code>
<reason>add prologue</reason>
<field>page</field>
</record>
<record><htmlcode_id>417722</htmlcode_id>
<patch_code>[%
   my $DEV= getNode( 'pmdev','usergroup' );
   return "Sorry, you can't see this because you aren't a developer."
      unless  $DB-&gt;isApproved( $USER, $DEV );

   my $field = htmlcode('lookup_patchable_field');

   unless ($field) {
     return "&lt;p&gt;&lt;b&gt;Sorry 'viewcode' Does Not Mean Anything For This Nodetype.&lt;/b&gt;&lt;/p&gt;".
            "&lt;p&gt;There doesn't appear to be any code associated directly ".
            "with the nodetype of this node (".
            linkNode($NODE-&gt;{type}).
            "). If you think this is wrong please ask a ".
            linkNode(getNode("gods",'usergroup'),"god").
            " to update ".
            "the relevent setting.&lt;/p&gt;&lt;p&gt;It is much more likely that ".
            "the code you really want to see is in one of the following ".
            "display pages that are used to render this nodetype:&lt;/p&gt;".
            htmlcode('get_display_types');
   }
      

   my $html;
   if ($field eq "vars") {
      $html .= htmlcode( 'displayvars', '', $field );
      $html .= htmlcode( 'open_new_patch_form', '', 'vars', 'edit' );
      $html .= $q-&gt;hidden( -name=&gt;"patch_code", -value=&gt;$NODE-&gt;{vars}, -force=&gt;1 );
      $html .= htmlcode( 'closeform', 'Create Patch' );
   } else {
      $html .= htmlcode( 'listcode', '', $field );
   }
   return $html .
      '&lt;hr /&gt;'.
      htmlcode('listpatches');
%]</patch_code>
<applied>2004-12-28 03:57:40</applied>
<htmlcode_id>106846</htmlcode_id>
<live_code>[%
    return "Sorry, you can't see this because you aren't a developer."
        if  ! $DB-&gt;isApproved( $USER, 'pmdev' );

    my $field= htmlcode('lookup_patchable_field');

    if(  ! $field  ) {
        return join "\n",
            "&lt;p&gt;&lt;b&gt;Sorry 'viewcode' means nothing for this nodetype.&lt;/b&gt;&lt;/p&gt;",
            "&lt;p&gt;There doesn't appear to be any code associated directly",
            "with the nodetype of this node",
            "(" . linkNode( $NODE-&gt;{type} ) . ").",
            "If you think this is wrong please ask a",
            linkNode( getNode("gods",'usergroup'), "god" ),
            "to update the relevent setting.&lt;/p&gt;",
            "&lt;p&gt;It is much more likely that the code you really",
            "want to see is in one of the following display",
            "pages that are used to render this nodetype:&lt;/p&gt;",
            htmlcode('get_display_types'),
        '';
    }

    my $html= '';
    if(  'vars' ne $field  ) {
        $html .= htmlcode( 'listcode','', $field );
    } else {
        $html .= join "\n",
            htmlcode( 'displayvars','', $field ),
            htmlcode( 'open_new_patch_form','', 'vars', 'edit' ),
            $q-&gt;sethidden( "patch_code", $NODE-&gt;{vars} ),
            htmlcode( 'closeform','', 'Create Patch' ),
        '';
    }

    if(  'patch' ne $NODE-&gt;{type}{title}  ) {
        $html .= join "\n",
            "&lt;br /&gt;",
            htmlcode('showsitedoclet'),
            htmlcode('listpatches'),
        '';
    } elsif(  'vars' ne $field  ) {
        $html .= join "\n",
            "&lt;p&gt;This text area allows you to cut/copy the patched text:",
            "&lt;br /&gt;&lt;form&gt;",
            $q-&gt;textarea( 'code', $NODE-&gt;{$field}, 20, 60 ),
            "&lt;/form&gt;&lt;/p&gt;",
        '';
    }

    return $html;
%]
</live_code>
<reason>enhance the "no code to view" error message with relevent display pages</reason>
<field>page</field>
</record>
<record><htmlcode_id>776083</htmlcode_id>
<patch_code>[%
    my $author= getNodeById( $NODE-&gt;{author_user});
    if(  '[NodeReaper]' eq $author-&gt;{nick}  ) {
        return join '',
            q{&lt;p&gt;Account locked&lt;/p&gt;},
            q{&lt;p&gt;Please &lt;a href="?node_id=491035"&gt;contact the site administrators&lt;/a&gt;},
              q{ if you feel your account should be made available again.&lt;/p&gt;},
    } else {
        return htmlcode('handle_scratchpad_display')
    }
%]</patch_code>
<applied>2009-06-30 17:36:53</applied>
<htmlcode_id>182720</htmlcode_id>
<live_code>[%
    my $author= getNodeById( $NODE-&gt;{author_user} );
    if(  '[NodeReaper]' eq $author-&gt;{nick}  ) {
        return join "\n",
            q{&lt;p&gt;Account locked&lt;/p&gt;},
            q{&lt;p&gt;Please &lt;a href="?node_id=491035"&gt;contact the site administrators&lt;/a&gt;},
            q{ if you feel your account should be made available again.&lt;/p&gt;},
        '';
    } elsif(    $HTMLVARS{guest_user} == getId($USER)
            &amp;&amp;  Everything::Experience::getLevel($NODE-&gt;{author_user}) &lt; 4
    ) {
        return join "\n",
            q{&lt;p&gt;Anonymous users can't see the scratchpads of new monks.&lt;/p&gt;},
            q{&lt;p&gt;Please &lt;a href="?node_id=109"&gt;log in&lt;/a&gt;},
            q{ if you want to view this scratchpad.&lt;/p&gt;},
            q{&lt;p&gt;At Level 4, a monk's scratchpad becomes visible},
            q{to even anonymous visitors.&lt;/p&gt;},
        '';
    } else {
        return htmlcode('handle_scratchpad_display');
    }
%]
</live_code>
<reason>Don't display locked users' content</reason>
<field>page</field>
</record>
<record><htmlcode_id>781064</htmlcode_id>
<patch_code>[%
    return ''
        if  ! canUpdateNode($USER,$NODE);
    return join "\n",
        '&lt;p align="right"&gt;&lt;small&gt;&lt;b&gt;',
        linkNode(
            $NODE,
            'Edit',
            { displaytype =&gt; 'edit' },
        ),
        '&lt;/b&gt;&lt;/small&gt;&lt;p&gt;';
%]
[% htmlcode( 'get_sitedoclet','', $NODE ) %]
</patch_code>
<applied>2009-07-17 10:05:11</applied>
<htmlcode_id>370027</htmlcode_id>
<live_code>[%
    return ''
        if  ! canUpdateNode($USER,$NODE);
    return join "\n",
        '&lt;p align="right"&gt;&lt;small&gt;&lt;b&gt;',
        linkNode(
            $NODE,
            'Edit',
            { displaytype =&gt; 'edit' },
        ),
        linkNode(
            $NODE,
            'History',
            { displaytype =&gt; 'edithistory' },
        ),
        '&lt;/b&gt;&lt;/small&gt;&lt;p&gt;';
%]
[% htmlcode( 'get_sitedoclet','', $NODE ) %]
</live_code>
<reason>Clean code (no functional change)</reason>
<field>page</field>
</record>
<record><htmlcode_id>450953</htmlcode_id>
<patch_code>[%
  if(  my $msg = htmlcode('reject_anon_user') ) {
    return $msg;
  } else {
    return htmlcode('parsecode','doctext');
  }
%]
</patch_code>
<applied>2005-04-24 10:29:07</applied>
<htmlcode_id>450952</htmlcode_id>
<live_code>This display type does nothing (useful).
[%
# It used to be the user_superdoc 'display' displaytype
%]</live_code>
<reason>exclude annony</reason>
<field>page</field>
</record>
<record><htmlcode_id>450977</htmlcode_id>
<patch_code>[%
  if(  my $msg = htmlcode('reject_anon_user') ) {
    return $msg;
  } else {
    return htmlcode('parsecode','doctext');
  }
%]
</patch_code>
<applied>2005-04-24 10:30:27</applied>
<htmlcode_id>450956</htmlcode_id>
<live_code>This displaytype does nothing (useful).
[%
# It used to be the "raw" displaytype for user_superdoc but we no
# longer need lots of flavors of 'superdoc' so these became useless
%]</live_code>
<reason>reject anonymous users</reason>
<field>page</field>
</record>
<record><htmlcode_id>546823</htmlcode_id>
<patch_code>[{openform}]

&lt;h4&gt;title:&lt;/h4&gt;
&lt;p&gt;[{textfield:title}]&lt;/p&gt;

&lt;h4&gt;Choices:&lt;/h4&gt;
&lt;p&gt;[{textarea:choices}]&lt;/p&gt;

&lt;h4&gt;numbers&lt;/h4&gt;
&lt;p&gt;[{textarea:numbers}]&lt;/p&gt;

&lt;h4&gt;gimmick&lt;/h4&gt;
&lt;p&gt;[{textfield:gimmick,11}]&lt;/p&gt;

&lt;h4&gt;gimmickchoice&lt;/h4&gt;
&lt;p&gt;[{textfield:gimmickchoice,11}]&lt;/p&gt;

[{closeform}]</patch_code>
<applied>2006-05-02 01:22:45</applied>
<htmlcode_id>517553</htmlcode_id>
<live_code>[{openform}]

&lt;h4&gt;title:&lt;/h4&gt;
&lt;p&gt;[{textfield:title}]&lt;/p&gt;

&lt;h4&gt;Choices:&lt;/h4&gt;
&lt;p&gt;[{textarea:choices}]&lt;/p&gt;

&lt;h4&gt;numbers&lt;/h4&gt;
&lt;p&gt;[{textarea:numbers}]&lt;/p&gt;

&lt;h4&gt;prologue&lt;/h4&gt;
&lt;p&gt;[{textarea:prologue}]&lt;/p&gt;

&lt;h4&gt;gimmick&lt;/h4&gt;
&lt;p&gt;[{textfield:gimmick,11}]&lt;/p&gt;

&lt;h4&gt;gimmickchoice&lt;/h4&gt;
&lt;p&gt;[{textfield:gimmickchoice,11}]&lt;/p&gt;

[{closeform}]</live_code>
<reason>gimmicks</reason>
<field>page</field>
</record>
<record><htmlcode_id>519225</htmlcode_id>
<patch_code>&lt;h4&gt;[% htmlcode( 'ParseLinksInContent', $NODE-&gt;{title}, simplecode =&gt; 1 ) %]&lt;/h4&gt;
[%

# Note: when patch this, don't forget to synch [Voting Booth]

my @choice = split( /\n/, $NODE-&gt;{choices} );
my @choice_votecount = split( /\n/, $NODE-&gt;{numbers} );

my %labels = map {
    $_ =&gt; htmlcode(
        'ParseLinksInContent', '',
        $choice[ $_ ],
        simplecode =&gt; 1,
    )
} 0 .. $#choice;

my $total_votes = 0;
$total_votes += $_ foreach @choice_votecount;

htmlcode('openform', -displaytype =&gt; 'display')
. "\n&lt;p&gt;\n"
. $query-&gt;radio_group(
    -name      =&gt; 'vote',
    -values    =&gt; [ 0 .. $#choice ],
    -labels    =&gt; \%labels,
    -linebreak =&gt;'true',
)
. &lt;&lt;'END_HTML'
&lt;input type="submit" value="Vote"&gt;
&lt;/p&gt;
&lt;/form&gt;

&lt;p&gt;
END_HTML
. linkNode($NODE, "Results ($total_votes votes)")
. ', '
. linkNodeTitle("past polls|past polls")
. '&lt;/p&gt;'
%]</patch_code>
<applied>2005-12-26 19:04:01</applied>
<htmlcode_id>517554</htmlcode_id>
<live_code>&lt;h4&gt;[% htmlcode( 'ParseLinksInContent', $NODE-&gt;{title}, simplecode =&gt; 1 ) %]&lt;/h4&gt;
[%

# Note: when patch this, don't forget to synch [Voting Booth]

my @choice = split( /\n/, $NODE-&gt;{choices} );
my @choice_votecount = split( /\n/, $NODE-&gt;{numbers} );

my %labels = map {
    $_ =&gt; htmlcode(
        'ParseLinksInContent', '',
        $choice[ $_ ],
        simplecode =&gt; 1,
    )
} 0 .. $#choice;

my $total_votes = 0;
$total_votes += $_ foreach @choice_votecount;

( $NODE-&gt;{prologue} &amp;&amp; htmlcode( 'ParseLinksInContent', '', $NODE-&gt;{prologue} ) )
. htmlcode('openform', -displaytype =&gt; 'display')
. "\n&lt;p&gt;\n"
. $query-&gt;radio_group(
    -name      =&gt; 'vote',
    -values    =&gt; [ 0 .. $#choice ],
    -labels    =&gt; \%labels,
    -linebreak =&gt;'true',
    -default   =&gt; 'n/a',
)
. &lt;&lt;'END_HTML'
&lt;input type="submit" value="Vote"&gt;
&lt;/p&gt;
&lt;/form&gt;

&lt;p&gt;
END_HTML
. linkNode($NODE, "Results ($total_votes votes)")
. ', '
. linkNodeTitle("past polls|past polls")
. '&lt;/p&gt;'
%]</live_code>
<reason>keep in sync</reason>
<field>page</field>
</record>
<record><htmlcode_id>605813</htmlcode_id>
<patch_code>[%
    my $text= $NODE-&gt;{doctext};
    my $as= lc(($q-&gt;param("as"))[-1])
        || $VARS-&gt;{sourcetext_as} || "code";
    if(  "text" eq $as  ) {
        if(  "bare" eq $q-&gt;param("style")  ) {
            return join '',
                $q-&gt;header("text/plain"),
                $text;
        }
        return join '',
            "&lt;pre&gt;\n",
            $q-&gt;escapeHTML( $text ),
            "\n&lt;/pre&gt;\n";
    }
    if(  "html" eq $as  ) {
        $text= $q-&gt;escapeHTML( $text );
        $text =~ s/  / &amp;nbsp;/g;
        $text =~ s/\t/&amp;rarr;/g;
        $text =~ s!\n!&lt;br /&gt;\n!g;
        return $text;
    }
    return htmlcode( 'wrapcode','', $text );
%]
</patch_code>
<applied>2007-03-21 06:09:07</applied>
<htmlcode_id>605808</htmlcode_id>
<live_code>[%
    my $text= $NODE-&gt;{doctext};
    my $as= lc(($q-&gt;param("as"))[-1])
        || $VARS-&gt;{sourcetext_as} || "code";
    if(  "text" eq $as  ) {
        if(  "bare" eq $q-&gt;param("style")  ) {
            $CURRENTNODE-&gt;{parent_container}= '';
            return join '',
                $q-&gt;header("text/plain"),
                $text;
        }
        return join '',
            "&lt;pre&gt;\n",
            $q-&gt;escapeHTML( $text ),
            "\n&lt;/pre&gt;\n";
    }
    if(  "html" eq $as  ) {
        $text= $q-&gt;escapeHTML( $text );
        $text =~ s/  / &amp;nbsp;/g;
        $text =~ s/\t/&amp;rarr;/g;
        $text =~ s!\n!&lt;br /&gt;\n!g;
        return $text;
    }
    return htmlcode( 'wrapcode','', $text );
%]
</live_code>
<reason>Make "html" and non-bare "text" not so awful</reason>
<field>page</field>
</record>
</sqlqueryresult>
</node>
