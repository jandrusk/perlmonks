<node>
  <doctext>&lt;HR&gt;
&lt;P&gt;
&lt;H1&gt;&lt;A NAME=&quot;NAME&quot;&gt;NAME&lt;/A&gt;&lt;/H1&gt;
&lt;P&gt;
perllocale - Perl locale handling (internationalization and localization)

&lt;P&gt;
&lt;HR&gt;
&lt;H1&gt;&lt;A NAME=&quot;DESCRIPTION&quot;&gt;DESCRIPTION&lt;/A&gt;&lt;/H1&gt;
&lt;P&gt;
Perl supports language-specific notions of data such as ``is this a
letter'', ``what is the uppercase equivalent of this letter'', and ``which
of these letters comes first''. These are important issues, especially for
languages other than English--but also for English: it would be na&amp;iuml;ve
to imagine that &lt;CODE&gt;A-Za-z&lt;/CODE&gt; defines all the ``letters'' needed to write in English. Perl is also aware
that some character other than '.' may be preferred as a decimal point, and
that output date representations may be language-specific. The process of
making an application take account of its users' preferences in such
matters is called &lt;STRONG&gt;internationalization&lt;/STRONG&gt; (often abbreviated as &lt;STRONG&gt;i18n&lt;/STRONG&gt;); telling such an application about a particular set of preferences is
known as
&lt;STRONG&gt;localization&lt;/STRONG&gt; (&lt;STRONG&gt;l10n&lt;/STRONG&gt;).

&lt;P&gt;
Perl can understand language-specific data via the standardized 
&lt;FONT SIZE=-1&gt;(ISO&lt;/FONT&gt; 
&lt;FONT SIZE=-1&gt;C,&lt;/FONT&gt; 
&lt;FONT SIZE=-1&gt;XPG4,&lt;/FONT&gt; 
&lt;FONT SIZE=-1&gt;POSIX&lt;/FONT&gt; 1.c) method called ``the locale system''. The locale system is controlled per application using one pragma, one function call, and several environment variables.

&lt;P&gt;
&lt;STRONG&gt;NOTE&lt;/STRONG&gt;: This feature is new in Perl 5.004, and does not apply unless an
application specifically requests it--see &lt;A HREF=&quot;#Backward_compatibility&quot;&gt;Backward compatibility&lt;/A&gt;. The one exception is that 
&lt;CODE&gt;write()&lt;/CODE&gt; now &lt;STRONG&gt;always&lt;/STRONG&gt; uses the current locale - see &lt;A HREF=&quot;#NOTES&quot;&gt;NOTES&lt;/A&gt;.

&lt;P&gt;
&lt;HR&gt;
&lt;H1&gt;&lt;A NAME=&quot;PREPARING_TO_USE_LOCALES&quot;&gt;PREPARING TO USE LOCALES&lt;/A&gt;&lt;/H1&gt;
&lt;P&gt;
If Perl applications are to understand and present your data correctly
according a locale of your choice, &lt;STRONG&gt;all&lt;/STRONG&gt; of the following must be true:

&lt;UL&gt;
&lt;LI&gt;
&lt;P&gt;
&lt;STRONG&gt;Your operating system must support the locale system&lt;/STRONG&gt;. If it does, you should find that the 
&lt;CODE&gt;setlocale()&lt;/CODE&gt; function is a documented part of its 
&lt;FONT SIZE=-1&gt;C&lt;/FONT&gt; library.

&lt;P&gt;&lt;LI&gt;

&lt;STRONG&gt;Definitions for locales that you use must be installed&lt;/STRONG&gt;. You, or your system administrator, must make sure that this is the case.
The available locales, the location in which they are kept, and the manner
in which they are installed all vary from system to system. Some systems
provide only a few, hard-wired locales and do not allow more to be added.
Others allow you to add ``canned'' locales provided by the system supplier.
Still others allow you or the system administrator to define and add
arbitrary locales. (You may have to ask your supplier to provide canned
locales that are not delivered with your operating system.) Read your
system documentation for further illumination.

&lt;P&gt;&lt;LI&gt;

&lt;STRONG&gt;Perl must believe that the locale system is supported&lt;/STRONG&gt;. If it does,
&lt;CODE&gt;perl -V:d_setlocale&lt;/CODE&gt; will say that the value for &lt;CODE&gt;d_setlocale&lt;/CODE&gt; is
&lt;CODE&gt;define&lt;/CODE&gt;.

&lt;/UL&gt;
&lt;P&gt;
If you want a Perl application to process and present your data according
to a particular locale, the application code should include the &lt;CODE&gt;use&amp;nbsp;locale&lt;/CODE&gt; pragma (see &lt;A HREF=&quot;#The_use_locale_pragma&quot;&gt;The use locale pragma&lt;/A&gt;) where appropriate, and &lt;STRONG&gt;at least one&lt;/STRONG&gt; of the following must be true:

&lt;UL&gt;
&lt;LI&gt;
&lt;P&gt;
&lt;STRONG&gt;The locale-determining environment variables (see &lt;A HREF=&quot;#ENVIRONMENT&quot;&gt;ENVIRONMENT&lt;/A&gt;)
must be correctly set up&lt;/STRONG&gt; at the time the application is started, either by yourself or by whoever
set up your system account.

&lt;P&gt;&lt;LI&gt;

&lt;STRONG&gt;The application must set its own locale&lt;/STRONG&gt; using the method described in
&lt;A HREF=&quot;#The_setlocale_function&quot;&gt;The setlocale function&lt;/A&gt;.

&lt;/UL&gt;
&lt;P&gt;
&lt;HR&gt;
&lt;H1&gt;&lt;A NAME=&quot;USING_LOCALES&quot;&gt;USING LOCALES&lt;/A&gt;&lt;/H1&gt;
&lt;P&gt;
&lt;HR&gt;
&lt;H2&gt;&lt;A NAME=&quot;The_use_locale_pragma&quot;&gt;The use locale pragma&lt;/A&gt;&lt;/H2&gt;
&lt;P&gt;
By default, Perl ignores the current locale. The &lt;CODE&gt;use&amp;nbsp;locale&lt;/CODE&gt;
pragma tells Perl to use the current locale for some operations:

&lt;UL&gt;
&lt;LI&gt;
&lt;P&gt;
&lt;STRONG&gt;The comparison operators&lt;/STRONG&gt; (&lt;CODE&gt;lt&lt;/CODE&gt;, &lt;CODE&gt;le&lt;/CODE&gt;, &lt;CODE&gt;cmp&lt;/CODE&gt;, &lt;CODE&gt;ge&lt;/CODE&gt;, and &lt;CODE&gt;gt&lt;/CODE&gt;) and the 
&lt;FONT SIZE=-1&gt;POSIX&lt;/FONT&gt; string collation functions 
&lt;CODE&gt;strcoll()&lt;/CODE&gt; and 
&lt;CODE&gt;strxfrm()&lt;/CODE&gt; use

&lt;CODE&gt;LC_COLLATE&lt;/CODE&gt;. 
&lt;CODE&gt;sort()&lt;/CODE&gt; is also affected if used
without an explicit comparison function, because it uses &lt;CODE&gt;cmp&lt;/CODE&gt; by default.

&lt;P&gt;
&lt;STRONG&gt;Note:&lt;/STRONG&gt;  &lt;CODE&gt;eq&lt;/CODE&gt; and &lt;CODE&gt;ne&lt;/CODE&gt; are unaffected by locale: they always perform a byte-by-byte comparison of
their scalar operands. What's more, if &lt;CODE&gt;cmp&lt;/CODE&gt; finds that its operands are equal according to the collation sequence
specified by the current locale, it goes on to perform a byte-by-byte
comparison, and only returns &lt;EM&gt;0&lt;/EM&gt; (equal) if the operands are bit-for-bit identical. If you really want to
know whether two strings--which &lt;CODE&gt;eq&lt;/CODE&gt; and &lt;CODE&gt;cmp&lt;/CODE&gt; may consider different--are equal as far as collation in the locale is
concerned, see the discussion in
&lt;A HREF=&quot;#Category_LC_COLLATE_Collation&quot;&gt;Category LC_COLLATE: Collation&lt;/A&gt;.

&lt;P&gt;&lt;LI&gt;

&lt;STRONG&gt;Regular expressions and case-modification functions&lt;/STRONG&gt; (uc(), 
&lt;CODE&gt;lc(),&lt;/CODE&gt; 
&lt;CODE&gt;ucfirst(),&lt;/CODE&gt; and 
&lt;CODE&gt;lcfirst())&lt;/CODE&gt; use
 &lt;CODE&gt;LC_CTYPE&lt;/CODE&gt;

&lt;P&gt;&lt;LI&gt;

&lt;STRONG&gt;The formatting functions&lt;/STRONG&gt; (printf(), 
&lt;CODE&gt;sprintf()&lt;/CODE&gt; and 
&lt;CODE&gt;write())&lt;/CODE&gt; use

&lt;CODE&gt;LC_NUMERIC&lt;/CODE&gt;

&lt;P&gt;&lt;LI&gt;

&lt;STRONG&gt;The POSIX date formatting function&lt;/STRONG&gt; (strftime()) uses &lt;CODE&gt;LC_TIME&lt;/CODE&gt;.

&lt;/UL&gt;
&lt;P&gt;
&lt;CODE&gt;LC_COLLATE&lt;/CODE&gt;, &lt;CODE&gt;LC_CTYPE&lt;/CODE&gt;, and so on, are discussed further in &lt;A HREF=&quot;#LOCALE_CATEGORIES&quot;&gt;LOCALE CATEGORIES&lt;/A&gt;.

&lt;P&gt;
The default behavior is restored with the &lt;CODE&gt;no&amp;nbsp;locale&lt;/CODE&gt; pragma, or upon reaching the end of block enclosing &lt;CODE&gt;use locale&lt;/CODE&gt;.

&lt;P&gt;
The string result of any operation that uses locale information is tainted,
as it is possible for a locale to be untrustworthy. See &lt;A HREF=&quot;#SECURITY&quot;&gt;SECURITY&lt;/A&gt;.

&lt;P&gt;
&lt;HR&gt;
&lt;H2&gt;&lt;A NAME=&quot;The_setlocale_function&quot;&gt;The setlocale function&lt;/A&gt;&lt;/H2&gt;
&lt;P&gt;
You can switch locales as often as you wish at run time with the
POSIX::setlocale() function:

&lt;P&gt;
&lt;PRE&gt;        # This functionality not usable prior to Perl 5.004
        require 5.004;
&lt;/PRE&gt;
&lt;P&gt;
&lt;PRE&gt;        # Import locale-handling tool set from POSIX module.
        # This example uses: setlocale -- the function call
        #                    LC_CTYPE -- explained below
        use POSIX qw(locale_h);
&lt;/PRE&gt;
&lt;P&gt;
&lt;PRE&gt;        # query and save the old locale
        $old_locale = setlocale(LC_CTYPE);
&lt;/PRE&gt;
&lt;P&gt;
&lt;PRE&gt;        setlocale(LC_CTYPE, &amp;quot;fr_CA.ISO8859-1&amp;quot;);
        # LC_CTYPE now in locale &amp;quot;French, Canada, codeset ISO 8859-1&amp;quot;
&lt;/PRE&gt;
&lt;P&gt;
&lt;PRE&gt;        setlocale(LC_CTYPE, &amp;quot;&amp;quot;);
        # LC_CTYPE now reset to default defined by LC_ALL/LC_CTYPE/LANG
        # environment variables.  See below for documentation.
&lt;/PRE&gt;
&lt;P&gt;
&lt;PRE&gt;        # restore the old locale
        setlocale(LC_CTYPE, $old_locale);
&lt;/PRE&gt;
&lt;P&gt;
The first argument of 
&lt;CODE&gt;setlocale()&lt;/CODE&gt; gives the &lt;STRONG&gt;category&lt;/STRONG&gt;, the second the
&lt;STRONG&gt;locale&lt;/STRONG&gt;. The category tells in what aspect of data processing you want to apply
locale-specific rules. Category names are discussed in
&lt;A HREF=&quot;#LOCALE_CATEGORIES&quot;&gt;LOCALE CATEGORIES&lt;/A&gt; and &lt;A HREF=&quot;#ENVIRONMENT&quot;&gt;ENVIRONMENT&lt;/A&gt;. The locale is the name of a collection of customization information
corresponding to a particular combination of language, country or
territory, and codeset. Read on for hints on the naming of locales: not all
systems name locales as in the example.

&lt;P&gt;
If no second argument is provided and the category is something else than 
&lt;FONT SIZE=-1&gt;LC_ALL,&lt;/FONT&gt; the function returns a string naming the current locale for the category. You can use this value as the second argument in a subsequent call to 
&lt;CODE&gt;setlocale().&lt;/CODE&gt;

&lt;P&gt;
If no second argument is provided and the category is 
&lt;FONT SIZE=-1&gt;LC_ALL,&lt;/FONT&gt; the result is implementation-dependent. It may
be a string of concatenated locales names (separator also
implementation-dependent) or a single locale name. Please consult your &lt;EM&gt;setlocale(3)&lt;/EM&gt; for details.

&lt;P&gt;
If a second argument is given and it corresponds to a valid locale, the locale for the category is set to that value, and the function returns the now-current locale value. You can then use this in yet another call to 
&lt;CODE&gt;setlocale().&lt;/CODE&gt; (In some implementations, the return value may sometimes differ from the value you gave as the second argument--think of it as an alias for the value you gave.)

&lt;P&gt;
As the example shows, if the second argument is an empty string, the category's locale is returned to the default specified by the corresponding environment variables. Generally, this results in a return to the default that was in force when Perl started up: changes to the environment made by the application after startup may or may not be noticed, depending on your system's 
&lt;FONT SIZE=-1&gt;C&lt;/FONT&gt; library.

&lt;P&gt;
If the second argument does not correspond to a valid locale, the locale
for the category is not changed, and the function returns &lt;EM&gt;undef&lt;/EM&gt;.

&lt;P&gt;
For further information about the categories, consult &lt;EM&gt;setlocale(3)&lt;/EM&gt;.

&lt;P&gt;
&lt;HR&gt;
&lt;H2&gt;&lt;A NAME=&quot;Finding_locales&quot;&gt;Finding locales&lt;/A&gt;&lt;/H2&gt;
&lt;P&gt;
For locales available in your system, consult also &lt;EM&gt;setlocale(3)&lt;/EM&gt; to see whether it leads to the list of available locales (search for the
&lt;EM&gt;SEE ALSO&lt;/EM&gt; section). If that fails, try the following command lines:

&lt;P&gt;
&lt;PRE&gt;        locale -a
&lt;/PRE&gt;
&lt;P&gt;
&lt;PRE&gt;        nlsinfo
&lt;/PRE&gt;
&lt;P&gt;
&lt;PRE&gt;        ls /usr/lib/nls/loc
&lt;/PRE&gt;
&lt;P&gt;
&lt;PRE&gt;        ls /usr/lib/locale
&lt;/PRE&gt;
&lt;P&gt;
&lt;PRE&gt;        ls /usr/lib/nls
&lt;/PRE&gt;
&lt;P&gt;
and see whether they list something resembling these

&lt;P&gt;
&lt;PRE&gt;        en_US.ISO8859-1     de_DE.ISO8859-1     ru_RU.ISO8859-5
        en_US.iso88591      de_DE.iso88591      ru_RU.iso88595
        en_US               de_DE               ru_RU
        en                  de                  ru
        english             german              russian
        english.iso88591    german.iso88591     russian.iso88595
        english.roman8                          russian.koi8r
&lt;/PRE&gt;
&lt;P&gt;
Sadly, even though the calling interface for 
&lt;CODE&gt;setlocale()&lt;/CODE&gt; has been
standardized, names of locales and the directories where the configuration
resides have not been. The basic form of the name is
&lt;EM&gt;language_country/territory&lt;/EM&gt;&lt;STRONG&gt;.&lt;/STRONG&gt;&lt;EM&gt;codeset&lt;/EM&gt;, but the latter parts after
&lt;EM&gt;language&lt;/EM&gt; are not always present. The &lt;EM&gt;language&lt;/EM&gt; and &lt;EM&gt;country&lt;/EM&gt; are usually from the standards &lt;STRONG&gt;ISO 3166&lt;/STRONG&gt; and &lt;STRONG&gt;ISO 639&lt;/STRONG&gt;, the two-letter abbreviations for the countries and the languages of the
world, respectively. The &lt;EM&gt;codeset&lt;/EM&gt; part often mentions some &lt;STRONG&gt;ISO 8859&lt;/STRONG&gt;
character set, the Latin codesets. For example, &lt;CODE&gt;ISO 8859-1&lt;/CODE&gt; is the so-called ``Western codeset'' that can be used to encode most
Western European languages. Again, there are several ways to write even the
name of that one standard. Lamentably.

&lt;P&gt;
Two special locales are worth particular mention: 
&lt;FONT SIZE=-1&gt;``C''&lt;/FONT&gt; and 
&lt;FONT SIZE=-1&gt;``POSIX''.&lt;/FONT&gt; Currently these are effectively the same locale: the difference is mainly that the first one is defined by the 
&lt;FONT SIZE=-1&gt;C&lt;/FONT&gt; standard, the second by the 
&lt;FONT SIZE=-1&gt;POSIX&lt;/FONT&gt; standard. They define the
 &lt;STRONG&gt;default locale&lt;/STRONG&gt; in which every program starts in the absence of locale information in its
environment. (The &lt;EM&gt;default&lt;/EM&gt; default locale, if you will.) Its language is (American) English and its character codeset 
&lt;FONT SIZE=-1&gt;ASCII.&lt;/FONT&gt;

&lt;P&gt;
&lt;STRONG&gt;NOTE&lt;/STRONG&gt;: Not all systems have the 
&lt;FONT SIZE=-1&gt;``POSIX''&lt;/FONT&gt; locale (not all systems are POSIX-conformant), so use 
&lt;FONT SIZE=-1&gt;``C''&lt;/FONT&gt; when you need explicitly to specify this default locale.

&lt;P&gt;
&lt;HR&gt;
&lt;H2&gt;&lt;A NAME=&quot;LOCALE_PROBLEMS&quot;&gt;LOCALE PROBLEMS&lt;/A&gt;&lt;/H2&gt;
&lt;P&gt;
You may encounter the following warning message at Perl startup:

&lt;P&gt;
&lt;PRE&gt;        perl: warning: Setting locale failed.
        perl: warning: Please check that your locale settings:
                LC_ALL = &amp;quot;En_US&amp;quot;,
                LANG = (unset)
            are supported and installed on your system.
        perl: warning: Falling back to the standard locale (&amp;quot;C&amp;quot;).
&lt;/PRE&gt;
&lt;P&gt;
This means that your locale settings had 
&lt;FONT SIZE=-1&gt;LC_ALL&lt;/FONT&gt; set to ``En_US'' and 
&lt;FONT SIZE=-1&gt;LANG&lt;/FONT&gt; exists but has no value. Perl tried to believe you but could not. Instead, Perl gave up and fell back to the 
&lt;FONT SIZE=-1&gt;``C''&lt;/FONT&gt; locale, the default locale that is supposed to work no matter what. This usually means your locale settings were wrong, they mention locales your system has never heard of, or the locale installation in your system has problems (for example, some system files are broken or missing). There are quick and temporary fixes to these problems, as well as more thorough and lasting fixes.

&lt;P&gt;
&lt;HR&gt;
&lt;H2&gt;&lt;A NAME=&quot;Temporarily_fixing_locale_proble&quot;&gt;Temporarily fixing locale problems&lt;/A&gt;&lt;/H2&gt;
&lt;P&gt;
The two quickest fixes are either to render Perl silent about any locale inconsistencies or to run Perl under the default locale 
&lt;FONT SIZE=-1&gt;``C''.&lt;/FONT&gt;

&lt;P&gt;
Perl's moaning about locale problems can be silenced by setting the environment variable 
&lt;FONT SIZE=-1&gt;PERL_BADLANG&lt;/FONT&gt; to a non-zero value, for example ``1''. This method really just sweeps the problem under the carpet: you tell Perl to shut up even when Perl sees that something is wrong. Do not be surprised if later something locale-dependent misbehaves.

&lt;P&gt;
Perl can be run under the 
&lt;FONT SIZE=-1&gt;``C''&lt;/FONT&gt; locale by setting the environment variable 
&lt;FONT SIZE=-1&gt;LC_ALL&lt;/FONT&gt; to 
&lt;FONT SIZE=-1&gt;``C''.&lt;/FONT&gt; This method is perhaps a bit more civilized than the 
&lt;FONT SIZE=-1&gt;PERL_BADLANG&lt;/FONT&gt; approach, but setting 
&lt;FONT SIZE=-1&gt;LC_ALL&lt;/FONT&gt; (or other locale variables) may affect other programs as well, not just Perl. In particular, external programs run from within Perl will see these changes. If you make the new settings permanent (read on), all programs you run see the changes. See
 &lt;A HREF=&quot;#ENVIRONMENT&quot;&gt;ENVIRONMENT&lt;/A&gt; for for the full list of relevant environment variables and &lt;A HREF=&quot;#USING_LOCALES&quot;&gt;USING LOCALES&lt;/A&gt;
for their effects in Perl. Effects in other programs are easily deducible. For example, the variable 
&lt;FONT SIZE=-1&gt;LC_COLLATE&lt;/FONT&gt; may well affect your
 &lt;STRONG&gt;sort&lt;/STRONG&gt; program (or whatever the program that arranges `records' alphabetically in
your system is called).

&lt;P&gt;
You can test out changing these variables temporarily, and if the new
settings seem to help, put those settings into your shell startup files.
Consult your local documentation for the exact details. For in Bourne-like
shells (&lt;STRONG&gt;sh&lt;/STRONG&gt;, &lt;STRONG&gt;ksh&lt;/STRONG&gt;, &lt;STRONG&gt;bash&lt;/STRONG&gt;, &lt;STRONG&gt;zsh&lt;/STRONG&gt;):

&lt;P&gt;
&lt;PRE&gt;        LC_ALL=en_US.ISO8859-1
        export LC_ALL
&lt;/PRE&gt;
&lt;P&gt;
This assumes that we saw the locale ``en_US.ISO8859-1'' using the commands
discussed above. We decided to try that instead of the above faulty locale
``En_US''--and in Cshish shells (&lt;STRONG&gt;csh&lt;/STRONG&gt;, &lt;STRONG&gt;tcsh&lt;/STRONG&gt;)

&lt;P&gt;
&lt;PRE&gt;        setenv LC_ALL en_US.ISO8859-1
        
If you do not know what shell you have, consult your local
helpdesk or the equivalent.
&lt;/PRE&gt;
&lt;P&gt;
&lt;HR&gt;
&lt;H2&gt;&lt;A NAME=&quot;Permanently_fixing_locale_proble&quot;&gt;Permanently fixing locale problems&lt;/A&gt;&lt;/H2&gt;
&lt;P&gt;
The slower but superior fixes are when you may be able to yourself fix the misconfiguration of your own environment variables. The 
&lt;CODE&gt;mis(sing)configuration&lt;/CODE&gt; of the whole system's locales usually requires the help of your friendly system administrator.

&lt;P&gt;
First, see earlier in this document about &lt;A HREF=&quot;#Finding_locales&quot;&gt;Finding locales&lt;/A&gt;. That tells how to find which locales are really supported--and more importantly, installed--on your system. In our example error message, environment variables affecting the locale are listed in the order of decreasing importance (and unset variables do not matter). Therefore, having 
&lt;FONT SIZE=-1&gt;LC_ALL&lt;/FONT&gt; set to ``En_US'' must have been the bad choice, as shown by the error message. First try fixing locale settings listed first.

&lt;P&gt;
Second, if using the listed commands you see something &lt;STRONG&gt;exactly&lt;/STRONG&gt;
(prefix matches do not count and case usually counts) like ``En_US''
without the quotes, then you should be okay because you are using a locale
name that should be installed and available in your system. In this case,
see &lt;A HREF=&quot;#Fixing_system_locale_configurati&quot;&gt;Fixing system locale configuration&lt;/A&gt;.

&lt;P&gt;
&lt;HR&gt;
&lt;H2&gt;&lt;A NAME=&quot;Permanently_fixing_your_locale_c&quot;&gt;Permanently fixing your locale configuration&lt;/A&gt;&lt;/H2&gt;
&lt;P&gt;
This is when you see something like:

&lt;P&gt;
&lt;PRE&gt;        perl: warning: Please check that your locale settings:
                LC_ALL = &amp;quot;En_US&amp;quot;,
                LANG = (unset)
            are supported and installed on your system.
&lt;/PRE&gt;
&lt;P&gt;
but then cannot see that ``En_US'' listed by the above-mentioned commands.
You may see things like ``en_US.ISO8859-1'', but that isn't the same. In
this case, try running under a locale that you can list and which somehow
matches what you tried. The rules for matching locale names are a bit vague
because standardization is weak in this area. See again the &lt;A HREF=&quot;#Finding_locales&quot;&gt;Finding locales&lt;/A&gt; about general rules.

&lt;P&gt;
&lt;HR&gt;
&lt;H2&gt;&lt;A NAME=&quot;Permanently_fixing_system_locale&quot;&gt;Permanently fixing system locale configuration&lt;/A&gt;&lt;/H2&gt;
&lt;P&gt;
Contact a system administrator (preferably your own) and report the exact
error message you get, and ask them to read this same documentation you are
now reading. They should be able to check whether there is something wrong
with the locale configuration of the system. The &lt;A HREF=&quot;#Finding_locales&quot;&gt;Finding locales&lt;/A&gt;
section is unfortunately a bit vague about the exact commands and places
because these things are not that standardized.

&lt;P&gt;
&lt;HR&gt;
&lt;H2&gt;&lt;A NAME=&quot;The_localeconv_function&quot;&gt;The localeconv function&lt;/A&gt;&lt;/H2&gt;
&lt;P&gt;
The POSIX::localeconv() function allows you to get particulars of the
locale-dependent numeric formatting information specified by the current
&lt;CODE&gt;LC_NUMERIC&lt;/CODE&gt; and &lt;CODE&gt;LC_MONETARY&lt;/CODE&gt; locales. (If you just want the name of the current locale for a particular
category, use POSIX::setlocale() with a single parameter--see &lt;A HREF=&quot;#The_setlocale_function&quot;&gt;The setlocale function&lt;/A&gt;.)

&lt;P&gt;
&lt;PRE&gt;        use POSIX qw(locale_h);
&lt;/PRE&gt;
&lt;P&gt;
&lt;PRE&gt;        # Get a reference to a hash of locale-dependent info
        $locale_values = localeconv();
&lt;/PRE&gt;
&lt;P&gt;
&lt;PRE&gt;        # Output sorted list of the values
        for (sort keys %$locale_values) {
            printf &amp;quot;%-20s = %s\n&amp;quot;, $_, $locale_values-&amp;gt;{$_}
        }
&lt;/PRE&gt;
&lt;P&gt;

&lt;CODE&gt;localeconv()&lt;/CODE&gt; takes no
arguments, and returns &lt;STRONG&gt;a reference to&lt;/STRONG&gt; a hash. The keys of this hash are variable names for formatting, such as
&lt;CODE&gt;decimal_point&lt;/CODE&gt; and &lt;CODE&gt;thousands_sep&lt;/CODE&gt;. The values are the corresponding, er, values. See &lt;EM&gt;POSIX (3)&lt;/EM&gt; for a longer example listing the categories an implementation might be
expected to provide; some provide more and others fewer. You don't need an
explicit &lt;CODE&gt;use locale&lt;/CODE&gt;, because 
&lt;CODE&gt;localeconv()&lt;/CODE&gt; always
observes the current locale.

&lt;P&gt;
Here's a simple-minded example program that rewrites its command-line
parameters as integers correctly formatted in the current locale:

&lt;P&gt;
&lt;PRE&gt;        # See comments in previous example
        require 5.004;
        use POSIX qw(locale_h);
&lt;/PRE&gt;
&lt;P&gt;
&lt;PRE&gt;        # Get some of locale's numeric formatting parameters
        my ($thousands_sep, $grouping) =
             @{localeconv()}{'thousands_sep', 'grouping'};
&lt;/PRE&gt;
&lt;P&gt;
&lt;PRE&gt;        # Apply defaults if values are missing
        $thousands_sep = ',' unless $thousands_sep;
&lt;/PRE&gt;
&lt;P&gt;
&lt;PRE&gt;        # grouping and mon_grouping are packed lists
        # of small integers (characters) telling the
        # grouping (thousand_seps and mon_thousand_seps
        # being the group dividers) of numbers and
        # monetary quantities.  The integers' meanings:
        # 255 means no more grouping, 0 means repeat
        # the previous grouping, 1-254 means use that
        # as the current grouping.  Grouping goes from
        # right to left (low to high digits).  In the
        # below we cheat slightly by never using anything
        # else than the first grouping (whatever that is).
        if ($grouping) {
            @grouping = unpack(&amp;quot;C*&amp;quot;, $grouping);
        } else {
            @grouping = (3);
        }
&lt;/PRE&gt;
&lt;P&gt;
&lt;PRE&gt;        # Format command line params for current locale
        for (@ARGV) {
            $_ = int;    # Chop non-integer part
            1 while
            s/(\d)(\d{$grouping&amp;#091;0&amp;#093;}($|$thousands_sep))/$1$thousands_sep$2/;
            print &amp;quot;$_&amp;quot;;
        }
        print &amp;quot;\n&amp;quot;;
&lt;/PRE&gt;
&lt;P&gt;
&lt;HR&gt;
&lt;H1&gt;&lt;A NAME=&quot;LOCALE_CATEGORIES&quot;&gt;LOCALE CATEGORIES&lt;/A&gt;&lt;/H1&gt;
&lt;P&gt;
The following subsections describe basic locale categories. Beyond these,
some combination categories allow manipulation of more than one basic
category at a time. See &lt;A HREF=&quot;#ENVIRONMENT&quot;&gt;ENVIRONMENT&lt;/A&gt; for a discussion of these.

&lt;P&gt;
&lt;HR&gt;
&lt;H2&gt;&lt;A NAME=&quot;Category_LC_COLLATE_Collation&quot;&gt;Category LC_COLLATE: Collation&lt;/A&gt;&lt;/H2&gt;
&lt;P&gt;
In the scope of &lt;CODE&gt;use&amp;nbsp;locale&lt;/CODE&gt;, Perl looks to the &lt;CODE&gt;LC_COLLATE&lt;/CODE&gt;
environment variable to determine the application's notions on collation
(ordering) of characters. For example, 'b' follows 'a' in Latin alphabets,
but where do '&amp;aacute;' and '&amp;aring;' belong? And while 'color' follows
'chocolate' in English, what about in Spanish?

&lt;P&gt;
The following collations all make sense and you may meet any of them if you
``use locale''.

&lt;P&gt;
&lt;PRE&gt;        A B C D E a b c d e
        A a B b C c D d D e
        a A b B c C d D e E
        a b c d e A B C D E
&lt;/PRE&gt;
&lt;P&gt;
Here is a code snippet to tell what alphanumeric characters are in the
current locale, in that locale's order:

&lt;P&gt;
&lt;PRE&gt;        use locale;
        print +(sort grep /\w/, map { chr() } 0..255), &amp;quot;\n&amp;quot;;
&lt;/PRE&gt;
&lt;P&gt;
Compare this with the characters that you see and their order if you state
explicitly that the locale should be ignored:

&lt;P&gt;
&lt;PRE&gt;        no locale;
        print +(sort grep /\w/, map { chr() } 0..255), &amp;quot;\n&amp;quot;;
&lt;/PRE&gt;
&lt;P&gt;
This machine-native collation (which is what you get unless &lt;CODE&gt;use
locale&lt;/CODE&gt; has appeared earlier in the same block) must be used for sorting raw binary
data, whereas the locale-dependent collation of the first example is useful
for natural text.

&lt;P&gt;
As noted in &lt;A HREF=&quot;#USING_LOCALES&quot;&gt;USING LOCALES&lt;/A&gt;, &lt;CODE&gt;cmp&lt;/CODE&gt; compares according to the current collation locale when &lt;CODE&gt;use locale&lt;/CODE&gt; is in effect, but falls back to a byte-by-byte comparison for strings that
the locale says are equal. You can use POSIX::strcoll() if you don't want
this fall-back:

&lt;P&gt;
&lt;PRE&gt;        use POSIX qw(strcoll);
        $equal_in_locale =
            !strcoll(&amp;quot;space and case ignored&amp;quot;, &amp;quot;SpaceAndCaseIgnored&amp;quot;);
&lt;/PRE&gt;
&lt;P&gt;
&lt;CODE&gt;$equal_in_locale&lt;/CODE&gt; will be true if the collation locale
specifies a dictionary-like ordering that ignores space characters
completely and which folds case.

&lt;P&gt;
If you have a single string that you want to check for ``equality in
locale'' against several others, you might think you could gain a little
efficiency by using POSIX::strxfrm() in conjunction with &lt;CODE&gt;eq&lt;/CODE&gt;:

&lt;P&gt;
&lt;PRE&gt;        use POSIX qw(strxfrm);
        $xfrm_string = strxfrm(&amp;quot;Mixed-case string&amp;quot;);
        print &amp;quot;locale collation ignores spaces\n&amp;quot;
            if $xfrm_string eq strxfrm(&amp;quot;Mixed-casestring&amp;quot;);
        print &amp;quot;locale collation ignores hyphens\n&amp;quot;
            if $xfrm_string eq strxfrm(&amp;quot;Mixedcase string&amp;quot;);
        print &amp;quot;locale collation ignores case\n&amp;quot;
            if $xfrm_string eq strxfrm(&amp;quot;mixed-case string&amp;quot;);
&lt;/PRE&gt;
&lt;P&gt;

&lt;CODE&gt;strxfrm()&lt;/CODE&gt; takes a string and maps it into a transformed string for use in byte-by-byte comparisons against other transformed strings during collation. ``Under the hood'', locale-affected Perl comparison operators call 
&lt;CODE&gt;strxfrm()&lt;/CODE&gt; for both operands, then do a byte-by-byte comparison of the transformed strings. By calling 
&lt;CODE&gt;strxfrm()&lt;/CODE&gt; explicitly and using a non locale-affected comparison, the example attempts to save a couple of transformations. But in fact, it doesn't save anything: Perl magic (see
 [perlman:perlguts]) creates the transformed version of a string the first time it's needed in
a comparison, then keeps this version around in case it's needed again. An
example rewritten the easy way with
&lt;CODE&gt;cmp&lt;/CODE&gt; runs just about as fast. It also copes with null characters embedded in strings; if you call 
&lt;CODE&gt;strxfrm()&lt;/CODE&gt; directly, it treats the first null it finds as a terminator. don't expect the transformed strings it produces to be portable across systems--or even from one revision of your operating system to the next. In short, don't call 
&lt;CODE&gt;strxfrm()&lt;/CODE&gt; directly: let Perl do it for you.

&lt;P&gt;
Note: &lt;CODE&gt;use locale&lt;/CODE&gt; isn't shown in some of these examples because it isn't needed: 
&lt;CODE&gt;strcoll()&lt;/CODE&gt; and 
&lt;CODE&gt;strxfrm()&lt;/CODE&gt; exist only to generate locale-dependent results, and so always obey the current
 &lt;CODE&gt;LC_COLLATE&lt;/CODE&gt; locale.

&lt;P&gt;
&lt;HR&gt;
&lt;H2&gt;&lt;A NAME=&quot;Category_LC_CTYPE_Character_Typ&quot;&gt;Category LC_CTYPE: Character Types&lt;/A&gt;&lt;/H2&gt;
&lt;P&gt;
In the scope of &lt;CODE&gt;use&amp;nbsp;locale&lt;/CODE&gt;, Perl obeys the &lt;CODE&gt;LC_CTYPE&lt;/CODE&gt; locale setting. This controls the application's notion of which characters
are alphabetic. This affects Perl's &lt;CODE&gt;\w&lt;/CODE&gt; regular expression metanotation, which stands for alphanumeric
characters--that is, alphabetic and numeric characters. (Consult [perlman:perlre|the perlre manpage] for more information about regular expressions.) Thanks to &lt;CODE&gt;LC_CTYPE&lt;/CODE&gt;, depending on your locale setting, characters like '&amp;aelig;', '&amp;eth;',
'&amp;szlig;', and '&amp;oslash;' may be understood as &lt;CODE&gt;\w&lt;/CODE&gt; characters.

&lt;P&gt;
The &lt;CODE&gt;LC_CTYPE&lt;/CODE&gt; locale also provides the map used in transliterating characters between lower and uppercase. This affects the case-mapping functions--lc(), lcfirst, 
&lt;CODE&gt;uc(),&lt;/CODE&gt; and 
&lt;CODE&gt;ucfirst();&lt;/CODE&gt; case-mapping interpolation with
 &lt;CODE&gt;\l&lt;/CODE&gt;, &lt;CODE&gt;\L&lt;/CODE&gt;, &lt;CODE&gt;\u&lt;/CODE&gt;, or &lt;CODE&gt;\U&lt;/CODE&gt; in double-quoted strings and [perlman:perlop] substitutions; and case-independent regular expression pattern matching
using the &lt;CODE&gt;i&lt;/CODE&gt; modifier.

&lt;P&gt;
Finally, &lt;CODE&gt;LC_CTYPE&lt;/CODE&gt; affects the 
&lt;FONT SIZE=-1&gt;POSIX&lt;/FONT&gt; character-class test functions--isalpha(), 
&lt;CODE&gt;islower(),&lt;/CODE&gt; and so on. For example, if you move from the 
&lt;FONT SIZE=-1&gt;``C''&lt;/FONT&gt; locale to a 7-bit Scandinavian one, you may find--possibly to your surprise--that ``|'' moves from the 
&lt;CODE&gt;ispunct()&lt;/CODE&gt; class to 
&lt;CODE&gt;isalpha().&lt;/CODE&gt;

&lt;P&gt;
&lt;STRONG&gt;Note:&lt;/STRONG&gt; 
&lt;FONT SIZE=-1&gt;A&lt;/FONT&gt; broken or malicious &lt;CODE&gt;LC_CTYPE&lt;/CODE&gt; locale definition may result in clearly ineligible characters being
considered to be alphanumeric by your application. For strict matching of
(mundane) letters and digits--for example, in command strings--locale-aware
applications should use &lt;CODE&gt;\w&lt;/CODE&gt; inside a &lt;CODE&gt;no locale&lt;/CODE&gt; block. See &lt;A HREF=&quot;#SECURITY&quot;&gt;SECURITY&lt;/A&gt;.

&lt;P&gt;
&lt;HR&gt;
&lt;H2&gt;&lt;A NAME=&quot;Category_LC_NUMERIC_Numeric_For&quot;&gt;Category LC_NUMERIC: Numeric Formatting&lt;/A&gt;&lt;/H2&gt;
&lt;P&gt;
In the scope of &lt;CODE&gt;use&amp;nbsp;locale&lt;/CODE&gt;, Perl obeys the &lt;CODE&gt;LC_NUMERIC&lt;/CODE&gt; locale information, which controls an application's idea of how numbers should be formatted for human readability by the 
&lt;CODE&gt;printf(),&lt;/CODE&gt; 
&lt;CODE&gt;sprintf(),&lt;/CODE&gt; and 
&lt;CODE&gt;write()&lt;/CODE&gt; functions. String-to-numeric conversion by the POSIX::strtod() function is also affected. In most implementations the only effect is to change the character used for the decimal point--perhaps from '.' to ','. These functions aren't aware of such niceties as thousands separation and so on. (See
 &lt;A HREF=&quot;#The_localeconv_function&quot;&gt;The localeconv function&lt;/A&gt; if you care about these things.)

&lt;P&gt;
Output produced by 
&lt;CODE&gt;print()&lt;/CODE&gt; is &lt;STRONG&gt;never&lt;/STRONG&gt; affected by the current locale: it is independent of whether &lt;CODE&gt;use locale&lt;/CODE&gt; or &lt;CODE&gt;no
locale&lt;/CODE&gt; is in effect, and corresponds to what you'd get from 
&lt;CODE&gt;printf()&lt;/CODE&gt; in the 
&lt;FONT SIZE=-1&gt;``C''&lt;/FONT&gt; locale. The same is true for Perl's internal conversions between numeric and string formats:

&lt;P&gt;
&lt;PRE&gt;        use POSIX qw(strtod);
        use locale;
&lt;/PRE&gt;
&lt;P&gt;
&lt;PRE&gt;        $n = 5/2;   # Assign numeric 2.5 to $n
&lt;/PRE&gt;
&lt;P&gt;
&lt;PRE&gt;        $a = &amp;quot; $n&amp;quot;; # Locale-independent conversion to string
&lt;/PRE&gt;
&lt;P&gt;
&lt;PRE&gt;        print &amp;quot;half five is $n\n&amp;quot;;       # Locale-independent output
&lt;/PRE&gt;
&lt;P&gt;
&lt;PRE&gt;        printf &amp;quot;half five is %g\n&amp;quot;, $n;  # Locale-dependent output
&lt;/PRE&gt;
&lt;P&gt;
&lt;PRE&gt;        print &amp;quot;DECIMAL POINT IS COMMA\n&amp;quot;
            if $n == (strtod(&amp;quot;2,5&amp;quot;))&amp;#091;0&amp;#093;; # Locale-dependent conversion
&lt;/PRE&gt;
&lt;P&gt;
&lt;HR&gt;
&lt;H2&gt;&lt;A NAME=&quot;Category_LC_MONETARY_Formatting&quot;&gt;Category LC_MONETARY: Formatting of monetary amounts&lt;/A&gt;&lt;/H2&gt;
&lt;P&gt;
The 
&lt;FONT SIZE=-1&gt;C&lt;/FONT&gt; standard defines the &lt;CODE&gt;LC_MONETARY&lt;/CODE&gt; category, but no function that is affected by its contents. (Those with
experience of standards committees will recognize that the working group
decided to punt on the issue.) Consequently, Perl takes no notice of it. If
you really want to use &lt;CODE&gt;LC_MONETARY&lt;/CODE&gt;, you can query its contents--see &lt;A HREF=&quot;#The_localeconv_function&quot;&gt;The localeconv function&lt;/A&gt;--and use the information that it returns in your application's own
formatting of currency amounts. However, you may well find that the
information, voluminous and complex though it may be, still does not quite
meet your requirements: currency formatting is a hard nut to crack.

&lt;P&gt;
&lt;HR&gt;
&lt;H2&gt;&lt;A NAME=&quot;LC_TIME&quot;&gt;LC_TIME&lt;/A&gt;&lt;/H2&gt;
&lt;P&gt;
Output produced by POSIX::strftime(), which builds a formatted
human-readable date/time string, is affected by the current &lt;CODE&gt;LC_TIME&lt;/CODE&gt;
locale. Thus, in a French locale, the output produced by the &lt;CODE&gt;%B&lt;/CODE&gt;
format element (full month name) for the first month of the year would be
``janvier''. Here's how to get a list of long month names in the current
locale:

&lt;P&gt;
&lt;PRE&gt;        use POSIX qw(strftime);
        for (0..11) {
            $long_month_name&amp;#091;$_&amp;#093; =
                strftime(&amp;quot;%B&amp;quot;, 0, 0, 0, 1, $_, 96);
        }
&lt;/PRE&gt;
&lt;P&gt;
Note: &lt;CODE&gt;use locale&lt;/CODE&gt; isn't needed in this example: as a function that exists only to generate locale-dependent results, 
&lt;CODE&gt;strftime()&lt;/CODE&gt; always obeys the current
 &lt;CODE&gt;LC_TIME&lt;/CODE&gt; locale.

&lt;P&gt;
&lt;HR&gt;
&lt;H2&gt;&lt;A NAME=&quot;Other_categories&quot;&gt;Other categories&lt;/A&gt;&lt;/H2&gt;
&lt;P&gt;
The remaining locale category, &lt;CODE&gt;LC_MESSAGES&lt;/CODE&gt; (possibly supplemented by others in particular implementations) is not
currently used by Perl--except possibly to affect the behavior of library
functions called by extensions outside the standard Perl distribution.

&lt;P&gt;
&lt;HR&gt;
&lt;H1&gt;&lt;A NAME=&quot;SECURITY&quot;&gt;SECURITY&lt;/A&gt;&lt;/H1&gt;
&lt;P&gt;
Although the main discussion of Perl security issues can be found in
[perlman:perlsec|the perlsec manpage], a discussion of Perl's locale handling would be incomplete if it did not draw your attention to locale-dependent security issues. Locales--particularly on systems that allow unprivileged users to build their own locales--are untrustworthy. 
&lt;FONT SIZE=-1&gt;A&lt;/FONT&gt; malicious (or just plain broken) locale can make a locale-aware application give unexpected results. Here are a few possibilities:

&lt;UL&gt;
&lt;LI&gt;
&lt;P&gt;
Regular expression checks for safe file names or mail addresses using
&lt;CODE&gt;\w&lt;/CODE&gt; may be spoofed by an &lt;CODE&gt;LC_CTYPE&lt;/CODE&gt; locale that claims that characters such as ``&amp;gt;'' and ``|'' are
alphanumeric.

&lt;P&gt;&lt;LI&gt;

String interpolation with case-mapping, as in, say, &lt;CODE&gt;$dest =
&amp;quot;C:\U$name.$ext&amp;quot;&lt;/CODE&gt;, may produce dangerous results if a bogus 
&lt;FONT SIZE=-1&gt;LC_CTYPE&lt;/FONT&gt; case-mapping table is in effect.

&lt;P&gt;&lt;LI&gt;

If the decimal point character in the &lt;CODE&gt;LC_NUMERIC&lt;/CODE&gt; locale is surreptitiously changed from a dot to a comma, &lt;A HREF=&quot;perlfunc/sprintf.html&quot;&gt;sprintf(&amp;quot;%g&amp;quot;,
0.123456e3)&lt;/A&gt; produces a string result of ``123,456''. Many people would interpret this
as one hundred and twenty-three thousand, four hundred and fifty-six.

&lt;P&gt;&lt;LI&gt;


&lt;FONT SIZE=-1&gt;A&lt;/FONT&gt; sneaky &lt;CODE&gt;LC_COLLATE&lt;/CODE&gt; locale could result in the names of students with 
&lt;FONT SIZE=-1&gt;``D''&lt;/FONT&gt; grades appearing ahead of those with ``A''s.

&lt;P&gt;&lt;LI&gt;

An application that takes the trouble to use information in
&lt;CODE&gt;LC_MONETARY&lt;/CODE&gt; may format debits as if they were credits and vice versa if that locale has been subverted. Or it might make payments in 
&lt;FONT SIZE=-1&gt;US&lt;/FONT&gt; dollars instead of Hong Kong dollars.

&lt;P&gt;&lt;LI&gt;

The date and day names in dates formatted by 
&lt;CODE&gt;strftime()&lt;/CODE&gt; could be
manipulated to advantage by a malicious user able to subvert the
&lt;CODE&gt;LC_DATE&lt;/CODE&gt; locale. (``Look--it says 
&lt;FONT SIZE=-1&gt;I&lt;/FONT&gt; wasn't in the building on Sunday.'')

&lt;/UL&gt;
&lt;P&gt;
Such dangers are not peculiar to the locale system: any aspect of an
application's environment which may be modified maliciously presents
similar challenges. Similarly, they are not specific to Perl: any
programming language that allows you to write programs that take account of
their environment exposes you to these issues.

&lt;P&gt;
Perl cannot protect you from all possibilities shown in the examples--there
is no substitute for your own vigilance--but, when
&lt;CODE&gt;use locale&lt;/CODE&gt; is in effect, Perl uses the tainting mechanism (see
[perlman:perlsec|the perlsec manpage]) to mark string results that become locale-dependent, and which may be
untrustworthy in consequence. Here is a summary of the tainting behavior of
operators and functions that may be affected by the locale:

&lt;DL&gt;
&lt;DT&gt;&lt;STRONG&gt;&lt;A NAME=&quot;item_Comparison&quot;&gt;Comparison operators (lt, le, ge, gt and cmp):&lt;/A&gt;&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;
Scalar true/false (or less/equal/greater) result is never tainted.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;&lt;A NAME=&quot;item_Case&quot;&gt;Case-mapping interpolation (with \l, \L, \u or \U)&lt;/A&gt;&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;
Result string containing interpolated material is tainted if
&lt;CODE&gt;use locale&lt;/CODE&gt; is in effect.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;&lt;A NAME=&quot;item_Matching&quot;&gt;Matching operator (m//):&lt;/A&gt;&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;
Scalar true/false result never tainted.

&lt;P&gt;
Subpatterns, either delivered as a list-context result or as
&lt;CODE&gt;$1&lt;/CODE&gt; etc. are tainted if &lt;CODE&gt;use locale&lt;/CODE&gt; is in effect, and the subpattern regular expression contains &lt;CODE&gt;\w&lt;/CODE&gt; (to match an alphanumeric character), &lt;CODE&gt;\W&lt;/CODE&gt;
(non-alphanumeric character), [perlman:perlop] (white-space character), or &lt;CODE&gt;\S&lt;/CODE&gt;
(non white-space character). The matched-pattern variable, $&amp;amp;, $`
(pre-match), $' (post-match), and $+ (last match) are also tainted if
&lt;CODE&gt;use locale&lt;/CODE&gt; is in effect and the regular expression contains &lt;CODE&gt;\w&lt;/CODE&gt;,
&lt;CODE&gt;\W&lt;/CODE&gt;, [perlman:perlop], or &lt;CODE&gt;\S&lt;/CODE&gt;.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;&lt;A NAME=&quot;item_Substitution&quot;&gt;Substitution operator (s///):&lt;/A&gt;&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;
Has the same behavior as the match operator. Also, the left operand of &lt;CODE&gt;=~&lt;/CODE&gt; becomes tainted when &lt;CODE&gt;use locale&lt;/CODE&gt; in effect if modified as a result of a substitution based on a regular
expression match involving &lt;CODE&gt;\w&lt;/CODE&gt;, &lt;CODE&gt;\W&lt;/CODE&gt;, [perlman:perlop], or &lt;CODE&gt;\S&lt;/CODE&gt;; or of case-mapping with &lt;CODE&gt;\l&lt;/CODE&gt;, &lt;CODE&gt;\L&lt;/CODE&gt;,&lt;CODE&gt;\u&lt;/CODE&gt; or &lt;CODE&gt;\U&lt;/CODE&gt;.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;&lt;A NAME=&quot;item_In&quot;&gt;In-memory formatting function (sprintf()):&lt;/A&gt;&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;
Result is tainted if ``use locale'' is in effect.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;&lt;A NAME=&quot;item_Output&quot;&gt;Output formatting functions (printf() and write()):&lt;/A&gt;&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;
Success/failure result is never tainted.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;Case-mapping functions (lc(), lcfirst(), uc(), ucfirst()):&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;
Results are tainted if &lt;CODE&gt;use locale&lt;/CODE&gt; is in effect.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;&lt;A NAME=&quot;item_POSIX&quot;&gt;POSIX locale-dependent functions (localeconv(), strcoll(),
strftime(), strxfrm()):&lt;/A&gt;&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;
Results are never tainted.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;POSIX character class tests (isalnum(), isalpha(), isdigit(),
isgraph(), islower(), isprint(), ispunct(), isspace(), isupper(),
isxdigit()):&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;
True/false results are never tainted.

&lt;/DL&gt;
&lt;P&gt;
Three examples illustrate locale-dependent tainting. The first program,
which ignores its locale, won't run: a value taken directly from the
command line may not be used to name an output file when taint checks are
enabled.

&lt;P&gt;
&lt;PRE&gt;        #/usr/local/bin/perl -T
        # Run with taint checking
&lt;/PRE&gt;
&lt;P&gt;
&lt;PRE&gt;        # Command line sanity check omitted...
        $tainted_output_file = shift;
&lt;/PRE&gt;
&lt;P&gt;
&lt;PRE&gt;        open(F, &amp;quot;&amp;gt;$tainted_output_file&amp;quot;)
            or warn &amp;quot;Open of $untainted_output_file failed: $!\n&amp;quot;;
&lt;/PRE&gt;
&lt;P&gt;
The program can be made to run by ``laundering'' the tainted value through
a regular expression: the second example--which still ignores locale
information--runs, creating the file named on its command line if it can.

&lt;P&gt;
&lt;PRE&gt;        #/usr/local/bin/perl -T
&lt;/PRE&gt;
&lt;P&gt;
&lt;PRE&gt;        $tainted_output_file = shift;
        $tainted_output_file =~ m%&amp;#091;\w/&amp;#093;+%;
        $untainted_output_file = $&amp;amp;;
&lt;/PRE&gt;
&lt;P&gt;
&lt;PRE&gt;        open(F, &amp;quot;&amp;gt;$untainted_output_file&amp;quot;)
            or warn &amp;quot;Open of $untainted_output_file failed: $!\n&amp;quot;;
&lt;/PRE&gt;
&lt;P&gt;
Compare this with a similar but locale-aware program:

&lt;P&gt;
&lt;PRE&gt;        #/usr/local/bin/perl -T
&lt;/PRE&gt;
&lt;P&gt;
&lt;PRE&gt;        $tainted_output_file = shift;
        use locale;
        $tainted_output_file =~ m%&amp;#091;\w/&amp;#093;+%;
        $localized_output_file = $&amp;amp;;
&lt;/PRE&gt;
&lt;P&gt;
&lt;PRE&gt;        open(F, &amp;quot;&amp;gt;$localized_output_file&amp;quot;)
            or warn &amp;quot;Open of $localized_output_file failed: $!\n&amp;quot;;
&lt;/PRE&gt;
&lt;P&gt;
This third program fails to run because $&amp;amp; is tainted: it is the result
of a match involving &lt;CODE&gt;\w&lt;/CODE&gt; while &lt;CODE&gt;use locale&lt;/CODE&gt; is in effect.

&lt;P&gt;
&lt;HR&gt;
&lt;H1&gt;&lt;A NAME=&quot;ENVIRONMENT&quot;&gt;ENVIRONMENT&lt;/A&gt;&lt;/H1&gt;
&lt;DL&gt;
&lt;DT&gt;&lt;STRONG&gt;&lt;A NAME=&quot;item_PERL_BADLANG&quot;&gt;PERL_BADLANG&lt;/A&gt;&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;

&lt;FONT SIZE=-1&gt;A&lt;/FONT&gt; string that can suppress Perl's warning about failed
locale settings at startup. Failure can occur if the locale support in the
operating system is lacking (broken) in some way--or if you mistyped the
name of a locale when you set up your environment. If this environment
variable is absent, or has a value that does not evaluate to integer
zero--that is, ``0'' or ``''--Perl will complain about locale setting
failures.

&lt;P&gt;
&lt;STRONG&gt;NOTE&lt;/STRONG&gt;: 
&lt;FONT SIZE=-1&gt;PERL_BADLANG&lt;/FONT&gt; only gives you a way to hide the warning
message. The message tells about some problem in your system's locale
support, and you should investigate what the problem is.

&lt;/DL&gt;
&lt;P&gt;
The following environment variables are not specific to Perl: They are part of the standardized 
&lt;FONT SIZE=-1&gt;(ISO&lt;/FONT&gt; 
&lt;FONT SIZE=-1&gt;C,&lt;/FONT&gt; 
&lt;FONT SIZE=-1&gt;XPG4,&lt;/FONT&gt; 
&lt;FONT SIZE=-1&gt;POSIX&lt;/FONT&gt; 1.c) 
&lt;CODE&gt;setlocale()&lt;/CODE&gt; method for controlling an application's opinion on data.

&lt;DL&gt;
&lt;DT&gt;&lt;STRONG&gt;&lt;A NAME=&quot;item_LC_ALL&quot;&gt;LC_ALL&lt;/A&gt;&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;
&lt;CODE&gt;LC_ALL&lt;/CODE&gt; is the ``override-all'' locale environment variable. If set, it overrides
all the rest of the locale environment variables.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;&lt;A NAME=&quot;item_LC_CTYPE&quot;&gt;LC_CTYPE&lt;/A&gt;&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;
In the absence of &lt;CODE&gt;LC_ALL&lt;/CODE&gt;, &lt;CODE&gt;LC_CTYPE&lt;/CODE&gt; chooses the character type locale. In the absence of both &lt;CODE&gt;LC_ALL&lt;/CODE&gt; and &lt;CODE&gt;LC_CTYPE&lt;/CODE&gt;, &lt;CODE&gt;LANG&lt;/CODE&gt;
chooses the character type locale.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;&lt;A NAME=&quot;item_LC_COLLATE&quot;&gt;LC_COLLATE&lt;/A&gt;&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;
In the absence of &lt;CODE&gt;LC_ALL&lt;/CODE&gt;, &lt;CODE&gt;LC_COLLATE&lt;/CODE&gt; chooses the collation (sorting) locale. In the absence of both &lt;CODE&gt;LC_ALL&lt;/CODE&gt; and &lt;CODE&gt;LC_COLLATE&lt;/CODE&gt;,
&lt;CODE&gt;LANG&lt;/CODE&gt; chooses the collation locale.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;&lt;A NAME=&quot;item_LC_MONETARY&quot;&gt;LC_MONETARY&lt;/A&gt;&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;
In the absence of &lt;CODE&gt;LC_ALL&lt;/CODE&gt;, &lt;CODE&gt;LC_MONETARY&lt;/CODE&gt; chooses the monetary formatting locale. In the absence of both &lt;CODE&gt;LC_ALL&lt;/CODE&gt; and &lt;CODE&gt;LC_MONETARY&lt;/CODE&gt;,
&lt;CODE&gt;LANG&lt;/CODE&gt; chooses the monetary formatting locale.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;&lt;A NAME=&quot;item_LC_NUMERIC&quot;&gt;LC_NUMERIC&lt;/A&gt;&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;
In the absence of &lt;CODE&gt;LC_ALL&lt;/CODE&gt;, &lt;CODE&gt;LC_NUMERIC&lt;/CODE&gt; chooses the numeric format locale. In the absence of both &lt;CODE&gt;LC_ALL&lt;/CODE&gt; and &lt;CODE&gt;LC_NUMERIC&lt;/CODE&gt;, &lt;CODE&gt;LANG&lt;/CODE&gt;
chooses the numeric format.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;&lt;A NAME=&quot;item_LC_TIME&quot;&gt;LC_TIME&lt;/A&gt;&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;
In the absence of &lt;CODE&gt;LC_ALL&lt;/CODE&gt;, &lt;CODE&gt;LC_TIME&lt;/CODE&gt; chooses the date and time formatting locale. In the absence of both &lt;CODE&gt;LC_ALL&lt;/CODE&gt; and &lt;CODE&gt;LC_TIME&lt;/CODE&gt;,
&lt;CODE&gt;LANG&lt;/CODE&gt; chooses the date and time formatting locale.

&lt;P&gt;&lt;DT&gt;&lt;STRONG&gt;&lt;A NAME=&quot;item_LANG&quot;&gt;LANG&lt;/A&gt;&lt;/STRONG&gt;&lt;P&gt;
&lt;DD&gt;
&lt;CODE&gt;LANG&lt;/CODE&gt; is the ``catch-all'' locale environment variable. If it is set, it is used
as the last resort after the overall &lt;CODE&gt;LC_ALL&lt;/CODE&gt; and the category-specific &lt;CODE&gt;LC_...&lt;/CODE&gt;.

&lt;/DL&gt;
&lt;P&gt;
&lt;HR&gt;
&lt;H1&gt;&lt;A NAME=&quot;NOTES&quot;&gt;NOTES&lt;/A&gt;&lt;/H1&gt;
&lt;P&gt;
&lt;HR&gt;
&lt;H2&gt;&lt;A NAME=&quot;Backward_compatibility&quot;&gt;Backward compatibility&lt;/A&gt;&lt;/H2&gt;
&lt;P&gt;
Versions of Perl prior to 5.004 &lt;STRONG&gt;mostly&lt;/STRONG&gt; ignored locale information, generally behaving as if something similar to
the [perlman:perlop] locale were always in force, even if the program environment suggested
otherwise (see &lt;A HREF=&quot;#The_setlocale_function&quot;&gt;The setlocale function&lt;/A&gt;). By default, Perl still behaves this way for backward compatibility. If
you want a Perl application to pay attention to locale information, you &lt;STRONG&gt;must&lt;/STRONG&gt; use the &lt;CODE&gt;use&amp;nbsp;locale&lt;/CODE&gt;
pragma (see &lt;A HREF=&quot;#The_use_locale_Pragma&quot;&gt;The use locale Pragma&lt;/A&gt;) to instruct it to do so.

&lt;P&gt;
Versions of Perl from 5.002 to 5.003 did use the &lt;CODE&gt;LC_CTYPE&lt;/CODE&gt;
information if available; that is, &lt;CODE&gt;\w&lt;/CODE&gt; did understand what were the letters according to the locale environment variables. The problem was that the user had no control over the feature: if the 
&lt;FONT SIZE=-1&gt;C&lt;/FONT&gt; library supported locales, Perl used them.

&lt;P&gt;
&lt;HR&gt;
&lt;H2&gt;&lt;A NAME=&quot;I18N_Collate_obsolete&quot;&gt;I18N:Collate obsolete&lt;/A&gt;&lt;/H2&gt;
&lt;P&gt;
In versions of Perl prior to 5.004, per-locale collation was possible using
the &lt;CODE&gt;I18N::Collate&lt;/CODE&gt; library module. This module is now mildly obsolete and should be avoided in
new applications. The &lt;CODE&gt;LC_COLLATE&lt;/CODE&gt;
functionality is now integrated into the Perl core language: One can use
locale-specific scalar data completely normally with &lt;CODE&gt;use locale&lt;/CODE&gt;, so there is no longer any need to juggle with the scalar references of
&lt;CODE&gt;I18N::Collate&lt;/CODE&gt;.

&lt;P&gt;
&lt;HR&gt;
&lt;H2&gt;&lt;A NAME=&quot;Sort_speed_and_memory_use_impact&quot;&gt;Sort speed and memory use impacts&lt;/A&gt;&lt;/H2&gt;
&lt;P&gt;
Comparing and sorting by locale is usually slower than the default sorting;
slow-downs of two to four times have been observed. It will also consume
more memory: once a Perl scalar variable has participated in any string
comparison or sorting operation obeying the locale collation rules, it will
take 3-15 times more memory than before. (The exact multiplier depends on
the string's contents, the operating system and the locale.) These
downsides are dictated more by the operating system's implementation of the
locale system than by Perl.

&lt;P&gt;
&lt;HR&gt;
&lt;H2&gt;&lt;A NAME=&quot;write_and_LC_NUMERIC&quot;&gt;write() and LC_NUMERIC&lt;/A&gt;&lt;/H2&gt;
&lt;P&gt;
Formats are the only part of Perl that unconditionally use information from a program's locale; if a program's environment specifies an 
&lt;FONT SIZE=-1&gt;LC_NUMERIC&lt;/FONT&gt; locale, it is always used to specify the decimal point character in formatted output. Formatted output cannot be controlled by

&lt;CODE&gt;use locale&lt;/CODE&gt; because the pragma is tied to the block structure of the program, and, for
historical reasons, formats exist outside that block structure.

&lt;P&gt;
&lt;HR&gt;
&lt;H2&gt;&lt;A NAME=&quot;Freely_available_locale_definiti&quot;&gt;Freely available locale definitions&lt;/A&gt;&lt;/H2&gt;
&lt;P&gt;
There is a large collection of locale definitions at
&lt;CODE&gt;ftp://dkuug.dk/i18n/WG15-collection&lt;/CODE&gt;. You should be aware that it is unsupported, and is not claimed to be fit
for any purpose. If your system allows installation of arbitrary locales,
you may find the definitions useful as they are, or as a basis for the
development of your own locales.

&lt;P&gt;
&lt;HR&gt;
&lt;H2&gt;&lt;A NAME=&quot;I18n_and_l10n&quot;&gt;I18n and l10n&lt;/A&gt;&lt;/H2&gt;
&lt;P&gt;
``Internationalization'' is often abbreviated as &lt;STRONG&gt;i18n&lt;/STRONG&gt; because its first and last letters are separated by eighteen others. (You
may guess why the internalin ... internaliti ... i18n tends to get
abbreviated.) In the same way, ``localization'' is often abbreviated to &lt;STRONG&gt;l10n&lt;/STRONG&gt;.

&lt;P&gt;
&lt;HR&gt;
&lt;H2&gt;&lt;A NAME=&quot;An_imperfect_standard&quot;&gt;An imperfect standard&lt;/A&gt;&lt;/H2&gt;
&lt;P&gt;
Internationalization, as defined in the 
&lt;FONT SIZE=-1&gt;C&lt;/FONT&gt; and 
&lt;FONT SIZE=-1&gt;POSIX&lt;/FONT&gt; standards, can be criticized as incomplete, ungainly, and having too large a granularity. (Locales apply to a whole process, when it would arguably be more useful to have them apply to a single thread, window group, or whatever.) They also have a tendency, like standards groups, to divide the world into nations, when we all know that the world can equally well be divided into bankers, bikers, gamers, and so on. But, for now, it's the only standard we've got. This may be construed as a bug.

&lt;P&gt;
&lt;HR&gt;
&lt;H1&gt;&lt;A NAME=&quot;BUGS&quot;&gt;BUGS&lt;/A&gt;&lt;/H1&gt;
&lt;P&gt;
&lt;HR&gt;
&lt;H2&gt;&lt;A NAME=&quot;Broken_systems&quot;&gt;Broken systems&lt;/A&gt;&lt;/H2&gt;
&lt;P&gt;
In certain systems, the operating system's locale support is broken and
cannot be fixed or used by Perl. Such deficiencies can and will result in
mysterious hangs and/or Perl core dumps when the
&lt;CODE&gt;use locale&lt;/CODE&gt; is in effect. When confronted with such a system, please report in
excruciating detail to &amp;lt;&lt;EM&gt;perlbug@perl.com&lt;/EM&gt;&amp;gt;, and complain to your vendor: bug fixes may exist for these problems
in your operating system. Sometimes such bug fixes are called an operating
system upgrade.

&lt;P&gt;
&lt;HR&gt;
&lt;H1&gt;&lt;A NAME=&quot;SEE_ALSO&quot;&gt;SEE ALSO&lt;/A&gt;&lt;/H1&gt;
&lt;P&gt;
&lt;EM&gt;POSIX (3)&lt;/EM&gt;

&lt;P&gt;
&lt;EM&gt;POSIX (3)&lt;/EM&gt;

&lt;P&gt;
&lt;EM&gt;POSIX (3)&lt;/EM&gt;

&lt;P&gt;
&lt;EM&gt;POSIX (3)&lt;/EM&gt;

&lt;P&gt;
&lt;EM&gt;POSIX (3)&lt;/EM&gt;

&lt;P&gt;
&lt;EM&gt;POSIX (3)&lt;/EM&gt;,

&lt;P&gt;
&lt;EM&gt;POSIX (3)&lt;/EM&gt;

&lt;P&gt;
&lt;EM&gt;POSIX (3)&lt;/EM&gt;

&lt;P&gt;
&lt;EM&gt;POSIX (3)&lt;/EM&gt;,

&lt;P&gt;
&lt;EM&gt;POSIX (3)&lt;/EM&gt;

&lt;P&gt;
&lt;EM&gt;POSIX (3)&lt;/EM&gt;

&lt;P&gt;
&lt;EM&gt;POSIX (3)&lt;/EM&gt;,

&lt;P&gt;
&lt;EM&gt;POSIX (3)&lt;/EM&gt;

&lt;P&gt;
&lt;EM&gt;POSIX (3)&lt;/EM&gt;

&lt;P&gt;
&lt;EM&gt;POSIX (3)&lt;/EM&gt;,

&lt;P&gt;
&lt;EM&gt;POSIX (3)&lt;/EM&gt;

&lt;P&gt;
&lt;HR&gt;
&lt;H1&gt;&lt;A NAME=&quot;HISTORY&quot;&gt;HISTORY&lt;/A&gt;&lt;/H1&gt;
&lt;P&gt;
Jarkko Hietaniemi's original &lt;EM&gt;perli18n.pod&lt;/EM&gt; heavily hacked by Dominic Dunlop, assisted by the perl5-porters. Prose
worked over a bit by Tom Christiansen.

&lt;P&gt;
Last update: Thu Jun 11 08:44:13 
&lt;FONT SIZE=-1&gt;MDT&lt;/FONT&gt; 1998
&lt;HR&gt;
&lt;BR&gt;Return to the [Library]&lt;BR&gt;</doctext>
  <type_nodetype>116</type_nodetype>
  <node_id>407</node_id>
  <author_user>114</author_user>
  <title>perlman:perllocale</title>
  <createtime>1999-08-25 02:48:43</createtime>
  <nodeupdated>2005-08-14 17:07:15</nodeupdated>
</node>
