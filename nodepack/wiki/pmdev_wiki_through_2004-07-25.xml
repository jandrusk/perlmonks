<node>
  <doctext>&lt;p&gt;[davido], 2004-07-25&lt;br /&gt;
I didn't intend it to be a policy attack against [Wassercrats].  [chiburashka] and [freak] have also started a speedy descent, as well as others going back further in time.  It's too late for [Wassercrats]; he is whatever he is.  My suggestion is aimed at discouraging others who have yet to begin down that road.  If it gets implemented, I wouldn't even mind if [Wassercrats] be given an exemption for 60 days or something like that.  My thought is that for someone starting down that road, revocation of ability to post in the CB might be enough of a motivation to turn it around that the person wouldn't continue to the next step.  If it got bad enough, the person would have yet another deterrant (loss of all CB privs, both reading and writing).  Since the CB is one of the motivations for even coming to the Monastery, maybe that person would just leave, but at very least, would lose a privilidge.  But all this started as just a thought, and if people don't like it, I'm not 100% sold on it either... no hard feelings. ;)
&lt;/p&gt;
&lt;p&gt;[tye], 2004-07-25&lt;br /&gt;
I've been meaning to mention that the 'prefect example' to consider for this idea is Wassercrats.  And although I find his attitude to still be quite trollish both in nodes and in the CB, I think that much of his trollishness is unitentional.  More importantly, I think that banning him from the CB (whether as part of some policy that might be claimed to not be directed personally at him or in some other way), is more likely to worsen his attitude than improve it, IMHO.
&lt;/p&gt;&lt;hr /&gt;
&lt;p&gt;[demerphq], 2004-07-25&lt;br /&gt; 
I have one question: Is this solely meant to block [wassercrats] from the CB? Is that fair? 
&lt;/p&gt; 
&lt;hr /&gt; 
&lt;p&gt;[Corion], 2004-07-24&lt;br /&gt; 
Removing CB privileges would be an interesting possibility, removing posting privileges would be really horrible, as then somebody who made an error has no way of starting over as &quot;themselves&quot; but has to create a new account. A real troll who wanted to troll in the CB would simply create an account without ever posting and thus would have unlimited access to the CB unless Nodereaper swallows that troll for a long time. So I'm not sure whether this will deter the really determined trolls... 
&lt;/p&gt;&lt;p&gt; 
On the other hand, I find the -5 XP limit far too high - -5 XP can be easily attained if you're starting fresh but with the wrong node. I think that about -25 XP or something in that range should be it, and maybe even a second limit on the number of nodes already written, so that nobody &quot;fresh&quot; gets hit by that limit too early. 
&lt;/p&gt;&lt;hr /&gt; 
&lt;p&gt;[davido], 2004-07-24&lt;br /&gt; 
I don't condone removing posting priviliges, but do think there might be some merit in removing CB priviliges.  To prevent &quot;gang ups&quot;, I would suggest that CB speaking privs be removed at negative 5 xp.  That means that even if the person only posts one node, it would have to go pretty solidly into the negative before their CB talking privs disappear.  I would remove CB reading privs at negative 50.  Someone who goes that far in the hole is doing it on purpose, or refusing to listen.  It doesn't happen on accident.  Node posting privs should remain, I think.  Otherwise the person will just open a new account with a new email address.  Let the removal of CB priviliges happen silently, but the re-acquisition thereof should come with a &quot;congratulations, you have regained CB reading priviliges.&quot; (for example) 
&lt;/p&gt; 
&lt;hr /&gt; 
&lt;p&gt;[demerphq], 2004-07-24&lt;br /&gt; 
re castaway: Personally I dont see any issue in storing such information as last private message read via IM2. I fully agree with you however that you shouldn't hold passwords or cookies. As for storing on PM a &quot;last fetched message id&quot; I did actually put some thought into that direction as well. However the main problem is as you say multiple clients. Sure we could use some logic to make this less of an impact but for little value. Especially as I think the current code (in the patch) pretty well resolves the main issues already. 
&lt;/p&gt; 
&lt;p&gt; 
re davido: I think that the id of making the CB off limit to trolls is a good idea. Im not sure how comfortable I am with making the restrictions harder than that as [castaway] suggests. For instance preventing folks from posting would essentially mean they could never turn over a new leaf. Also I think we need to think carefully about this. We dont want to provide a way for folks to gang up on others to cause them to lose privs. 
&lt;/p&gt; 
&lt;hr /&gt; 
&lt;p&gt;[castaway], 2004-07-24&lt;br /&gt; 
Not sure if I can explain it well enough, but.. My reasoning is that people have specifically signed up with perlmonks, and entrusted it with their password, identity, private messages and so on. They have however not signed up with me (nor received any assurances), thus I would prefer not to save their information, last message id, passwords, cookies etc to my hard disk in the offchance that they may use [im2] again. (I know saving it to memory while it's running is similar, but not quite the same in my opinion.) Thus yes, I think that perlmonks itself should 'do the work'. 
&lt;p&gt; 
I don't know why this just occured to me, but.. Why can't PM itself save the 'last fetched message id' somewhere useful? (VARS?) And in the absence of any since_id, prior_id etc, return the 20 messages since that last seen id? This would ensure that clients dont have to be amended to put less load on PM, it could do it itself.. A setting (like the one for NN), could be provided to 'clear last fetched message id', in case anyone needs it. 
&lt;p&gt; 
This might cause some problems for people who use multiple cliens simultaneously.. (I have im2 FPC and im2 running usually, tho I could add a 'dont show private messages' flag to im2 chat, to solve it for myself.. or add a flag to specifically use since_id or... hmm..) 
&lt;hr /&gt; 
[davido]: I offered several similar ideas to that conversation, partly in fun.. If we really want people to stop bucking the system by going negative (by adding posts which are detrimental to the site, and getting away with it), then I think some sort of negative action is called for. Without giving the negative levels names, (which would give them something to aim for, which we dont want to do), removing priv as they go down sounds like a workable idea. My list would include: cant post to certain sections, cant see certain nodelets, can only chat so many lines in the CB (eventually none), cant use /ignore, cant read/send /msgs (except maybe to [gods]), cant reply in certain sections (except to own posts?).. and so on.. starting with something subtle but annoying things, and getting worse.. the difficulty is getting the subtly right, so that whomever doesnt just go and create a new user as soon as it happens. 
&lt;p&gt; 
Slight problem with all this: We're assuming the user actually cares about keeping their username, and becoming someone of merit. Some just don't give a damn at all. These will just create new users, the minute their account becomes too unusable, making it more difficult to track them, overall. (Maybe one could track via email somehow, since a valid one has to be provided for a username..) 
&lt;hr /&gt; 
&lt;p&gt;[davido], 2004-07-23&lt;br /&gt; 
The topic of trolls came up in the CB the other day, and a thought came to me.  It seems that some (not all, but some) of the trolls we see are fueled by the CB.  Furthermore, while there is positive reinforcement for XP gains (higher levels, ability to moderate, and so on), there is no negative consequence for trolling, besides the XP loss (which may actually become a reward for someone who takes pride in defiance).  It struck me that it might provide incentive to fit in a little better if we remove the ability to talk in the CB when ones XP drop into the negative range, and further, remove the ability to read the CB when XP drops below some other number, say, negative 50.  This may be a horrible idea, which is why I mention it here in a forum where hopefully levelminded thought will prevail.  On the other hand, I have to wonder if the idea doesn't have some merit.  The idea is that is provides incentive to &quot;turn it around&quot; when someone goes into the negative.  It also removes an avenue of inflamatory behavior when someone drops into the negative, and it removes one source of continued aggrevation from those who REALLY have negative XP.  Thoughts?  I'm almost afraid to ask. ;)&lt;/p&gt; 
&lt;hr /&gt; 
&lt;p&gt;[demerphq], 2004-07-23&lt;br /&gt; 
Well, I have to say that this logic is unconvincing to me. Basically what you are saying is that PM should do extra work so clients dont have to do so themselves. My feeling is that this is not the correct way to approach this. For instance you say that [im2] doesnt preserve state in between invocations and that PM should be designed so that you don't have to. This doesnt seem to be the correct prioritisation to me. Perhaps there is some reason why you can't preserve state, its not clear from what you say though. Anyway, I fail to see why PM should carry a larger load just so you don't have to preserve state, especially as the cost to you is a one off, (writing the code to preserve state, or delete/archive prior messages) but the cost to PM will be continuous and long term. I mean it should be trivial to modify IM2 to preserve the ID of the last message it handled, or to delete processed messages. 
&lt;/p&gt; 
&lt;p&gt; 
However, despite the above I have put together [id://377056] to provide the behaviour you all have been asking for.  In the process I have provided a way to ask for the N record &lt;b&gt;prior_to&lt;/b&gt; X, which is in addition to the existing way of getting the N records &lt;b&gt;since_id&lt;/b&gt; X. Furthermore the patch would make the default behaviour; when neither prior_to nor since_id is provided; to return at most 20 of the most recent records. Or rather the hard limit would be 20 if no id was provided. The records will always be returned in ascending order by idthat is oldest to newest. 
&lt;/p&gt; 
&lt;p&gt; 
This means that the client can do an initial argumentless request to get the 20 most recent records, then use since_id to get records newer that the newest returned, and prior_to to get the records older than the oldest returned. 
&lt;/p&gt; 
&lt;p&gt; 
I hope that this approach settles the matter and we can put this into effect on the first. I dont believe we need to extend the deadline as the only thing we are doing is changing the default behaviour. Anything already designed to use since_id should still work. 
&lt;/p&gt; 
&lt;hr /&gt; 
&lt;p&gt;[castaway], 2004-07-21&lt;br /&gt; 
I also have an objection. I don't thing *forcing* people to delete/archive their messages is very userfriendly, even if it does require less server load in the long run. Usability should come first, not last. (Else we could just throw away [Super Search], after all thats quite a load..). To this end I would also prefer that the default be the most recent X messages. OTOH I'm quite happy for it to be only the last 15-20 or so, and to have a from_id-&gt;to_id possibility, to get older ones/other ranges. (Or from/to date, since IDs for each user arent consecutive. 
&lt;p&gt; 
Rationale:&lt;br /&gt; 
[im2] does not save any user information (cookies, names, last message IDs) between runs, so it always grabs all messages since 0, on the first grab since a restart. The newest of the IDs returned by that will be stored as 'last id', and the next grab will get all since 'last id'. If people have hundreds of messages unarchived, this will go through several 'fetch 100 msgs since id X' iterations, before it catches up to the newest ones. Returning the newest 100 msgs would mean we would be uptodate right after the first fetch. - Less work for the server to do. 
&lt;hr /&gt; 
&lt;p&gt;[demerphq], 2004-07-19&lt;br /&gt; 
Hi folks. Ive not been around much as Im on vacation and have been avoiding using the computer. However a /msg I received today has recalled a debate that afaict has yet to be resolved: the pending change to the private xml ticker. As this is supposed to occur on Aug 1 I think we need to finish the debate. 
&lt;/p&gt; 
&lt;p&gt; 
The debate can be summarized in my opinion as this: Assuming that we are going to implement a hard limit on the number of returned records per private message retreival should we make additional changes to make this change &quot;lower impact&quot; on the end user. (Ie client author.) Currently private messages are returned in ascending order by id, with all private messages returned.  If a &quot;since_id&quot; parameter is provided then up to 100 messages later than that id are returned, still in the same order. At some point this behaviour will become default with since_id defaulting to 0 if not provided. This means that clients not altered to take advantage of this behaviour will always get the users oldest 100 messages. [sporty] and [theorbtwo] have mentioned that they believe that this behaviour should be changed so that it returns the 100 NEWEST messages instead. It has also been suggested that records should be returned in reverse order (ie descending). 
&lt;/p&gt; 
&lt;p&gt; 
I believe that these proposals should be rejected. First off they involve more load on the web servers. Second they remove much of the efficiency gain of clients not fetching the same data multiple times. Lazy client authors will simply get the latest 100 messages every time without bothering to use since_id at all. Third, i dont really see how the behaviour they propose works with since_id at all, and if it does I bet its pretty clunky code. Fourth i believe that there are at least one or two clients out there that already take advantage of the new behaviour so we would break the clients who are maintained actively to suit lazy client authors. The revers option is IMO even worse as it will surely clobber lots of things as its a drammatic change. 
&lt;/p&gt; 
&lt;p&gt; 
Aug 1 is approaching so id like to put this debate to rest well before that time. And for the record [epoptai] has told me he is changing framechat to utilize the new behaviour in time so at least one of the major clients in use will already be utlizing the existing code. So i think the current plan should proceed despite the well intentioned objections raised by [sporty] and [theorbtwo]. Anyway, ciao. 
&lt;/p&gt; 
&lt;hr /&gt; 

&lt;p&gt;[ysth], 2004-07-11X&lt;br /&gt; 
Here are some todo notes for small projects I've been accumulating.  I'd like to hear reactions (or implementations!) to any or all: 
&lt;ul&gt; 
&lt;li&gt;Wiki overflow protection (see [tye]'s suggestion) 
&lt;/li&gt;&lt;li&gt;Don't show reaped notes as awaiting approval on [id://479], etc. 
&lt;/li&gt;&lt;li&gt;Easier way to see effect of readmore tags for root nodes (param ;readmore=0??) 
&lt;/li&gt;&lt;li&gt;[superdoc] to do what [id://274951] does, with preview of changes (form to allow tweaks) 
&lt;/li&gt;&lt;li&gt;user setting to cc /msgs to the sender 
&lt;/li&gt;&lt;li&gt;user setting to forward msgs to master user 
&lt;/li&gt;&lt;li&gt;show mimetype on [htmlpage display page] 
&lt;/li&gt;&lt;li&gt;auto-add new [Q&amp;A_Section]'s ala [id://14827] 
&lt;/li&gt;&lt;/ul&gt; 

&lt;/p&gt;&lt;hr /&gt; 

&lt;p&gt; 
 &lt;p&gt;[crazyinsomniac], 2004-07-06&lt;br /&gt; 
Hi.  Please apply the following two patches 
&lt;ul&gt; 
&lt;li&gt;[id://371509] accomodate imageoff (like jsoff) 
&lt;li&gt;[id://371511] add imageoff setting (like jsoff) for patch 371509 
&lt;/ul&gt; 
They afford users the option of disabling &lt;code&gt;&lt;img ...&gt;&lt;/code&gt; tags on homenode much in the same way 
they are disabled for users less than level 5 (or much like &lt;CODE&gt;&lt;script&gt;&lt;/code&gt; tags are disabled). 

 &lt;/p&gt; 
 &lt;!-- followup to crazyinsomniac in a pair of P tags in here please --&gt; 
&lt;/p&gt; 
&lt;hr &gt; 
&lt;p&gt;[demerphq], 2004-07-04&lt;br /&gt; 
I'm a bit perturbed by the code duplication involved in [showchatter] [new chatterbox xml ticker] and the [chatterbox xml ticker]. IMO this should all be refactored out into a single &quot;getmessages&quot; node that can be reused by all and sundry. 
&lt;/p&gt; 
&lt;p&gt; 
Ive also reviewed [ysth]s new scratchpad changes, they look good with a few caveats that ive posted on the main server. 
&lt;/p&gt; 
&lt;p&gt; 
Ive also fixed a few minor glitches in the [Synch Nodelet] and [createpatchfrom] nodes, as well as resolved the race condition in [get_picked_nodes]. Ive also moved a patch over from DEV that fixes a subtle race condition in the locking mechanism used for wikis but i havent applied it yet. 
&lt;/p&gt; 
&lt;p&gt; 
I'm also looking at extending such code as well as related editors material for reuse in site(doc|faq)lets and the like. 
&lt;/p&gt; 
&lt;hr/&gt; 

&lt;p&gt;[tye], 2004-07-02&lt;br /&gt; 
My first impression is that the bulk of editor code should become a htmlcode and the node-editors-page check that you are a janitor and that the node allows janitors and then call the moved code.  Then a sdc edit page could just call the moved code and use standard security.  The /msg-author stuff would become optional, of course. 
&lt;/p&gt;&lt;p&gt; 
I haven't thought of any reason why that code shouldn't be reused, but I also have't looked at closely recently. 
&lt;/p&gt;&lt;p&gt; 
Another advantage would be the sdc nodes getting locking, thus allowing some beaurocracy to go away or at least become less important. 
&lt;/p&gt;&lt;p&gt; 
It would be nice to move the wiki edit to use this code as well so we'd have preview. 
&lt;/p&gt;&lt;p&gt; 
Even w/ preview, it might be nice to reuse the previous history record in the case of repeated edits by the same user within a short period of time. 
&lt;/p&gt;&lt;p&gt; 
Does the editor code validate that you didn't edit a stale copy?  That step is important. 
&lt;/p&gt;&lt;hr /&gt; 

&lt;p&gt;[demerphq], 2004-07-03&lt;br /&gt; 
I was just having a poke around to see what would be involved with making [sitefaqlet]s and [sitedoclet]s access to the edithistory infrastructure. It appears to me that Wikis and Nodes use different code. Also it appears like it wouldnt be too difficult to take the [node editors page] and make it usable on sitefaqlets instead of the current direct edit mode. Is there any good reason not to do this or does anybody have plans or suggestions that this might affect? Id like to know before I start on it... 
&lt;/p&gt;&lt;hr /&gt; 
&lt;p&gt;[castaway], 2004-07-02&lt;br /&gt; 
Someone just pointed out to me that setting 'Show unmoderated content' on [user settings] and being &gt;= level 5 means that one sees unmoderated nodes twice.. (once in the normal list, and once at the bottom of the page in the list of content to be approved). Am I off-base in thinking that this could be integrated? ie. All unmoderated content shows with an approval button for level &gt;=5, and the user settings checkbox just determines where its placed? (It also seems strange to have that setting, then show them anyway when the user is &gt;= 5) 
&lt;p&gt; 
I dont use the frontpage or sections much myself, so Im not sure how people who do usually go about looking for/at unapproved content. 
&lt;p&gt; 
Of course, if we actually get around to defaulting to approved, all this is somewhat of a needless discussion.. ,) 
&lt;hr /&gt; 
&lt;p&gt;[demerphq], 2004-06-30&lt;br /&gt; 
[castaway]: yeah that sounds good for a wiki.  The only reason I havent created one yet is I had some weird thought there might be something special involved. As there probably isnt Ill put it together today unless someone beats me to it. (In which case leave a note here [gods] to that effect. 
&lt;/p&gt; 
&lt;p&gt; 
[ysth]: regarding passthorough. SPV is a particularly special case as it really doesnt and shouldnt show any XML but the XML of the scratchpad youve asked it to. This means that the call flow is like this: [node xml page|NXP]-&gt;[handle_xml_display|HXD]-&gt;[handle_scratch_pad_viewer|HSPV]-&gt;[handle_xml_display|HXD]. With the new XML stuff I just piggybacked on the infrastructure established for that. The passthrough flag is IMO required to prevent that from becoming an infinite loop, and when it isnt provided to to allow [pmdev] to actually view the doctext of the SPV. 
&lt;/p&gt; 
&lt;p&gt; 
So to handle the newer tickers without requiring the passthrough flag being set I changed things a touch and made the passthrough setting default to assume the XML handler is intended for inline use and not passthrough use. Perhaps it would be a good idea renaming the setting [xml passthrough setting] to [node xml handlers] so that it isnt so confusing. But the fact remains that the SPV functionality isnt and CANT be executed inline. So ONLY when the handler IS NOT inline is passthrough required, and then it is mandatory to get the effect. 
&lt;/p&gt; 
&lt;p&gt; 
As for seeing what used to be in the XML view for those nodes, afaik its still there, just the new stuff is now embedded in the old output, hence the term &quot;inline&quot;. The xml handlers result will be injected inline to the old feed. So nothing has been lost for these nodes, just new fancy stuff is added. 
&lt;/p&gt; 
&lt;p&gt; 
As an example let me illustrate how we could do this with [Saints In Our Book] as an example. First we would create a new [htmlcode] node called [handle_siob] that was responsible for building the table in both HTML and xml. Then we would replace the current SIOB table code with a call to [handle_siob]. Then we would add a new entry to [xml passthrough setting] with SIOB's node id as the key and 'handle_siob' as the value. Then when you did an XML display view of SIOB youd get the usual stuff, as well as whatever XML output came from handle_siob. (Not its the handlers responsibility to determin if its been called in XML mode, not the dispatchers). 
&lt;/p&gt; 
&lt;p&gt; 
Hopefully this all makes sense. 
&lt;/p&gt; 
&lt;p&gt; 
PS: noticing some comments in the CB about using patches as a base of PM discussion. I dont think this is the greatest idea. Its useful for critiqueing code but I dont think its suitable for discussing design stuff in a bigger way. I think there really is a call for a PMDEV Related root node ALA PMD but not viewable to public. That way the wiki can go back to being for trivial stuff and not for long drawn out debates and design discussions. 
&lt;/p&gt; 
&lt;hr /&gt; 
&lt;p&gt;[castaway], 2004-06-30&lt;br /&gt; 
I havent actually used perltidy or any such similar, so Im willing to conceed the point that it might actually produce the desired effects as [demerphq|you] say. (Tho I think indenting and positioning of braces are the least of the style differences ,) 
&lt;p&gt; 
Having Style Guide as a Wiki - good plan - probably best with a discussion part, and s static 'current situation part', methinks.. 
&lt;hr /&gt; 
&lt;p&gt;[ysth], 2004-06-29&lt;br /&gt; 
What's with [user_filtered_page]?  Can it get axed?  It still looks at the old scratchpad fields. Update: I meant [user filtered page]. 
&lt;/p&gt;&lt;hr /&gt; 

&lt;p&gt;[ysth], 2004-06-29&lt;br /&gt; 
[demerphq], the xml passthrough stuff is a really cool idea. 
&lt;p&gt; 
But I'm not sure what the purpose of requiring passthrough= is?  I can 
see wanting the existing xml dump of the actual doctext for those 
nodes to still be available, and it's a little confusing that the 
!$no_inline nodes don't require the passthrough parameter...how do you 
do what displaytype=xml used to do for those? 
&lt;p&gt; 
Perhaps have a new displaytype for that, and drop the passthrough 
stuff altogether.  (I've also wanted a displaytype that would dump 
the doctext for *superdocs, htmlpages, etc. as fullpage text/plain.) 
&lt;p&gt; 
But maybe there's just a piece I'm missing in all this. 
&lt;/p&gt;&lt;hr /&gt; 

&lt;p&gt;[demerphq], 2004-06-28&lt;br /&gt; 
Well i see using robust constructs over fragile ones to be much the same as using strict: They both help you avoid errors. :-)  While I don't want to argue over it either, I do think its worthy of a [Meditatios|meditation] to discuss.  I think there are some interesting angles that are worthy of the full analytical capabailities of pm-think. 
&lt;/p&gt; 
&lt;p&gt; 
I think [perltidy] is a fine tool and use it fairly regularly. It doesn't always handle some of the constructs I tend to favour the way I would like it to, (chained ternarys and chained list operators) so I don't use it as often as I might.  As usual I see using it in an almost opposite light than you do [castaway]: I found that by using it regularly I started writing my code in a fashion very similar to what it would output. By reading and working in a regular and consistant style I grew accustomed to its output and just naturally started imitating most of what it does. 
&lt;/p&gt; 
&lt;p&gt; 
Also I used to work with someone who used Emacs in a mode where it used 4 spaces for an indent, but would automatically convert 8 spaces in a row to a tab (and refused to reconfigure it).  This played havoc with my editor where I usually have tabs set to 4 spaces. Also his style was extremely messy (he often didnt bother with indentation) so to avoid the regular readability fights I would just perltidy his code and check it back in. He used to bitch about the fact that this would screw his diffs, but after a while he realized that I wasnt going to stop doing it and started cleaning up his coding habits (or tidying himself). When that happened I stopped tidying his code, and there was much happyness and rejoicing. 
&lt;/p&gt; 
&lt;p&gt; 
Anyway, i think maybe that a style guide wiki is a good idea. Then folks can collaborate on it. 
&lt;/p&gt; 
&lt;hr /&gt; 
&lt;p&gt;[castaway], 2004-06-28&lt;br /&gt; 
I'll have to poke a little bit of fun here.. but isn't using a construct that covers up your mistakes (re join vs. q), like not using strict? Surely its better not to have mistakes ,) Using a double dot by accident is a syntax error, which one fixes as soon as the code doesnt run, a double ,, in join may stay and make people wonder.. :) - Anyway, not worth arguing about really.. 
&lt;p&gt; 
Last comment (or so): Note I didnt say tidying up old code was a bad idea, I just dislike 1) fixing style and actual content simultaneously and 2) jumping from one code piece to another and getting confused by the (sometimes vastly) different styles). Im just curious if Im the only one with this problem. I guess its also inevitable if we're ever going to fixup code and style it the same, no way it can be done in a short time period.. 
&lt;p&gt; 
BTW, re perltidy: having something that 'fixes' my code stylewise doesnt get me in the habit of writing as it should be, which Id rather do so I can also understand other peoples code in that style.. make any sense? 
&lt;p&gt; 
Ok, will have a go at a guide when I feel inspired, we'll see what comes of it.. Were there not some 'best pmdev practices' or something around here somewhere? (For new pmdevers, 'how things are done', or indeed any docs, seem to be lacking ,) 
&lt;hr /&gt; 
&lt;p&gt;[ysth], 2004-06-28&lt;br /&gt; 
While there appear to be [id://370323|some differences of opinion] as to how things should end up (or at least more to talk about), [davido]'s patch should still be applied rather than waiting for some nebulous future (IMO). 
&lt;/p&gt;&lt;hr /&gt; 

&lt;p&gt;[davido], 2004-06-28&lt;br /&gt; 
[id://370403] after being applied and tested on the test server, has now been pushed over to the main site.  If someone could check it out and approve it, we can do away with the need to keep both the Node Status nodelet, and the Approval Nodelet active at the same time to get the whole story.&lt;/p&gt; 
&lt;hr /&gt; 
&lt;p&gt;[demerphq], 2004-06-28&lt;br /&gt; 
I don't understand the perltidy argument. If a node is tidied and checked in there is a one time bridge between the two. This will be true of any rewrite. I see no reason why such drastic measures should occur more than once to a node.  And once done its a lot easier to move forward.  Not doing so seems to mean that for reasons that have minimal benefits we will always be working with old and crusty code. If its not appropriate to &quot;modernize&quot; the nodes im talking about when the first modern patch is applied then when will it be appropriate? Never? So we have to deal with crusty code until the node is outright replaced? At which point we have what connection to the old code and as such totally defeat the objective you seem to have. 

&lt;/p&gt; 
&lt;p&gt; 
Regarding joins versus concatenation I think its clear the we wont agree about readability, but you completely sidestep the issue that it reduces the chance of error by using a more robust way of coding the same thing. Which to me is infinitely more important. 
&lt;/p&gt; 
&lt;p&gt; 
Moving on to the question of style, that may well be true of some projects. I personally haven't seen that stated anywhere, but I think in terms of overall code base the nodes we are talking about are written in a style that is far from orthodox and far from common. As such moving to a more conventional style only increases the accessability and maintainability of the code. I know that personally I have scratched my head a couple of times and been forced to totally rewrite things just to get things into a form that my brain could absorb. As such id rather see as little such code around as pos. 
&lt;/p&gt; 
&lt;p&gt; 
And lastly with regard to NOT writing a style guide. Im sorry if my comments were perceived as being totally negative. I think a style &lt;i&gt;guide&lt;/i&gt; is a good idea. I think an understanding of what the [gods] typically want to see in a patch is important to help minimize frustration. But I think that its going to be hard to come up with a set of guidelines that everybody is happy with. Just cause its hard doesnt mean its not worth doing. 
&lt;/p&gt; 
&lt;p&gt; 
Regarding patch-fu and the like: Im flattered that you think i have more -fu than others. I personally am unconvinced. If one makes it into [PMDev] than presumably one has patch-fu sufficient to restructure an ancient node. The next point is that there is a lot of procrastination and hassle in [pmdev] historically. A lot of this is/was becuase of lack of testing facilities and lack of sufficient staff to review nodes. One of the things that exacerbated this last point was that a lot of the code is pretty hard to follow. I remember spending a LOT of time on the signature stuff just trying to figure out what it did and why it did it and in the process found that signifigant chunks of what was there shouldnt have been. So when we look at simple patches to such code its really hard to tell what the effects could and will be. Which means that the person responsible for applying it has to do a lot more work to decide what is up. Whereas a restrcutured cleaned up node is a lot easier to review as its usually a lot easier to follow its logic. 
&lt;/p&gt; 
&lt;p&gt; 
Ultimately as i said before it comes down to a judgement call. First by the developer, then later by the god reviewing and applying the code.  I asked [davido] when he made a slight change to one of the older nodes to do a cleanup as well.  My judgement was that there was no reason to touch the node unless it was going to be materially improved. Its possible that [theorbtwo] or [tye] would have applied it as it was written, but he didn't ask them he asked me and I gave him the answer I thought was in the best interest of the site. I recall in earlier days that [tye] and [ar0n] used to do a lot of cleanup/rewrites. And I certainly remember in a number of situations [tye] asking me to cleanup other parts of a patch that were unrelated to the direct issue I was addressing, so I think there is precedent for this position. 
&lt;/p&gt; 
&lt;p&gt; 
Anyway, all this yattering is just distracting us from out principle job: Make PM better, faster, cooler, and eventually able to serve beer. I dont think we need to quibble over stuff like this so much, (even though I am a very effective quibbler :-), its better to just let stuff flow. I think on the balance we can work things out without too much friction and the like. 
&lt;/p&gt; 
&lt;hr /&gt; 
&lt;p&gt;[castaway], 2004-06-28&lt;br /&gt; 
Hmm, opened a can of worms there, didnt I?&lt;br /&gt; 
To perltidy: It might sound like a nice idea to have the code in the DB all looking the same, but if I write something, convert, check it in, when I come to look at it again, I'll have to re-figure out the code. Also as the others have already noticed, it's usually the actual constructs used that differ, not just indentation. 
&lt;p&gt; 
My thought to you, demerphq, its not so bad if you like to rework code yourself (as long as its still readable after, which is a large matter of opinion), but I dont find it clever to impose the 'reqork that before I apply it' on oothers, they may not have the -fu or inclination, and may get dispirited beforethey actually get started. So why not allow simple changes.. Personally Id prefer that code changes and style changes go in different patches entitled such, to make them easier to follow. 
&lt;p&gt; 
I guess it all comes down to opinion tho. I find the join('', .. ) syntax harder to read than the one with &lt;code&gt;q]&lt;/code&gt;. But what can one do but differ, and struggle through the code. (BTW Im not sure the 'its an open source problem' excuse applies, at least a few of the larger OS projects dont accept code not after their own style, or so I've heard. 
&lt;p&gt; 
Sounds like thats a 'no' to my idea then.. Since theres not much point if the most prolific coders arent going to agree. 
&lt;hr /&gt; 
&lt;p&gt;[demerphq], 2004-06-28&lt;br /&gt; 
Heh. Ok, since i have been guilty of this at least once I feel obliged to offer both a rationale and a what i consider to be a demarcation line. There are in my eyes broadly speaking two kinds of patches here (this is a purely subjective demarcation), really early ones that use a much older style of Perl that is IMO not really appropriate for shared development. Characteristics of these nodes are heavy use of $$HASH{KEY}, very long lines, minimal indentation or code structuring or comments. These nodes are to be on the &quot;Hunt-And-Kill&quot; list. I personally will ask folks to &quot;modernize&quot; these nodes before applying any other patches. In my view its better to take a one time hit rewriting the code than it is to keep working with that code. Also, I feel that this process represents a code review. In some cases the code has subtle errors that because of the style are hard to spot. But when you restructure and recode the errors pop out at you. 
&lt;/p&gt; 
&lt;p&gt; 
The second type of nodes are more recent and may use various unusual style approaches (such as the &lt;code&gt;qq[]&lt;/code&gt; for newlines. As I said I find this style extremely difficult to work with and I personally will probably rewrite them in a more conventional mode. I dont know that I would ask folks to actually remove it though, and if the patch was really trivial even I might not touch it. However usually these nodes are under active development by active [pmdev]ers. In that case I would probably bow to the authors intention. 
&lt;/p&gt; 
&lt;p&gt; 
Having said all of that I still think it comes down to a question of personal judgement. If you think the approach you take makes sense then take that approach and dont feel bad about it. I argued with the gods before I was one, ill keep arguing now if I think they are wrong and I don't expect anyone to do anything different from what I myself do. The question really to me is &quot;does it work? is it secure and stable? does it make life easier in the long run? is it better than before.&quot; If the answer in your opinion is yes to these questions then dont fear anyones criticism. 
&lt;/p&gt; 
&lt;hr /&gt; 
&lt;p&gt;[davido], 2004-06-28&lt;br /&gt; 
I have to jump in here to clarify my position, as I think I'm the one who started all this discussion on style, etc.&lt;/p&gt; 
&lt;p&gt; 
My frustration is that in my initial attempts at creating patches as a new [pmdev]'er I tried to touch as little code as possible while accomplishing the objective.  I assumed that styles used should be respected, and that changes should be isolated to as small a portion of the code as possible, so that people reviewing the changes would have some idea what the hell was important. 
&lt;/p&gt; 
&lt;p&gt; 
But none of those patches got applied as-is, and it wasn't for lack of their doing what they were supposed to do.  I was asked to go back and rework the code segment; fixing style issues in the old code (parts that were unrelated to my primary objective), work out concatenation chains, reduce wordy constructs into more Perlish idioms, etc.  Fine, I'm ok with that.  I actually kind of like doing it.  But that's an entirely different philosophy from the philosophy of getting in there and messing with as little as possible. 
&lt;/p&gt; 
&lt;p&gt; 
Messing with as little as possible eventually results in spaghetti code.  But in the short-run, it makes each incremental patch easier to look at and debug.  In the long-run, newcomers to a particular segment of code that has had minimalist incremental patches applied to it, and will scratch their heads and say, &quot;Why did people do it this way, I wonder?&quot; 
&lt;/p&gt; 
&lt;p&gt; 
Reworking code is dependant on the person who does it making judgement calls.  And if you ask three volunteer developers what their judgement is, you'll get three different answers much of the time.  Herein is my frustration.  When I create a patch with a minimalist approach, it won't get applied until I've gone back and reworked the entire old code segment to &quot;clean it up&quot;.  Yet if I dive in and rework a section of code, the patch won't get applied because it's too difficult to look at the 'diff' of the code and understand all of the reds and blues to determine what really changed and how it will effect the world.  This is nobody's fault in particular, but I do find that one person follows one school of thought, and another person follows a different school.  I would be happy to adopt either school, if I could just figure out which one is going to get my patches applied without rewriting them again and again to satisfy the opposing views.  Jokingly I mentioned that perhaps I should create two versions of each patch. 
&lt;/p&gt; 
&lt;hr /&gt; 
&lt;p&gt;[demerphq], 2004-06-28&lt;br /&gt; 
[BigLug] since you are new to [pmdev] you have not yet had the joy of debugging the HTML we produce. Comments and newlines and similar constructs can be absolutely critical to that process. Sure we can minimze this somewhat for bandwdth purposes, but the structure and nature of the everything setup means that often a well placed comment in the output is the easiest and most direct means of debugging what the hell is going on. Likewise newlines mean that you dont have to run the page through htmltidy to clearly see what is up. My editor behaves very strangley with extremely long lines which makes it very difficult to work with CGI.pm'esque HTML (ie with no spaces or newlines 99% of the time). Thus throwing in newlines or comments with nelwines in them can be very helpful to me. 
&lt;/p&gt;&lt;hr /&gt; 
&lt;p&gt;[demerphq], 2004-06-28&lt;br /&gt; 
Well, I think I better respond to a few of these as I suspect to an extent they aimed at me. First SQL. I write SQL statements almost exclusively along the lines: 
&lt;code&gt; 
  select field1, 
         field2, 
         field3 
    from table1, 
         table2 
   where fieldx=fieldy 
     and blah=10 
order by field1 
&lt;/code&gt; 
As [tye] said, the purpose of this is to produce easy to read queries that are quite clear in what and how they do things. When stuff is rolled up on a single line or less lines I find its really easy to lose track, furthermore when one of the clauses gets so long as to require a line break for legibility I find the result particularly difficult to read and comprehened and thus keep error free. If there are issues with MySQL silent truncating queries then I think tyes suggestion of eliminating whitespace after the query is declared is probably the best approach. Maybe we could add a utility sub to one of the PM modules for this purpose. 
&lt;/p&gt; 
&lt;p&gt; 
Regarding other style issues. I think generally this is a problem in Open Source/Collaborative development that isnt going to go away. A style guide would be good, but I dont see any prospect of enforcing it on a bunch of volunteers. I suppose that a list of DON'Ts might work, but I think you are going to have a hard convincing me not to cuddle my elses in new code, and I think I would have a hard time convincing [castaway] to cuddle her's. (Poor things deserve a cuddle, they do so much work ;-)  And frankly my view is that its neither necessary nor in the best interest of developement here. 
&lt;/p&gt; 
&lt;p&gt; 
But id like to make a distinction here, theres a big difference between a new node, (or a rewrite), and patches to existing body of code. My general policy is that I either patch close to the original style, or I do a rewrite. On occasion I run existing nodes (particularly very old ones with extremely long lines) through perltidy. When I patch I typically do my best to break ANY long lines in the node, as well as convert all $$FOO{BAR}'s to $FOO-&gt;{BAR}'s. The fomer to me is anathema and as such I search and destroy whenever I touch a node. 
&lt;/p&gt; 
&lt;p&gt; 
I also will convert any examples of repeated concatenation against a var ($s.=&quot;foo&quot;; $s.=&quot;bar&quot;;) to either $s.=&quot;foo&quot;.&quot;bar&quot; or strongly preferably to $s=join &quot;&quot;,$s,&quot;foo&quot;,&quot;bar&quot;; I have a very good reason for the later. It is MUCH easier to fix, and modify without error joins of lists. The concatenation operator is far less tolerant of error than the list seperator. Ie: $s=$x.$y.$z.; is a syntax error as is $s=$x..$y.$z; as is $s=.$x.$y; etc. The equivelent join version of these statements is never a syntax error. Given the way PM works and the PITA it can be to make and apply even a simple patch anything that can prevent stupid error just by style decision is a huge win in my eyes. Likewise I often use map{} on a list of data to avoid repeated code or text. And I have and will continue to change code that repeats code or text. IMO its error prone to repeat text, and it makes a maintainers life difficult. 
&lt;/p&gt; 
&lt;p&gt; 
Continuing on to the odd &lt;code&gt;qq[]&lt;/code&gt; stuff in the code. I find that this is stylish, but to my eyes stylish like a hawiian shirt. The noise level in reading and parsing the code is to me just confusing and error prone. So when I work on code that has them I remove them unless my patch is trivial. My view is that if you want newlines in the code put them in explicitly. To me &quot;\n\t&quot; is vastly preferable to &lt;code&gt;qq[ 
  ];&lt;/code&gt; I realize tye seldom doesnt do anything without a good reason (at least thats his repuation) but i think that anything that reduces comprehension and increases errors on the basis of output considerations is a mistake. 
&lt;/p&gt; 
&lt;p&gt; 
So all in all, my rules of thumb (and im not suggesting this is binding on anyone else at all) is: remove error prone constructs, eliminate misleading and poorly scalable constructs ($$HASH{KEY}), use join instead of concatenation, write your queries out explicitly so people don't have to wonder how they work, use $q-&gt;html() for generating non trivial html. I also tend to try to structure my code to minimize nesting. Thus i make use of next if $cond; over unless($cond) { ... }. Actually thats another point. Its a minor peeve of mine when people write do_something() if !$foo. I always write that as do_something unless $foo. As the unless makes things a lot more clear. I dont always code with my glasses on and that exclam can just dispappear on occassion. Also long lines are unacceptable to me. If the nodelets move a non trivial distance when viewing a patch or node then the code needs to be restructured in my book. 
&lt;/p&gt; 
&lt;p&gt; 
In short, small patches should more or less respect the style of the node they are for. But total rewrites with style improvements are fine. Write with clarity, comprehension and error reduction in mind. 
&lt;/p&gt; 
&lt;p&gt; 
But again, these are just my views and I dont expect everybody to agree or necessarily follow them. OTOH, Its very likely that I wont apply patches or that I will repatch your code if it violate certain of them, (like long lines). 
&lt;/p&gt; 
&lt;p&gt; 
Anyway, ive got a bit of a pounding headache right now so if my tone here seems a bit hard please forgive me. Im not trying to bit or insult or annoy anybody. :-) 
&lt;/p&gt; 
&lt;hr /&gt; 
&lt;p&gt;[BigLug], 2004-06-28&lt;/p&gt; 
&lt;p&gt;Sounds like a good idea [castaway]. How about creating a .perltidyrc that pmdevers can use to tidy their code. That way we can each have a perltidyrc for formatting our code how *we* like it, and then another that is the default PM style. Using the two it's then easy to swap between one's own style and the 'official' PM style. (I'm not suggesting we build perltidy into PerlMonks, but that we do the formating on our own machines.)&lt;/p&gt; 
&lt;p&gt;While I'm talking about tidy, [tye] why do we need to send out HTML that is formatted? As you say, there is an overhead in doing so. Why don't we remove all extraneous space from the output? While we're at it, remove all comments too. Slow connections will then be happier. Once we've done that, create a displaytype that leaves it all in (so people can read all the extraneous comments!). For that matter, as we have infinite processing power :) we could run both the pruned and full outputs from tidy.&lt;/p&gt; 
&lt;p&gt;Another thought is to introduce a triple-dash comment that is removed before sending the page to the user. At the top of all [sitedoclet]s there are comments that the [SiteDocClan] use to keep a track of changes. These don't need to be read by the end-user, so I'm suggesting that they're put into triple-dash comments: &amp;lt;!--- This is never rendered except in the edit view ---&amp;gt;&lt;/p&gt; 
&lt;i&gt;&amp;lt;aol&amp;gt;first post to pmdev&amp;lt;/aol&amp;gt;&lt;/i&gt; 
&lt;hr /&gt; 

&lt;p&gt;[castaway], 2004-06-28&lt;br /&gt; 
Recent discussion has reminded me of something that occured to me while at YAPC::NA. A Perl Monks Styleguide. There has been quite a bit of new code/patching recently, some of which styles itself differently to existing code. Yes, I include myself in this, I'm prone to not 'cuddle' my elses, for example, and I think most of the existing code does. Does anyone have an opinion on this? My main reason would be code is easier to understand at a glance if it is all styled similarly, especially when looking at a bunch of code chunks that make up a particular function. 
&lt;p&gt; 
I will probably start a guide based on the majority of existing code, and then we can go from there (unless anyone has better ideas..) - I know it's hard to stick to other peoples coding styles, but hopefully people will see the overall benefits. 
&lt;hr /&gt; 
&lt;p&gt;[davido], 2004-06-27&lt;br /&gt; 
I've created a patch to the Approval Nodelet on the test server.  The intent was to fix the Approval Nodelet so that it displays all of the information found in the Node Status nodelet, making it unnecessary to keep both active.  If someone gets a chance, please apply it over there on the test server so I can verify that I've dotted all my I's. 
&lt;/p&gt; 
&lt;hr /&gt; 
&lt;p&gt;[tye], 2004-06-27&lt;br /&gt; 
One reason was to *indent* the resulting HTML.  I now think that this was overdone.  I still like frequent newlines in the HTML we produce, but the total volume of indenting spaces became significant to download size (and speed on slow connections).  I'd like the code that produces the HTML to remain well indented but no longer expend effort on trying to make the HTML output indented. 
&lt;/p&gt;&lt;p&gt; 
It was also a matter of doing mullti-line strings and just unquoting whenever more than a simple scalar needed to be inserted.  It certainly wasn't a result of sloppiness.  I don't see the appeal of backslash-n unless its presense has such significance to warrant stressing it.  In HTML, it isn't significant. 
&lt;/p&gt;&lt;p&gt; 
But I see advantage to the alternate style for not sending out the indenting spaces. 
&lt;/p&gt;&lt;p&gt; 
On a slightly related note, I would like to avoid newlines in SQL.  Unfortunate limitations in MySQL mean that some tools report quite truncated queries string and lots of whitespace in queries makes those tools less useful.  Other reports are easier to process when each reported item stays on one (long) line. 
&lt;/p&gt;&lt;p&gt; 
But I think I'll see more multi-line strings of SQL as time goes on.  Here I think the motivation *is* sloppiness. And it is exactly the kind of sloppiness we should encourage (making the code faster to write and easier to maintain). 
&lt;p&gt;&lt;p&gt; 
So I think I'd like to make it easy for authors to &lt;code&gt;s#\s*\n\s*# #g&lt;/code&gt; or even &lt;code&gt;s#\s+# #g&lt;/code&gt; on their SQL strings (when they use placeholders) so we can have the best of both.  Perhaps this would fit in with other tools that prefetch all rows (since stopping early does no good with MySQL and fetching fast may help with MySQL/FreeBSD issues). 
&lt;/p&gt;&lt;hr /&gt; 

&lt;p&gt;[davido], 2004-06-27&lt;br /&gt; 
Style question:  Is there a reason why I often see in site code something along the lines of the following: 
&lt;/p&gt; 
&lt;code&gt; 
$str .= qq[ 
 ] . somefunc() . qq[ 
 ]; 
&lt;/code&gt; 
&lt;p&gt;...in stead of something like...&lt;/p&gt; 
&lt;code&gt; 
$str .= qq[\n] 
    .  somefunc() 
    .  qq[\n]; 
&lt;/code&gt; 
&lt;p&gt;The primary question being, why do we use embeded invisible newlines instead of \n explicit newlines?  I suppose it doesn't matter too much.  But I've been tinkering with some code here and keep itching to &quot;fix&quot; those invisible embeded newlines.  They seem like a sloppy shortcut to me, but I may not be grasping the clarity of the convention. 
&lt;/p&gt; 
&lt;hr /&gt; 
&lt;p&gt;[demerphq], 2004-06-27&lt;br /&gt; 
Please review the [cabal wiki] for details of the new [sitedoclet] nodetype and  [get_sitedoclet] htmlcode. Hopefully between the docs in the code and the stuff i said in the cabal wiki everything is good. Anyway. Im off for beer. Complaints to /dev/null :-) 
&lt;/p&gt;&lt;hr /&gt; 
&lt;p&gt;[davido], 2004-06-27&lt;br /&gt; 
If we remove [Craft], where does its contents go?  Are you suggesting just removing the links to it, or the section designation itself?  [Super Search] still turns up 1034 nodes posted under [Craft].  Would we also remove the [Craft] checkbox in [Super Search]?  And if so, would those 1034 Craft nodes be re-assigned to [Code]?  ...just wondering about implementation.&amp;lt;br /&gt; 
&lt;b&gt;Update: &lt;/b&gt;Looks like I spoke too soon... removing it only from the titlebar shouldn't create any problems. 
&lt;/p&gt; 
&lt;p&gt;[demerphq], 2004-06-27&lt;br /&gt; 
Ok, i fixed a few minor nits in [Craft] as observed by [castaway] (linenumbering and deleted nodes were a touch wonky). But as the section is deprecated shouldn't we just remove it from the titlebar? Anyway, I've posted a patch that removes it and moves Q&amp;A down a row to take its place. I havent applied it as I reckon such an action needs community approval, and as such I'll let some other god apply it if they think its appropriate. [id://369972] 
&lt;/p&gt;&lt;hr /&gt; 
&lt;p&gt;[davido], 2004-06-20&lt;br /&gt; 
I personally wouldn't mind seeing Node Status Nodelet's contents merged with Moderation Nodelet's stuff, so that I could get away with keeping only one of them active.  It seems like they, to some degree, overlap in functionality some of the time, and yet I have to keep both turned on to get the whole story. 
&lt;/p&gt; 
&lt;p&gt;[Corion], 2004-06-20&lt;br /&gt; 
Another brief change of subject - [id://368047|I've patched] the [Node Status nodelet] to show 
the current node ID as text enclosed in brackets (for example &lt;tt&gt;&amp;#91;id://666&amp;#93;&lt;/tt&gt;) - this would make copying and pasting of the node ID easier for those who want/need to use the node ID (for bulk renaming). 
&lt;/p&gt;&lt;hr /&gt; 
&lt;p&gt;[davido], 2004-06-19&lt;br /&gt; 
Brief change of subject here... Should the PMDev Nodelet contain a link to the test server?&lt;/p&gt; 
&lt;hr /&gt; 
&lt;p&gt;[demerphq], 2004-06-19&lt;br /&gt; 
Ive backedup the previous wiki as i noticed that sometime today we exceeded the 64 k barrier. Unfortunately this means a small part of the wiki was chopped off. I only noticed it after replying to [tye] and it looks like it was truncated sometime before then, possibly by my first entry from today. If so apologies to all. 
&lt;/p&gt; 
&lt;hr /&gt; 
&lt;p&gt;[demerphq], 2004-06-19&lt;br /&gt; 
Erm, it might have been me with the tempate sorry. :-) 
&lt;/p&gt; 
&lt;p&gt; 
Ok, *deep breath*. :-) I think I've not explained myself well and you haven't looked at the code closely enough to compensate. Our ideas are &lt;b&gt;identical&lt;/b&gt; except for the parameter passing conventions. Which I agree are sucky. :-) Although im hard pressed to decide if safe but clunky is more or less sucky than not-so-safe but not-so-clunky. 
&lt;/p&gt; 
&lt;p&gt; 
If I had wanted to take the approach that you outline in the V/E node i could have done so with the current code, ie: something like this: 
&lt;Code&gt; 
[{get_sitedoclet:V/E,top}] 
[% 
 #code to create and print table and fetch $NORM 
 htmlcode('get_sitedoclet','','V/E','bottom',{tags=&gt;{norm=&gt;$NORM}}); 
%] 
&lt;/code&gt; 
&lt;p&gt; 
Which as you can see is pretty close to what you have. Instead it seemed that there was no reason to dictate the placement of the table so i did it something like this: 
&lt;/p&gt; 
&lt;Code&gt; 
[% 
 # code to create table, and fetch $NORM 
 htmlcode('get_sitedoclet','','V/E',{tags=&gt;{norm=&gt;$NORM,table=&gt;$table_html}}); 
%] 
&lt;/code&gt; 
&lt;p&gt; 
Which seemed to me to be more flexible for this example. In something else, say [Titlebar Settings] (just to use a finicky example) i probably would have gone with the first approach and not the second becuase in that case various aspects of the interface strongly suggest a particular placement. 
&lt;/p&gt; 
&lt;p&gt; 
So the point is that what I already have does what you ask. Now the question is calling syntax. I think perhaps that the following might be better: 
&lt;/p&gt; 
&lt;code&gt; 
[% 
 # code to create table, and fetch $NORM 
 htmlcode('get_sitedoclet','',-norm=&gt;$NORM,-table=&gt;$table_html); 
%] 
&lt;/code&gt; 
&lt;p&gt; 
Or assuming that we want a specific set of sections from sitedoclet with specific tags interpolated and a more flexible return: 
&lt;/p&gt; 
&lt;code&gt; 
[% 
 my $complex={}; 
 # code to create table, and fetch $NORM 
 htmlcode('get_sitedoclet','',qw(top middle bottom), 
          -norm=&gt;$NORM,-table=&gt;$table_html,$complex); 
%] 
&lt;/code&gt; 
&lt;p&gt; 
So i think its good you avoided that speculation. :-) Especially as given the simple case (at least the one you think will be more common, im inclined to think more situations will show the tags approach is more ameniable) is _exactly_ the same as yours: 
&lt;/p&gt; 
&lt;code&gt; 
[{get_sitedoclet:SomeSiteDocLet,SectionName}] 
[{get_sitedoclet:SomeSiteDocLet}] 
&lt;/code&gt; 
&lt;p&gt; 
So the only subject of dispute (in my eyes) is how to pass the tag info in. As i said I think that will be more common than wanting sections. But the key thing to remember is that I already support sections, and with the exact same syntax as yours. 
&lt;/p&gt; 
&lt;hr /&gt; 
&lt;p&gt;[tye], 2004-06-19&lt;br /&gt; 
You can set $norm early.  It was a quick example so I used a single code block. 
&lt;/p&gt;&lt;p&gt; 
My idea replaces one or more blocks of HTML in a superdoc, each with a single &lt;code&gt;[{...}]&lt;/code&gt; and none of any other existing Everything templating in the rest of the superdoc needs to be touched. 
&lt;/p&gt;&lt;p&gt; 
Your solution requires that existing Everything templating between blocks be wrapped up into something so it can be passed into the sitedoclet or else requires 2 sitedoclets be created to avoid that.  I'd speculate about your lack of forethought on this subject but I see no reason to be rude. 
&lt;/p&gt;&lt;p&gt; 
As for &quot;I dont really see much of difference&quot;: I was replying to your request to address &quot;the interface into [get_sitedoclet] is pretty sucky&quot;.  Well, I don't find my interface sucky.  If there are no little values to be plugged into the prose (perhaps in more than one place), then the interface is drop-dead simple.  Since voting/XP was the most complicated case we could think of and it only used one, I find it appropriate to optimize the design for the vast majority of cases when no template variables will be used. 
&lt;/p&gt;&lt;p&gt; 
Your solution makes it easier for SDC to move (the results of) chunks of code around in whatever part of the page pmdev decides to give to them but makes it harder for pmdev to move chunks of SDC prose around within a page that is already a template. 
&lt;/p&gt;&lt;p&gt; 
My solution allows pmdev to do the simple case very simply or to do the extra work to pass in the results of some code in to let SDC move them relative to each other. 
&lt;/p&gt;&lt;p&gt; 
And I think my solution makes even the difficult (and very rare) case simpler than your solution makes it (and pmdev doesn't have to use %HTMLVARS, but they can). 
&lt;/p&gt;&lt;hr /&gt; 

&lt;p&gt;[demerphq], 2004-06-19&lt;br /&gt; 
Well, I dont really see much of difference from your example. (Removed original response as it was not fully thought through.) Actually on rereading I think that my approach already allows yours (albeit with different syntax) so I dont understand what the issue here is. All i did was go with a different approach in the superdoc node that allowed SDC to put the table wherever they like, and to put $NORM wherever they like, i could have done something functionally equivelent to yours but i saw no reason to complicate things with sections when in fact the situation is perfectly well handled by only exploiting substitution. 
&lt;/p&gt; 
&lt;p&gt; 
The point about caching is interesting. Ill have to think about that more before commenting more though. Actually ditto goes for your other comments. I will say that i find using HTMLVARS for parameter passing pretty odd, and probably undesirable. But at this point ill just say that and see if you have a follow up. 
&lt;/p&gt; 
&lt;p&gt; 
Regarding what was discussed at the time, it may be that I didnt get it all as I recall I was somewhat distracted at the time of the conversation. Anyway, this is just a proof of concept so modifications and patches before we move it here are welcome. 
&lt;/p&gt; 
&lt;p&gt; 
Also there were good reasons i avoided square bracket style linking for the substitution: it interfered with normal link parsing. 
&lt;/p&gt; 
&lt;hr /&gt; 
&lt;p&gt;[tye], 2004-06-19&lt;br /&gt; 
I agreed with [theorbtwo] that SDC should be providing more prose and less mark-up in this type of situation and so your implentation does most of the templating backward from how I thought we'd all discussed it. 
&lt;/p&gt;&lt;p&gt; 
The voting/XP superdoc would look something like: 
&lt;code&gt; 
[{sitedoclet:voting/XP,head}] 
[% 
   code to produce table 
   $HTMLVARS{sdl_norm}= $NORM; 
%] 
[{sitedoclet:voting/XP,tail}] 
&lt;/code&gt; 
And the sdl would look like: 
&lt;code&gt; 
&lt;!--head--&gt;&lt;h3&gt;What &lt;em&gt;is&lt;/em&gt;... 
... 
&lt;!--tail--&gt;... 
... [&quot;norm&quot;] ... 
... 
&lt;/code&gt; 
and the htmlcode for sitedoclet would fetch the node from the cache as $sdl.  Then, if $sdl-&gt;{sdlparts} is empty, it'd do &lt;code&gt;%{$sdl-&gt;{sdlparts}} = split /&lt;!--(\w+)--&gt;/, $sdl-&gt;{doctext}&lt;/code&gt; (so this is only done once per cache refresh, not on every fetch). 
&lt;/p&gt;&lt;p&gt; 
Then it'd assert that &lt;code&gt;$sdl-&gt;{sdlparts}{$_[0]}&lt;/code&gt; existed and run &lt;code&gt;s/[&quot;(\w+)&quot;]/$HTMLVARS{&quot;sdl_$1&quot;} || $HTMLVARS{$1} || &quot;&lt;!-- $1 not set --&gt;&quot;/ge&lt;/code&gt; on a copy of it and return the modified copy. 
&lt;/p&gt;&lt;p&gt; 
Except that @_ being empty would mean that $sdl-&gt;{doctext} would be used instead and sdlparts would not be updated. 
&lt;/p&gt;&lt;p&gt; 
BTW, the reason I used %HTMLVARS was mostly because &lt;code&gt;[{sitedoclet:vote/XP,tail,norm,$NORM}]&lt;/code&gt; 
won't work and the syntax using htmlcode() is so much uglier.  You could allow for both by prepending a &lt;code&gt;$_[1]{$1} ||&lt;/code&gt; to the replacement in the above s///.  But it also allows some generic settings to be used w/o the including superdoc having to worry about it. 
&lt;/p&gt;&lt;hr /&gt; 

&lt;p&gt;[demerphq], 2004-06-19&lt;br /&gt; 
Regarding [sitedoclet]s: The test server now has a working proof of concept of this in place. I used [Voting/Experience System] as my first target as its a complex page. The change involved adding an htmlcode routine called [get_sitedoclet], a new display page for the new nodetype which uses the htmlcode, and then obviously creating a sitedoclet for the V/E node and patches to the V/E node itself. Additionally i discovered that the full set of table tags, caption, colgroup, col, thead,tbody,tfoot were not supported so I added them to the [allowed html tags] setting. 
&lt;/p&gt; 
&lt;p&gt; 
Id like to move all these changes over (and will in patch form, or in unused code form), except for one minor issue: My normal creativity seems a bit diminished today and i have to say that the interface into [get_sitedoclet] is pretty sucky. I cant think of an intelligent way to set up the interface. Currently its: 
&lt;/p&gt; 
&lt;code&gt; 
get_sitedoclet($NameOrNode,@FIELDS,$OptionalHashref) 
&lt;/code&gt; 
&lt;p&gt; 
Where $NameOrNode is either a $NODE that isa [sitedoclet] or the title of a node of that type. @Fields are the requested &quot;sections&quot; of the sitedoclet and $OptionalHashref is a way to return complex data, and also to specify substitituion tags. The hashref is of the following structure: 
&lt;/p&gt; 
&lt;code&gt; 
$opts={ 
       tags=&gt;{},     #hash of tagnames =&gt; substitution text 
       fields=&gt;[],   #alternate way to specify fields (return as well) 
       sections=&gt;{}, #hash of sectionname =&gt; presubstituted text 
       parts=&gt;[],    #same as sections but in array form that respects ordering 
       contains=&gt;[], #a list of section names in the order they occur in the node 
     }; 
&lt;/code&gt; 
&lt;p&gt; 
Most of this is just if someone wants to do complex stuff, get_sitedoclinks returns either the whole sitedoclet if no @fields or $opts-&gt;{fields} are provided (in addition to setting all the above $opts as appropriate). If no sections are encountered then the sections hash key will be the same as for the sitedoclet itself, as will contains and parts. If @fields are provided returns a joined string of the the sections. 
&lt;/p&gt; 
&lt;p&gt; 
Sections are specified by &lt;code&gt;&lt;!--&amp;SectionName&amp;--&gt;&lt;/code&gt; and simple substitution tags are specified by &lt;code&gt;&lt;!--$VarName$--&gt;&lt;/code&gt; 
&lt;/p&gt; 
&lt;p&gt; 
Anyway, my main problem is that i dont think too many people will want to call this with a $opts hash provided, and actually im not so sure how often folks will want to use the sections stuff either. Which means that the main thing that folks will want to do is pass in a set of tagnames to be replaced. So what do you think? Renengineer the interface so it accepts a list of tagname=&gt;values and then let folks specify sections via the opts hash? Figure out some way to supply the fields and tags without resorting to seperate root key/value pairs of the opts hash? Anything else? 
&lt;/p&gt; 
&lt;hr /&gt; 
&lt;p&gt; 
See [id://368198] for previous material in wiki. 
&lt;/p&gt;</doctext>
  <type_nodetype>68046</type_nodetype>
  <node_id>379726</node_id>
  <author_user>979</author_user>
  <title>pmdev wiki through 2004-07-25</title>
  <createtime>2001-08-22 02:44:52</createtime>
  <nodeupdated>2005-08-15 14:33:22</nodeupdated>
</node>
